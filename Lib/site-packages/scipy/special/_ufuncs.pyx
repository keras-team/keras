# This file is automatically generated by _generate_pyx.py.
# Do not edit manually!

from libc.math cimport NAN

include "_ufuncs_extra_code_common.pxi"
include "_ufuncs_extra_code.pxi"
__all__ = ['agm', 'bdtr', 'bdtrc', 'bdtri', 'bdtrik', 'bdtrin', 'betainc', 'betaincc', 'betainccinv', 'betaincinv', 'boxcox', 'boxcox1p', 'btdtria', 'btdtrib', 'chdtr', 'chdtrc', 'chdtri', 'chdtriv', 'chndtr', 'chndtridf', 'chndtrinc', 'chndtrix', 'dawsn', 'elliprc', 'elliprd', 'elliprf', 'elliprg', 'elliprj', 'entr', 'erf', 'erfc', 'erfcinv', 'erfcx', 'erfi', 'erfinv', 'eval_chebyc', 'eval_chebys', 'eval_chebyt', 'eval_chebyu', 'eval_gegenbauer', 'eval_genlaguerre', 'eval_hermite', 'eval_hermitenorm', 'eval_jacobi', 'eval_laguerre', 'eval_legendre', 'eval_sh_chebyt', 'eval_sh_chebyu', 'eval_sh_jacobi', 'eval_sh_legendre', 'exp10', 'exp2', 'expm1', 'expn', 'fdtr', 'fdtrc', 'fdtri', 'fdtridfd', 'gdtr', 'gdtrc', 'gdtria', 'gdtrib', 'gdtrix', 'huber', 'hyp0f1', 'hyp1f1', 'hyperu', 'inv_boxcox', 'inv_boxcox1p', 'kl_div', 'kn', 'kolmogi', 'kolmogorov', 'log1p', 'log_ndtr', 'lpmv', 'nbdtr', 'nbdtrc', 'nbdtri', 'nbdtrik', 'nbdtrin', 'ncfdtr', 'ncfdtri', 'ncfdtridfd', 'ncfdtridfn', 'ncfdtrinc', 'nctdtr', 'nctdtridf', 'nctdtrinc', 'nctdtrit', 'ndtr', 'ndtri', 'ndtri_exp', 'nrdtrimn', 'nrdtrisd', 'owens_t', 'pdtr', 'pdtrc', 'pdtri', 'pdtrik', 'poch', 'powm1', 'pseudo_huber', 'rel_entr', 'round', 'shichi', 'sici', 'smirnov', 'smirnovi', 'spence', 'stdtr', 'stdtridf', 'stdtrit', 'tklmbda', 'voigt_profile', 'wofz', 'wrightomega', 'xlog1py', 'xlogy', 'yn', 'geterr', 'seterr', 'errstate', 'jn', 'airy', 'airye', 'bei', 'beip', 'ber', 'berp', 'binom', 'exp1', 'expi', 'expit', 'exprel', 'gamma', 'gammaln', 'hankel1', 'hankel1e', 'hankel2', 'hankel2e', 'hyp2f1', 'it2i0k0', 'it2j0y0', 'it2struve0', 'itairy', 'iti0k0', 'itj0y0', 'itmodstruve0', 'itstruve0', 'iv', 'ive', 'jv', 'jve', 'kei', 'keip', 'kelvin', 'ker', 'kerp', 'kv', 'kve', 'log_expit', 'log_wright_bessel', 'loggamma', 'logit', 'mathieu_a', 'mathieu_b', 'mathieu_cem', 'mathieu_modcem1', 'mathieu_modcem2', 'mathieu_modsem1', 'mathieu_modsem2', 'mathieu_sem', 'modfresnelm', 'modfresnelp', 'obl_ang1', 'obl_ang1_cv', 'obl_cv', 'obl_rad1', 'obl_rad1_cv', 'obl_rad2', 'obl_rad2_cv', 'pbdv', 'pbvv', 'pbwa', 'pro_ang1', 'pro_ang1_cv', 'pro_cv', 'pro_rad1', 'pro_rad1_cv', 'pro_rad2', 'pro_rad2_cv', 'psi', 'rgamma', 'sph_harm', 'wright_bessel', 'yv', 'yve', 'zetac', 'sindg', 'cosdg', 'tandg', 'cotdg', 'i0', 'i0e', 'i1', 'i1e', 'k0', 'k0e', 'k1', 'k1e', 'y0', 'y1', 'j0', 'j1', 'struve', 'modstruve', 'beta', 'betaln', 'besselpoly', 'gammaln', 'gammasgn', 'cbrt', 'radian', 'cosm1', 'gammainc', 'gammaincinv', 'gammaincc', 'gammainccinv', 'fresnel', 'ellipe', 'ellipeinc', 'ellipk', 'ellipkinc', 'ellipkm1', 'ellipj']
cdef void loop_D_DDDD__As_DDDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDDD__As_FFFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_DDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_FFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_DD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_FF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_D_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_F_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_dD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_fF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_dddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_fffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_d_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<double*>ip0)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_dd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_ddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_dddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_ddddddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_fffffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], <double>(<float*>ip5)[0], <double>(<float*>ip6)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddiiddd__As_ddllddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0] and <int>(<long*>ip3)[0] == (<long*>ip3)[0]:
            ov0 = (<double(*)(double, double, int, int, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], <int>(<long*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddp_d_As_ddp_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, Py_ssize_t, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <Py_ssize_t>(<Py_ssize_t*>ip2)[0], &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dpd__As_dpd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, Py_ssize_t, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <Py_ssize_t>(<Py_ssize_t*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_pd__As_pd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_pdd__As_pdd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, double, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_pddd__As_pddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, double, double, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_ppd__As_ppd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, Py_ssize_t, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <Py_ssize_t>(<Py_ssize_t*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_f_f__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float) noexcept nogil>func)(<float>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_f_ff__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_f_fff__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0], <float>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_f_ffff__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float, float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0], <float>(<float*>ip2)[0], <float>(<float*>ip3)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_D_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_F_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_d_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_f_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_i__As_l_l(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef int ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<int(*)(int) noexcept nogil>func)(<int>(<long*>ip0)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <int>0xbad0bad0
        (<long *>op0)[0] = <long>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_cdf "cosine_cdf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_invcdf "cosine_invcdf"(double) noexcept nogil
from ._ellip_harm cimport ellip_harmonic as _func_ellip_harmonic
ctypedef double _proto_ellip_harmonic_t(double, double, int, int, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_t *_proto_ellip_harmonic_t_var = &_func_ellip_harmonic
from ._legacy cimport ellip_harmonic_unsafe as _func_ellip_harmonic_unsafe
ctypedef double _proto_ellip_harmonic_unsafe_t(double, double, double, double, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_unsafe_t *_proto_ellip_harmonic_unsafe_t_var = &_func_ellip_harmonic_unsafe
from ._factorial cimport _factorial as _func__factorial
ctypedef double _proto__factorial_t(double) noexcept nogil
cdef _proto__factorial_t *_proto__factorial_t_var = &_func__factorial
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_igam_fac "cephes_igam_fac"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_kolmogc "xsf_kolmogc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_kolmogci "xsf_kolmogci"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_kolmogp "xsf_kolmogp"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_lanczos_sum_expg_scaled "cephes_lanczos_sum_expg_scaled"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_lgam1p "cephes_lgam1p"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_log1pmx "cephes_log1pmx"(double) noexcept nogil
from .sf_error cimport _sf_error_test_function as _func__sf_error_test_function
ctypedef int _proto__sf_error_test_function_t(int) noexcept nogil
cdef _proto__sf_error_test_function_t *_proto__sf_error_test_function_t_var = &_func__sf_error_test_function
from ._legacy cimport smirnovc_unsafe as _func_smirnovc_unsafe
ctypedef double _proto_smirnovc_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovc_unsafe_t *_proto_smirnovc_unsafe_t_var = &_func_smirnovc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovc_wrap "cephes_smirnovc_wrap"(Py_ssize_t, double) noexcept nogil
from ._legacy cimport smirnovci_unsafe as _func_smirnovci_unsafe
ctypedef double _proto_smirnovci_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovci_unsafe_t *_proto_smirnovci_unsafe_t_var = &_func_smirnovci_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovci_wrap "cephes_smirnovci_wrap"(Py_ssize_t, double) noexcept nogil
from ._legacy cimport smirnovp_unsafe as _func_smirnovp_unsafe
ctypedef double _proto_smirnovp_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovp_unsafe_t *_proto_smirnovp_unsafe_t_var = &_func_smirnovp_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovp_wrap "cephes_smirnovp_wrap"(Py_ssize_t, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes__struve_asymp_large_z "cephes__struve_asymp_large_z"(double, double, Py_ssize_t, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes__struve_bessel_series "cephes__struve_bessel_series"(double, double, Py_ssize_t, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes__struve_power_series "cephes__struve_power_series"(double, double, Py_ssize_t, double *) noexcept nogil
from ._agm cimport agm as _func_agm
ctypedef double _proto_agm_t(double, double) noexcept nogil
cdef _proto_agm_t *_proto_agm_t_var = &_func_agm
from ._legacy cimport bdtr_unsafe as _func_bdtr_unsafe
ctypedef double _proto_bdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtr_unsafe_t *_proto_bdtr_unsafe_t_var = &_func_bdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_bdtr_wrap "cephes_bdtr_wrap"(double, Py_ssize_t, double) noexcept nogil
from ._legacy cimport bdtrc_unsafe as _func_bdtrc_unsafe
ctypedef double _proto_bdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtrc_unsafe_t *_proto_bdtrc_unsafe_t_var = &_func_bdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_bdtrc_wrap "cephes_bdtrc_wrap"(double, Py_ssize_t, double) noexcept nogil
from ._legacy cimport bdtri_unsafe as _func_bdtri_unsafe
ctypedef double _proto_bdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtri_unsafe_t *_proto_bdtri_unsafe_t_var = &_func_bdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_bdtri_wrap "cephes_bdtri_wrap"(double, Py_ssize_t, double) noexcept nogil
from ._cdflib_wrappers cimport bdtrik as _func_bdtrik
ctypedef double _proto_bdtrik_t(double, double, double) noexcept nogil
cdef _proto_bdtrik_t *_proto_bdtrik_t_var = &_func_bdtrik
from ._cdflib_wrappers cimport bdtrin as _func_bdtrin
ctypedef double _proto_bdtrin_t(double, double, double) noexcept nogil
cdef _proto_bdtrin_t *_proto_bdtrin_t_var = &_func_bdtrin
from ._boxcox cimport boxcox as _func_boxcox
ctypedef double _proto_boxcox_t(double, double) noexcept nogil
cdef _proto_boxcox_t *_proto_boxcox_t_var = &_func_boxcox
from ._boxcox cimport boxcox1p as _func_boxcox1p
ctypedef double _proto_boxcox1p_t(double, double) noexcept nogil
cdef _proto_boxcox1p_t *_proto_boxcox1p_t_var = &_func_boxcox1p
from ._cdflib_wrappers cimport btdtria as _func_btdtria
ctypedef double _proto_btdtria_t(double, double, double) noexcept nogil
cdef _proto_btdtria_t *_proto_btdtria_t_var = &_func_btdtria
from ._cdflib_wrappers cimport btdtrib as _func_btdtrib
ctypedef double _proto_btdtrib_t(double, double, double) noexcept nogil
cdef _proto_btdtrib_t *_proto_btdtrib_t_var = &_func_btdtrib
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_chdtr "xsf_chdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_chdtrc "xsf_chdtrc"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_chdtri "xsf_chdtri"(double, double) noexcept nogil
from ._cdflib_wrappers cimport chdtriv as _func_chdtriv
ctypedef double _proto_chdtriv_t(double, double) noexcept nogil
cdef _proto_chdtriv_t *_proto_chdtriv_t_var = &_func_chdtriv
from ._cdflib_wrappers cimport chndtr as _func_chndtr
ctypedef double _proto_chndtr_t(double, double, double) noexcept nogil
cdef _proto_chndtr_t *_proto_chndtr_t_var = &_func_chndtr
from ._cdflib_wrappers cimport chndtridf as _func_chndtridf
ctypedef double _proto_chndtridf_t(double, double, double) noexcept nogil
cdef _proto_chndtridf_t *_proto_chndtridf_t_var = &_func_chndtridf
from ._cdflib_wrappers cimport chndtrinc as _func_chndtrinc
ctypedef double _proto_chndtrinc_t(double, double, double) noexcept nogil
cdef _proto_chndtrinc_t *_proto_chndtrinc_t_var = &_func_chndtrinc
from ._cdflib_wrappers cimport chndtrix as _func_chndtrix
ctypedef double _proto_chndtrix_t(double, double, double) noexcept nogil
cdef _proto_chndtrix_t *_proto_chndtrix_t_var = &_func_chndtrix
from ._convex_analysis cimport entr as _func_entr
ctypedef double _proto_entr_t(double) noexcept nogil
cdef _proto_entr_t *_proto_entr_t_var = &_func_entr
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_erf "cephes_erf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_erfc "cephes_erfc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_erfcinv "cephes_erfcinv"(double) noexcept nogil
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double complex _proto_eval_chebyc_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyc_double_complex__t *_proto_eval_chebyc_double_complex__t_var = &_func_eval_chebyc[double_complex]
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double _proto_eval_chebyc_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyc_double__t *_proto_eval_chebyc_double__t_var = &_func_eval_chebyc[double]
from .orthogonal_eval cimport eval_chebyc_l as _func_eval_chebyc_l
ctypedef double _proto_eval_chebyc_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebyc_l_t *_proto_eval_chebyc_l_t_var = &_func_eval_chebyc_l
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double complex _proto_eval_chebys_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebys_double_complex__t *_proto_eval_chebys_double_complex__t_var = &_func_eval_chebys[double_complex]
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double _proto_eval_chebys_double__t(double, double) noexcept nogil
cdef _proto_eval_chebys_double__t *_proto_eval_chebys_double__t_var = &_func_eval_chebys[double]
from .orthogonal_eval cimport eval_chebys_l as _func_eval_chebys_l
ctypedef double _proto_eval_chebys_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebys_l_t *_proto_eval_chebys_l_t_var = &_func_eval_chebys_l
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double complex _proto_eval_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyt_double_complex__t *_proto_eval_chebyt_double_complex__t_var = &_func_eval_chebyt[double_complex]
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double _proto_eval_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyt_double__t *_proto_eval_chebyt_double__t_var = &_func_eval_chebyt[double]
from .orthogonal_eval cimport eval_chebyt_l as _func_eval_chebyt_l
ctypedef double _proto_eval_chebyt_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebyt_l_t *_proto_eval_chebyt_l_t_var = &_func_eval_chebyt_l
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double complex _proto_eval_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyu_double_complex__t *_proto_eval_chebyu_double_complex__t_var = &_func_eval_chebyu[double_complex]
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double _proto_eval_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyu_double__t *_proto_eval_chebyu_double__t_var = &_func_eval_chebyu[double]
from .orthogonal_eval cimport eval_chebyu_l as _func_eval_chebyu_l
ctypedef double _proto_eval_chebyu_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebyu_l_t *_proto_eval_chebyu_l_t_var = &_func_eval_chebyu_l
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double complex _proto_eval_gegenbauer_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_gegenbauer_double_complex__t *_proto_eval_gegenbauer_double_complex__t_var = &_func_eval_gegenbauer[double_complex]
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double _proto_eval_gegenbauer_double__t(double, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_double__t *_proto_eval_gegenbauer_double__t_var = &_func_eval_gegenbauer[double]
from .orthogonal_eval cimport eval_gegenbauer_l as _func_eval_gegenbauer_l
ctypedef double _proto_eval_gegenbauer_l_t(Py_ssize_t, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_l_t *_proto_eval_gegenbauer_l_t_var = &_func_eval_gegenbauer_l
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double complex _proto_eval_genlaguerre_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_genlaguerre_double_complex__t *_proto_eval_genlaguerre_double_complex__t_var = &_func_eval_genlaguerre[double_complex]
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double _proto_eval_genlaguerre_double__t(double, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_double__t *_proto_eval_genlaguerre_double__t_var = &_func_eval_genlaguerre[double]
from .orthogonal_eval cimport eval_genlaguerre_l as _func_eval_genlaguerre_l
ctypedef double _proto_eval_genlaguerre_l_t(Py_ssize_t, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_l_t *_proto_eval_genlaguerre_l_t_var = &_func_eval_genlaguerre_l
from .orthogonal_eval cimport eval_hermite as _func_eval_hermite
ctypedef double _proto_eval_hermite_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_hermite_t *_proto_eval_hermite_t_var = &_func_eval_hermite
from .orthogonal_eval cimport eval_hermitenorm as _func_eval_hermitenorm
ctypedef double _proto_eval_hermitenorm_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_hermitenorm_t *_proto_eval_hermitenorm_t_var = &_func_eval_hermitenorm
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double complex _proto_eval_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_jacobi_double_complex__t *_proto_eval_jacobi_double_complex__t_var = &_func_eval_jacobi[double_complex]
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double _proto_eval_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_double__t *_proto_eval_jacobi_double__t_var = &_func_eval_jacobi[double]
from .orthogonal_eval cimport eval_jacobi_l as _func_eval_jacobi_l
ctypedef double _proto_eval_jacobi_l_t(Py_ssize_t, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_l_t *_proto_eval_jacobi_l_t_var = &_func_eval_jacobi_l
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double complex _proto_eval_laguerre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_laguerre_double_complex__t *_proto_eval_laguerre_double_complex__t_var = &_func_eval_laguerre[double_complex]
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double _proto_eval_laguerre_double__t(double, double) noexcept nogil
cdef _proto_eval_laguerre_double__t *_proto_eval_laguerre_double__t_var = &_func_eval_laguerre[double]
from .orthogonal_eval cimport eval_laguerre_l as _func_eval_laguerre_l
ctypedef double _proto_eval_laguerre_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_laguerre_l_t *_proto_eval_laguerre_l_t_var = &_func_eval_laguerre_l
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double complex _proto_eval_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_legendre_double_complex__t *_proto_eval_legendre_double_complex__t_var = &_func_eval_legendre[double_complex]
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double _proto_eval_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_legendre_double__t *_proto_eval_legendre_double__t_var = &_func_eval_legendre[double]
from .orthogonal_eval cimport eval_legendre_l as _func_eval_legendre_l
ctypedef double _proto_eval_legendre_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_legendre_l_t *_proto_eval_legendre_l_t_var = &_func_eval_legendre_l
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double complex _proto_eval_sh_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyt_double_complex__t *_proto_eval_sh_chebyt_double_complex__t_var = &_func_eval_sh_chebyt[double_complex]
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double _proto_eval_sh_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyt_double__t *_proto_eval_sh_chebyt_double__t_var = &_func_eval_sh_chebyt[double]
from .orthogonal_eval cimport eval_sh_chebyt_l as _func_eval_sh_chebyt_l
ctypedef double _proto_eval_sh_chebyt_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_sh_chebyt_l_t *_proto_eval_sh_chebyt_l_t_var = &_func_eval_sh_chebyt_l
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double complex _proto_eval_sh_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyu_double_complex__t *_proto_eval_sh_chebyu_double_complex__t_var = &_func_eval_sh_chebyu[double_complex]
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double _proto_eval_sh_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyu_double__t *_proto_eval_sh_chebyu_double__t_var = &_func_eval_sh_chebyu[double]
from .orthogonal_eval cimport eval_sh_chebyu_l as _func_eval_sh_chebyu_l
ctypedef double _proto_eval_sh_chebyu_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_sh_chebyu_l_t *_proto_eval_sh_chebyu_l_t_var = &_func_eval_sh_chebyu_l
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double complex _proto_eval_sh_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_sh_jacobi_double_complex__t *_proto_eval_sh_jacobi_double_complex__t_var = &_func_eval_sh_jacobi[double_complex]
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double _proto_eval_sh_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_double__t *_proto_eval_sh_jacobi_double__t_var = &_func_eval_sh_jacobi[double]
from .orthogonal_eval cimport eval_sh_jacobi_l as _func_eval_sh_jacobi_l
ctypedef double _proto_eval_sh_jacobi_l_t(Py_ssize_t, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_l_t *_proto_eval_sh_jacobi_l_t_var = &_func_eval_sh_jacobi_l
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double complex _proto_eval_sh_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_legendre_double_complex__t *_proto_eval_sh_legendre_double_complex__t_var = &_func_eval_sh_legendre[double_complex]
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double _proto_eval_sh_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_legendre_double__t *_proto_eval_sh_legendre_double__t_var = &_func_eval_sh_legendre[double]
from .orthogonal_eval cimport eval_sh_legendre_l as _func_eval_sh_legendre_l
ctypedef double _proto_eval_sh_legendre_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_sh_legendre_l_t *_proto_eval_sh_legendre_l_t_var = &_func_eval_sh_legendre_l
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_exp10 "cephes_exp10"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_exp2 "cephes_exp2"(double) noexcept nogil
from ._cunity cimport cexpm1 as _func_cexpm1
ctypedef double complex _proto_cexpm1_t(double complex) noexcept nogil
cdef _proto_cexpm1_t *_proto_cexpm1_t_var = &_func_cexpm1
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_expm1 "cephes_expm1"(double) noexcept nogil
from ._legacy cimport expn_unsafe as _func_expn_unsafe
ctypedef double _proto_expn_unsafe_t(double, double) noexcept nogil
cdef _proto_expn_unsafe_t *_proto_expn_unsafe_t_var = &_func_expn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_expn_wrap "cephes_expn_wrap"(Py_ssize_t, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_fdtr "xsf_fdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_fdtrc "xsf_fdtrc"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_fdtri "xsf_fdtri"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport fdtridfd as _func_fdtridfd
ctypedef double _proto_fdtridfd_t(double, double, double) noexcept nogil
cdef _proto_fdtridfd_t *_proto_fdtridfd_t_var = &_func_fdtridfd
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_gdtr "xsf_gdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_gdtrc "xsf_gdtrc"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport gdtria as _func_gdtria
ctypedef double _proto_gdtria_t(double, double, double) noexcept nogil
cdef _proto_gdtria_t *_proto_gdtria_t_var = &_func_gdtria
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_gdtrib "xsf_gdtrib"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport gdtrix as _func_gdtrix
ctypedef double _proto_gdtrix_t(double, double, double) noexcept nogil
cdef _proto_gdtrix_t *_proto_gdtrix_t_var = &_func_gdtrix
from ._convex_analysis cimport huber as _func_huber
ctypedef double _proto_huber_t(double, double) noexcept nogil
cdef _proto_huber_t *_proto_huber_t_var = &_func_huber
from ._hyp0f1 cimport _hyp0f1_cmplx as _func__hyp0f1_cmplx
ctypedef double complex _proto__hyp0f1_cmplx_t(double, double complex) noexcept nogil
cdef _proto__hyp0f1_cmplx_t *_proto__hyp0f1_cmplx_t_var = &_func__hyp0f1_cmplx
from ._hyp0f1 cimport _hyp0f1_real as _func__hyp0f1_real
ctypedef double _proto__hyp0f1_real_t(double, double) noexcept nogil
cdef _proto__hyp0f1_real_t *_proto__hyp0f1_real_t_var = &_func__hyp0f1_real
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_chyp1f1_wrap "chyp1f1_wrap"(double, double, double complex) noexcept nogil
from ._hypergeometric cimport hyperu as _func_hyperu
ctypedef double _proto_hyperu_t(double, double, double) noexcept nogil
cdef _proto_hyperu_t *_proto_hyperu_t_var = &_func_hyperu
from ._boxcox cimport inv_boxcox as _func_inv_boxcox
ctypedef double _proto_inv_boxcox_t(double, double) noexcept nogil
cdef _proto_inv_boxcox_t *_proto_inv_boxcox_t_var = &_func_inv_boxcox
from ._boxcox cimport inv_boxcox1p as _func_inv_boxcox1p
ctypedef double _proto_inv_boxcox1p_t(double, double) noexcept nogil
cdef _proto_inv_boxcox1p_t *_proto_inv_boxcox1p_t_var = &_func_inv_boxcox1p
from ._convex_analysis cimport kl_div as _func_kl_div
ctypedef double _proto_kl_div_t(double, double) noexcept nogil
cdef _proto_kl_div_t *_proto_kl_div_t_var = &_func_kl_div
from ._legacy cimport kn_unsafe as _func_kn_unsafe
ctypedef double _proto_kn_unsafe_t(double, double) noexcept nogil
cdef _proto_kn_unsafe_t *_proto_kn_unsafe_t_var = &_func_kn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_special_cyl_bessel_k_int "special_cyl_bessel_k_int"(Py_ssize_t, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_kolmogi "xsf_kolmogi"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_kolmogorov "xsf_kolmogorov"(double) noexcept nogil
from ._cunity cimport clog1p as _func_clog1p
ctypedef double complex _proto_clog1p_t(double complex) noexcept nogil
cdef _proto_clog1p_t *_proto_clog1p_t_var = &_func_clog1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_log1p "cephes_log1p"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pmv_wrap "pmv_wrap"(double, double, double) noexcept nogil
from ._legacy cimport nbdtr_unsafe as _func_nbdtr_unsafe
ctypedef double _proto_nbdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtr_unsafe_t *_proto_nbdtr_unsafe_t_var = &_func_nbdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_nbdtr_wrap "cephes_nbdtr_wrap"(Py_ssize_t, Py_ssize_t, double) noexcept nogil
from ._legacy cimport nbdtrc_unsafe as _func_nbdtrc_unsafe
ctypedef double _proto_nbdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtrc_unsafe_t *_proto_nbdtrc_unsafe_t_var = &_func_nbdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_nbdtrc_wrap "cephes_nbdtrc_wrap"(Py_ssize_t, Py_ssize_t, double) noexcept nogil
from ._legacy cimport nbdtri_unsafe as _func_nbdtri_unsafe
ctypedef double _proto_nbdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtri_unsafe_t *_proto_nbdtri_unsafe_t_var = &_func_nbdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_nbdtri_wrap "cephes_nbdtri_wrap"(Py_ssize_t, Py_ssize_t, double) noexcept nogil
from ._cdflib_wrappers cimport nbdtrik as _func_nbdtrik
ctypedef double _proto_nbdtrik_t(double, double, double) noexcept nogil
cdef _proto_nbdtrik_t *_proto_nbdtrik_t_var = &_func_nbdtrik
from ._cdflib_wrappers cimport nbdtrin as _func_nbdtrin
ctypedef double _proto_nbdtrin_t(double, double, double) noexcept nogil
cdef _proto_nbdtrin_t *_proto_nbdtrin_t_var = &_func_nbdtrin
from ._cdflib_wrappers cimport ncfdtridfd as _func_ncfdtridfd
ctypedef double _proto_ncfdtridfd_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtridfd_t *_proto_ncfdtridfd_t_var = &_func_ncfdtridfd
from ._cdflib_wrappers cimport ncfdtridfn as _func_ncfdtridfn
ctypedef double _proto_ncfdtridfn_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtridfn_t *_proto_ncfdtridfn_t_var = &_func_ncfdtridfn
from ._cdflib_wrappers cimport ncfdtrinc as _func_ncfdtrinc
ctypedef double _proto_ncfdtrinc_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtrinc_t *_proto_ncfdtrinc_t_var = &_func_ncfdtrinc
from ._cdflib_wrappers cimport nctdtridf as _func_nctdtridf
ctypedef double _proto_nctdtridf_t(double, double, double) noexcept nogil
cdef _proto_nctdtridf_t *_proto_nctdtridf_t_var = &_func_nctdtridf
from ._cdflib_wrappers cimport nctdtrinc as _func_nctdtrinc
ctypedef double _proto_nctdtrinc_t(double, double, double) noexcept nogil
cdef _proto_nctdtrinc_t *_proto_nctdtrinc_t_var = &_func_nctdtrinc
from ._cdflib_wrappers cimport nctdtrit as _func_nctdtrit
ctypedef double _proto_nctdtrit_t(double, double, double) noexcept nogil
cdef _proto_nctdtrit_t *_proto_nctdtrit_t_var = &_func_nctdtrit
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_ndtr "xsf_ndtr"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_ndtri "xsf_ndtri"(double) noexcept nogil
from ._ndtri_exp cimport ndtri_exp as _func_ndtri_exp
ctypedef double _proto_ndtri_exp_t(double) noexcept nogil
cdef _proto_ndtri_exp_t *_proto_ndtri_exp_t_var = &_func_ndtri_exp
from ._cdflib_wrappers cimport nrdtrimn as _func_nrdtrimn
ctypedef double _proto_nrdtrimn_t(double, double, double) noexcept nogil
cdef _proto_nrdtrimn_t *_proto_nrdtrimn_t_var = &_func_nrdtrimn
from ._cdflib_wrappers cimport nrdtrisd as _func_nrdtrisd
ctypedef double _proto_nrdtrisd_t(double, double, double) noexcept nogil
cdef _proto_nrdtrisd_t *_proto_nrdtrisd_t_var = &_func_nrdtrisd
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_owens_t "xsf_owens_t"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_pdtr "xsf_pdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_pdtrc "xsf_pdtrc"(double, double) noexcept nogil
from ._legacy cimport pdtri_unsafe as _func_pdtri_unsafe
ctypedef double _proto_pdtri_unsafe_t(double, double) noexcept nogil
cdef _proto_pdtri_unsafe_t *_proto_pdtri_unsafe_t_var = &_func_pdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_pdtri_wrap "cephes_pdtri_wrap"(Py_ssize_t, double) noexcept nogil
from ._cdflib_wrappers cimport pdtrik as _func_pdtrik
ctypedef double _proto_pdtrik_t(double, double) noexcept nogil
cdef _proto_pdtrik_t *_proto_pdtrik_t_var = &_func_pdtrik
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_poch "cephes_poch"(double, double) noexcept nogil
from ._convex_analysis cimport pseudo_huber as _func_pseudo_huber
ctypedef double _proto_pseudo_huber_t(double, double) noexcept nogil
cdef _proto_pseudo_huber_t *_proto_pseudo_huber_t_var = &_func_pseudo_huber
from ._convex_analysis cimport rel_entr as _func_rel_entr
ctypedef double _proto_rel_entr_t(double, double) noexcept nogil
cdef _proto_rel_entr_t *_proto_rel_entr_t_var = &_func_rel_entr
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_round "cephes_round"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_xsf_cshichi "xsf_cshichi"(double complex, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_xsf_shichi "xsf_shichi"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_xsf_csici "xsf_csici"(double complex, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_xsf_sici "xsf_sici"(double, double *, double *) noexcept nogil
from ._legacy cimport smirnov_unsafe as _func_smirnov_unsafe
ctypedef double _proto_smirnov_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnov_unsafe_t *_proto_smirnov_unsafe_t_var = &_func_smirnov_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnov_wrap "cephes_smirnov_wrap"(Py_ssize_t, double) noexcept nogil
from ._legacy cimport smirnovi_unsafe as _func_smirnovi_unsafe
ctypedef double _proto_smirnovi_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovi_unsafe_t *_proto_smirnovi_unsafe_t_var = &_func_smirnovi_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovi_wrap "cephes_smirnovi_wrap"(Py_ssize_t, double) noexcept nogil
from ._spence cimport cspence as _func_cspence
ctypedef double complex _proto_cspence_t(double complex) noexcept nogil
cdef _proto_cspence_t *_proto_cspence_t_var = &_func_cspence
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_spence "cephes_spence"(double) noexcept nogil
from ._cdflib_wrappers cimport stdtr as _func_stdtr
ctypedef double _proto_stdtr_t(double, double) noexcept nogil
cdef _proto_stdtr_t *_proto_stdtr_t_var = &_func_stdtr
from ._cdflib_wrappers cimport stdtridf as _func_stdtridf
ctypedef double _proto_stdtridf_t(double, double) noexcept nogil
cdef _proto_stdtridf_t *_proto_stdtridf_t_var = &_func_stdtridf
from ._cdflib_wrappers cimport stdtrit as _func_stdtrit
ctypedef double _proto_stdtrit_t(double, double) noexcept nogil
cdef _proto_stdtrit_t *_proto_stdtrit_t_var = &_func_stdtrit
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_xsf_tukeylambdacdf "xsf_tukeylambdacdf"(double, double) noexcept nogil
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double _proto_xlog1py_double__t(double, double) noexcept nogil
cdef _proto_xlog1py_double__t *_proto_xlog1py_double__t_var = &_func_xlog1py[double]
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double complex _proto_xlog1py_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlog1py_double_complex__t *_proto_xlog1py_double_complex__t_var = &_func_xlog1py[double_complex]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double _proto_xlogy_double__t(double, double) noexcept nogil
cdef _proto_xlogy_double__t *_proto_xlogy_double__t_var = &_func_xlogy[double]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double complex _proto_xlogy_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlogy_double_complex__t *_proto_xlogy_double_complex__t_var = &_func_xlogy[double_complex]
from ._legacy cimport yn_unsafe as _func_yn_unsafe
ctypedef double _proto_yn_unsafe_t(double, double) noexcept nogil
cdef _proto_yn_unsafe_t *_proto_yn_unsafe_t_var = &_func_yn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_yn_wrap "cephes_yn_wrap"(Py_ssize_t, double) noexcept nogil
cdef np.PyUFuncGenericFunction ufunc__beta_pdf_loops[2]
cdef void *ufunc__beta_pdf_ptr[4]
cdef void *ufunc__beta_pdf_data[2]
cdef char ufunc__beta_pdf_types[8]
cdef char *ufunc__beta_pdf_doc = (
    "_beta_pdf(x, a, b)\n"
    "\n"
    "Probability density function of beta distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__beta_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__beta_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__beta_pdf_types[0] = <char>NPY_FLOAT
ufunc__beta_pdf_types[1] = <char>NPY_FLOAT
ufunc__beta_pdf_types[2] = <char>NPY_FLOAT
ufunc__beta_pdf_types[3] = <char>NPY_FLOAT
ufunc__beta_pdf_types[4] = <char>NPY_DOUBLE
ufunc__beta_pdf_types[5] = <char>NPY_DOUBLE
ufunc__beta_pdf_types[6] = <char>NPY_DOUBLE
ufunc__beta_pdf_types[7] = <char>NPY_DOUBLE
ufunc__beta_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_beta_pdf_float
ufunc__beta_pdf_ptr[2*0+1] = <void*>(<char*>"_beta_pdf")
ufunc__beta_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_beta_pdf_double
ufunc__beta_pdf_ptr[2*1+1] = <void*>(<char*>"_beta_pdf")
ufunc__beta_pdf_data[0] = &ufunc__beta_pdf_ptr[2*0]
ufunc__beta_pdf_data[1] = &ufunc__beta_pdf_ptr[2*1]
_beta_pdf = np.PyUFunc_FromFuncAndData(ufunc__beta_pdf_loops, ufunc__beta_pdf_data, ufunc__beta_pdf_types, 2, 3, 1, 0, "_beta_pdf", ufunc__beta_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__beta_ppf_loops[2]
cdef void *ufunc__beta_ppf_ptr[4]
cdef void *ufunc__beta_ppf_data[2]
cdef char ufunc__beta_ppf_types[8]
cdef char *ufunc__beta_ppf_doc = (
    "_beta_ppf(x, a, b)\n"
    "\n"
    "Percent point function of beta distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__beta_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__beta_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__beta_ppf_types[0] = <char>NPY_FLOAT
ufunc__beta_ppf_types[1] = <char>NPY_FLOAT
ufunc__beta_ppf_types[2] = <char>NPY_FLOAT
ufunc__beta_ppf_types[3] = <char>NPY_FLOAT
ufunc__beta_ppf_types[4] = <char>NPY_DOUBLE
ufunc__beta_ppf_types[5] = <char>NPY_DOUBLE
ufunc__beta_ppf_types[6] = <char>NPY_DOUBLE
ufunc__beta_ppf_types[7] = <char>NPY_DOUBLE
ufunc__beta_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_beta_ppf_float
ufunc__beta_ppf_ptr[2*0+1] = <void*>(<char*>"_beta_ppf")
ufunc__beta_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_beta_ppf_double
ufunc__beta_ppf_ptr[2*1+1] = <void*>(<char*>"_beta_ppf")
ufunc__beta_ppf_data[0] = &ufunc__beta_ppf_ptr[2*0]
ufunc__beta_ppf_data[1] = &ufunc__beta_ppf_ptr[2*1]
_beta_ppf = np.PyUFunc_FromFuncAndData(ufunc__beta_ppf_loops, ufunc__beta_ppf_data, ufunc__beta_ppf_types, 2, 3, 1, 0, "_beta_ppf", ufunc__beta_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_cdf_loops[2]
cdef void *ufunc__binom_cdf_ptr[4]
cdef void *ufunc__binom_cdf_data[2]
cdef char ufunc__binom_cdf_types[8]
cdef char *ufunc__binom_cdf_doc = (
    "_binom_cdf(x, n, p)\n"
    "\n"
    "Cumulative density function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_cdf_types[0] = <char>NPY_FLOAT
ufunc__binom_cdf_types[1] = <char>NPY_FLOAT
ufunc__binom_cdf_types[2] = <char>NPY_FLOAT
ufunc__binom_cdf_types[3] = <char>NPY_FLOAT
ufunc__binom_cdf_types[4] = <char>NPY_DOUBLE
ufunc__binom_cdf_types[5] = <char>NPY_DOUBLE
ufunc__binom_cdf_types[6] = <char>NPY_DOUBLE
ufunc__binom_cdf_types[7] = <char>NPY_DOUBLE
ufunc__binom_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_cdf_float
ufunc__binom_cdf_ptr[2*0+1] = <void*>(<char*>"_binom_cdf")
ufunc__binom_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_cdf_double
ufunc__binom_cdf_ptr[2*1+1] = <void*>(<char*>"_binom_cdf")
ufunc__binom_cdf_data[0] = &ufunc__binom_cdf_ptr[2*0]
ufunc__binom_cdf_data[1] = &ufunc__binom_cdf_ptr[2*1]
_binom_cdf = np.PyUFunc_FromFuncAndData(ufunc__binom_cdf_loops, ufunc__binom_cdf_data, ufunc__binom_cdf_types, 2, 3, 1, 0, "_binom_cdf", ufunc__binom_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_isf_loops[2]
cdef void *ufunc__binom_isf_ptr[4]
cdef void *ufunc__binom_isf_data[2]
cdef char ufunc__binom_isf_types[8]
cdef char *ufunc__binom_isf_doc = (
    "_binom_isf(x, n, p)\n"
    "\n"
    "Inverse survival function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_isf_types[0] = <char>NPY_FLOAT
ufunc__binom_isf_types[1] = <char>NPY_FLOAT
ufunc__binom_isf_types[2] = <char>NPY_FLOAT
ufunc__binom_isf_types[3] = <char>NPY_FLOAT
ufunc__binom_isf_types[4] = <char>NPY_DOUBLE
ufunc__binom_isf_types[5] = <char>NPY_DOUBLE
ufunc__binom_isf_types[6] = <char>NPY_DOUBLE
ufunc__binom_isf_types[7] = <char>NPY_DOUBLE
ufunc__binom_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_isf_float
ufunc__binom_isf_ptr[2*0+1] = <void*>(<char*>"_binom_isf")
ufunc__binom_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_isf_double
ufunc__binom_isf_ptr[2*1+1] = <void*>(<char*>"_binom_isf")
ufunc__binom_isf_data[0] = &ufunc__binom_isf_ptr[2*0]
ufunc__binom_isf_data[1] = &ufunc__binom_isf_ptr[2*1]
_binom_isf = np.PyUFunc_FromFuncAndData(ufunc__binom_isf_loops, ufunc__binom_isf_data, ufunc__binom_isf_types, 2, 3, 1, 0, "_binom_isf", ufunc__binom_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_pmf_loops[2]
cdef void *ufunc__binom_pmf_ptr[4]
cdef void *ufunc__binom_pmf_data[2]
cdef char ufunc__binom_pmf_types[8]
cdef char *ufunc__binom_pmf_doc = (
    "_binom_pmf(x, n, p)\n"
    "\n"
    "Probability mass function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_pmf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_pmf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_pmf_types[0] = <char>NPY_FLOAT
ufunc__binom_pmf_types[1] = <char>NPY_FLOAT
ufunc__binom_pmf_types[2] = <char>NPY_FLOAT
ufunc__binom_pmf_types[3] = <char>NPY_FLOAT
ufunc__binom_pmf_types[4] = <char>NPY_DOUBLE
ufunc__binom_pmf_types[5] = <char>NPY_DOUBLE
ufunc__binom_pmf_types[6] = <char>NPY_DOUBLE
ufunc__binom_pmf_types[7] = <char>NPY_DOUBLE
ufunc__binom_pmf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_pmf_float
ufunc__binom_pmf_ptr[2*0+1] = <void*>(<char*>"_binom_pmf")
ufunc__binom_pmf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_pmf_double
ufunc__binom_pmf_ptr[2*1+1] = <void*>(<char*>"_binom_pmf")
ufunc__binom_pmf_data[0] = &ufunc__binom_pmf_ptr[2*0]
ufunc__binom_pmf_data[1] = &ufunc__binom_pmf_ptr[2*1]
_binom_pmf = np.PyUFunc_FromFuncAndData(ufunc__binom_pmf_loops, ufunc__binom_pmf_data, ufunc__binom_pmf_types, 2, 3, 1, 0, "_binom_pmf", ufunc__binom_pmf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_ppf_loops[2]
cdef void *ufunc__binom_ppf_ptr[4]
cdef void *ufunc__binom_ppf_data[2]
cdef char ufunc__binom_ppf_types[8]
cdef char *ufunc__binom_ppf_doc = (
    "_binom_ppf(x, n, p)\n"
    "\n"
    "Percent point function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_ppf_types[0] = <char>NPY_FLOAT
ufunc__binom_ppf_types[1] = <char>NPY_FLOAT
ufunc__binom_ppf_types[2] = <char>NPY_FLOAT
ufunc__binom_ppf_types[3] = <char>NPY_FLOAT
ufunc__binom_ppf_types[4] = <char>NPY_DOUBLE
ufunc__binom_ppf_types[5] = <char>NPY_DOUBLE
ufunc__binom_ppf_types[6] = <char>NPY_DOUBLE
ufunc__binom_ppf_types[7] = <char>NPY_DOUBLE
ufunc__binom_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_ppf_float
ufunc__binom_ppf_ptr[2*0+1] = <void*>(<char*>"_binom_ppf")
ufunc__binom_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_ppf_double
ufunc__binom_ppf_ptr[2*1+1] = <void*>(<char*>"_binom_ppf")
ufunc__binom_ppf_data[0] = &ufunc__binom_ppf_ptr[2*0]
ufunc__binom_ppf_data[1] = &ufunc__binom_ppf_ptr[2*1]
_binom_ppf = np.PyUFunc_FromFuncAndData(ufunc__binom_ppf_loops, ufunc__binom_ppf_data, ufunc__binom_ppf_types, 2, 3, 1, 0, "_binom_ppf", ufunc__binom_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_sf_loops[2]
cdef void *ufunc__binom_sf_ptr[4]
cdef void *ufunc__binom_sf_data[2]
cdef char ufunc__binom_sf_types[8]
cdef char *ufunc__binom_sf_doc = (
    "_binom_sf(x, n, p)\n"
    "\n"
    "Survival function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_sf_types[0] = <char>NPY_FLOAT
ufunc__binom_sf_types[1] = <char>NPY_FLOAT
ufunc__binom_sf_types[2] = <char>NPY_FLOAT
ufunc__binom_sf_types[3] = <char>NPY_FLOAT
ufunc__binom_sf_types[4] = <char>NPY_DOUBLE
ufunc__binom_sf_types[5] = <char>NPY_DOUBLE
ufunc__binom_sf_types[6] = <char>NPY_DOUBLE
ufunc__binom_sf_types[7] = <char>NPY_DOUBLE
ufunc__binom_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_sf_float
ufunc__binom_sf_ptr[2*0+1] = <void*>(<char*>"_binom_sf")
ufunc__binom_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_sf_double
ufunc__binom_sf_ptr[2*1+1] = <void*>(<char*>"_binom_sf")
ufunc__binom_sf_data[0] = &ufunc__binom_sf_ptr[2*0]
ufunc__binom_sf_data[1] = &ufunc__binom_sf_ptr[2*1]
_binom_sf = np.PyUFunc_FromFuncAndData(ufunc__binom_sf_loops, ufunc__binom_sf_data, ufunc__binom_sf_types, 2, 3, 1, 0, "_binom_sf", ufunc__binom_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cauchy_isf_loops[2]
cdef void *ufunc__cauchy_isf_ptr[4]
cdef void *ufunc__cauchy_isf_data[2]
cdef char ufunc__cauchy_isf_types[8]
cdef char *ufunc__cauchy_isf_doc = (
    "_cauchy_isf(p, loc, scale)\n"
    "\n"
    "Inverse survival function of the Cauchy distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probabilities\n"
    "loc : array_like\n"
    "    Location parameter of the distribution.\n"
    "scale : array_like\n"
    "    Scale parameter of the distribution.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__cauchy_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__cauchy_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__cauchy_isf_types[0] = <char>NPY_FLOAT
ufunc__cauchy_isf_types[1] = <char>NPY_FLOAT
ufunc__cauchy_isf_types[2] = <char>NPY_FLOAT
ufunc__cauchy_isf_types[3] = <char>NPY_FLOAT
ufunc__cauchy_isf_types[4] = <char>NPY_DOUBLE
ufunc__cauchy_isf_types[5] = <char>NPY_DOUBLE
ufunc__cauchy_isf_types[6] = <char>NPY_DOUBLE
ufunc__cauchy_isf_types[7] = <char>NPY_DOUBLE
ufunc__cauchy_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_cauchy_isf_float
ufunc__cauchy_isf_ptr[2*0+1] = <void*>(<char*>"_cauchy_isf")
ufunc__cauchy_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_cauchy_isf_double
ufunc__cauchy_isf_ptr[2*1+1] = <void*>(<char*>"_cauchy_isf")
ufunc__cauchy_isf_data[0] = &ufunc__cauchy_isf_ptr[2*0]
ufunc__cauchy_isf_data[1] = &ufunc__cauchy_isf_ptr[2*1]
_cauchy_isf = np.PyUFunc_FromFuncAndData(ufunc__cauchy_isf_loops, ufunc__cauchy_isf_data, ufunc__cauchy_isf_types, 2, 3, 1, 0, "_cauchy_isf", ufunc__cauchy_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cauchy_ppf_loops[2]
cdef void *ufunc__cauchy_ppf_ptr[4]
cdef void *ufunc__cauchy_ppf_data[2]
cdef char ufunc__cauchy_ppf_types[8]
cdef char *ufunc__cauchy_ppf_doc = (
    "_cauchy_ppf(p, loc, scale)\n"
    "\n"
    "Percent point function (i.e. quantile) of the Cauchy distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probabilities\n"
    "loc : array_like\n"
    "    Location parameter of the distribution.\n"
    "scale : array_like\n"
    "    Scale parameter of the distribution.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__cauchy_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__cauchy_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__cauchy_ppf_types[0] = <char>NPY_FLOAT
ufunc__cauchy_ppf_types[1] = <char>NPY_FLOAT
ufunc__cauchy_ppf_types[2] = <char>NPY_FLOAT
ufunc__cauchy_ppf_types[3] = <char>NPY_FLOAT
ufunc__cauchy_ppf_types[4] = <char>NPY_DOUBLE
ufunc__cauchy_ppf_types[5] = <char>NPY_DOUBLE
ufunc__cauchy_ppf_types[6] = <char>NPY_DOUBLE
ufunc__cauchy_ppf_types[7] = <char>NPY_DOUBLE
ufunc__cauchy_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_cauchy_ppf_float
ufunc__cauchy_ppf_ptr[2*0+1] = <void*>(<char*>"_cauchy_ppf")
ufunc__cauchy_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_cauchy_ppf_double
ufunc__cauchy_ppf_ptr[2*1+1] = <void*>(<char*>"_cauchy_ppf")
ufunc__cauchy_ppf_data[0] = &ufunc__cauchy_ppf_ptr[2*0]
ufunc__cauchy_ppf_data[1] = &ufunc__cauchy_ppf_ptr[2*1]
_cauchy_ppf = np.PyUFunc_FromFuncAndData(ufunc__cauchy_ppf_loops, ufunc__cauchy_ppf_data, ufunc__cauchy_ppf_types, 2, 3, 1, 0, "_cauchy_ppf", ufunc__cauchy_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cosine_cdf_loops[2]
cdef void *ufunc__cosine_cdf_ptr[4]
cdef void *ufunc__cosine_cdf_data[2]
cdef char ufunc__cosine_cdf_types[4]
cdef char *ufunc__cosine_cdf_doc = (
    "_cosine_cdf(x)\n"
    "\n"
    "Cumulative distribution function (CDF) of the cosine distribution::\n"
    "\n"
    "             {             0,              x < -pi\n"
    "    cdf(x) = { (pi + x + sin(x))/(2*pi),   -pi <= x <= pi\n"
    "             {             1,              x > pi\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The cosine distribution CDF evaluated at `x`.")
ufunc__cosine_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_cdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_cdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_cdf_ptr[2*0] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*0+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_ptr[2*1] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*1+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_data[0] = &ufunc__cosine_cdf_ptr[2*0]
ufunc__cosine_cdf_data[1] = &ufunc__cosine_cdf_ptr[2*1]
_cosine_cdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_cdf_loops, ufunc__cosine_cdf_data, ufunc__cosine_cdf_types, 2, 1, 1, 0, "_cosine_cdf", ufunc__cosine_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cosine_invcdf_loops[2]
cdef void *ufunc__cosine_invcdf_ptr[4]
cdef void *ufunc__cosine_invcdf_data[2]
cdef char ufunc__cosine_invcdf_types[4]
cdef char *ufunc__cosine_invcdf_doc = (
    "_cosine_invcdf(p)\n"
    "\n"
    "Inverse of the cumulative distribution function (CDF) of the cosine\n"
    "distribution.\n"
    "\n"
    "The CDF of the cosine distribution is::\n"
    "\n"
    "    cdf(x) = (pi + x + sin(x))/(2*pi)\n"
    "\n"
    "This function computes the inverse of cdf(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    `p` must contain real numbers in the interval ``0 <= p <= 1``.\n"
    "    `nan` is returned for values of `p` outside the interval [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The inverse of the cosine distribution CDF evaluated at `p`.")
ufunc__cosine_invcdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_invcdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_invcdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_ptr[2*0] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*0+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_ptr[2*1] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*1+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_data[0] = &ufunc__cosine_invcdf_ptr[2*0]
ufunc__cosine_invcdf_data[1] = &ufunc__cosine_invcdf_ptr[2*1]
_cosine_invcdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_invcdf_loops, ufunc__cosine_invcdf_data, ufunc__cosine_invcdf_types, 2, 1, 1, 0, "_cosine_invcdf", ufunc__cosine_invcdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ellip_harm_loops[3]
cdef void *ufunc__ellip_harm_ptr[6]
cdef void *ufunc__ellip_harm_data[3]
cdef char ufunc__ellip_harm_types[24]
cdef char *ufunc__ellip_harm_doc = (
    "Internal function, use `ellip_harm` instead.")
ufunc__ellip_harm_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_fffffff_f
ufunc__ellip_harm_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddiiddd__As_ddllddd_d
ufunc__ellip_harm_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_ddddddd_d
ufunc__ellip_harm_types[0] = <char>NPY_FLOAT
ufunc__ellip_harm_types[1] = <char>NPY_FLOAT
ufunc__ellip_harm_types[2] = <char>NPY_FLOAT
ufunc__ellip_harm_types[3] = <char>NPY_FLOAT
ufunc__ellip_harm_types[4] = <char>NPY_FLOAT
ufunc__ellip_harm_types[5] = <char>NPY_FLOAT
ufunc__ellip_harm_types[6] = <char>NPY_FLOAT
ufunc__ellip_harm_types[7] = <char>NPY_FLOAT
ufunc__ellip_harm_types[8] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[9] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[10] = <char>NPY_LONG
ufunc__ellip_harm_types[11] = <char>NPY_LONG
ufunc__ellip_harm_types[12] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[13] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[14] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[15] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[16] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[17] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[18] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[19] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[20] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[21] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[22] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[23] = <char>NPY_DOUBLE
ufunc__ellip_harm_ptr[2*0] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*0+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*1] = <void*>_func_ellip_harmonic
ufunc__ellip_harm_ptr[2*1+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*2] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*2+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_data[0] = &ufunc__ellip_harm_ptr[2*0]
ufunc__ellip_harm_data[1] = &ufunc__ellip_harm_ptr[2*1]
ufunc__ellip_harm_data[2] = &ufunc__ellip_harm_ptr[2*2]
_ellip_harm = np.PyUFunc_FromFuncAndData(ufunc__ellip_harm_loops, ufunc__ellip_harm_data, ufunc__ellip_harm_types, 3, 7, 1, 0, "_ellip_harm", ufunc__ellip_harm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__factorial_loops[2]
cdef void *ufunc__factorial_ptr[4]
cdef void *ufunc__factorial_data[2]
cdef char ufunc__factorial_types[4]
cdef char *ufunc__factorial_doc = (
    "Internal function, do not use.")
ufunc__factorial_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__factorial_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__factorial_types[0] = <char>NPY_FLOAT
ufunc__factorial_types[1] = <char>NPY_FLOAT
ufunc__factorial_types[2] = <char>NPY_DOUBLE
ufunc__factorial_types[3] = <char>NPY_DOUBLE
ufunc__factorial_ptr[2*0] = <void*>_func__factorial
ufunc__factorial_ptr[2*0+1] = <void*>(<char*>"_factorial")
ufunc__factorial_ptr[2*1] = <void*>_func__factorial
ufunc__factorial_ptr[2*1+1] = <void*>(<char*>"_factorial")
ufunc__factorial_data[0] = &ufunc__factorial_ptr[2*0]
ufunc__factorial_data[1] = &ufunc__factorial_ptr[2*1]
_factorial = np.PyUFunc_FromFuncAndData(ufunc__factorial_loops, ufunc__factorial_data, ufunc__factorial_types, 2, 1, 1, 0, "_factorial", ufunc__factorial_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_cdf_loops[2]
cdef void *ufunc__hypergeom_cdf_ptr[4]
cdef void *ufunc__hypergeom_cdf_data[2]
cdef char ufunc__hypergeom_cdf_types[10]
cdef char *ufunc__hypergeom_cdf_doc = (
    "_hypergeom_cdf(x, r, N, M)\n"
    "\n"
    "Cumulative density function of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__hypergeom_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__hypergeom_cdf_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[4] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[8] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[9] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_cdf_float
ufunc__hypergeom_cdf_ptr[2*0+1] = <void*>(<char*>"_hypergeom_cdf")
ufunc__hypergeom_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_cdf_double
ufunc__hypergeom_cdf_ptr[2*1+1] = <void*>(<char*>"_hypergeom_cdf")
ufunc__hypergeom_cdf_data[0] = &ufunc__hypergeom_cdf_ptr[2*0]
ufunc__hypergeom_cdf_data[1] = &ufunc__hypergeom_cdf_ptr[2*1]
_hypergeom_cdf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_cdf_loops, ufunc__hypergeom_cdf_data, ufunc__hypergeom_cdf_types, 2, 4, 1, 0, "_hypergeom_cdf", ufunc__hypergeom_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_mean_loops[2]
cdef void *ufunc__hypergeom_mean_ptr[4]
cdef void *ufunc__hypergeom_mean_data[2]
cdef char ufunc__hypergeom_mean_types[8]
cdef char *ufunc__hypergeom_mean_doc = (
    "_hypergeom_mean(r, N, M)\n"
    "\n"
    "Mean of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__hypergeom_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__hypergeom_mean_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[4] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_mean_float
ufunc__hypergeom_mean_ptr[2*0+1] = <void*>(<char*>"_hypergeom_mean")
ufunc__hypergeom_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_mean_double
ufunc__hypergeom_mean_ptr[2*1+1] = <void*>(<char*>"_hypergeom_mean")
ufunc__hypergeom_mean_data[0] = &ufunc__hypergeom_mean_ptr[2*0]
ufunc__hypergeom_mean_data[1] = &ufunc__hypergeom_mean_ptr[2*1]
_hypergeom_mean = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_mean_loops, ufunc__hypergeom_mean_data, ufunc__hypergeom_mean_types, 2, 3, 1, 0, "_hypergeom_mean", ufunc__hypergeom_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_pmf_loops[2]
cdef void *ufunc__hypergeom_pmf_ptr[4]
cdef void *ufunc__hypergeom_pmf_data[2]
cdef char ufunc__hypergeom_pmf_types[10]
cdef char *ufunc__hypergeom_pmf_doc = (
    "_hypergeom_pmf(x, r, N, M)\n"
    "\n"
    "Probability mass function of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_pmf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__hypergeom_pmf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__hypergeom_pmf_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[4] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[8] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[9] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_pmf_float
ufunc__hypergeom_pmf_ptr[2*0+1] = <void*>(<char*>"_hypergeom_pmf")
ufunc__hypergeom_pmf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_pmf_double
ufunc__hypergeom_pmf_ptr[2*1+1] = <void*>(<char*>"_hypergeom_pmf")
ufunc__hypergeom_pmf_data[0] = &ufunc__hypergeom_pmf_ptr[2*0]
ufunc__hypergeom_pmf_data[1] = &ufunc__hypergeom_pmf_ptr[2*1]
_hypergeom_pmf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_pmf_loops, ufunc__hypergeom_pmf_data, ufunc__hypergeom_pmf_types, 2, 4, 1, 0, "_hypergeom_pmf", ufunc__hypergeom_pmf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_sf_loops[2]
cdef void *ufunc__hypergeom_sf_ptr[4]
cdef void *ufunc__hypergeom_sf_data[2]
cdef char ufunc__hypergeom_sf_types[10]
cdef char *ufunc__hypergeom_sf_doc = (
    "_hypergeom_sf(x, r, N, M)\n"
    "\n"
    "Survival function of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__hypergeom_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__hypergeom_sf_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[4] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[8] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[9] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_sf_float
ufunc__hypergeom_sf_ptr[2*0+1] = <void*>(<char*>"_hypergeom_sf")
ufunc__hypergeom_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_sf_double
ufunc__hypergeom_sf_ptr[2*1+1] = <void*>(<char*>"_hypergeom_sf")
ufunc__hypergeom_sf_data[0] = &ufunc__hypergeom_sf_ptr[2*0]
ufunc__hypergeom_sf_data[1] = &ufunc__hypergeom_sf_ptr[2*1]
_hypergeom_sf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_sf_loops, ufunc__hypergeom_sf_data, ufunc__hypergeom_sf_types, 2, 4, 1, 0, "_hypergeom_sf", ufunc__hypergeom_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_skewness_loops[2]
cdef void *ufunc__hypergeom_skewness_ptr[4]
cdef void *ufunc__hypergeom_skewness_data[2]
cdef char ufunc__hypergeom_skewness_types[8]
cdef char *ufunc__hypergeom_skewness_doc = (
    "_hypergeom_skewness(r, N, M)\n"
    "\n"
    "Skewness of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__hypergeom_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__hypergeom_skewness_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[4] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_skewness_float
ufunc__hypergeom_skewness_ptr[2*0+1] = <void*>(<char*>"_hypergeom_skewness")
ufunc__hypergeom_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_skewness_double
ufunc__hypergeom_skewness_ptr[2*1+1] = <void*>(<char*>"_hypergeom_skewness")
ufunc__hypergeom_skewness_data[0] = &ufunc__hypergeom_skewness_ptr[2*0]
ufunc__hypergeom_skewness_data[1] = &ufunc__hypergeom_skewness_ptr[2*1]
_hypergeom_skewness = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_skewness_loops, ufunc__hypergeom_skewness_data, ufunc__hypergeom_skewness_types, 2, 3, 1, 0, "_hypergeom_skewness", ufunc__hypergeom_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_variance_loops[2]
cdef void *ufunc__hypergeom_variance_ptr[4]
cdef void *ufunc__hypergeom_variance_data[2]
cdef char ufunc__hypergeom_variance_types[8]
cdef char *ufunc__hypergeom_variance_doc = (
    "_hypergeom_variance(r, N, M)\n"
    "\n"
    "Mean of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__hypergeom_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__hypergeom_variance_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[4] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_variance_float
ufunc__hypergeom_variance_ptr[2*0+1] = <void*>(<char*>"_hypergeom_variance")
ufunc__hypergeom_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_variance_double
ufunc__hypergeom_variance_ptr[2*1+1] = <void*>(<char*>"_hypergeom_variance")
ufunc__hypergeom_variance_data[0] = &ufunc__hypergeom_variance_ptr[2*0]
ufunc__hypergeom_variance_data[1] = &ufunc__hypergeom_variance_ptr[2*1]
_hypergeom_variance = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_variance_loops, ufunc__hypergeom_variance_data, ufunc__hypergeom_variance_types, 2, 3, 1, 0, "_hypergeom_variance", ufunc__hypergeom_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__igam_fac_loops[2]
cdef void *ufunc__igam_fac_ptr[4]
cdef void *ufunc__igam_fac_data[2]
cdef char ufunc__igam_fac_types[6]
cdef char *ufunc__igam_fac_doc = (
    "Internal function, do not use.")
ufunc__igam_fac_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__igam_fac_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__igam_fac_types[0] = <char>NPY_FLOAT
ufunc__igam_fac_types[1] = <char>NPY_FLOAT
ufunc__igam_fac_types[2] = <char>NPY_FLOAT
ufunc__igam_fac_types[3] = <char>NPY_DOUBLE
ufunc__igam_fac_types[4] = <char>NPY_DOUBLE
ufunc__igam_fac_types[5] = <char>NPY_DOUBLE
ufunc__igam_fac_ptr[2*0] = <void*>_func_cephes_igam_fac
ufunc__igam_fac_ptr[2*0+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_ptr[2*1] = <void*>_func_cephes_igam_fac
ufunc__igam_fac_ptr[2*1+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_data[0] = &ufunc__igam_fac_ptr[2*0]
ufunc__igam_fac_data[1] = &ufunc__igam_fac_ptr[2*1]
_igam_fac = np.PyUFunc_FromFuncAndData(ufunc__igam_fac_loops, ufunc__igam_fac_data, ufunc__igam_fac_types, 2, 2, 1, 0, "_igam_fac", ufunc__igam_fac_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__invgauss_isf_loops[2]
cdef void *ufunc__invgauss_isf_ptr[4]
cdef void *ufunc__invgauss_isf_data[2]
cdef char ufunc__invgauss_isf_types[8]
cdef char *ufunc__invgauss_isf_doc = (
    "_invgauss_isf(x, mu, s)\n"
    "\n"
    "Inverse survival function of inverse gaussian distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "mu : array_like\n"
    "    Positive, real-valued parameters\n"
    "s : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__invgauss_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__invgauss_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__invgauss_isf_types[0] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[1] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[2] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[3] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[4] = <char>NPY_DOUBLE
ufunc__invgauss_isf_types[5] = <char>NPY_DOUBLE
ufunc__invgauss_isf_types[6] = <char>NPY_DOUBLE
ufunc__invgauss_isf_types[7] = <char>NPY_DOUBLE
ufunc__invgauss_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_invgauss_isf_float
ufunc__invgauss_isf_ptr[2*0+1] = <void*>(<char*>"_invgauss_isf")
ufunc__invgauss_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_invgauss_isf_double
ufunc__invgauss_isf_ptr[2*1+1] = <void*>(<char*>"_invgauss_isf")
ufunc__invgauss_isf_data[0] = &ufunc__invgauss_isf_ptr[2*0]
ufunc__invgauss_isf_data[1] = &ufunc__invgauss_isf_ptr[2*1]
_invgauss_isf = np.PyUFunc_FromFuncAndData(ufunc__invgauss_isf_loops, ufunc__invgauss_isf_data, ufunc__invgauss_isf_types, 2, 3, 1, 0, "_invgauss_isf", ufunc__invgauss_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__invgauss_ppf_loops[2]
cdef void *ufunc__invgauss_ppf_ptr[4]
cdef void *ufunc__invgauss_ppf_data[2]
cdef char ufunc__invgauss_ppf_types[8]
cdef char *ufunc__invgauss_ppf_doc = (
    "_invgauss_ppf(x, mu)\n"
    "\n"
    "Percent point function of inverse gaussian distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "mu : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__invgauss_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__invgauss_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__invgauss_ppf_types[0] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[1] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[2] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[3] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[4] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_types[5] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_types[6] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_types[7] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_invgauss_ppf_float
ufunc__invgauss_ppf_ptr[2*0+1] = <void*>(<char*>"_invgauss_ppf")
ufunc__invgauss_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_invgauss_ppf_double
ufunc__invgauss_ppf_ptr[2*1+1] = <void*>(<char*>"_invgauss_ppf")
ufunc__invgauss_ppf_data[0] = &ufunc__invgauss_ppf_ptr[2*0]
ufunc__invgauss_ppf_data[1] = &ufunc__invgauss_ppf_ptr[2*1]
_invgauss_ppf = np.PyUFunc_FromFuncAndData(ufunc__invgauss_ppf_loops, ufunc__invgauss_ppf_data, ufunc__invgauss_ppf_types, 2, 3, 1, 0, "_invgauss_ppf", ufunc__invgauss_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogc_loops[2]
cdef void *ufunc__kolmogc_ptr[4]
cdef void *ufunc__kolmogc_data[2]
cdef char ufunc__kolmogc_types[4]
cdef char *ufunc__kolmogc_doc = (
    "Internal function, do not use.")
ufunc__kolmogc_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogc_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogc_types[0] = <char>NPY_FLOAT
ufunc__kolmogc_types[1] = <char>NPY_FLOAT
ufunc__kolmogc_types[2] = <char>NPY_DOUBLE
ufunc__kolmogc_types[3] = <char>NPY_DOUBLE
ufunc__kolmogc_ptr[2*0] = <void*>_func_xsf_kolmogc
ufunc__kolmogc_ptr[2*0+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_ptr[2*1] = <void*>_func_xsf_kolmogc
ufunc__kolmogc_ptr[2*1+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_data[0] = &ufunc__kolmogc_ptr[2*0]
ufunc__kolmogc_data[1] = &ufunc__kolmogc_ptr[2*1]
_kolmogc = np.PyUFunc_FromFuncAndData(ufunc__kolmogc_loops, ufunc__kolmogc_data, ufunc__kolmogc_types, 2, 1, 1, 0, "_kolmogc", ufunc__kolmogc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogci_loops[2]
cdef void *ufunc__kolmogci_ptr[4]
cdef void *ufunc__kolmogci_data[2]
cdef char ufunc__kolmogci_types[4]
cdef char *ufunc__kolmogci_doc = (
    "Internal function, do not use.")
ufunc__kolmogci_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogci_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogci_types[0] = <char>NPY_FLOAT
ufunc__kolmogci_types[1] = <char>NPY_FLOAT
ufunc__kolmogci_types[2] = <char>NPY_DOUBLE
ufunc__kolmogci_types[3] = <char>NPY_DOUBLE
ufunc__kolmogci_ptr[2*0] = <void*>_func_xsf_kolmogci
ufunc__kolmogci_ptr[2*0+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_ptr[2*1] = <void*>_func_xsf_kolmogci
ufunc__kolmogci_ptr[2*1+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_data[0] = &ufunc__kolmogci_ptr[2*0]
ufunc__kolmogci_data[1] = &ufunc__kolmogci_ptr[2*1]
_kolmogci = np.PyUFunc_FromFuncAndData(ufunc__kolmogci_loops, ufunc__kolmogci_data, ufunc__kolmogci_types, 2, 1, 1, 0, "_kolmogci", ufunc__kolmogci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogp_loops[2]
cdef void *ufunc__kolmogp_ptr[4]
cdef void *ufunc__kolmogp_data[2]
cdef char ufunc__kolmogp_types[4]
cdef char *ufunc__kolmogp_doc = (
    "Internal function, do not use.")
ufunc__kolmogp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogp_types[0] = <char>NPY_FLOAT
ufunc__kolmogp_types[1] = <char>NPY_FLOAT
ufunc__kolmogp_types[2] = <char>NPY_DOUBLE
ufunc__kolmogp_types[3] = <char>NPY_DOUBLE
ufunc__kolmogp_ptr[2*0] = <void*>_func_xsf_kolmogp
ufunc__kolmogp_ptr[2*0+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_ptr[2*1] = <void*>_func_xsf_kolmogp
ufunc__kolmogp_ptr[2*1+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_data[0] = &ufunc__kolmogp_ptr[2*0]
ufunc__kolmogp_data[1] = &ufunc__kolmogp_ptr[2*1]
_kolmogp = np.PyUFunc_FromFuncAndData(ufunc__kolmogp_loops, ufunc__kolmogp_data, ufunc__kolmogp_types, 2, 1, 1, 0, "_kolmogp", ufunc__kolmogp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lanczos_sum_expg_scaled_loops[2]
cdef void *ufunc__lanczos_sum_expg_scaled_ptr[4]
cdef void *ufunc__lanczos_sum_expg_scaled_data[2]
cdef char ufunc__lanczos_sum_expg_scaled_types[4]
cdef char *ufunc__lanczos_sum_expg_scaled_doc = (
    "Internal function, do not use.")
ufunc__lanczos_sum_expg_scaled_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lanczos_sum_expg_scaled_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lanczos_sum_expg_scaled_types[0] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[1] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[2] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_types[3] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_ptr[2*0] = <void*>_func_cephes_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*0+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_ptr[2*1] = <void*>_func_cephes_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*1+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_data[0] = &ufunc__lanczos_sum_expg_scaled_ptr[2*0]
ufunc__lanczos_sum_expg_scaled_data[1] = &ufunc__lanczos_sum_expg_scaled_ptr[2*1]
_lanczos_sum_expg_scaled = np.PyUFunc_FromFuncAndData(ufunc__lanczos_sum_expg_scaled_loops, ufunc__lanczos_sum_expg_scaled_data, ufunc__lanczos_sum_expg_scaled_types, 2, 1, 1, 0, "_lanczos_sum_expg_scaled", ufunc__lanczos_sum_expg_scaled_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__landau_cdf_loops[2]
cdef void *ufunc__landau_cdf_ptr[4]
cdef void *ufunc__landau_cdf_data[2]
cdef char ufunc__landau_cdf_types[8]
cdef char *ufunc__landau_cdf_doc = (
    "_landau_cdf(x, loc, scale)\n"
    "\n"
    "Cumulative distribution function of the Landau distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued argument\n"
    "loc : array_like\n"
    "    Real-valued distribution location\n"
    "scale : array_like\n"
    "    Positive, real-valued distribution scale\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__landau_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__landau_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__landau_cdf_types[0] = <char>NPY_FLOAT
ufunc__landau_cdf_types[1] = <char>NPY_FLOAT
ufunc__landau_cdf_types[2] = <char>NPY_FLOAT
ufunc__landau_cdf_types[3] = <char>NPY_FLOAT
ufunc__landau_cdf_types[4] = <char>NPY_DOUBLE
ufunc__landau_cdf_types[5] = <char>NPY_DOUBLE
ufunc__landau_cdf_types[6] = <char>NPY_DOUBLE
ufunc__landau_cdf_types[7] = <char>NPY_DOUBLE
ufunc__landau_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_landau_cdf_float
ufunc__landau_cdf_ptr[2*0+1] = <void*>(<char*>"_landau_cdf")
ufunc__landau_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_landau_cdf_double
ufunc__landau_cdf_ptr[2*1+1] = <void*>(<char*>"_landau_cdf")
ufunc__landau_cdf_data[0] = &ufunc__landau_cdf_ptr[2*0]
ufunc__landau_cdf_data[1] = &ufunc__landau_cdf_ptr[2*1]
_landau_cdf = np.PyUFunc_FromFuncAndData(ufunc__landau_cdf_loops, ufunc__landau_cdf_data, ufunc__landau_cdf_types, 2, 3, 1, 0, "_landau_cdf", ufunc__landau_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__landau_isf_loops[2]
cdef void *ufunc__landau_isf_ptr[4]
cdef void *ufunc__landau_isf_data[2]
cdef char ufunc__landau_isf_types[8]
cdef char *ufunc__landau_isf_doc = (
    "_landau_isf(p, loc, scale)\n"
    "\n"
    "Inverse survival function of the Landau distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Real-valued argument between 0 and 1\n"
    "loc : array_like\n"
    "    Real-valued distribution location\n"
    "scale : array_like\n"
    "    Positive, real-valued distribution scale\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__landau_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__landau_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__landau_isf_types[0] = <char>NPY_FLOAT
ufunc__landau_isf_types[1] = <char>NPY_FLOAT
ufunc__landau_isf_types[2] = <char>NPY_FLOAT
ufunc__landau_isf_types[3] = <char>NPY_FLOAT
ufunc__landau_isf_types[4] = <char>NPY_DOUBLE
ufunc__landau_isf_types[5] = <char>NPY_DOUBLE
ufunc__landau_isf_types[6] = <char>NPY_DOUBLE
ufunc__landau_isf_types[7] = <char>NPY_DOUBLE
ufunc__landau_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_landau_isf_float
ufunc__landau_isf_ptr[2*0+1] = <void*>(<char*>"_landau_isf")
ufunc__landau_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_landau_isf_double
ufunc__landau_isf_ptr[2*1+1] = <void*>(<char*>"_landau_isf")
ufunc__landau_isf_data[0] = &ufunc__landau_isf_ptr[2*0]
ufunc__landau_isf_data[1] = &ufunc__landau_isf_ptr[2*1]
_landau_isf = np.PyUFunc_FromFuncAndData(ufunc__landau_isf_loops, ufunc__landau_isf_data, ufunc__landau_isf_types, 2, 3, 1, 0, "_landau_isf", ufunc__landau_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__landau_pdf_loops[2]
cdef void *ufunc__landau_pdf_ptr[4]
cdef void *ufunc__landau_pdf_data[2]
cdef char ufunc__landau_pdf_types[8]
cdef char *ufunc__landau_pdf_doc = (
    "_landau_pdf(x, loc, scale)\n"
    "\n"
    "Probability density function of the Landau distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued argument\n"
    "loc : array_like\n"
    "    Real-valued distribution location\n"
    "scale : array_like\n"
    "    Positive, real-valued distribution scale\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__landau_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__landau_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__landau_pdf_types[0] = <char>NPY_FLOAT
ufunc__landau_pdf_types[1] = <char>NPY_FLOAT
ufunc__landau_pdf_types[2] = <char>NPY_FLOAT
ufunc__landau_pdf_types[3] = <char>NPY_FLOAT
ufunc__landau_pdf_types[4] = <char>NPY_DOUBLE
ufunc__landau_pdf_types[5] = <char>NPY_DOUBLE
ufunc__landau_pdf_types[6] = <char>NPY_DOUBLE
ufunc__landau_pdf_types[7] = <char>NPY_DOUBLE
ufunc__landau_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_landau_pdf_float
ufunc__landau_pdf_ptr[2*0+1] = <void*>(<char*>"_landau_pdf")
ufunc__landau_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_landau_pdf_double
ufunc__landau_pdf_ptr[2*1+1] = <void*>(<char*>"_landau_pdf")
ufunc__landau_pdf_data[0] = &ufunc__landau_pdf_ptr[2*0]
ufunc__landau_pdf_data[1] = &ufunc__landau_pdf_ptr[2*1]
_landau_pdf = np.PyUFunc_FromFuncAndData(ufunc__landau_pdf_loops, ufunc__landau_pdf_data, ufunc__landau_pdf_types, 2, 3, 1, 0, "_landau_pdf", ufunc__landau_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__landau_ppf_loops[2]
cdef void *ufunc__landau_ppf_ptr[4]
cdef void *ufunc__landau_ppf_data[2]
cdef char ufunc__landau_ppf_types[8]
cdef char *ufunc__landau_ppf_doc = (
    "_landau_ppf(p, loc, scale)\n"
    "\n"
    "Percent point function of the Landau distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Real-valued argument between 0 and 1\n"
    "loc : array_like\n"
    "    Real-valued distribution location\n"
    "scale : array_like\n"
    "    Positive, real-valued distribution scale\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__landau_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__landau_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__landau_ppf_types[0] = <char>NPY_FLOAT
ufunc__landau_ppf_types[1] = <char>NPY_FLOAT
ufunc__landau_ppf_types[2] = <char>NPY_FLOAT
ufunc__landau_ppf_types[3] = <char>NPY_FLOAT
ufunc__landau_ppf_types[4] = <char>NPY_DOUBLE
ufunc__landau_ppf_types[5] = <char>NPY_DOUBLE
ufunc__landau_ppf_types[6] = <char>NPY_DOUBLE
ufunc__landau_ppf_types[7] = <char>NPY_DOUBLE
ufunc__landau_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_landau_ppf_float
ufunc__landau_ppf_ptr[2*0+1] = <void*>(<char*>"_landau_ppf")
ufunc__landau_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_landau_ppf_double
ufunc__landau_ppf_ptr[2*1+1] = <void*>(<char*>"_landau_ppf")
ufunc__landau_ppf_data[0] = &ufunc__landau_ppf_ptr[2*0]
ufunc__landau_ppf_data[1] = &ufunc__landau_ppf_ptr[2*1]
_landau_ppf = np.PyUFunc_FromFuncAndData(ufunc__landau_ppf_loops, ufunc__landau_ppf_data, ufunc__landau_ppf_types, 2, 3, 1, 0, "_landau_ppf", ufunc__landau_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__landau_sf_loops[2]
cdef void *ufunc__landau_sf_ptr[4]
cdef void *ufunc__landau_sf_data[2]
cdef char ufunc__landau_sf_types[8]
cdef char *ufunc__landau_sf_doc = (
    "_landau_sf(x, loc, scale)\n"
    "\n"
    "Survival function of the Landau distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued argument\n"
    "loc : array_like\n"
    "    Real-valued distribution location\n"
    "scale : array_like\n"
    "    Positive, real-valued distribution scale\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__landau_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__landau_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__landau_sf_types[0] = <char>NPY_FLOAT
ufunc__landau_sf_types[1] = <char>NPY_FLOAT
ufunc__landau_sf_types[2] = <char>NPY_FLOAT
ufunc__landau_sf_types[3] = <char>NPY_FLOAT
ufunc__landau_sf_types[4] = <char>NPY_DOUBLE
ufunc__landau_sf_types[5] = <char>NPY_DOUBLE
ufunc__landau_sf_types[6] = <char>NPY_DOUBLE
ufunc__landau_sf_types[7] = <char>NPY_DOUBLE
ufunc__landau_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_landau_sf_float
ufunc__landau_sf_ptr[2*0+1] = <void*>(<char*>"_landau_sf")
ufunc__landau_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_landau_sf_double
ufunc__landau_sf_ptr[2*1+1] = <void*>(<char*>"_landau_sf")
ufunc__landau_sf_data[0] = &ufunc__landau_sf_ptr[2*0]
ufunc__landau_sf_data[1] = &ufunc__landau_sf_ptr[2*1]
_landau_sf = np.PyUFunc_FromFuncAndData(ufunc__landau_sf_loops, ufunc__landau_sf_data, ufunc__landau_sf_types, 2, 3, 1, 0, "_landau_sf", ufunc__landau_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lgam1p_loops[2]
cdef void *ufunc__lgam1p_ptr[4]
cdef void *ufunc__lgam1p_data[2]
cdef char ufunc__lgam1p_types[4]
cdef char *ufunc__lgam1p_doc = (
    "Internal function, do not use.")
ufunc__lgam1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lgam1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lgam1p_types[0] = <char>NPY_FLOAT
ufunc__lgam1p_types[1] = <char>NPY_FLOAT
ufunc__lgam1p_types[2] = <char>NPY_DOUBLE
ufunc__lgam1p_types[3] = <char>NPY_DOUBLE
ufunc__lgam1p_ptr[2*0] = <void*>_func_cephes_lgam1p
ufunc__lgam1p_ptr[2*0+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_ptr[2*1] = <void*>_func_cephes_lgam1p
ufunc__lgam1p_ptr[2*1+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_data[0] = &ufunc__lgam1p_ptr[2*0]
ufunc__lgam1p_data[1] = &ufunc__lgam1p_ptr[2*1]
_lgam1p = np.PyUFunc_FromFuncAndData(ufunc__lgam1p_loops, ufunc__lgam1p_data, ufunc__lgam1p_types, 2, 1, 1, 0, "_lgam1p", ufunc__lgam1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__log1pmx_loops[2]
cdef void *ufunc__log1pmx_ptr[4]
cdef void *ufunc__log1pmx_data[2]
cdef char ufunc__log1pmx_types[4]
cdef char *ufunc__log1pmx_doc = (
    "Internal function, do not use.")
ufunc__log1pmx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__log1pmx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__log1pmx_types[0] = <char>NPY_FLOAT
ufunc__log1pmx_types[1] = <char>NPY_FLOAT
ufunc__log1pmx_types[2] = <char>NPY_DOUBLE
ufunc__log1pmx_types[3] = <char>NPY_DOUBLE
ufunc__log1pmx_ptr[2*0] = <void*>_func_cephes_log1pmx
ufunc__log1pmx_ptr[2*0+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_ptr[2*1] = <void*>_func_cephes_log1pmx
ufunc__log1pmx_ptr[2*1+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_data[0] = &ufunc__log1pmx_ptr[2*0]
ufunc__log1pmx_data[1] = &ufunc__log1pmx_ptr[2*1]
_log1pmx = np.PyUFunc_FromFuncAndData(ufunc__log1pmx_loops, ufunc__log1pmx_data, ufunc__log1pmx_types, 2, 1, 1, 0, "_log1pmx", ufunc__log1pmx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_cdf_loops[2]
cdef void *ufunc__nbinom_cdf_ptr[4]
cdef void *ufunc__nbinom_cdf_data[2]
cdef char ufunc__nbinom_cdf_types[8]
cdef char *ufunc__nbinom_cdf_doc = (
    "_nbinom_cdf(x, r, p)\n"
    "\n"
    "Cumulative density function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_cdf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_cdf_float
ufunc__nbinom_cdf_ptr[2*0+1] = <void*>(<char*>"_nbinom_cdf")
ufunc__nbinom_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_cdf_double
ufunc__nbinom_cdf_ptr[2*1+1] = <void*>(<char*>"_nbinom_cdf")
ufunc__nbinom_cdf_data[0] = &ufunc__nbinom_cdf_ptr[2*0]
ufunc__nbinom_cdf_data[1] = &ufunc__nbinom_cdf_ptr[2*1]
_nbinom_cdf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_cdf_loops, ufunc__nbinom_cdf_data, ufunc__nbinom_cdf_types, 2, 3, 1, 0, "_nbinom_cdf", ufunc__nbinom_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_isf_loops[2]
cdef void *ufunc__nbinom_isf_ptr[4]
cdef void *ufunc__nbinom_isf_data[2]
cdef char ufunc__nbinom_isf_types[8]
cdef char *ufunc__nbinom_isf_doc = (
    "_nbinom_isf(x, r, p)\n"
    "\n"
    "Inverse survival function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_isf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_isf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_isf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_isf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_isf_float
ufunc__nbinom_isf_ptr[2*0+1] = <void*>(<char*>"_nbinom_isf")
ufunc__nbinom_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_isf_double
ufunc__nbinom_isf_ptr[2*1+1] = <void*>(<char*>"_nbinom_isf")
ufunc__nbinom_isf_data[0] = &ufunc__nbinom_isf_ptr[2*0]
ufunc__nbinom_isf_data[1] = &ufunc__nbinom_isf_ptr[2*1]
_nbinom_isf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_isf_loops, ufunc__nbinom_isf_data, ufunc__nbinom_isf_types, 2, 3, 1, 0, "_nbinom_isf", ufunc__nbinom_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_kurtosis_excess_loops[2]
cdef void *ufunc__nbinom_kurtosis_excess_ptr[4]
cdef void *ufunc__nbinom_kurtosis_excess_data[2]
cdef char ufunc__nbinom_kurtosis_excess_types[6]
cdef char *ufunc__nbinom_kurtosis_excess_doc = (
    "_nbinom_kurtosis_excess(r, p)\n"
    "\n"
    "Kurtosis excess of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_kurtosis_excess_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_kurtosis_excess_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_kurtosis_excess_types[0] = <char>NPY_FLOAT
ufunc__nbinom_kurtosis_excess_types[1] = <char>NPY_FLOAT
ufunc__nbinom_kurtosis_excess_types[2] = <char>NPY_FLOAT
ufunc__nbinom_kurtosis_excess_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_kurtosis_excess_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_kurtosis_excess_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_kurtosis_excess_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_kurtosis_excess_float
ufunc__nbinom_kurtosis_excess_ptr[2*0+1] = <void*>(<char*>"_nbinom_kurtosis_excess")
ufunc__nbinom_kurtosis_excess_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_kurtosis_excess_double
ufunc__nbinom_kurtosis_excess_ptr[2*1+1] = <void*>(<char*>"_nbinom_kurtosis_excess")
ufunc__nbinom_kurtosis_excess_data[0] = &ufunc__nbinom_kurtosis_excess_ptr[2*0]
ufunc__nbinom_kurtosis_excess_data[1] = &ufunc__nbinom_kurtosis_excess_ptr[2*1]
_nbinom_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__nbinom_kurtosis_excess_loops, ufunc__nbinom_kurtosis_excess_data, ufunc__nbinom_kurtosis_excess_types, 2, 2, 1, 0, "_nbinom_kurtosis_excess", ufunc__nbinom_kurtosis_excess_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_mean_loops[2]
cdef void *ufunc__nbinom_mean_ptr[4]
cdef void *ufunc__nbinom_mean_data[2]
cdef char ufunc__nbinom_mean_types[6]
cdef char *ufunc__nbinom_mean_doc = (
    "_nbinom_mean(r, p)\n"
    "\n"
    "Mean of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_mean_types[0] = <char>NPY_FLOAT
ufunc__nbinom_mean_types[1] = <char>NPY_FLOAT
ufunc__nbinom_mean_types[2] = <char>NPY_FLOAT
ufunc__nbinom_mean_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_mean_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_mean_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_mean_float
ufunc__nbinom_mean_ptr[2*0+1] = <void*>(<char*>"_nbinom_mean")
ufunc__nbinom_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_mean_double
ufunc__nbinom_mean_ptr[2*1+1] = <void*>(<char*>"_nbinom_mean")
ufunc__nbinom_mean_data[0] = &ufunc__nbinom_mean_ptr[2*0]
ufunc__nbinom_mean_data[1] = &ufunc__nbinom_mean_ptr[2*1]
_nbinom_mean = np.PyUFunc_FromFuncAndData(ufunc__nbinom_mean_loops, ufunc__nbinom_mean_data, ufunc__nbinom_mean_types, 2, 2, 1, 0, "_nbinom_mean", ufunc__nbinom_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_pmf_loops[2]
cdef void *ufunc__nbinom_pmf_ptr[4]
cdef void *ufunc__nbinom_pmf_data[2]
cdef char ufunc__nbinom_pmf_types[8]
cdef char *ufunc__nbinom_pmf_doc = (
    "_nbinom_pmf(x, r, p)\n"
    "\n"
    "Probability mass function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_pmf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_pmf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_pmf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_pmf_float
ufunc__nbinom_pmf_ptr[2*0+1] = <void*>(<char*>"_nbinom_pmf")
ufunc__nbinom_pmf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_pmf_double
ufunc__nbinom_pmf_ptr[2*1+1] = <void*>(<char*>"_nbinom_pmf")
ufunc__nbinom_pmf_data[0] = &ufunc__nbinom_pmf_ptr[2*0]
ufunc__nbinom_pmf_data[1] = &ufunc__nbinom_pmf_ptr[2*1]
_nbinom_pmf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_pmf_loops, ufunc__nbinom_pmf_data, ufunc__nbinom_pmf_types, 2, 3, 1, 0, "_nbinom_pmf", ufunc__nbinom_pmf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_ppf_loops[2]
cdef void *ufunc__nbinom_ppf_ptr[4]
cdef void *ufunc__nbinom_ppf_data[2]
cdef char ufunc__nbinom_ppf_types[8]
cdef char *ufunc__nbinom_ppf_doc = (
    "_nbinom_ppf(x, r, p)\n"
    "\n"
    "Percent point function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_ppf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_ppf_float
ufunc__nbinom_ppf_ptr[2*0+1] = <void*>(<char*>"_nbinom_ppf")
ufunc__nbinom_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_ppf_double
ufunc__nbinom_ppf_ptr[2*1+1] = <void*>(<char*>"_nbinom_ppf")
ufunc__nbinom_ppf_data[0] = &ufunc__nbinom_ppf_ptr[2*0]
ufunc__nbinom_ppf_data[1] = &ufunc__nbinom_ppf_ptr[2*1]
_nbinom_ppf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_ppf_loops, ufunc__nbinom_ppf_data, ufunc__nbinom_ppf_types, 2, 3, 1, 0, "_nbinom_ppf", ufunc__nbinom_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_sf_loops[2]
cdef void *ufunc__nbinom_sf_ptr[4]
cdef void *ufunc__nbinom_sf_data[2]
cdef char ufunc__nbinom_sf_types[8]
cdef char *ufunc__nbinom_sf_doc = (
    "_nbinom_sf(x, r, p)\n"
    "\n"
    "Survival function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_sf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_sf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_sf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_sf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_sf_float
ufunc__nbinom_sf_ptr[2*0+1] = <void*>(<char*>"_nbinom_sf")
ufunc__nbinom_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_sf_double
ufunc__nbinom_sf_ptr[2*1+1] = <void*>(<char*>"_nbinom_sf")
ufunc__nbinom_sf_data[0] = &ufunc__nbinom_sf_ptr[2*0]
ufunc__nbinom_sf_data[1] = &ufunc__nbinom_sf_ptr[2*1]
_nbinom_sf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_sf_loops, ufunc__nbinom_sf_data, ufunc__nbinom_sf_types, 2, 3, 1, 0, "_nbinom_sf", ufunc__nbinom_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_skewness_loops[2]
cdef void *ufunc__nbinom_skewness_ptr[4]
cdef void *ufunc__nbinom_skewness_data[2]
cdef char ufunc__nbinom_skewness_types[6]
cdef char *ufunc__nbinom_skewness_doc = (
    "_nbinom_skewness(r, p)\n"
    "\n"
    "Skewness of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_skewness_types[0] = <char>NPY_FLOAT
ufunc__nbinom_skewness_types[1] = <char>NPY_FLOAT
ufunc__nbinom_skewness_types[2] = <char>NPY_FLOAT
ufunc__nbinom_skewness_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_skewness_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_skewness_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_skewness_float
ufunc__nbinom_skewness_ptr[2*0+1] = <void*>(<char*>"_nbinom_skewness")
ufunc__nbinom_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_skewness_double
ufunc__nbinom_skewness_ptr[2*1+1] = <void*>(<char*>"_nbinom_skewness")
ufunc__nbinom_skewness_data[0] = &ufunc__nbinom_skewness_ptr[2*0]
ufunc__nbinom_skewness_data[1] = &ufunc__nbinom_skewness_ptr[2*1]
_nbinom_skewness = np.PyUFunc_FromFuncAndData(ufunc__nbinom_skewness_loops, ufunc__nbinom_skewness_data, ufunc__nbinom_skewness_types, 2, 2, 1, 0, "_nbinom_skewness", ufunc__nbinom_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_variance_loops[2]
cdef void *ufunc__nbinom_variance_ptr[4]
cdef void *ufunc__nbinom_variance_data[2]
cdef char ufunc__nbinom_variance_types[6]
cdef char *ufunc__nbinom_variance_doc = (
    "_nbinom_variance(r, p)\n"
    "\n"
    "Variance of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_variance_types[0] = <char>NPY_FLOAT
ufunc__nbinom_variance_types[1] = <char>NPY_FLOAT
ufunc__nbinom_variance_types[2] = <char>NPY_FLOAT
ufunc__nbinom_variance_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_variance_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_variance_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_variance_float
ufunc__nbinom_variance_ptr[2*0+1] = <void*>(<char*>"_nbinom_variance")
ufunc__nbinom_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_variance_double
ufunc__nbinom_variance_ptr[2*1+1] = <void*>(<char*>"_nbinom_variance")
ufunc__nbinom_variance_data[0] = &ufunc__nbinom_variance_ptr[2*0]
ufunc__nbinom_variance_data[1] = &ufunc__nbinom_variance_ptr[2*1]
_nbinom_variance = np.PyUFunc_FromFuncAndData(ufunc__nbinom_variance_loops, ufunc__nbinom_variance_data, ufunc__nbinom_variance_types, 2, 2, 1, 0, "_nbinom_variance", ufunc__nbinom_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_isf_loops[2]
cdef void *ufunc__ncf_isf_ptr[4]
cdef void *ufunc__ncf_isf_data[2]
cdef char ufunc__ncf_isf_types[10]
cdef char *ufunc__ncf_isf_doc = (
    "_ncf_isf(x, v1, v2, l)\n"
    "\n"
    "Inverse survival function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_isf_types[0] = <char>NPY_FLOAT
ufunc__ncf_isf_types[1] = <char>NPY_FLOAT
ufunc__ncf_isf_types[2] = <char>NPY_FLOAT
ufunc__ncf_isf_types[3] = <char>NPY_FLOAT
ufunc__ncf_isf_types[4] = <char>NPY_FLOAT
ufunc__ncf_isf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_isf_float
ufunc__ncf_isf_ptr[2*0+1] = <void*>(<char*>"_ncf_isf")
ufunc__ncf_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_isf_double
ufunc__ncf_isf_ptr[2*1+1] = <void*>(<char*>"_ncf_isf")
ufunc__ncf_isf_data[0] = &ufunc__ncf_isf_ptr[2*0]
ufunc__ncf_isf_data[1] = &ufunc__ncf_isf_ptr[2*1]
_ncf_isf = np.PyUFunc_FromFuncAndData(ufunc__ncf_isf_loops, ufunc__ncf_isf_data, ufunc__ncf_isf_types, 2, 4, 1, 0, "_ncf_isf", ufunc__ncf_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_kurtosis_excess_loops[2]
cdef void *ufunc__ncf_kurtosis_excess_ptr[4]
cdef void *ufunc__ncf_kurtosis_excess_data[2]
cdef char ufunc__ncf_kurtosis_excess_types[8]
cdef char *ufunc__ncf_kurtosis_excess_doc = (
    "_ncf_kurtosis_excess(v1, v2, l)\n"
    "\n"
    "Kurtosis excess of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_kurtosis_excess_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_kurtosis_excess_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_kurtosis_excess_types[0] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[1] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[2] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[3] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[4] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_types[5] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_types[6] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_types[7] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_kurtosis_excess_float
ufunc__ncf_kurtosis_excess_ptr[2*0+1] = <void*>(<char*>"_ncf_kurtosis_excess")
ufunc__ncf_kurtosis_excess_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_kurtosis_excess_double
ufunc__ncf_kurtosis_excess_ptr[2*1+1] = <void*>(<char*>"_ncf_kurtosis_excess")
ufunc__ncf_kurtosis_excess_data[0] = &ufunc__ncf_kurtosis_excess_ptr[2*0]
ufunc__ncf_kurtosis_excess_data[1] = &ufunc__ncf_kurtosis_excess_ptr[2*1]
_ncf_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__ncf_kurtosis_excess_loops, ufunc__ncf_kurtosis_excess_data, ufunc__ncf_kurtosis_excess_types, 2, 3, 1, 0, "_ncf_kurtosis_excess", ufunc__ncf_kurtosis_excess_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_mean_loops[2]
cdef void *ufunc__ncf_mean_ptr[4]
cdef void *ufunc__ncf_mean_data[2]
cdef char ufunc__ncf_mean_types[8]
cdef char *ufunc__ncf_mean_doc = (
    "_ncf_mean(v1, v2, l)\n"
    "\n"
    "Mean of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_mean_types[0] = <char>NPY_FLOAT
ufunc__ncf_mean_types[1] = <char>NPY_FLOAT
ufunc__ncf_mean_types[2] = <char>NPY_FLOAT
ufunc__ncf_mean_types[3] = <char>NPY_FLOAT
ufunc__ncf_mean_types[4] = <char>NPY_DOUBLE
ufunc__ncf_mean_types[5] = <char>NPY_DOUBLE
ufunc__ncf_mean_types[6] = <char>NPY_DOUBLE
ufunc__ncf_mean_types[7] = <char>NPY_DOUBLE
ufunc__ncf_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_mean_float
ufunc__ncf_mean_ptr[2*0+1] = <void*>(<char*>"_ncf_mean")
ufunc__ncf_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_mean_double
ufunc__ncf_mean_ptr[2*1+1] = <void*>(<char*>"_ncf_mean")
ufunc__ncf_mean_data[0] = &ufunc__ncf_mean_ptr[2*0]
ufunc__ncf_mean_data[1] = &ufunc__ncf_mean_ptr[2*1]
_ncf_mean = np.PyUFunc_FromFuncAndData(ufunc__ncf_mean_loops, ufunc__ncf_mean_data, ufunc__ncf_mean_types, 2, 3, 1, 0, "_ncf_mean", ufunc__ncf_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_pdf_loops[2]
cdef void *ufunc__ncf_pdf_ptr[4]
cdef void *ufunc__ncf_pdf_data[2]
cdef char ufunc__ncf_pdf_types[10]
cdef char *ufunc__ncf_pdf_doc = (
    "_ncf_pdf(x, v1, v2, l)\n"
    "\n"
    "Probability density function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_pdf_types[0] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[1] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[2] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[3] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[4] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_pdf_float
ufunc__ncf_pdf_ptr[2*0+1] = <void*>(<char*>"_ncf_pdf")
ufunc__ncf_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_pdf_double
ufunc__ncf_pdf_ptr[2*1+1] = <void*>(<char*>"_ncf_pdf")
ufunc__ncf_pdf_data[0] = &ufunc__ncf_pdf_ptr[2*0]
ufunc__ncf_pdf_data[1] = &ufunc__ncf_pdf_ptr[2*1]
_ncf_pdf = np.PyUFunc_FromFuncAndData(ufunc__ncf_pdf_loops, ufunc__ncf_pdf_data, ufunc__ncf_pdf_types, 2, 4, 1, 0, "_ncf_pdf", ufunc__ncf_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_sf_loops[2]
cdef void *ufunc__ncf_sf_ptr[4]
cdef void *ufunc__ncf_sf_data[2]
cdef char ufunc__ncf_sf_types[10]
cdef char *ufunc__ncf_sf_doc = (
    "_ncf_sf(x, v1, v2, l)\n"
    "\n"
    "Survival function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_sf_types[0] = <char>NPY_FLOAT
ufunc__ncf_sf_types[1] = <char>NPY_FLOAT
ufunc__ncf_sf_types[2] = <char>NPY_FLOAT
ufunc__ncf_sf_types[3] = <char>NPY_FLOAT
ufunc__ncf_sf_types[4] = <char>NPY_FLOAT
ufunc__ncf_sf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_sf_float
ufunc__ncf_sf_ptr[2*0+1] = <void*>(<char*>"_ncf_sf")
ufunc__ncf_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_sf_double
ufunc__ncf_sf_ptr[2*1+1] = <void*>(<char*>"_ncf_sf")
ufunc__ncf_sf_data[0] = &ufunc__ncf_sf_ptr[2*0]
ufunc__ncf_sf_data[1] = &ufunc__ncf_sf_ptr[2*1]
_ncf_sf = np.PyUFunc_FromFuncAndData(ufunc__ncf_sf_loops, ufunc__ncf_sf_data, ufunc__ncf_sf_types, 2, 4, 1, 0, "_ncf_sf", ufunc__ncf_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_skewness_loops[2]
cdef void *ufunc__ncf_skewness_ptr[4]
cdef void *ufunc__ncf_skewness_data[2]
cdef char ufunc__ncf_skewness_types[8]
cdef char *ufunc__ncf_skewness_doc = (
    "_ncf_skewness(v1, v2, l)\n"
    "\n"
    "Skewness of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_skewness_types[0] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[1] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[2] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[3] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[4] = <char>NPY_DOUBLE
ufunc__ncf_skewness_types[5] = <char>NPY_DOUBLE
ufunc__ncf_skewness_types[6] = <char>NPY_DOUBLE
ufunc__ncf_skewness_types[7] = <char>NPY_DOUBLE
ufunc__ncf_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_skewness_float
ufunc__ncf_skewness_ptr[2*0+1] = <void*>(<char*>"_ncf_skewness")
ufunc__ncf_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_skewness_double
ufunc__ncf_skewness_ptr[2*1+1] = <void*>(<char*>"_ncf_skewness")
ufunc__ncf_skewness_data[0] = &ufunc__ncf_skewness_ptr[2*0]
ufunc__ncf_skewness_data[1] = &ufunc__ncf_skewness_ptr[2*1]
_ncf_skewness = np.PyUFunc_FromFuncAndData(ufunc__ncf_skewness_loops, ufunc__ncf_skewness_data, ufunc__ncf_skewness_types, 2, 3, 1, 0, "_ncf_skewness", ufunc__ncf_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_variance_loops[2]
cdef void *ufunc__ncf_variance_ptr[4]
cdef void *ufunc__ncf_variance_data[2]
cdef char ufunc__ncf_variance_types[8]
cdef char *ufunc__ncf_variance_doc = (
    "_ncf_variance(v1, v2, l)\n"
    "\n"
    "Variance of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_variance_types[0] = <char>NPY_FLOAT
ufunc__ncf_variance_types[1] = <char>NPY_FLOAT
ufunc__ncf_variance_types[2] = <char>NPY_FLOAT
ufunc__ncf_variance_types[3] = <char>NPY_FLOAT
ufunc__ncf_variance_types[4] = <char>NPY_DOUBLE
ufunc__ncf_variance_types[5] = <char>NPY_DOUBLE
ufunc__ncf_variance_types[6] = <char>NPY_DOUBLE
ufunc__ncf_variance_types[7] = <char>NPY_DOUBLE
ufunc__ncf_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_variance_float
ufunc__ncf_variance_ptr[2*0+1] = <void*>(<char*>"_ncf_variance")
ufunc__ncf_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_variance_double
ufunc__ncf_variance_ptr[2*1+1] = <void*>(<char*>"_ncf_variance")
ufunc__ncf_variance_data[0] = &ufunc__ncf_variance_ptr[2*0]
ufunc__ncf_variance_data[1] = &ufunc__ncf_variance_ptr[2*1]
_ncf_variance = np.PyUFunc_FromFuncAndData(ufunc__ncf_variance_loops, ufunc__ncf_variance_data, ufunc__ncf_variance_types, 2, 3, 1, 0, "_ncf_variance", ufunc__ncf_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_isf_loops[2]
cdef void *ufunc__nct_isf_ptr[4]
cdef void *ufunc__nct_isf_data[2]
cdef char ufunc__nct_isf_types[8]
cdef char *ufunc__nct_isf_doc = (
    "_nct_isf(x, v, l)\n"
    "\n"
    "Inverse survival function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_isf_types[0] = <char>NPY_FLOAT
ufunc__nct_isf_types[1] = <char>NPY_FLOAT
ufunc__nct_isf_types[2] = <char>NPY_FLOAT
ufunc__nct_isf_types[3] = <char>NPY_FLOAT
ufunc__nct_isf_types[4] = <char>NPY_DOUBLE
ufunc__nct_isf_types[5] = <char>NPY_DOUBLE
ufunc__nct_isf_types[6] = <char>NPY_DOUBLE
ufunc__nct_isf_types[7] = <char>NPY_DOUBLE
ufunc__nct_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_isf_float
ufunc__nct_isf_ptr[2*0+1] = <void*>(<char*>"_nct_isf")
ufunc__nct_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_isf_double
ufunc__nct_isf_ptr[2*1+1] = <void*>(<char*>"_nct_isf")
ufunc__nct_isf_data[0] = &ufunc__nct_isf_ptr[2*0]
ufunc__nct_isf_data[1] = &ufunc__nct_isf_ptr[2*1]
_nct_isf = np.PyUFunc_FromFuncAndData(ufunc__nct_isf_loops, ufunc__nct_isf_data, ufunc__nct_isf_types, 2, 3, 1, 0, "_nct_isf", ufunc__nct_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_kurtosis_excess_loops[2]
cdef void *ufunc__nct_kurtosis_excess_ptr[4]
cdef void *ufunc__nct_kurtosis_excess_data[2]
cdef char ufunc__nct_kurtosis_excess_types[6]
cdef char *ufunc__nct_kurtosis_excess_doc = (
    "_nct_kurtosis_excess(v, l)\n"
    "\n"
    "Kurtosis excess of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_kurtosis_excess_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_kurtosis_excess_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_kurtosis_excess_types[0] = <char>NPY_FLOAT
ufunc__nct_kurtosis_excess_types[1] = <char>NPY_FLOAT
ufunc__nct_kurtosis_excess_types[2] = <char>NPY_FLOAT
ufunc__nct_kurtosis_excess_types[3] = <char>NPY_DOUBLE
ufunc__nct_kurtosis_excess_types[4] = <char>NPY_DOUBLE
ufunc__nct_kurtosis_excess_types[5] = <char>NPY_DOUBLE
ufunc__nct_kurtosis_excess_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_kurtosis_excess_float
ufunc__nct_kurtosis_excess_ptr[2*0+1] = <void*>(<char*>"_nct_kurtosis_excess")
ufunc__nct_kurtosis_excess_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_kurtosis_excess_double
ufunc__nct_kurtosis_excess_ptr[2*1+1] = <void*>(<char*>"_nct_kurtosis_excess")
ufunc__nct_kurtosis_excess_data[0] = &ufunc__nct_kurtosis_excess_ptr[2*0]
ufunc__nct_kurtosis_excess_data[1] = &ufunc__nct_kurtosis_excess_ptr[2*1]
_nct_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__nct_kurtosis_excess_loops, ufunc__nct_kurtosis_excess_data, ufunc__nct_kurtosis_excess_types, 2, 2, 1, 0, "_nct_kurtosis_excess", ufunc__nct_kurtosis_excess_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_mean_loops[2]
cdef void *ufunc__nct_mean_ptr[4]
cdef void *ufunc__nct_mean_data[2]
cdef char ufunc__nct_mean_types[6]
cdef char *ufunc__nct_mean_doc = (
    "_nct_mean(v, l)\n"
    "\n"
    "Mean of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_mean_types[0] = <char>NPY_FLOAT
ufunc__nct_mean_types[1] = <char>NPY_FLOAT
ufunc__nct_mean_types[2] = <char>NPY_FLOAT
ufunc__nct_mean_types[3] = <char>NPY_DOUBLE
ufunc__nct_mean_types[4] = <char>NPY_DOUBLE
ufunc__nct_mean_types[5] = <char>NPY_DOUBLE
ufunc__nct_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_mean_float
ufunc__nct_mean_ptr[2*0+1] = <void*>(<char*>"_nct_mean")
ufunc__nct_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_mean_double
ufunc__nct_mean_ptr[2*1+1] = <void*>(<char*>"_nct_mean")
ufunc__nct_mean_data[0] = &ufunc__nct_mean_ptr[2*0]
ufunc__nct_mean_data[1] = &ufunc__nct_mean_ptr[2*1]
_nct_mean = np.PyUFunc_FromFuncAndData(ufunc__nct_mean_loops, ufunc__nct_mean_data, ufunc__nct_mean_types, 2, 2, 1, 0, "_nct_mean", ufunc__nct_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_pdf_loops[2]
cdef void *ufunc__nct_pdf_ptr[4]
cdef void *ufunc__nct_pdf_data[2]
cdef char ufunc__nct_pdf_types[8]
cdef char *ufunc__nct_pdf_doc = (
    "_nct_pdf(x, v, l)\n"
    "\n"
    "Probability density function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_pdf_types[0] = <char>NPY_FLOAT
ufunc__nct_pdf_types[1] = <char>NPY_FLOAT
ufunc__nct_pdf_types[2] = <char>NPY_FLOAT
ufunc__nct_pdf_types[3] = <char>NPY_FLOAT
ufunc__nct_pdf_types[4] = <char>NPY_DOUBLE
ufunc__nct_pdf_types[5] = <char>NPY_DOUBLE
ufunc__nct_pdf_types[6] = <char>NPY_DOUBLE
ufunc__nct_pdf_types[7] = <char>NPY_DOUBLE
ufunc__nct_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_pdf_float
ufunc__nct_pdf_ptr[2*0+1] = <void*>(<char*>"_nct_pdf")
ufunc__nct_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_pdf_double
ufunc__nct_pdf_ptr[2*1+1] = <void*>(<char*>"_nct_pdf")
ufunc__nct_pdf_data[0] = &ufunc__nct_pdf_ptr[2*0]
ufunc__nct_pdf_data[1] = &ufunc__nct_pdf_ptr[2*1]
_nct_pdf = np.PyUFunc_FromFuncAndData(ufunc__nct_pdf_loops, ufunc__nct_pdf_data, ufunc__nct_pdf_types, 2, 3, 1, 0, "_nct_pdf", ufunc__nct_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_ppf_loops[2]
cdef void *ufunc__nct_ppf_ptr[4]
cdef void *ufunc__nct_ppf_data[2]
cdef char ufunc__nct_ppf_types[8]
cdef char *ufunc__nct_ppf_doc = (
    "_nct_ppf(x, v, l)\n"
    "\n"
    "Percent point function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_ppf_types[0] = <char>NPY_FLOAT
ufunc__nct_ppf_types[1] = <char>NPY_FLOAT
ufunc__nct_ppf_types[2] = <char>NPY_FLOAT
ufunc__nct_ppf_types[3] = <char>NPY_FLOAT
ufunc__nct_ppf_types[4] = <char>NPY_DOUBLE
ufunc__nct_ppf_types[5] = <char>NPY_DOUBLE
ufunc__nct_ppf_types[6] = <char>NPY_DOUBLE
ufunc__nct_ppf_types[7] = <char>NPY_DOUBLE
ufunc__nct_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_ppf_float
ufunc__nct_ppf_ptr[2*0+1] = <void*>(<char*>"_nct_ppf")
ufunc__nct_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_ppf_double
ufunc__nct_ppf_ptr[2*1+1] = <void*>(<char*>"_nct_ppf")
ufunc__nct_ppf_data[0] = &ufunc__nct_ppf_ptr[2*0]
ufunc__nct_ppf_data[1] = &ufunc__nct_ppf_ptr[2*1]
_nct_ppf = np.PyUFunc_FromFuncAndData(ufunc__nct_ppf_loops, ufunc__nct_ppf_data, ufunc__nct_ppf_types, 2, 3, 1, 0, "_nct_ppf", ufunc__nct_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_sf_loops[2]
cdef void *ufunc__nct_sf_ptr[4]
cdef void *ufunc__nct_sf_data[2]
cdef char ufunc__nct_sf_types[8]
cdef char *ufunc__nct_sf_doc = (
    "_nct_sf(x, v, l)\n"
    "\n"
    "Survival function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_sf_types[0] = <char>NPY_FLOAT
ufunc__nct_sf_types[1] = <char>NPY_FLOAT
ufunc__nct_sf_types[2] = <char>NPY_FLOAT
ufunc__nct_sf_types[3] = <char>NPY_FLOAT
ufunc__nct_sf_types[4] = <char>NPY_DOUBLE
ufunc__nct_sf_types[5] = <char>NPY_DOUBLE
ufunc__nct_sf_types[6] = <char>NPY_DOUBLE
ufunc__nct_sf_types[7] = <char>NPY_DOUBLE
ufunc__nct_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_sf_float
ufunc__nct_sf_ptr[2*0+1] = <void*>(<char*>"_nct_sf")
ufunc__nct_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_sf_double
ufunc__nct_sf_ptr[2*1+1] = <void*>(<char*>"_nct_sf")
ufunc__nct_sf_data[0] = &ufunc__nct_sf_ptr[2*0]
ufunc__nct_sf_data[1] = &ufunc__nct_sf_ptr[2*1]
_nct_sf = np.PyUFunc_FromFuncAndData(ufunc__nct_sf_loops, ufunc__nct_sf_data, ufunc__nct_sf_types, 2, 3, 1, 0, "_nct_sf", ufunc__nct_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_skewness_loops[2]
cdef void *ufunc__nct_skewness_ptr[4]
cdef void *ufunc__nct_skewness_data[2]
cdef char ufunc__nct_skewness_types[6]
cdef char *ufunc__nct_skewness_doc = (
    "_nct_skewness(v, l)\n"
    "\n"
    "Skewness of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_skewness_types[0] = <char>NPY_FLOAT
ufunc__nct_skewness_types[1] = <char>NPY_FLOAT
ufunc__nct_skewness_types[2] = <char>NPY_FLOAT
ufunc__nct_skewness_types[3] = <char>NPY_DOUBLE
ufunc__nct_skewness_types[4] = <char>NPY_DOUBLE
ufunc__nct_skewness_types[5] = <char>NPY_DOUBLE
ufunc__nct_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_skewness_float
ufunc__nct_skewness_ptr[2*0+1] = <void*>(<char*>"_nct_skewness")
ufunc__nct_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_skewness_double
ufunc__nct_skewness_ptr[2*1+1] = <void*>(<char*>"_nct_skewness")
ufunc__nct_skewness_data[0] = &ufunc__nct_skewness_ptr[2*0]
ufunc__nct_skewness_data[1] = &ufunc__nct_skewness_ptr[2*1]
_nct_skewness = np.PyUFunc_FromFuncAndData(ufunc__nct_skewness_loops, ufunc__nct_skewness_data, ufunc__nct_skewness_types, 2, 2, 1, 0, "_nct_skewness", ufunc__nct_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_variance_loops[2]
cdef void *ufunc__nct_variance_ptr[4]
cdef void *ufunc__nct_variance_data[2]
cdef char ufunc__nct_variance_types[6]
cdef char *ufunc__nct_variance_doc = (
    "_nct_variance(v, l)\n"
    "\n"
    "Variance of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_variance_types[0] = <char>NPY_FLOAT
ufunc__nct_variance_types[1] = <char>NPY_FLOAT
ufunc__nct_variance_types[2] = <char>NPY_FLOAT
ufunc__nct_variance_types[3] = <char>NPY_DOUBLE
ufunc__nct_variance_types[4] = <char>NPY_DOUBLE
ufunc__nct_variance_types[5] = <char>NPY_DOUBLE
ufunc__nct_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_variance_float
ufunc__nct_variance_ptr[2*0+1] = <void*>(<char*>"_nct_variance")
ufunc__nct_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_variance_double
ufunc__nct_variance_ptr[2*1+1] = <void*>(<char*>"_nct_variance")
ufunc__nct_variance_data[0] = &ufunc__nct_variance_ptr[2*0]
ufunc__nct_variance_data[1] = &ufunc__nct_variance_ptr[2*1]
_nct_variance = np.PyUFunc_FromFuncAndData(ufunc__nct_variance_loops, ufunc__nct_variance_data, ufunc__nct_variance_types, 2, 2, 1, 0, "_nct_variance", ufunc__nct_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_cdf_loops[2]
cdef void *ufunc__ncx2_cdf_ptr[4]
cdef void *ufunc__ncx2_cdf_data[2]
cdef char ufunc__ncx2_cdf_types[8]
cdef char *ufunc__ncx2_cdf_doc = (
    "_ncx2_cdf(x, k, l)\n"
    "\n"
    "Cumulative density function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_cdf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_cdf_float
ufunc__ncx2_cdf_ptr[2*0+1] = <void*>(<char*>"_ncx2_cdf")
ufunc__ncx2_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_cdf_double
ufunc__ncx2_cdf_ptr[2*1+1] = <void*>(<char*>"_ncx2_cdf")
ufunc__ncx2_cdf_data[0] = &ufunc__ncx2_cdf_ptr[2*0]
ufunc__ncx2_cdf_data[1] = &ufunc__ncx2_cdf_ptr[2*1]
_ncx2_cdf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_cdf_loops, ufunc__ncx2_cdf_data, ufunc__ncx2_cdf_types, 2, 3, 1, 0, "_ncx2_cdf", ufunc__ncx2_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_isf_loops[2]
cdef void *ufunc__ncx2_isf_ptr[4]
cdef void *ufunc__ncx2_isf_data[2]
cdef char ufunc__ncx2_isf_types[8]
cdef char *ufunc__ncx2_isf_doc = (
    "_ncx2_isf(x, k, l)\n"
    "\n"
    "Inverse survival function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_isf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_isf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_isf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_isf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_isf_float
ufunc__ncx2_isf_ptr[2*0+1] = <void*>(<char*>"_ncx2_isf")
ufunc__ncx2_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_isf_double
ufunc__ncx2_isf_ptr[2*1+1] = <void*>(<char*>"_ncx2_isf")
ufunc__ncx2_isf_data[0] = &ufunc__ncx2_isf_ptr[2*0]
ufunc__ncx2_isf_data[1] = &ufunc__ncx2_isf_ptr[2*1]
_ncx2_isf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_isf_loops, ufunc__ncx2_isf_data, ufunc__ncx2_isf_types, 2, 3, 1, 0, "_ncx2_isf", ufunc__ncx2_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_pdf_loops[2]
cdef void *ufunc__ncx2_pdf_ptr[4]
cdef void *ufunc__ncx2_pdf_data[2]
cdef char ufunc__ncx2_pdf_types[8]
cdef char *ufunc__ncx2_pdf_doc = (
    "_ncx2_pdf(x, k, l)\n"
    "\n"
    "Probability density function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_pdf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_pdf_float
ufunc__ncx2_pdf_ptr[2*0+1] = <void*>(<char*>"_ncx2_pdf")
ufunc__ncx2_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_pdf_double
ufunc__ncx2_pdf_ptr[2*1+1] = <void*>(<char*>"_ncx2_pdf")
ufunc__ncx2_pdf_data[0] = &ufunc__ncx2_pdf_ptr[2*0]
ufunc__ncx2_pdf_data[1] = &ufunc__ncx2_pdf_ptr[2*1]
_ncx2_pdf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_pdf_loops, ufunc__ncx2_pdf_data, ufunc__ncx2_pdf_types, 2, 3, 1, 0, "_ncx2_pdf", ufunc__ncx2_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_ppf_loops[2]
cdef void *ufunc__ncx2_ppf_ptr[4]
cdef void *ufunc__ncx2_ppf_data[2]
cdef char ufunc__ncx2_ppf_types[8]
cdef char *ufunc__ncx2_ppf_doc = (
    "_ncx2_ppf(x, k, l)\n"
    "\n"
    "Percent point function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_ppf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_ppf_float
ufunc__ncx2_ppf_ptr[2*0+1] = <void*>(<char*>"_ncx2_ppf")
ufunc__ncx2_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_ppf_double
ufunc__ncx2_ppf_ptr[2*1+1] = <void*>(<char*>"_ncx2_ppf")
ufunc__ncx2_ppf_data[0] = &ufunc__ncx2_ppf_ptr[2*0]
ufunc__ncx2_ppf_data[1] = &ufunc__ncx2_ppf_ptr[2*1]
_ncx2_ppf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_ppf_loops, ufunc__ncx2_ppf_data, ufunc__ncx2_ppf_types, 2, 3, 1, 0, "_ncx2_ppf", ufunc__ncx2_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_sf_loops[2]
cdef void *ufunc__ncx2_sf_ptr[4]
cdef void *ufunc__ncx2_sf_data[2]
cdef char ufunc__ncx2_sf_types[8]
cdef char *ufunc__ncx2_sf_doc = (
    "_ncx2_sf(x, k, l)\n"
    "\n"
    "Survival function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_sf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_sf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_sf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_sf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_sf_float
ufunc__ncx2_sf_ptr[2*0+1] = <void*>(<char*>"_ncx2_sf")
ufunc__ncx2_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_sf_double
ufunc__ncx2_sf_ptr[2*1+1] = <void*>(<char*>"_ncx2_sf")
ufunc__ncx2_sf_data[0] = &ufunc__ncx2_sf_ptr[2*0]
ufunc__ncx2_sf_data[1] = &ufunc__ncx2_sf_ptr[2*1]
_ncx2_sf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_sf_loops, ufunc__ncx2_sf_data, ufunc__ncx2_sf_types, 2, 3, 1, 0, "_ncx2_sf", ufunc__ncx2_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sf_error_test_function_loops[1]
cdef void *ufunc__sf_error_test_function_ptr[2]
cdef void *ufunc__sf_error_test_function_data[1]
cdef char ufunc__sf_error_test_function_types[2]
cdef char *ufunc__sf_error_test_function_doc = (
    "Private function; do not use.")
ufunc__sf_error_test_function_loops[0] = <np.PyUFuncGenericFunction>loop_i_i__As_l_l
ufunc__sf_error_test_function_types[0] = <char>NPY_LONG
ufunc__sf_error_test_function_types[1] = <char>NPY_LONG
ufunc__sf_error_test_function_ptr[2*0] = <void*>_func__sf_error_test_function
ufunc__sf_error_test_function_ptr[2*0+1] = <void*>(<char*>"_sf_error_test_function")
ufunc__sf_error_test_function_data[0] = &ufunc__sf_error_test_function_ptr[2*0]
_sf_error_test_function = np.PyUFunc_FromFuncAndData(ufunc__sf_error_test_function_loops, ufunc__sf_error_test_function_data, ufunc__sf_error_test_function_types, 1, 1, 1, 0, "_sf_error_test_function", ufunc__sf_error_test_function_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__skewnorm_cdf_loops[2]
cdef void *ufunc__skewnorm_cdf_ptr[4]
cdef void *ufunc__skewnorm_cdf_data[2]
cdef char ufunc__skewnorm_cdf_types[10]
cdef char *ufunc__skewnorm_cdf_doc = (
    "_skewnorm_cdf(x, l, sc, sh)\n"
    "\n"
    "Cumulative density function of skewnorm distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "sc : array_like\n"
    "    Positive, Real-valued parameters\n"
    "sh : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__skewnorm_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__skewnorm_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__skewnorm_cdf_types[0] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[1] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[2] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[3] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[4] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[5] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[6] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[7] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[8] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[9] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_cdf_float
ufunc__skewnorm_cdf_ptr[2*0+1] = <void*>(<char*>"_skewnorm_cdf")
ufunc__skewnorm_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_cdf_double
ufunc__skewnorm_cdf_ptr[2*1+1] = <void*>(<char*>"_skewnorm_cdf")
ufunc__skewnorm_cdf_data[0] = &ufunc__skewnorm_cdf_ptr[2*0]
ufunc__skewnorm_cdf_data[1] = &ufunc__skewnorm_cdf_ptr[2*1]
_skewnorm_cdf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_cdf_loops, ufunc__skewnorm_cdf_data, ufunc__skewnorm_cdf_types, 2, 4, 1, 0, "_skewnorm_cdf", ufunc__skewnorm_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__skewnorm_isf_loops[2]
cdef void *ufunc__skewnorm_isf_ptr[4]
cdef void *ufunc__skewnorm_isf_data[2]
cdef char ufunc__skewnorm_isf_types[10]
cdef char *ufunc__skewnorm_isf_doc = (
    "_skewnorm_isf(x, l, sc, sh)\n"
    "\n"
    "Inverse survival function of skewnorm distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "sc : array_like\n"
    "    Positive, Real-valued parameters\n"
    "sh : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__skewnorm_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__skewnorm_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__skewnorm_isf_types[0] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[1] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[2] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[3] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[4] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[5] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[6] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[7] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[8] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[9] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_isf_float
ufunc__skewnorm_isf_ptr[2*0+1] = <void*>(<char*>"_skewnorm_isf")
ufunc__skewnorm_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_isf_double
ufunc__skewnorm_isf_ptr[2*1+1] = <void*>(<char*>"_skewnorm_isf")
ufunc__skewnorm_isf_data[0] = &ufunc__skewnorm_isf_ptr[2*0]
ufunc__skewnorm_isf_data[1] = &ufunc__skewnorm_isf_ptr[2*1]
_skewnorm_isf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_isf_loops, ufunc__skewnorm_isf_data, ufunc__skewnorm_isf_types, 2, 4, 1, 0, "_skewnorm_isf", ufunc__skewnorm_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__skewnorm_ppf_loops[2]
cdef void *ufunc__skewnorm_ppf_ptr[4]
cdef void *ufunc__skewnorm_ppf_data[2]
cdef char ufunc__skewnorm_ppf_types[10]
cdef char *ufunc__skewnorm_ppf_doc = (
    "_skewnorm_ppf(x, l, sc, sh)\n"
    "\n"
    "Percent point function of skewnorm distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "sc : array_like\n"
    "    Positive, Real-valued parameters\n"
    "sh : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__skewnorm_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__skewnorm_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__skewnorm_ppf_types[0] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[1] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[2] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[3] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[4] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[5] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[6] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[7] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[8] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[9] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_ppf_float
ufunc__skewnorm_ppf_ptr[2*0+1] = <void*>(<char*>"_skewnorm_ppf")
ufunc__skewnorm_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_ppf_double
ufunc__skewnorm_ppf_ptr[2*1+1] = <void*>(<char*>"_skewnorm_ppf")
ufunc__skewnorm_ppf_data[0] = &ufunc__skewnorm_ppf_ptr[2*0]
ufunc__skewnorm_ppf_data[1] = &ufunc__skewnorm_ppf_ptr[2*1]
_skewnorm_ppf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_ppf_loops, ufunc__skewnorm_ppf_data, ufunc__skewnorm_ppf_types, 2, 4, 1, 0, "_skewnorm_ppf", ufunc__skewnorm_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovc_loops[3]
cdef void *ufunc__smirnovc_ptr[6]
cdef void *ufunc__smirnovc_data[3]
cdef char ufunc__smirnovc_types[9]
cdef char *ufunc__smirnovc_doc = (
    "_smirnovc(n, d)\n"
    " Internal function, do not use.")
ufunc__smirnovc_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc__smirnovc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovc_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovc_types[0] = <char>NPY_INTP
ufunc__smirnovc_types[1] = <char>NPY_DOUBLE
ufunc__smirnovc_types[2] = <char>NPY_DOUBLE
ufunc__smirnovc_types[3] = <char>NPY_FLOAT
ufunc__smirnovc_types[4] = <char>NPY_FLOAT
ufunc__smirnovc_types[5] = <char>NPY_FLOAT
ufunc__smirnovc_types[6] = <char>NPY_DOUBLE
ufunc__smirnovc_types[7] = <char>NPY_DOUBLE
ufunc__smirnovc_types[8] = <char>NPY_DOUBLE
ufunc__smirnovc_ptr[2*0] = <void*>_func_cephes_smirnovc_wrap
ufunc__smirnovc_ptr[2*0+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*1] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*1+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*2] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*2+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_data[0] = &ufunc__smirnovc_ptr[2*0]
ufunc__smirnovc_data[1] = &ufunc__smirnovc_ptr[2*1]
ufunc__smirnovc_data[2] = &ufunc__smirnovc_ptr[2*2]
_smirnovc = np.PyUFunc_FromFuncAndData(ufunc__smirnovc_loops, ufunc__smirnovc_data, ufunc__smirnovc_types, 3, 2, 1, 0, "_smirnovc", ufunc__smirnovc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovci_loops[3]
cdef void *ufunc__smirnovci_ptr[6]
cdef void *ufunc__smirnovci_data[3]
cdef char ufunc__smirnovci_types[9]
cdef char *ufunc__smirnovci_doc = (
    "Internal function, do not use.")
ufunc__smirnovci_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc__smirnovci_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovci_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovci_types[0] = <char>NPY_INTP
ufunc__smirnovci_types[1] = <char>NPY_DOUBLE
ufunc__smirnovci_types[2] = <char>NPY_DOUBLE
ufunc__smirnovci_types[3] = <char>NPY_FLOAT
ufunc__smirnovci_types[4] = <char>NPY_FLOAT
ufunc__smirnovci_types[5] = <char>NPY_FLOAT
ufunc__smirnovci_types[6] = <char>NPY_DOUBLE
ufunc__smirnovci_types[7] = <char>NPY_DOUBLE
ufunc__smirnovci_types[8] = <char>NPY_DOUBLE
ufunc__smirnovci_ptr[2*0] = <void*>_func_cephes_smirnovci_wrap
ufunc__smirnovci_ptr[2*0+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*1] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*1+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*2] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*2+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_data[0] = &ufunc__smirnovci_ptr[2*0]
ufunc__smirnovci_data[1] = &ufunc__smirnovci_ptr[2*1]
ufunc__smirnovci_data[2] = &ufunc__smirnovci_ptr[2*2]
_smirnovci = np.PyUFunc_FromFuncAndData(ufunc__smirnovci_loops, ufunc__smirnovci_data, ufunc__smirnovci_types, 3, 2, 1, 0, "_smirnovci", ufunc__smirnovci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovp_loops[3]
cdef void *ufunc__smirnovp_ptr[6]
cdef void *ufunc__smirnovp_data[3]
cdef char ufunc__smirnovp_types[9]
cdef char *ufunc__smirnovp_doc = (
    "_smirnovp(n, p)\n"
    " Internal function, do not use.")
ufunc__smirnovp_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc__smirnovp_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovp_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovp_types[0] = <char>NPY_INTP
ufunc__smirnovp_types[1] = <char>NPY_DOUBLE
ufunc__smirnovp_types[2] = <char>NPY_DOUBLE
ufunc__smirnovp_types[3] = <char>NPY_FLOAT
ufunc__smirnovp_types[4] = <char>NPY_FLOAT
ufunc__smirnovp_types[5] = <char>NPY_FLOAT
ufunc__smirnovp_types[6] = <char>NPY_DOUBLE
ufunc__smirnovp_types[7] = <char>NPY_DOUBLE
ufunc__smirnovp_types[8] = <char>NPY_DOUBLE
ufunc__smirnovp_ptr[2*0] = <void*>_func_cephes_smirnovp_wrap
ufunc__smirnovp_ptr[2*0+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*1] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*1+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*2] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*2+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_data[0] = &ufunc__smirnovp_ptr[2*0]
ufunc__smirnovp_data[1] = &ufunc__smirnovp_ptr[2*1]
ufunc__smirnovp_data[2] = &ufunc__smirnovp_ptr[2*2]
_smirnovp = np.PyUFunc_FromFuncAndData(ufunc__smirnovp_loops, ufunc__smirnovp_data, ufunc__smirnovp_types, 3, 2, 1, 0, "_smirnovp", ufunc__smirnovp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__stirling2_inexact_loops[2]
cdef void *ufunc__stirling2_inexact_ptr[4]
cdef void *ufunc__stirling2_inexact_data[2]
cdef char ufunc__stirling2_inexact_types[6]
cdef char *ufunc__stirling2_inexact_doc = (
    "Internal function, do not use.")
ufunc__stirling2_inexact_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__stirling2_inexact_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__stirling2_inexact_types[0] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[1] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[2] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[3] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[4] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[5] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*0+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*1+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_data[0] = &ufunc__stirling2_inexact_ptr[2*0]
ufunc__stirling2_inexact_data[1] = &ufunc__stirling2_inexact_ptr[2*1]
_stirling2_inexact = np.PyUFunc_FromFuncAndData(ufunc__stirling2_inexact_loops, ufunc__stirling2_inexact_data, ufunc__stirling2_inexact_types, 2, 2, 1, 0, "_stirling2_inexact", ufunc__stirling2_inexact_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_asymp_large_z_loops[1]
cdef void *ufunc__struve_asymp_large_z_ptr[2]
cdef void *ufunc__struve_asymp_large_z_data[1]
cdef char ufunc__struve_asymp_large_z_types[5]
cdef char *ufunc__struve_asymp_large_z_doc = (
    "_struve_asymp_large_z(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using asymptotic expansion\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_asymp_large_z_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddp_d_As_ddp_dd
ufunc__struve_asymp_large_z_types[0] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[1] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[2] = <char>NPY_INTP
ufunc__struve_asymp_large_z_types[3] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[4] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_ptr[2*0] = <void*>_func_cephes__struve_asymp_large_z
ufunc__struve_asymp_large_z_ptr[2*0+1] = <void*>(<char*>"_struve_asymp_large_z")
ufunc__struve_asymp_large_z_data[0] = &ufunc__struve_asymp_large_z_ptr[2*0]
_struve_asymp_large_z = np.PyUFunc_FromFuncAndData(ufunc__struve_asymp_large_z_loops, ufunc__struve_asymp_large_z_data, ufunc__struve_asymp_large_z_types, 1, 3, 2, 0, "_struve_asymp_large_z", ufunc__struve_asymp_large_z_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_bessel_series_loops[1]
cdef void *ufunc__struve_bessel_series_ptr[2]
cdef void *ufunc__struve_bessel_series_data[1]
cdef char ufunc__struve_bessel_series_types[5]
cdef char *ufunc__struve_bessel_series_doc = (
    "_struve_bessel_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using Bessel function series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_bessel_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddp_d_As_ddp_dd
ufunc__struve_bessel_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[2] = <char>NPY_INTP
ufunc__struve_bessel_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_ptr[2*0] = <void*>_func_cephes__struve_bessel_series
ufunc__struve_bessel_series_ptr[2*0+1] = <void*>(<char*>"_struve_bessel_series")
ufunc__struve_bessel_series_data[0] = &ufunc__struve_bessel_series_ptr[2*0]
_struve_bessel_series = np.PyUFunc_FromFuncAndData(ufunc__struve_bessel_series_loops, ufunc__struve_bessel_series_data, ufunc__struve_bessel_series_types, 1, 3, 2, 0, "_struve_bessel_series", ufunc__struve_bessel_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_power_series_loops[1]
cdef void *ufunc__struve_power_series_ptr[2]
cdef void *ufunc__struve_power_series_data[1]
cdef char ufunc__struve_power_series_types[5]
cdef char *ufunc__struve_power_series_doc = (
    "_struve_power_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using power series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_power_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddp_d_As_ddp_dd
ufunc__struve_power_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[2] = <char>NPY_INTP
ufunc__struve_power_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_power_series_ptr[2*0] = <void*>_func_cephes__struve_power_series
ufunc__struve_power_series_ptr[2*0+1] = <void*>(<char*>"_struve_power_series")
ufunc__struve_power_series_data[0] = &ufunc__struve_power_series_ptr[2*0]
_struve_power_series = np.PyUFunc_FromFuncAndData(ufunc__struve_power_series_loops, ufunc__struve_power_series_data, ufunc__struve_power_series_types, 1, 3, 2, 0, "_struve_power_series", ufunc__struve_power_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_agm_loops[2]
cdef void *ufunc_agm_ptr[4]
cdef void *ufunc_agm_data[2]
cdef char ufunc_agm_types[6]
cdef char *ufunc_agm_doc = (
    "agm(a, b, out=None)\n"
    "\n"
    "Compute the arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Start with a_0 = a and b_0 = b and iteratively compute::\n"
    "\n"
    "    a_{n+1} = (a_n + b_n)/2\n"
    "    b_{n+1} = sqrt(a_n*b_n)\n"
    "\n"
    "a_n and b_n converge to the same limit as n increases; their common\n"
    "limit is agm(a, b).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real values only. If the values are both negative, the result\n"
    "    is negative. If one value is negative and the other is positive,\n"
    "    `nan` is returned.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import agm\n"
    ">>> a, b = 24.0, 6.0\n"
    ">>> agm(a, b)\n"
    "13.458171481725614\n"
    "\n"
    "Compare that result to the iteration:\n"
    "\n"
    ">>> while a != b:\n"
    "...     a, b = (a + b)/2, np.sqrt(a*b)\n"
    "...     print(\"a = %19.16f  b=%19.16f\" % (a, b))\n"
    "...\n"
    "a = 15.0000000000000000  b=12.0000000000000000\n"
    "a = 13.5000000000000000  b=13.4164078649987388\n"
    "a = 13.4582039324993694  b=13.4581390309909850\n"
    "a = 13.4581714817451772  b=13.4581714817060547\n"
    "a = 13.4581714817256159  b=13.4581714817256159\n"
    "\n"
    "When array-like arguments are given, broadcasting applies:\n"
    "\n"
    ">>> a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).\n"
    ">>> b = np.array([6, 12, 24, 48])    # b has shape (4,).\n"
    ">>> agm(a, b)\n"
    "array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],\n"
    "       [  4.37037309,   6.72908574,  10.84726853,  18.11597502],\n"
    "       [  6.        ,   8.74074619,  13.45817148,  21.69453707]])")
ufunc_agm_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_agm_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_agm_types[0] = <char>NPY_FLOAT
ufunc_agm_types[1] = <char>NPY_FLOAT
ufunc_agm_types[2] = <char>NPY_FLOAT
ufunc_agm_types[3] = <char>NPY_DOUBLE
ufunc_agm_types[4] = <char>NPY_DOUBLE
ufunc_agm_types[5] = <char>NPY_DOUBLE
ufunc_agm_ptr[2*0] = <void*>_func_agm
ufunc_agm_ptr[2*0+1] = <void*>(<char*>"agm")
ufunc_agm_ptr[2*1] = <void*>_func_agm
ufunc_agm_ptr[2*1+1] = <void*>(<char*>"agm")
ufunc_agm_data[0] = &ufunc_agm_ptr[2*0]
ufunc_agm_data[1] = &ufunc_agm_ptr[2*1]
agm = np.PyUFunc_FromFuncAndData(ufunc_agm_loops, ufunc_agm_data, ufunc_agm_types, 2, 2, 1, 0, "agm", ufunc_agm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtr_loops[3]
cdef void *ufunc_bdtr_ptr[6]
cdef void *ufunc_bdtr_data[3]
cdef char ufunc_bdtr_types[12]
cdef char *ufunc_bdtr_doc = (
    "bdtr(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution cumulative distribution function.\n"
    "\n"
    "Sum of the terms 0 through `floor(k)` of the Binomial probability density.\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    \\sum_{j=0}^{\\lfloor k \\rfloor} {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k)` or fewer successes in `n` independent events with\n"
    "    success probabilities of `p`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    I_{1 - p}(n - \\lfloor k \\rfloor, \\lfloor k \\rfloor + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dpd__As_dpd_d
ufunc_bdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtr_types[0] = <char>NPY_FLOAT
ufunc_bdtr_types[1] = <char>NPY_FLOAT
ufunc_bdtr_types[2] = <char>NPY_FLOAT
ufunc_bdtr_types[3] = <char>NPY_FLOAT
ufunc_bdtr_types[4] = <char>NPY_DOUBLE
ufunc_bdtr_types[5] = <char>NPY_INTP
ufunc_bdtr_types[6] = <char>NPY_DOUBLE
ufunc_bdtr_types[7] = <char>NPY_DOUBLE
ufunc_bdtr_types[8] = <char>NPY_DOUBLE
ufunc_bdtr_types[9] = <char>NPY_DOUBLE
ufunc_bdtr_types[10] = <char>NPY_DOUBLE
ufunc_bdtr_types[11] = <char>NPY_DOUBLE
ufunc_bdtr_ptr[2*0] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*0+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*1] = <void*>_func_cephes_bdtr_wrap
ufunc_bdtr_ptr[2*1+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*2] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*2+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_data[0] = &ufunc_bdtr_ptr[2*0]
ufunc_bdtr_data[1] = &ufunc_bdtr_ptr[2*1]
ufunc_bdtr_data[2] = &ufunc_bdtr_ptr[2*2]
bdtr = np.PyUFunc_FromFuncAndData(ufunc_bdtr_loops, ufunc_bdtr_data, ufunc_bdtr_types, 3, 3, 1, 0, "bdtr", ufunc_bdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrc_loops[3]
cdef void *ufunc_bdtrc_ptr[6]
cdef void *ufunc_bdtrc_data[3]
cdef char ufunc_bdtrc_types[12]
cdef char *ufunc_bdtrc_doc = (
    "bdtrc(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution survival function.\n"
    "\n"
    "Sum of the terms `floor(k) + 1` through `n` of the binomial probability\n"
    "density,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) =\n"
    "    \\sum_{j=\\lfloor k \\rfloor +1}^n {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int)\n"
    "p : array_like\n"
    "    Probability of success in a single event.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k) + 1` or more successes in `n` independent\n"
    "    events with success probabilities of `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) = I_{p}(\\lfloor k \\rfloor + 1, n - \\lfloor k \\rfloor).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dpd__As_dpd_d
ufunc_bdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrc_types[0] = <char>NPY_FLOAT
ufunc_bdtrc_types[1] = <char>NPY_FLOAT
ufunc_bdtrc_types[2] = <char>NPY_FLOAT
ufunc_bdtrc_types[3] = <char>NPY_FLOAT
ufunc_bdtrc_types[4] = <char>NPY_DOUBLE
ufunc_bdtrc_types[5] = <char>NPY_INTP
ufunc_bdtrc_types[6] = <char>NPY_DOUBLE
ufunc_bdtrc_types[7] = <char>NPY_DOUBLE
ufunc_bdtrc_types[8] = <char>NPY_DOUBLE
ufunc_bdtrc_types[9] = <char>NPY_DOUBLE
ufunc_bdtrc_types[10] = <char>NPY_DOUBLE
ufunc_bdtrc_types[11] = <char>NPY_DOUBLE
ufunc_bdtrc_ptr[2*0] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*0+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*1] = <void*>_func_cephes_bdtrc_wrap
ufunc_bdtrc_ptr[2*1+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*2] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*2+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_data[0] = &ufunc_bdtrc_ptr[2*0]
ufunc_bdtrc_data[1] = &ufunc_bdtrc_ptr[2*1]
ufunc_bdtrc_data[2] = &ufunc_bdtrc_ptr[2*2]
bdtrc = np.PyUFunc_FromFuncAndData(ufunc_bdtrc_loops, ufunc_bdtrc_data, ufunc_bdtrc_types, 3, 3, 1, 0, "bdtrc", ufunc_bdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtri_loops[3]
cdef void *ufunc_bdtri_ptr[6]
cdef void *ufunc_bdtri_data[3]
cdef char ufunc_bdtri_types[12]
cdef char *ufunc_bdtri_doc = (
    "bdtri(k, n, y, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `p`.\n"
    "\n"
    "Finds the event probability `p` such that the sum of the terms 0 through\n"
    "`k` of the binomial probability density is equal to the given cumulative\n"
    "probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (float)\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : scalar or ndarray\n"
    "    The event probability such that `bdtr(\\lfloor k \\rfloor, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betaincinv\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the inverse beta integral function\n"
    "and the relation,::\n"
    "\n"
    "    1 - p = betaincinv(n - k, k + 1, y).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtri`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dpd__As_dpd_d
ufunc_bdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtri_types[0] = <char>NPY_FLOAT
ufunc_bdtri_types[1] = <char>NPY_FLOAT
ufunc_bdtri_types[2] = <char>NPY_FLOAT
ufunc_bdtri_types[3] = <char>NPY_FLOAT
ufunc_bdtri_types[4] = <char>NPY_DOUBLE
ufunc_bdtri_types[5] = <char>NPY_INTP
ufunc_bdtri_types[6] = <char>NPY_DOUBLE
ufunc_bdtri_types[7] = <char>NPY_DOUBLE
ufunc_bdtri_types[8] = <char>NPY_DOUBLE
ufunc_bdtri_types[9] = <char>NPY_DOUBLE
ufunc_bdtri_types[10] = <char>NPY_DOUBLE
ufunc_bdtri_types[11] = <char>NPY_DOUBLE
ufunc_bdtri_ptr[2*0] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*0+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*1] = <void*>_func_cephes_bdtri_wrap
ufunc_bdtri_ptr[2*1+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*2] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*2+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_data[0] = &ufunc_bdtri_ptr[2*0]
ufunc_bdtri_data[1] = &ufunc_bdtri_ptr[2*1]
ufunc_bdtri_data[2] = &ufunc_bdtri_ptr[2*2]
bdtri = np.PyUFunc_FromFuncAndData(ufunc_bdtri_loops, ufunc_bdtri_data, ufunc_bdtri_types, 3, 3, 1, 0, "bdtri", ufunc_bdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrik_loops[2]
cdef void *ufunc_bdtrik_ptr[4]
cdef void *ufunc_bdtrik_data[2]
cdef char ufunc_bdtrik_types[8]
cdef char *ufunc_bdtrik_doc = (
    "bdtrik(y, n, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `k`.\n"
    "\n"
    "Finds the number of successes `k` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for `n` events with probability\n"
    "`p` is equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "n : array_like\n"
    "    Number of events (float).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : scalar or ndarray\n"
    "    The number of successes `k` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrik_types[0] = <char>NPY_FLOAT
ufunc_bdtrik_types[1] = <char>NPY_FLOAT
ufunc_bdtrik_types[2] = <char>NPY_FLOAT
ufunc_bdtrik_types[3] = <char>NPY_FLOAT
ufunc_bdtrik_types[4] = <char>NPY_DOUBLE
ufunc_bdtrik_types[5] = <char>NPY_DOUBLE
ufunc_bdtrik_types[6] = <char>NPY_DOUBLE
ufunc_bdtrik_types[7] = <char>NPY_DOUBLE
ufunc_bdtrik_ptr[2*0] = <void*>_func_bdtrik
ufunc_bdtrik_ptr[2*0+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_ptr[2*1] = <void*>_func_bdtrik
ufunc_bdtrik_ptr[2*1+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_data[0] = &ufunc_bdtrik_ptr[2*0]
ufunc_bdtrik_data[1] = &ufunc_bdtrik_ptr[2*1]
bdtrik = np.PyUFunc_FromFuncAndData(ufunc_bdtrik_loops, ufunc_bdtrik_data, ufunc_bdtrik_types, 2, 3, 1, 0, "bdtrik", ufunc_bdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrin_loops[2]
cdef void *ufunc_bdtrin_ptr[4]
cdef void *ufunc_bdtrin_data[2]
cdef char ufunc_bdtrin_types[8]
cdef char *ufunc_bdtrin_doc = (
    "bdtrin(k, y, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `n`.\n"
    "\n"
    "Finds the number of events `n` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for events with probability `p` is\n"
    "equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float).\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : scalar or ndarray\n"
    "    The number of events `n` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrin_types[0] = <char>NPY_FLOAT
ufunc_bdtrin_types[1] = <char>NPY_FLOAT
ufunc_bdtrin_types[2] = <char>NPY_FLOAT
ufunc_bdtrin_types[3] = <char>NPY_FLOAT
ufunc_bdtrin_types[4] = <char>NPY_DOUBLE
ufunc_bdtrin_types[5] = <char>NPY_DOUBLE
ufunc_bdtrin_types[6] = <char>NPY_DOUBLE
ufunc_bdtrin_types[7] = <char>NPY_DOUBLE
ufunc_bdtrin_ptr[2*0] = <void*>_func_bdtrin
ufunc_bdtrin_ptr[2*0+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_ptr[2*1] = <void*>_func_bdtrin
ufunc_bdtrin_ptr[2*1+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_data[0] = &ufunc_bdtrin_ptr[2*0]
ufunc_bdtrin_data[1] = &ufunc_bdtrin_ptr[2*1]
bdtrin = np.PyUFunc_FromFuncAndData(ufunc_bdtrin_loops, ufunc_bdtrin_data, ufunc_bdtrin_types, 2, 3, 1, 0, "bdtrin", ufunc_bdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainc_loops[2]
cdef void *ufunc_betainc_ptr[4]
cdef void *ufunc_betainc_data[2]
cdef char ufunc_betainc_types[8]
cdef char *ufunc_betainc_doc = (
    "betainc(a, b, x, out=None)\n"
    "\n"
    "Regularized incomplete beta function.\n"
    "\n"
    "Computes the regularized incomplete beta function, defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "    t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "This function is the cumulative distribution function for the beta\n"
    "distribution; its range is [0, 1].\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "beta : beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The term *regularized* in the name of this function refers to the\n"
    "scaling of the function by the gamma function terms shown in the\n"
    "formula.  When not qualified as *regularized*, the name *incomplete\n"
    "beta function* often refers to just the integral expression,\n"
    "without the gamma terms.  One can use the function `beta` from\n"
    "`scipy.special` to get this \"nonregularized\" incomplete beta\n"
    "function by multiplying the result of ``betainc(a, b, x)`` by\n"
    "``beta(a, b)``.\n"
    "\n"
    "This function wraps the ``ibeta`` routine from the\n"
    "Boost Math C++ library [2]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    ".. [2] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "\n"
    "Let :math:`B(a, b)` be the `beta` function.\n"
    "\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "The coefficient in terms of `gamma` is equal to\n"
    ":math:`1/B(a, b)`. Also, when :math:`x=1`\n"
    "the integral is equal to :math:`B(a, b)`.\n"
    "Therefore, :math:`I_{x=1}(a, b) = 1` for any :math:`a, b`.\n"
    "\n"
    ">>> sc.betainc(0.2, 3.5, 1.0)\n"
    "1.0\n"
    "\n"
    "It satisfies\n"
    ":math:`I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))`,\n"
    "where :math:`F` is the hypergeometric function `hyp2f1`:\n"
    "\n"
    ">>> a, b, x = 1.4, 3.1, 0.5\n"
    ">>> x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))\n"
    "0.8148904036225295\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.8148904036225296\n"
    "\n"
    "This functions satisfies the relationship\n"
    ":math:`I_x(a, b) = 1 - I_{1-x}(b, a)`:\n"
    "\n"
    ">>> sc.betainc(2.2, 3.1, 0.4)\n"
    "0.49339638807619446\n"
    ">>> 1 - sc.betainc(3.1, 2.2, 1 - 0.4)\n"
    "0.49339638807619446")
ufunc_betainc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainc_types[0] = <char>NPY_FLOAT
ufunc_betainc_types[1] = <char>NPY_FLOAT
ufunc_betainc_types[2] = <char>NPY_FLOAT
ufunc_betainc_types[3] = <char>NPY_FLOAT
ufunc_betainc_types[4] = <char>NPY_DOUBLE
ufunc_betainc_types[5] = <char>NPY_DOUBLE
ufunc_betainc_types[6] = <char>NPY_DOUBLE
ufunc_betainc_types[7] = <char>NPY_DOUBLE
ufunc_betainc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_float
ufunc_betainc_ptr[2*0+1] = <void*>(<char*>"betainc")
ufunc_betainc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_double
ufunc_betainc_ptr[2*1+1] = <void*>(<char*>"betainc")
ufunc_betainc_data[0] = &ufunc_betainc_ptr[2*0]
ufunc_betainc_data[1] = &ufunc_betainc_ptr[2*1]
betainc = np.PyUFunc_FromFuncAndData(ufunc_betainc_loops, ufunc_betainc_data, ufunc_betainc_types, 2, 3, 1, 0, "betainc", ufunc_betainc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincc_loops[2]
cdef void *ufunc_betaincc_ptr[4]
cdef void *ufunc_betaincc_data[2]
cdef char ufunc_betaincc_types[8]
cdef char *ufunc_betaincc_doc = (
    "betaincc(a, b, x, out=None)\n"
    "\n"
    "Complement of the regularized incomplete beta function.\n"
    "\n"
    "Computes the complement of the regularized incomplete beta function,\n"
    "defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\bar{I}_x(a, b) = 1 - I_x(a, b)\n"
    "                    = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "                              t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betainccinv :\n"
    "    inverse of the complement of the regularized incomplete beta function\n"
    "beta : beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "This function wraps the ``ibetac`` routine from the\n"
    "Boost Math C++ library [2]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    ".. [2] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betaincc, betainc\n"
    "\n"
    "The naive calculation ``1 - betainc(a, b, x)`` loses precision when\n"
    "the values of ``betainc(a, b, x)`` are close to 1:\n"
    "\n"
    ">>> 1 - betainc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.0574632e-09, 0.0000000e+00, 0.0000000e+00])\n"
    "\n"
    "By using ``betaincc``, we get the correct values:\n"
    "\n"
    ">>> betaincc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.05746321e-09, 1.97259354e-17, 1.96467954e-25])")
ufunc_betaincc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincc_types[0] = <char>NPY_FLOAT
ufunc_betaincc_types[1] = <char>NPY_FLOAT
ufunc_betaincc_types[2] = <char>NPY_FLOAT
ufunc_betaincc_types[3] = <char>NPY_FLOAT
ufunc_betaincc_types[4] = <char>NPY_DOUBLE
ufunc_betaincc_types[5] = <char>NPY_DOUBLE
ufunc_betaincc_types[6] = <char>NPY_DOUBLE
ufunc_betaincc_types[7] = <char>NPY_DOUBLE
ufunc_betaincc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_float
ufunc_betaincc_ptr[2*0+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_double
ufunc_betaincc_ptr[2*1+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_data[0] = &ufunc_betaincc_ptr[2*0]
ufunc_betaincc_data[1] = &ufunc_betaincc_ptr[2*1]
betaincc = np.PyUFunc_FromFuncAndData(ufunc_betaincc_loops, ufunc_betaincc_data, ufunc_betaincc_types, 2, 3, 1, 0, "betaincc", ufunc_betaincc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainccinv_loops[2]
cdef void *ufunc_betainccinv_ptr[4]
cdef void *ufunc_betainccinv_data[2]
cdef char ufunc_betainccinv_types[8]
cdef char *ufunc_betainccinv_doc = (
    "betainccinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the complemented regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = 1 - I_x(a, b) = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "This function wraps the ``ibetac_inv`` routine from the\n"
    "Boost Math C++ library [2]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    ".. [2] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betainccinv, betaincc\n"
    "\n"
    "This function is the inverse of `betaincc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = betaincc(a, b, 0.2)\n"
    ">>> betainccinv(a, b, y)\n"
    "0.2\n"
    "\n"
    ">>> a, b = 7, 2.5\n"
    ">>> x = betainccinv(a, b, 0.875)\n"
    ">>> betaincc(a, b, x)\n"
    "0.875")
ufunc_betainccinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainccinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainccinv_types[0] = <char>NPY_FLOAT
ufunc_betainccinv_types[1] = <char>NPY_FLOAT
ufunc_betainccinv_types[2] = <char>NPY_FLOAT
ufunc_betainccinv_types[3] = <char>NPY_FLOAT
ufunc_betainccinv_types[4] = <char>NPY_DOUBLE
ufunc_betainccinv_types[5] = <char>NPY_DOUBLE
ufunc_betainccinv_types[6] = <char>NPY_DOUBLE
ufunc_betainccinv_types[7] = <char>NPY_DOUBLE
ufunc_betainccinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_float
ufunc_betainccinv_ptr[2*0+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_double
ufunc_betainccinv_ptr[2*1+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_data[0] = &ufunc_betainccinv_ptr[2*0]
ufunc_betainccinv_data[1] = &ufunc_betainccinv_ptr[2*1]
betainccinv = np.PyUFunc_FromFuncAndData(ufunc_betainccinv_loops, ufunc_betainccinv_data, ufunc_betainccinv_types, 2, 3, 1, 0, "betainccinv", ufunc_betainccinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincinv_loops[2]
cdef void *ufunc_betaincinv_ptr[4]
cdef void *ufunc_betaincinv_data[2]
cdef char ufunc_betaincinv_types[8]
cdef char *ufunc_betaincinv_doc = (
    "betaincinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "gamma : gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function wraps the ``ibeta_inv`` routine from the\n"
    "Boost Math C++ library [2]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    ".. [2] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "This function is the inverse of `betainc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = sc.betainc(a, b, 0.2)\n"
    ">>> sc.betaincinv(a, b, y)\n"
    "0.2\n"
    ">>>\n"
    ">>> a, b = 7.5, 0.4\n"
    ">>> x = sc.betaincinv(a, b, 0.5)\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.5")
ufunc_betaincinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincinv_types[0] = <char>NPY_FLOAT
ufunc_betaincinv_types[1] = <char>NPY_FLOAT
ufunc_betaincinv_types[2] = <char>NPY_FLOAT
ufunc_betaincinv_types[3] = <char>NPY_FLOAT
ufunc_betaincinv_types[4] = <char>NPY_DOUBLE
ufunc_betaincinv_types[5] = <char>NPY_DOUBLE
ufunc_betaincinv_types[6] = <char>NPY_DOUBLE
ufunc_betaincinv_types[7] = <char>NPY_DOUBLE
ufunc_betaincinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_float
ufunc_betaincinv_ptr[2*0+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_double
ufunc_betaincinv_ptr[2*1+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_data[0] = &ufunc_betaincinv_ptr[2*0]
ufunc_betaincinv_data[1] = &ufunc_betaincinv_ptr[2*1]
betaincinv = np.PyUFunc_FromFuncAndData(ufunc_betaincinv_loops, ufunc_betaincinv_data, ufunc_betaincinv_types, 2, 3, 1, 0, "betaincinv", ufunc_betaincinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox_loops[2]
cdef void *ufunc_boxcox_ptr[4]
cdef void *ufunc_boxcox_data[2]
cdef char ufunc_boxcox_types[6]
cdef char *ufunc_boxcox_doc = (
    "boxcox(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation.\n"
    "\n"
    "The Box-Cox transformation is::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < 0``.\n"
    "Returns `-inf` if ``x == 0`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox\n"
    ">>> boxcox([1, 4, 10], 2.5)\n"
    "array([   0.        ,   12.4       ,  126.09110641])\n"
    ">>> boxcox(2, [0, 1, 2])\n"
    "array([ 0.69314718,  1.        ,  1.5       ])")
ufunc_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox_types[0] = <char>NPY_FLOAT
ufunc_boxcox_types[1] = <char>NPY_FLOAT
ufunc_boxcox_types[2] = <char>NPY_FLOAT
ufunc_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_boxcox_ptr[2*0] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*0+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_ptr[2*1] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*1+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_data[0] = &ufunc_boxcox_ptr[2*0]
ufunc_boxcox_data[1] = &ufunc_boxcox_ptr[2*1]
boxcox = np.PyUFunc_FromFuncAndData(ufunc_boxcox_loops, ufunc_boxcox_data, ufunc_boxcox_types, 2, 2, 1, 0, "boxcox", ufunc_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox1p_loops[2]
cdef void *ufunc_boxcox1p_ptr[4]
cdef void *ufunc_boxcox1p_data[2]
cdef char ufunc_boxcox1p_types[6]
cdef char *ufunc_boxcox1p_doc = (
    "boxcox1p(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation of 1 + `x`.\n"
    "\n"
    "The Box-Cox transformation computed by `boxcox1p` is::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < -1``.\n"
    "Returns `-inf` if ``x == -1`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p\n"
    ">>> boxcox1p(1e-4, [0, 0.5, 1])\n"
    "array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])\n"
    ">>> boxcox1p([0.01, 0.1], 0.25)\n"
    "array([ 0.00996272,  0.09645476])")
ufunc_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_boxcox1p_ptr[2*0] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*0+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_ptr[2*1] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*1+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_data[0] = &ufunc_boxcox1p_ptr[2*0]
ufunc_boxcox1p_data[1] = &ufunc_boxcox1p_ptr[2*1]
boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_boxcox1p_loops, ufunc_boxcox1p_data, ufunc_boxcox1p_types, 2, 2, 1, 0, "boxcox1p", ufunc_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtria_loops[2]
cdef void *ufunc_btdtria_ptr[4]
cdef void *ufunc_btdtria_data[2]
cdef char ufunc_btdtria_types[8]
cdef char *ufunc_btdtria_doc = (
    "btdtria(p, b, x, out=None)\n"
    "\n"
    "Inverse of `betainc` with respect to `a`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `betainc`,\n"
    "considered as a function of `a`, returning the value of `a` for which\n"
    "`betainc(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : scalar or ndarray\n"
    "    The value of the shape parameter `a` such that `betainc(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtrib : Inverse of the beta cumulative distribution function, with respect to `b`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtria_types[0] = <char>NPY_FLOAT
ufunc_btdtria_types[1] = <char>NPY_FLOAT
ufunc_btdtria_types[2] = <char>NPY_FLOAT
ufunc_btdtria_types[3] = <char>NPY_FLOAT
ufunc_btdtria_types[4] = <char>NPY_DOUBLE
ufunc_btdtria_types[5] = <char>NPY_DOUBLE
ufunc_btdtria_types[6] = <char>NPY_DOUBLE
ufunc_btdtria_types[7] = <char>NPY_DOUBLE
ufunc_btdtria_ptr[2*0] = <void*>_func_btdtria
ufunc_btdtria_ptr[2*0+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_ptr[2*1] = <void*>_func_btdtria
ufunc_btdtria_ptr[2*1+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_data[0] = &ufunc_btdtria_ptr[2*0]
ufunc_btdtria_data[1] = &ufunc_btdtria_ptr[2*1]
btdtria = np.PyUFunc_FromFuncAndData(ufunc_btdtria_loops, ufunc_btdtria_data, ufunc_btdtria_types, 2, 3, 1, 0, "btdtria", ufunc_btdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtrib_loops[2]
cdef void *ufunc_btdtrib_ptr[4]
cdef void *ufunc_btdtrib_data[2]
cdef char ufunc_btdtrib_types[8]
cdef char *ufunc_btdtrib_doc = (
    "btdtria(a, p, x, out=None)\n"
    "\n"
    "Inverse of `betainc` with respect to `b`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `betainc`,\n"
    "considered as a function of `b`, returning the value of `b` for which\n"
    "`betainc(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : scalar or ndarray\n"
    "    The value of the shape parameter `b` such that `betainc(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtria : Inverse of the beta cumulative distribution function, with respect to `a`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `b`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtrib_types[0] = <char>NPY_FLOAT
ufunc_btdtrib_types[1] = <char>NPY_FLOAT
ufunc_btdtrib_types[2] = <char>NPY_FLOAT
ufunc_btdtrib_types[3] = <char>NPY_FLOAT
ufunc_btdtrib_types[4] = <char>NPY_DOUBLE
ufunc_btdtrib_types[5] = <char>NPY_DOUBLE
ufunc_btdtrib_types[6] = <char>NPY_DOUBLE
ufunc_btdtrib_types[7] = <char>NPY_DOUBLE
ufunc_btdtrib_ptr[2*0] = <void*>_func_btdtrib
ufunc_btdtrib_ptr[2*0+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_ptr[2*1] = <void*>_func_btdtrib
ufunc_btdtrib_ptr[2*1+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_data[0] = &ufunc_btdtrib_ptr[2*0]
ufunc_btdtrib_data[1] = &ufunc_btdtrib_ptr[2*1]
btdtrib = np.PyUFunc_FromFuncAndData(ufunc_btdtrib_loops, ufunc_btdtrib_data, ufunc_btdtrib_types, 2, 3, 1, 0, "btdtrib", ufunc_btdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtr_loops[2]
cdef void *ufunc_chdtr_ptr[4]
cdef void *ufunc_chdtr_data[2]
cdef char ufunc_chdtr_types[6]
cdef char *ufunc_chdtr_doc = (
    "chdtr(v, x, out=None)\n"
    "\n"
    "Chi square cumulative distribution function.\n"
    "\n"
    "Returns the area under the left tail (from 0 to `x`) of the Chi\n"
    "square probability density function with `v` degrees of freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_0^x t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized lower\n"
    "incomplete gamma function `gammainc` as\n"
    "``gammainc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Upper bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtri, chdtriv, gammainc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized lower incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtr(v, x)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])\n"
    ">>> sc.gammainc(v / 2, x / 2)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])")
ufunc_chdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtr_types[0] = <char>NPY_FLOAT
ufunc_chdtr_types[1] = <char>NPY_FLOAT
ufunc_chdtr_types[2] = <char>NPY_FLOAT
ufunc_chdtr_types[3] = <char>NPY_DOUBLE
ufunc_chdtr_types[4] = <char>NPY_DOUBLE
ufunc_chdtr_types[5] = <char>NPY_DOUBLE
ufunc_chdtr_ptr[2*0] = <void*>_func_xsf_chdtr
ufunc_chdtr_ptr[2*0+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_ptr[2*1] = <void*>_func_xsf_chdtr
ufunc_chdtr_ptr[2*1+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_data[0] = &ufunc_chdtr_ptr[2*0]
ufunc_chdtr_data[1] = &ufunc_chdtr_ptr[2*1]
chdtr = np.PyUFunc_FromFuncAndData(ufunc_chdtr_loops, ufunc_chdtr_data, ufunc_chdtr_types, 2, 2, 1, 0, "chdtr", ufunc_chdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtrc_loops[2]
cdef void *ufunc_chdtrc_ptr[4]
cdef void *ufunc_chdtrc_data[2]
cdef char ufunc_chdtrc_types[6]
cdef char *ufunc_chdtrc_doc = (
    "chdtrc(v, x, out=None)\n"
    "\n"
    "Chi square survival function.\n"
    "\n"
    "Returns the area under the right hand tail (from `x` to infinity)\n"
    "of the Chi square probability density function with `v` degrees of\n"
    "freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_x^\\infty t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized upper\n"
    "incomplete gamma function `gammaincc` as\n"
    "``gammaincc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Lower bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the survival function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtri, chdtriv, gammaincc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized upper incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtrc(v, x)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])\n"
    ">>> sc.gammaincc(v / 2, x / 2)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])")
ufunc_chdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtrc_types[0] = <char>NPY_FLOAT
ufunc_chdtrc_types[1] = <char>NPY_FLOAT
ufunc_chdtrc_types[2] = <char>NPY_FLOAT
ufunc_chdtrc_types[3] = <char>NPY_DOUBLE
ufunc_chdtrc_types[4] = <char>NPY_DOUBLE
ufunc_chdtrc_types[5] = <char>NPY_DOUBLE
ufunc_chdtrc_ptr[2*0] = <void*>_func_xsf_chdtrc
ufunc_chdtrc_ptr[2*0+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_ptr[2*1] = <void*>_func_xsf_chdtrc
ufunc_chdtrc_ptr[2*1+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_data[0] = &ufunc_chdtrc_ptr[2*0]
ufunc_chdtrc_data[1] = &ufunc_chdtrc_ptr[2*1]
chdtrc = np.PyUFunc_FromFuncAndData(ufunc_chdtrc_loops, ufunc_chdtrc_data, ufunc_chdtrc_types, 2, 2, 1, 0, "chdtrc", ufunc_chdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtri_loops[2]
cdef void *ufunc_chdtri_ptr[4]
cdef void *ufunc_chdtri_data[2]
cdef char ufunc_chdtri_types[6]
cdef char *ufunc_chdtri_doc = (
    "chdtri(v, p, out=None)\n"
    "\n"
    "Inverse to `chdtrc` with respect to `x`.\n"
    "\n"
    "Returns `x` such that ``chdtrc(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "p : array_like\n"
    "    Probability.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a Chi square random variable\n"
    "    with `v` degrees of freedom is greater than `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtr, chdtriv\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtrc`.\n"
    "\n"
    ">>> v, p = 1, 0.3\n"
    ">>> sc.chdtrc(v, sc.chdtri(v, p))\n"
    "0.3\n"
    ">>> x = 1\n"
    ">>> sc.chdtri(v, sc.chdtrc(v, x))\n"
    "1.0")
ufunc_chdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtri_types[0] = <char>NPY_FLOAT
ufunc_chdtri_types[1] = <char>NPY_FLOAT
ufunc_chdtri_types[2] = <char>NPY_FLOAT
ufunc_chdtri_types[3] = <char>NPY_DOUBLE
ufunc_chdtri_types[4] = <char>NPY_DOUBLE
ufunc_chdtri_types[5] = <char>NPY_DOUBLE
ufunc_chdtri_ptr[2*0] = <void*>_func_xsf_chdtri
ufunc_chdtri_ptr[2*0+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_ptr[2*1] = <void*>_func_xsf_chdtri
ufunc_chdtri_ptr[2*1+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_data[0] = &ufunc_chdtri_ptr[2*0]
ufunc_chdtri_data[1] = &ufunc_chdtri_ptr[2*1]
chdtri = np.PyUFunc_FromFuncAndData(ufunc_chdtri_loops, ufunc_chdtri_data, ufunc_chdtri_types, 2, 2, 1, 0, "chdtri", ufunc_chdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtriv_loops[2]
cdef void *ufunc_chdtriv_ptr[4]
cdef void *ufunc_chdtriv_data[2]
cdef char ufunc_chdtriv_types[6]
cdef char *ufunc_chdtriv_doc = (
    "chdtriv(p, x, out=None)\n"
    "\n"
    "Inverse to `chdtr` with respect to `v`.\n"
    "\n"
    "Returns `v` such that ``chdtr(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability that the Chi square random variable is less than\n"
    "    or equal to `x`.\n"
    "x : array_like\n"
    "    Nonnegative input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Degrees of freedom.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtrc, chdtri\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtr`.\n"
    "\n"
    ">>> p, x = 0.5, 1\n"
    ">>> sc.chdtr(sc.chdtriv(p, x), x)\n"
    "0.5000000000202172\n"
    ">>> v = 1\n"
    ">>> sc.chdtriv(sc.chdtr(v, x), v)\n"
    "1.0000000000000013")
ufunc_chdtriv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtriv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtriv_types[0] = <char>NPY_FLOAT
ufunc_chdtriv_types[1] = <char>NPY_FLOAT
ufunc_chdtriv_types[2] = <char>NPY_FLOAT
ufunc_chdtriv_types[3] = <char>NPY_DOUBLE
ufunc_chdtriv_types[4] = <char>NPY_DOUBLE
ufunc_chdtriv_types[5] = <char>NPY_DOUBLE
ufunc_chdtriv_ptr[2*0] = <void*>_func_chdtriv
ufunc_chdtriv_ptr[2*0+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_ptr[2*1] = <void*>_func_chdtriv
ufunc_chdtriv_ptr[2*1+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_data[0] = &ufunc_chdtriv_ptr[2*0]
ufunc_chdtriv_data[1] = &ufunc_chdtriv_ptr[2*1]
chdtriv = np.PyUFunc_FromFuncAndData(ufunc_chdtriv_loops, ufunc_chdtriv_data, ufunc_chdtriv_types, 2, 2, 1, 0, "chdtriv", ufunc_chdtriv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtr_loops[2]
cdef void *ufunc_chndtr_ptr[4]
cdef void *ufunc_chndtr_data[2]
cdef char ufunc_chndtr_types[8]
cdef char *ufunc_chndtr_doc = (
    "chndtr(x, df, nc, out=None)\n"
    "\n"
    "Non-central chi square cumulative distribution function\n"
    "\n"
    "The cumulative distribution function is given by:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P(\\chi^{\\prime 2} \\vert \\nu, \\lambda) =\\sum_{j=0}^{\\infty}\n"
    "    e^{-\\lambda /2}\n"
    "    \\frac{(\\lambda /2)^j}{j!} P(\\chi^{\\prime 2} \\vert \\nu + 2j),\n"
    "\n"
    "where :math:`\\nu > 0` is the degrees of freedom (``df``) and\n"
    ":math:`\\lambda \\geq 0` is the non-centrality parameter (``nc``).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value of the non-central chi square cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtrix, chndtridf, chndtrinc")
ufunc_chndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtr_types[0] = <char>NPY_FLOAT
ufunc_chndtr_types[1] = <char>NPY_FLOAT
ufunc_chndtr_types[2] = <char>NPY_FLOAT
ufunc_chndtr_types[3] = <char>NPY_FLOAT
ufunc_chndtr_types[4] = <char>NPY_DOUBLE
ufunc_chndtr_types[5] = <char>NPY_DOUBLE
ufunc_chndtr_types[6] = <char>NPY_DOUBLE
ufunc_chndtr_types[7] = <char>NPY_DOUBLE
ufunc_chndtr_ptr[2*0] = <void*>_func_chndtr
ufunc_chndtr_ptr[2*0+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_ptr[2*1] = <void*>_func_chndtr
ufunc_chndtr_ptr[2*1+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_data[0] = &ufunc_chndtr_ptr[2*0]
ufunc_chndtr_data[1] = &ufunc_chndtr_ptr[2*1]
chndtr = np.PyUFunc_FromFuncAndData(ufunc_chndtr_loops, ufunc_chndtr_data, ufunc_chndtr_types, 2, 3, 1, 0, "chndtr", ufunc_chndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtridf_loops[2]
cdef void *ufunc_chndtridf_ptr[4]
cdef void *ufunc_chndtridf_data[2]
cdef char ufunc_chndtridf_types[8]
cdef char *ufunc_chndtridf_doc = (
    "chndtridf(x, p, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `df`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "df : scalar or ndarray\n"
    "    Degrees of freedom\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtridf_types[0] = <char>NPY_FLOAT
ufunc_chndtridf_types[1] = <char>NPY_FLOAT
ufunc_chndtridf_types[2] = <char>NPY_FLOAT
ufunc_chndtridf_types[3] = <char>NPY_FLOAT
ufunc_chndtridf_types[4] = <char>NPY_DOUBLE
ufunc_chndtridf_types[5] = <char>NPY_DOUBLE
ufunc_chndtridf_types[6] = <char>NPY_DOUBLE
ufunc_chndtridf_types[7] = <char>NPY_DOUBLE
ufunc_chndtridf_ptr[2*0] = <void*>_func_chndtridf
ufunc_chndtridf_ptr[2*0+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_ptr[2*1] = <void*>_func_chndtridf
ufunc_chndtridf_ptr[2*1+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_data[0] = &ufunc_chndtridf_ptr[2*0]
ufunc_chndtridf_data[1] = &ufunc_chndtridf_ptr[2*1]
chndtridf = np.PyUFunc_FromFuncAndData(ufunc_chndtridf_loops, ufunc_chndtridf_data, ufunc_chndtridf_types, 2, 3, 1, 0, "chndtridf", ufunc_chndtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrinc_loops[2]
cdef void *ufunc_chndtrinc_ptr[4]
cdef void *ufunc_chndtrinc_data[2]
cdef char ufunc_chndtrinc_types[8]
cdef char *ufunc_chndtrinc_doc = (
    "chndtrinc(x, df, p, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `nc`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Non-centrality\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrinc_types[0] = <char>NPY_FLOAT
ufunc_chndtrinc_types[1] = <char>NPY_FLOAT
ufunc_chndtrinc_types[2] = <char>NPY_FLOAT
ufunc_chndtrinc_types[3] = <char>NPY_FLOAT
ufunc_chndtrinc_types[4] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[5] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[6] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[7] = <char>NPY_DOUBLE
ufunc_chndtrinc_ptr[2*0] = <void*>_func_chndtrinc
ufunc_chndtrinc_ptr[2*0+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_ptr[2*1] = <void*>_func_chndtrinc
ufunc_chndtrinc_ptr[2*1+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_data[0] = &ufunc_chndtrinc_ptr[2*0]
ufunc_chndtrinc_data[1] = &ufunc_chndtrinc_ptr[2*1]
chndtrinc = np.PyUFunc_FromFuncAndData(ufunc_chndtrinc_loops, ufunc_chndtrinc_data, ufunc_chndtrinc_types, 2, 3, 1, 0, "chndtrinc", ufunc_chndtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrix_loops[2]
cdef void *ufunc_chndtrix_ptr[4]
cdef void *ufunc_chndtrix_data[2]
cdef char ufunc_chndtrix_types[8]
cdef char *ufunc_chndtrix_doc = (
    "chndtrix(p, df, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `x`\n"
    "\n"
    "Calculated using a search to find a value for `x` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a non-central Chi square random variable\n"
    "    with `df` degrees of freedom and non-centrality, `nc`, is greater than\n"
    "    `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtridf, chndtrinc")
ufunc_chndtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrix_types[0] = <char>NPY_FLOAT
ufunc_chndtrix_types[1] = <char>NPY_FLOAT
ufunc_chndtrix_types[2] = <char>NPY_FLOAT
ufunc_chndtrix_types[3] = <char>NPY_FLOAT
ufunc_chndtrix_types[4] = <char>NPY_DOUBLE
ufunc_chndtrix_types[5] = <char>NPY_DOUBLE
ufunc_chndtrix_types[6] = <char>NPY_DOUBLE
ufunc_chndtrix_types[7] = <char>NPY_DOUBLE
ufunc_chndtrix_ptr[2*0] = <void*>_func_chndtrix
ufunc_chndtrix_ptr[2*0+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_ptr[2*1] = <void*>_func_chndtrix
ufunc_chndtrix_ptr[2*1+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_data[0] = &ufunc_chndtrix_ptr[2*0]
ufunc_chndtrix_data[1] = &ufunc_chndtrix_ptr[2*1]
chndtrix = np.PyUFunc_FromFuncAndData(ufunc_chndtrix_loops, ufunc_chndtrix_data, ufunc_chndtrix_types, 2, 3, 1, 0, "chndtrix", ufunc_chndtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_dawsn_loops[4]
cdef void *ufunc_dawsn_ptr[8]
cdef void *ufunc_dawsn_data[4]
cdef char ufunc_dawsn_types[8]
cdef char *ufunc_dawsn_doc = (
    "dawsn(x, out=None)\n"
    "\n"
    "Dawson's integral.\n"
    "\n"
    "Computes::\n"
    "\n"
    "    exp(-x**2) * integral(exp(t**2), t=0..x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Function parameter.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "wofz, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-15, 15, num=1000)\n"
    ">>> plt.plot(x, special.dawsn(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$dawsn(x)$')\n"
    ">>> plt.show()")
ufunc_dawsn_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_dawsn_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_dawsn_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_dawsn_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_dawsn_types[0] = <char>NPY_FLOAT
ufunc_dawsn_types[1] = <char>NPY_FLOAT
ufunc_dawsn_types[2] = <char>NPY_DOUBLE
ufunc_dawsn_types[3] = <char>NPY_DOUBLE
ufunc_dawsn_types[4] = <char>NPY_CFLOAT
ufunc_dawsn_types[5] = <char>NPY_CFLOAT
ufunc_dawsn_types[6] = <char>NPY_CDOUBLE
ufunc_dawsn_types[7] = <char>NPY_CDOUBLE
ufunc_dawsn_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*0+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*1+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*2+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*3+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_data[0] = &ufunc_dawsn_ptr[2*0]
ufunc_dawsn_data[1] = &ufunc_dawsn_ptr[2*1]
ufunc_dawsn_data[2] = &ufunc_dawsn_ptr[2*2]
ufunc_dawsn_data[3] = &ufunc_dawsn_ptr[2*3]
dawsn = np.PyUFunc_FromFuncAndData(ufunc_dawsn_loops, ufunc_dawsn_data, ufunc_dawsn_types, 4, 1, 1, 0, "dawsn", ufunc_dawsn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprc_loops[4]
cdef void *ufunc_elliprc_ptr[8]
cdef void *ufunc_elliprc_data[4]
cdef char ufunc_elliprc_types[12]
cdef char *ufunc_elliprc_doc = (
    "elliprc(x, y, out=None)\n"
    "\n"
    "Degenerate symmetric elliptic integral.\n"
    "\n"
    "The function RC is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{C}}(x, y) =\n"
    "       \\frac{1}{2} \\int_0^{+\\infty} (t + x)^{-1/2} (t + y)^{-1} dt\n"
    "       = R_{\\mathrm{F}}(x, y, y)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y : array_like\n"
    "    Real or complex input parameters. `x` can be any number in the\n"
    "    complex plane cut along the negative real axis. `y` must be non-zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If `y` is real and negative, the Cauchy\n"
    "    principal value is returned. If both of `x` and `y` are real, the\n"
    "    return value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "RC is a degenerate case of the symmetric integral RF: ``elliprc(x, y) ==\n"
    "elliprf(x, y, y)``. It is an elementary function rather than an elliptic\n"
    "integral.\n"
    "\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order. [2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E6\n"
    ".. [2] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprc\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprc(scale*x, scale*y)\n"
    "(0.5484493976710874-0.4169557678995833j)\n"
    "\n"
    ">>> elliprc(x, y)/np.sqrt(scale)\n"
    "(0.5484493976710874-0.41695576789958333j)\n"
    "\n"
    "When the two arguments coincide, the integral is particularly\n"
    "simple:\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> elliprc(x, x)\n"
    "(0.4299173120614631-0.3041729818745595j)\n"
    "\n"
    ">>> 1/np.sqrt(x)\n"
    "(0.4299173120614631-0.30417298187455954j)\n"
    "\n"
    "Another simple case: the first argument vanishes:\n"
    "\n"
    ">>> y = 1.2 + 3.4j\n"
    ">>> elliprc(0, y)\n"
    "(0.6753125346116815-0.47779380263880866j)\n"
    "\n"
    ">>> np.pi/2/np.sqrt(y)\n"
    "(0.6753125346116815-0.4777938026388088j)\n"
    "\n"
    "When `x` and `y` are both positive, we can express\n"
    ":math:`R_C(x,y)` in terms of more elementary functions.  For the\n"
    "case :math:`0 \\le x < y`,\n"
    "\n"
    ">>> x = 3.2\n"
    ">>> y = 6.\n"
    ">>> elliprc(x, y)\n"
    "0.44942991498453444\n"
    "\n"
    ">>> np.arctan(np.sqrt((y-x)/x))/np.sqrt(y-x)\n"
    "0.44942991498453433\n"
    "\n"
    "And for the case :math:`0 \\le y < x`,\n"
    "\n"
    ">>> x = 6.\n"
    ">>> y = 3.2\n"
    ">>> elliprc(x,y)\n"
    "0.4989837501576147\n"
    "\n"
    ">>> np.log((np.sqrt(x)+np.sqrt(x-y))/np.sqrt(y))/np.sqrt(x-y)\n"
    "0.49898375015761476")
ufunc_elliprc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_elliprc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_elliprc_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_elliprc_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_elliprc_types[0] = <char>NPY_FLOAT
ufunc_elliprc_types[1] = <char>NPY_FLOAT
ufunc_elliprc_types[2] = <char>NPY_FLOAT
ufunc_elliprc_types[3] = <char>NPY_DOUBLE
ufunc_elliprc_types[4] = <char>NPY_DOUBLE
ufunc_elliprc_types[5] = <char>NPY_DOUBLE
ufunc_elliprc_types[6] = <char>NPY_CFLOAT
ufunc_elliprc_types[7] = <char>NPY_CFLOAT
ufunc_elliprc_types[8] = <char>NPY_CFLOAT
ufunc_elliprc_types[9] = <char>NPY_CDOUBLE
ufunc_elliprc_types[10] = <char>NPY_CDOUBLE
ufunc_elliprc_types[11] = <char>NPY_CDOUBLE
ufunc_elliprc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RC
ufunc_elliprc_ptr[2*0+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RC
ufunc_elliprc_ptr[2*1+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RC
ufunc_elliprc_ptr[2*2+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RC
ufunc_elliprc_ptr[2*3+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_data[0] = &ufunc_elliprc_ptr[2*0]
ufunc_elliprc_data[1] = &ufunc_elliprc_ptr[2*1]
ufunc_elliprc_data[2] = &ufunc_elliprc_ptr[2*2]
ufunc_elliprc_data[3] = &ufunc_elliprc_ptr[2*3]
elliprc = np.PyUFunc_FromFuncAndData(ufunc_elliprc_loops, ufunc_elliprc_data, ufunc_elliprc_types, 4, 2, 1, 0, "elliprc", ufunc_elliprc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprd_loops[4]
cdef void *ufunc_elliprd_ptr[8]
cdef void *ufunc_elliprd_data[4]
cdef char ufunc_elliprd_types[16]
cdef char *ufunc_elliprd_doc = (
    "elliprd(x, y, z, out=None)\n"
    "\n"
    "Symmetric elliptic integral of the second kind.\n"
    "\n"
    "The function RD is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{D}}(x, y, z) =\n"
    "       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y)]^{-1/2} (t + z)^{-3/2}\n"
    "       dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z : array_like\n"
    "    Real or complex input parameters. `x` or `y` can be any number in the\n"
    "    complex plane cut along the negative real axis, but at most one of them\n"
    "    can be zero, while `z` must be non-zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, and `z` are real, the\n"
    "    return value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric elliptic integral.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "RD is a degenerate case of the elliptic integral RJ: ``elliprd(x, y, z) ==\n"
    "elliprj(x, y, z, z)``.\n"
    "\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order. [2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E5\n"
    ".. [2] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprd\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprd(scale*x, scale*y, scale*z)\n"
    "(-0.03703043835680379-0.24500934665683802j)\n"
    "\n"
    ">>> elliprd(x, y, z)*np.power(scale, -1.5)\n"
    "(-0.0370304383568038-0.24500934665683805j)\n"
    "\n"
    "All three arguments coincide:\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> elliprd(x, x, x)\n"
    "(-0.03986825876151896-0.14051741840449586j)\n"
    "\n"
    ">>> np.power(x, -1.5)\n"
    "(-0.03986825876151894-0.14051741840449583j)\n"
    "\n"
    "The so-called \"second lemniscate constant\":\n"
    "\n"
    ">>> elliprd(0, 2, 1)/3\n"
    "0.5990701173677961\n"
    "\n"
    ">>> from scipy.special import gamma\n"
    ">>> gamma(0.75)**2/np.sqrt(2*np.pi)\n"
    "0.5990701173677959")
ufunc_elliprd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_elliprd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_elliprd_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDD__As_FFF_F
ufunc_elliprd_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDD__As_DDD_D
ufunc_elliprd_types[0] = <char>NPY_FLOAT
ufunc_elliprd_types[1] = <char>NPY_FLOAT
ufunc_elliprd_types[2] = <char>NPY_FLOAT
ufunc_elliprd_types[3] = <char>NPY_FLOAT
ufunc_elliprd_types[4] = <char>NPY_DOUBLE
ufunc_elliprd_types[5] = <char>NPY_DOUBLE
ufunc_elliprd_types[6] = <char>NPY_DOUBLE
ufunc_elliprd_types[7] = <char>NPY_DOUBLE
ufunc_elliprd_types[8] = <char>NPY_CFLOAT
ufunc_elliprd_types[9] = <char>NPY_CFLOAT
ufunc_elliprd_types[10] = <char>NPY_CFLOAT
ufunc_elliprd_types[11] = <char>NPY_CFLOAT
ufunc_elliprd_types[12] = <char>NPY_CDOUBLE
ufunc_elliprd_types[13] = <char>NPY_CDOUBLE
ufunc_elliprd_types[14] = <char>NPY_CDOUBLE
ufunc_elliprd_types[15] = <char>NPY_CDOUBLE
ufunc_elliprd_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RD
ufunc_elliprd_ptr[2*0+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RD
ufunc_elliprd_ptr[2*1+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RD
ufunc_elliprd_ptr[2*2+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RD
ufunc_elliprd_ptr[2*3+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_data[0] = &ufunc_elliprd_ptr[2*0]
ufunc_elliprd_data[1] = &ufunc_elliprd_ptr[2*1]
ufunc_elliprd_data[2] = &ufunc_elliprd_ptr[2*2]
ufunc_elliprd_data[3] = &ufunc_elliprd_ptr[2*3]
elliprd = np.PyUFunc_FromFuncAndData(ufunc_elliprd_loops, ufunc_elliprd_data, ufunc_elliprd_types, 4, 3, 1, 0, "elliprd", ufunc_elliprd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprf_loops[4]
cdef void *ufunc_elliprf_ptr[8]
cdef void *ufunc_elliprf_data[4]
cdef char ufunc_elliprf_types[16]
cdef char *ufunc_elliprf_doc = (
    "elliprf(x, y, z, out=None)\n"
    "\n"
    "Completely-symmetric elliptic integral of the first kind.\n"
    "\n"
    "The function RF is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{F}}(x, y, z) =\n"
    "       \\frac{1}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z : array_like\n"
    "    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n"
    "    the complex plane cut along the negative real axis, but at most one of\n"
    "    them can be zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n"
    "    value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric integral.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order (cf.:\n"
    "https://dlmf.nist.gov/19.36.i) and the AGM algorithm for the complete\n"
    "integral. [2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E1\n"
    ".. [2] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprf\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprf(scale*x, scale*y, scale*z)\n"
    "(0.5328051227278146-0.4008623567957094j)\n"
    "\n"
    ">>> elliprf(x, y, z)/np.sqrt(scale)\n"
    "(0.5328051227278147-0.4008623567957095j)\n"
    "\n"
    "All three arguments coincide:\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> elliprf(x, x, x)\n"
    "(0.42991731206146316-0.30417298187455954j)\n"
    "\n"
    ">>> 1/np.sqrt(x)\n"
    "(0.4299173120614631-0.30417298187455954j)\n"
    "\n"
    "The so-called \"first lemniscate constant\":\n"
    "\n"
    ">>> elliprf(0, 1, 2)\n"
    "1.3110287771460598\n"
    "\n"
    ">>> from scipy.special import gamma\n"
    ">>> gamma(0.25)**2/(4*np.sqrt(2*np.pi))\n"
    "1.3110287771460598")
ufunc_elliprf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_elliprf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_elliprf_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDD__As_FFF_F
ufunc_elliprf_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDD__As_DDD_D
ufunc_elliprf_types[0] = <char>NPY_FLOAT
ufunc_elliprf_types[1] = <char>NPY_FLOAT
ufunc_elliprf_types[2] = <char>NPY_FLOAT
ufunc_elliprf_types[3] = <char>NPY_FLOAT
ufunc_elliprf_types[4] = <char>NPY_DOUBLE
ufunc_elliprf_types[5] = <char>NPY_DOUBLE
ufunc_elliprf_types[6] = <char>NPY_DOUBLE
ufunc_elliprf_types[7] = <char>NPY_DOUBLE
ufunc_elliprf_types[8] = <char>NPY_CFLOAT
ufunc_elliprf_types[9] = <char>NPY_CFLOAT
ufunc_elliprf_types[10] = <char>NPY_CFLOAT
ufunc_elliprf_types[11] = <char>NPY_CFLOAT
ufunc_elliprf_types[12] = <char>NPY_CDOUBLE
ufunc_elliprf_types[13] = <char>NPY_CDOUBLE
ufunc_elliprf_types[14] = <char>NPY_CDOUBLE
ufunc_elliprf_types[15] = <char>NPY_CDOUBLE
ufunc_elliprf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RF
ufunc_elliprf_ptr[2*0+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RF
ufunc_elliprf_ptr[2*1+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RF
ufunc_elliprf_ptr[2*2+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RF
ufunc_elliprf_ptr[2*3+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_data[0] = &ufunc_elliprf_ptr[2*0]
ufunc_elliprf_data[1] = &ufunc_elliprf_ptr[2*1]
ufunc_elliprf_data[2] = &ufunc_elliprf_ptr[2*2]
ufunc_elliprf_data[3] = &ufunc_elliprf_ptr[2*3]
elliprf = np.PyUFunc_FromFuncAndData(ufunc_elliprf_loops, ufunc_elliprf_data, ufunc_elliprf_types, 4, 3, 1, 0, "elliprf", ufunc_elliprf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprg_loops[4]
cdef void *ufunc_elliprg_ptr[8]
cdef void *ufunc_elliprg_data[4]
cdef char ufunc_elliprg_types[16]
cdef char *ufunc_elliprg_doc = (
    "elliprg(x, y, z, out=None)\n"
    "\n"
    "Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "The function RG is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{G}}(x, y, z) =\n"
    "       \\frac{1}{4} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n"
    "       \\left(\\frac{x}{t + x} + \\frac{y}{t + y} + \\frac{z}{t + z}\\right) t\n"
    "       dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z : array_like\n"
    "    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n"
    "    the complex plane cut along the negative real axis.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n"
    "    value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric integral.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The implementation uses the relation [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    2 R_{\\mathrm{G}}(x, y, z) =\n"
    "       z R_{\\mathrm{F}}(x, y, z) -\n"
    "       \\frac{1}{3} (x - z) (y - z) R_{\\mathrm{D}}(x, y, z) +\n"
    "       \\sqrt{\\frac{x y}{z}}\n"
    "\n"
    "and the symmetry of `x`, `y`, `z` when at least one non-zero parameter can\n"
    "be chosen as the pivot. When one of the arguments is close to zero, the AGM\n"
    "method is applied instead. Other special cases are computed following Ref.\n"
    "[2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    ".. [2] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E1\n"
    "       https://dlmf.nist.gov/19.20.ii\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprg\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprg(scale*x, scale*y, scale*z)\n"
    "(1.195936862005246+0.8470988320464167j)\n"
    "\n"
    ">>> elliprg(x, y, z)*np.sqrt(scale)\n"
    "(1.195936862005246+0.8470988320464165j)\n"
    "\n"
    "Simplifications:\n"
    "\n"
    ">>> elliprg(0, y, y)\n"
    "1.756203682760182\n"
    "\n"
    ">>> 0.25*np.pi*np.sqrt(y)\n"
    "1.7562036827601817\n"
    "\n"
    ">>> elliprg(0, 0, z)\n"
    "1.224744871391589\n"
    "\n"
    ">>> 0.5*np.sqrt(z)\n"
    "1.224744871391589\n"
    "\n"
    "The surface area of a triaxial ellipsoid with semiaxes ``a``, ``b``, and\n"
    "``c`` is given by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    S = 4 \\pi a b c R_{\\mathrm{G}}(1 / a^2, 1 / b^2, 1 / c^2).\n"
    "\n"
    ">>> def ellipsoid_area(a, b, c):\n"
    "...     r = 4.0 * np.pi * a * b * c\n"
    "...     return r * elliprg(1.0 / (a * a), 1.0 / (b * b), 1.0 / (c * c))\n"
    ">>> print(ellipsoid_area(1, 3, 5))\n"
    "108.62688289491807")
ufunc_elliprg_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_elliprg_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_elliprg_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDD__As_FFF_F
ufunc_elliprg_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDD__As_DDD_D
ufunc_elliprg_types[0] = <char>NPY_FLOAT
ufunc_elliprg_types[1] = <char>NPY_FLOAT
ufunc_elliprg_types[2] = <char>NPY_FLOAT
ufunc_elliprg_types[3] = <char>NPY_FLOAT
ufunc_elliprg_types[4] = <char>NPY_DOUBLE
ufunc_elliprg_types[5] = <char>NPY_DOUBLE
ufunc_elliprg_types[6] = <char>NPY_DOUBLE
ufunc_elliprg_types[7] = <char>NPY_DOUBLE
ufunc_elliprg_types[8] = <char>NPY_CFLOAT
ufunc_elliprg_types[9] = <char>NPY_CFLOAT
ufunc_elliprg_types[10] = <char>NPY_CFLOAT
ufunc_elliprg_types[11] = <char>NPY_CFLOAT
ufunc_elliprg_types[12] = <char>NPY_CDOUBLE
ufunc_elliprg_types[13] = <char>NPY_CDOUBLE
ufunc_elliprg_types[14] = <char>NPY_CDOUBLE
ufunc_elliprg_types[15] = <char>NPY_CDOUBLE
ufunc_elliprg_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RG
ufunc_elliprg_ptr[2*0+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RG
ufunc_elliprg_ptr[2*1+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RG
ufunc_elliprg_ptr[2*2+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RG
ufunc_elliprg_ptr[2*3+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_data[0] = &ufunc_elliprg_ptr[2*0]
ufunc_elliprg_data[1] = &ufunc_elliprg_ptr[2*1]
ufunc_elliprg_data[2] = &ufunc_elliprg_ptr[2*2]
ufunc_elliprg_data[3] = &ufunc_elliprg_ptr[2*3]
elliprg = np.PyUFunc_FromFuncAndData(ufunc_elliprg_loops, ufunc_elliprg_data, ufunc_elliprg_types, 4, 3, 1, 0, "elliprg", ufunc_elliprg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprj_loops[4]
cdef void *ufunc_elliprj_ptr[8]
cdef void *ufunc_elliprj_data[4]
cdef char ufunc_elliprj_types[20]
cdef char *ufunc_elliprj_doc = (
    "elliprj(x, y, z, p, out=None)\n"
    "\n"
    "Symmetric elliptic integral of the third kind.\n"
    "\n"
    "The function RJ is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{J}}(x, y, z, p) =\n"
    "       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n"
    "       (t + p)^{-1} dt\n"
    "\n"
    ".. warning::\n"
    "    This function should be considered experimental when the inputs are\n"
    "    unbalanced.  Check correctness with another independent implementation.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z, p : array_like\n"
    "    Real or complex input parameters. `x`, `y`, or `z` are numbers in\n"
    "    the complex plane cut along the negative real axis (subject to further\n"
    "    constraints, see Notes), and at most one of them can be zero. `p` must\n"
    "    be non-zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, `z`, and `p` are real, the\n"
    "    return value is real. Otherwise, the return value is complex.\n"
    "\n"
    "    If `p` is real and negative, while `x`, `y`, and `z` are real,\n"
    "    non-negative, and at most one of them is zero, the Cauchy principal\n"
    "    value is returned. [1]_ [2]_\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric integral.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order. [3]_ The algorithm is slightly\n"
    "different from its earlier incarnation as it appears in [1]_, in that the\n"
    "call to `elliprc` (or ``atan``/``atanh``, see [4]_) is no longer needed in\n"
    "the inner loop. Asymptotic approximations are used where arguments differ\n"
    "widely in the order of magnitude. [5]_\n"
    "\n"
    "The input values are subject to certain sufficient but not necessary\n"
    "constraints when input arguments are complex. Notably, ``x``, ``y``, and\n"
    "``z`` must have non-negative real parts, unless two of them are\n"
    "non-negative and complex-conjugates to each other while the other is a real\n"
    "non-negative number. [1]_ If the inputs do not satisfy the sufficient\n"
    "condition described in Ref. [1]_ they are rejected outright with the output\n"
    "set to NaN.\n"
    "\n"
    "In the case where one of ``x``, ``y``, and ``z`` is equal to ``p``, the\n"
    "function ``elliprd`` should be preferred because of its less restrictive\n"
    "domain.\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    ".. [2] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.20.iii\n"
    ".. [3] B. C. Carlson, J. FitzSimmons, \"Reduction Theorems for Elliptic\n"
    "       Integrands with the Square Root of Two Quadratic Factors,\" J.\n"
    "       Comput. Appl. Math., vol. 118, nos. 1-2, pp. 71-85, 2000.\n"
    "       https://doi.org/10.1016/S0377-0427(00)00282-X\n"
    ".. [4] F. Johansson, \"Numerical Evaluation of Elliptic Functions, Elliptic\n"
    "       Integrals and Modular Forms,\" in J. Blumlein, C. Schneider, P.\n"
    "       Paule, eds., \"Elliptic Integrals, Elliptic Functions and Modular\n"
    "       Forms in Quantum Field Theory,\" pp. 269-293, 2019 (Cham,\n"
    "       Switzerland: Springer Nature Switzerland)\n"
    "       https://arxiv.org/abs/1806.06725\n"
    "       https://doi.org/10.1007/978-3-030-04480-0\n"
    ".. [5] B. C. Carlson, J. L. Gustafson, \"Asymptotic Approximations for\n"
    "       Symmetric Elliptic Integrals,\" SIAM J. Math. Anls., vol. 25, no. 2,\n"
    "       pp. 288-303, 1994.\n"
    "       https://arxiv.org/abs/math/9310223\n"
    "       https://doi.org/10.1137/S0036141092228477\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprj\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> p = 7.\n"
    ">>> scale = 0.3 - 0.4j\n"
    ">>> elliprj(scale*x, scale*y, scale*z, scale*p)\n"
    "(0.10834905565679157+0.19694950747103812j)\n"
    "\n"
    ">>> elliprj(x, y, z, p)*np.power(scale, -1.5)\n"
    "(0.10834905565679556+0.19694950747103854j)\n"
    "\n"
    "Reduction to simpler elliptic integral:\n"
    "\n"
    ">>> elliprj(x, y, z, z)\n"
    "(0.08288462362195129-0.028376809745123258j)\n"
    "\n"
    ">>> from scipy.special import elliprd\n"
    ">>> elliprd(x, y, z)\n"
    "(0.08288462362195136-0.028376809745123296j)\n"
    "\n"
    "All arguments coincide:\n"
    "\n"
    ">>> elliprj(x, x, x, x)\n"
    "(-0.03986825876151896-0.14051741840449586j)\n"
    "\n"
    ">>> np.power(x, -1.5)\n"
    "(-0.03986825876151894-0.14051741840449583j)")
ufunc_elliprj_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_elliprj_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_elliprj_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDDD__As_FFFF_F
ufunc_elliprj_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDDD__As_DDDD_D
ufunc_elliprj_types[0] = <char>NPY_FLOAT
ufunc_elliprj_types[1] = <char>NPY_FLOAT
ufunc_elliprj_types[2] = <char>NPY_FLOAT
ufunc_elliprj_types[3] = <char>NPY_FLOAT
ufunc_elliprj_types[4] = <char>NPY_FLOAT
ufunc_elliprj_types[5] = <char>NPY_DOUBLE
ufunc_elliprj_types[6] = <char>NPY_DOUBLE
ufunc_elliprj_types[7] = <char>NPY_DOUBLE
ufunc_elliprj_types[8] = <char>NPY_DOUBLE
ufunc_elliprj_types[9] = <char>NPY_DOUBLE
ufunc_elliprj_types[10] = <char>NPY_CFLOAT
ufunc_elliprj_types[11] = <char>NPY_CFLOAT
ufunc_elliprj_types[12] = <char>NPY_CFLOAT
ufunc_elliprj_types[13] = <char>NPY_CFLOAT
ufunc_elliprj_types[14] = <char>NPY_CFLOAT
ufunc_elliprj_types[15] = <char>NPY_CDOUBLE
ufunc_elliprj_types[16] = <char>NPY_CDOUBLE
ufunc_elliprj_types[17] = <char>NPY_CDOUBLE
ufunc_elliprj_types[18] = <char>NPY_CDOUBLE
ufunc_elliprj_types[19] = <char>NPY_CDOUBLE
ufunc_elliprj_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RJ
ufunc_elliprj_ptr[2*0+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RJ
ufunc_elliprj_ptr[2*1+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RJ
ufunc_elliprj_ptr[2*2+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RJ
ufunc_elliprj_ptr[2*3+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_data[0] = &ufunc_elliprj_ptr[2*0]
ufunc_elliprj_data[1] = &ufunc_elliprj_ptr[2*1]
ufunc_elliprj_data[2] = &ufunc_elliprj_ptr[2*2]
ufunc_elliprj_data[3] = &ufunc_elliprj_ptr[2*3]
elliprj = np.PyUFunc_FromFuncAndData(ufunc_elliprj_loops, ufunc_elliprj_data, ufunc_elliprj_types, 4, 4, 1, 0, "elliprj", ufunc_elliprj_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_entr_loops[2]
cdef void *ufunc_entr_ptr[4]
cdef void *ufunc_entr_data[2]
cdef char ufunc_entr_types[4]
cdef char *ufunc_entr_doc = (
    "entr(x, out=None)\n"
    "\n"
    "Elementwise function for computing entropy.\n"
    "\n"
    ".. math:: \\text{entr}(x) = \\begin{cases} - x \\log(x) & x > 0  \\\\ 0 & x = 0\n"
    "          \\\\ -\\infty & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : scalar or ndarray\n"
    "    The value of the elementwise entropy function at the given points `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kl_div, rel_entr, scipy.stats.entropy\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "This function is concave.\n"
    "\n"
    "The origin of this function is in convex programming; see [1]_.\n"
    "Given a probability distribution :math:`p_1, \\ldots, p_n`,\n"
    "the definition of entropy in the context of *information theory* is\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\sum_{i = 1}^n \\mathrm{entr}(p_i).\n"
    "\n"
    "To compute the latter quantity, use `scipy.stats.entropy`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n"
    "       Cambridge University Press, 2004.\n"
    "       :doi:`https://doi.org/10.1017/CBO9780511804441`")
ufunc_entr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_entr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_entr_types[0] = <char>NPY_FLOAT
ufunc_entr_types[1] = <char>NPY_FLOAT
ufunc_entr_types[2] = <char>NPY_DOUBLE
ufunc_entr_types[3] = <char>NPY_DOUBLE
ufunc_entr_ptr[2*0] = <void*>_func_entr
ufunc_entr_ptr[2*0+1] = <void*>(<char*>"entr")
ufunc_entr_ptr[2*1] = <void*>_func_entr
ufunc_entr_ptr[2*1+1] = <void*>(<char*>"entr")
ufunc_entr_data[0] = &ufunc_entr_ptr[2*0]
ufunc_entr_data[1] = &ufunc_entr_ptr[2*1]
entr = np.PyUFunc_FromFuncAndData(ufunc_entr_loops, ufunc_entr_data, ufunc_entr_types, 2, 1, 1, 0, "entr", ufunc_entr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erf_loops[4]
cdef void *ufunc_erf_ptr[8]
cdef void *ufunc_erf_data[4]
cdef char ufunc_erf_types[8]
cdef char *ufunc_erf_doc = (
    "erf(z, out=None)\n"
    "\n"
    "Returns the error function of complex argument.\n"
    "\n"
    "It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : scalar or ndarray\n"
    "    The values of the error function at the given points `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erfc, erfinv, erfcinv, wofz, erfcx, erfi\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The cumulative of the unit normal distribution is given by\n"
    "``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Error_function\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover,\n"
    "    1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm\n"
    ".. [3] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erf(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erf(x)$')\n"
    ">>> plt.show()")
ufunc_erf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erf_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erf_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erf_types[0] = <char>NPY_FLOAT
ufunc_erf_types[1] = <char>NPY_FLOAT
ufunc_erf_types[2] = <char>NPY_DOUBLE
ufunc_erf_types[3] = <char>NPY_DOUBLE
ufunc_erf_types[4] = <char>NPY_CFLOAT
ufunc_erf_types[5] = <char>NPY_CFLOAT
ufunc_erf_types[6] = <char>NPY_CDOUBLE
ufunc_erf_types[7] = <char>NPY_CDOUBLE
ufunc_erf_ptr[2*0] = <void*>_func_cephes_erf
ufunc_erf_ptr[2*0+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*1] = <void*>_func_cephes_erf
ufunc_erf_ptr[2*1+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erf
ufunc_erf_ptr[2*2+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erf
ufunc_erf_ptr[2*3+1] = <void*>(<char*>"erf")
ufunc_erf_data[0] = &ufunc_erf_ptr[2*0]
ufunc_erf_data[1] = &ufunc_erf_ptr[2*1]
ufunc_erf_data[2] = &ufunc_erf_ptr[2*2]
ufunc_erf_data[3] = &ufunc_erf_ptr[2*3]
erf = np.PyUFunc_FromFuncAndData(ufunc_erf_loops, ufunc_erf_data, ufunc_erf_types, 4, 1, 1, 0, "erf", ufunc_erf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfc_loops[4]
cdef void *ufunc_erfc_ptr[8]
cdef void *ufunc_erfc_data[4]
cdef char ufunc_erfc_types[8]
cdef char *ufunc_erfc_doc = (
    "erfc(x, out=None)\n"
    "\n"
    "Complementary error function, ``1 - erf(x)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the complementary error function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfi, erfcx, dawsn, wofz\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfc(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfc(x)$')\n"
    ">>> plt.show()")
ufunc_erfc_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfc_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfc_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfc_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfc_types[0] = <char>NPY_FLOAT
ufunc_erfc_types[1] = <char>NPY_FLOAT
ufunc_erfc_types[2] = <char>NPY_DOUBLE
ufunc_erfc_types[3] = <char>NPY_DOUBLE
ufunc_erfc_types[4] = <char>NPY_CFLOAT
ufunc_erfc_types[5] = <char>NPY_CFLOAT
ufunc_erfc_types[6] = <char>NPY_CDOUBLE
ufunc_erfc_types[7] = <char>NPY_CDOUBLE
ufunc_erfc_ptr[2*0] = <void*>_func_cephes_erfc
ufunc_erfc_ptr[2*0+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*1] = <void*>_func_cephes_erfc
ufunc_erfc_ptr[2*1+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex
ufunc_erfc_ptr[2*2+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex
ufunc_erfc_ptr[2*3+1] = <void*>(<char*>"erfc")
ufunc_erfc_data[0] = &ufunc_erfc_ptr[2*0]
ufunc_erfc_data[1] = &ufunc_erfc_ptr[2*1]
ufunc_erfc_data[2] = &ufunc_erfc_ptr[2*2]
ufunc_erfc_data[3] = &ufunc_erfc_ptr[2*3]
erfc = np.PyUFunc_FromFuncAndData(ufunc_erfc_loops, ufunc_erfc_data, ufunc_erfc_types, 4, 1, 1, 0, "erfc", ufunc_erfc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfcinv_loops[2]
cdef void *ufunc_erfcinv_ptr[4]
cdef void *ufunc_erfcinv_data[2]
cdef char ufunc_erfcinv_types[4]
cdef char *ufunc_erfcinv_doc = (
    "erfcinv(y, out=None)\n"
    "\n"
    "Inverse of the complementary error function.\n"
    "\n"
    "Computes the inverse of the complementary error function.\n"
    "\n"
    "In the complex domain, there is no unique complex number w satisfying\n"
    "erfc(w)=z. This indicates a true inverse function would be multivalued.\n"
    "When the domain restricts to the real, 0 < x < 2, there is a unique real\n"
    "number satisfying erfc(erfcinv(x)) = erfcinv(erfc(x)).\n"
    "\n"
    "It is related to inverse of the error function by erfcinv(1-x) = erfinv(x)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : ndarray\n"
    "    Argument at which to evaluate. Domain: [0, 2]\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "erfcinv : scalar or ndarray\n"
    "    The inverse of erfc of y, element-wise\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf : Error function of a complex argument\n"
    "erfc : Complementary error function, ``1 - erf(x)``\n"
    "erfinv : Inverse of the error function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import erfcinv\n"
    "\n"
    ">>> erfcinv(0.5)\n"
    "0.4769362762044699\n"
    "\n"
    ">>> y = np.linspace(0.0, 2.0, num=11)\n"
    ">>> erfcinv(y)\n"
    "array([        inf,  0.9061938 ,  0.59511608,  0.37080716,  0.17914345,\n"
    "       -0.        , -0.17914345, -0.37080716, -0.59511608, -0.9061938 ,\n"
    "              -inf])\n"
    "\n"
    "Plot the function:\n"
    "\n"
    ">>> y = np.linspace(0, 2, 200)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(y, erfcinv(y))\n"
    ">>> ax.grid(True)\n"
    ">>> ax.set_xlabel('y')\n"
    ">>> ax.set_title('erfcinv(y)')\n"
    ">>> plt.show()")
ufunc_erfcinv_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfcinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfcinv_types[0] = <char>NPY_FLOAT
ufunc_erfcinv_types[1] = <char>NPY_FLOAT
ufunc_erfcinv_types[2] = <char>NPY_DOUBLE
ufunc_erfcinv_types[3] = <char>NPY_DOUBLE
ufunc_erfcinv_ptr[2*0] = <void*>_func_cephes_erfcinv
ufunc_erfcinv_ptr[2*0+1] = <void*>(<char*>"erfcinv")
ufunc_erfcinv_ptr[2*1] = <void*>_func_cephes_erfcinv
ufunc_erfcinv_ptr[2*1+1] = <void*>(<char*>"erfcinv")
ufunc_erfcinv_data[0] = &ufunc_erfcinv_ptr[2*0]
ufunc_erfcinv_data[1] = &ufunc_erfcinv_ptr[2*1]
erfcinv = np.PyUFunc_FromFuncAndData(ufunc_erfcinv_loops, ufunc_erfcinv_data, ufunc_erfcinv_types, 2, 1, 1, 0, "erfcinv", ufunc_erfcinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfcx_loops[4]
cdef void *ufunc_erfcx_ptr[8]
cdef void *ufunc_erfcx_data[4]
cdef char ufunc_erfcx_types[8]
cdef char *ufunc_erfcx_doc = (
    "erfcx(x, out=None)\n"
    "\n"
    "Scaled complementary error function, ``exp(x**2) * erfc(x)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the scaled complementary error function\n"
    "\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfc, erfi, dawsn, wofz\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.12.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfcx(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfcx(x)$')\n"
    ">>> plt.show()")
ufunc_erfcx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfcx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfcx_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfcx_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfcx_types[0] = <char>NPY_FLOAT
ufunc_erfcx_types[1] = <char>NPY_FLOAT
ufunc_erfcx_types[2] = <char>NPY_DOUBLE
ufunc_erfcx_types[3] = <char>NPY_DOUBLE
ufunc_erfcx_types[4] = <char>NPY_CFLOAT
ufunc_erfcx_types[5] = <char>NPY_CFLOAT
ufunc_erfcx_types[6] = <char>NPY_CDOUBLE
ufunc_erfcx_types[7] = <char>NPY_CDOUBLE
ufunc_erfcx_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx
ufunc_erfcx_ptr[2*0+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx
ufunc_erfcx_ptr[2*1+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex
ufunc_erfcx_ptr[2*2+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex
ufunc_erfcx_ptr[2*3+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_data[0] = &ufunc_erfcx_ptr[2*0]
ufunc_erfcx_data[1] = &ufunc_erfcx_ptr[2*1]
ufunc_erfcx_data[2] = &ufunc_erfcx_ptr[2*2]
ufunc_erfcx_data[3] = &ufunc_erfcx_ptr[2*3]
erfcx = np.PyUFunc_FromFuncAndData(ufunc_erfcx_loops, ufunc_erfcx_data, ufunc_erfcx_types, 4, 1, 1, 0, "erfcx", ufunc_erfcx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfi_loops[4]
cdef void *ufunc_erfi_ptr[8]
cdef void *ufunc_erfi_data[4]
cdef char ufunc_erfi_types[8]
cdef char *ufunc_erfi_doc = (
    "erfi(z, out=None)\n"
    "\n"
    "Imaginary error function, ``-i erf(i z)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the imaginary error function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfc, erfcx, dawsn, wofz\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.12.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfi(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfi(x)$')\n"
    ">>> plt.show()")
ufunc_erfi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfi_types[0] = <char>NPY_FLOAT
ufunc_erfi_types[1] = <char>NPY_FLOAT
ufunc_erfi_types[2] = <char>NPY_DOUBLE
ufunc_erfi_types[3] = <char>NPY_DOUBLE
ufunc_erfi_types[4] = <char>NPY_CFLOAT
ufunc_erfi_types[5] = <char>NPY_CFLOAT
ufunc_erfi_types[6] = <char>NPY_CDOUBLE
ufunc_erfi_types[7] = <char>NPY_CDOUBLE
ufunc_erfi_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi
ufunc_erfi_ptr[2*0+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi
ufunc_erfi_ptr[2*1+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex
ufunc_erfi_ptr[2*2+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex
ufunc_erfi_ptr[2*3+1] = <void*>(<char*>"erfi")
ufunc_erfi_data[0] = &ufunc_erfi_ptr[2*0]
ufunc_erfi_data[1] = &ufunc_erfi_ptr[2*1]
ufunc_erfi_data[2] = &ufunc_erfi_ptr[2*2]
ufunc_erfi_data[3] = &ufunc_erfi_ptr[2*3]
erfi = np.PyUFunc_FromFuncAndData(ufunc_erfi_loops, ufunc_erfi_data, ufunc_erfi_types, 4, 1, 1, 0, "erfi", ufunc_erfi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfinv_loops[2]
cdef void *ufunc_erfinv_ptr[4]
cdef void *ufunc_erfinv_data[2]
cdef char ufunc_erfinv_types[4]
cdef char *ufunc_erfinv_doc = (
    "erfinv(y, out=None)\n"
    "\n"
    "Inverse of the error function.\n"
    "\n"
    "Computes the inverse of the error function.\n"
    "\n"
    "In the complex domain, there is no unique complex number w satisfying\n"
    "erf(w)=z. This indicates a true inverse function would be multivalued.\n"
    "When the domain restricts to the real, -1 < x < 1, there is a unique real\n"
    "number satisfying erf(erfinv(x)) = x.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : ndarray\n"
    "    Argument at which to evaluate. Domain: [-1, 1]\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "erfinv : scalar or ndarray\n"
    "    The inverse of erf of y, element-wise\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf : Error function of a complex argument\n"
    "erfc : Complementary error function, ``1 - erf(x)``\n"
    "erfcinv : Inverse of the complementary error function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function wraps the ``erf_inv`` routine from the\n"
    "Boost Math C++ library [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import erfinv, erf\n"
    "\n"
    ">>> erfinv(0.5)\n"
    "0.4769362762044699\n"
    "\n"
    ">>> y = np.linspace(-1.0, 1.0, num=9)\n"
    ">>> x = erfinv(y)\n"
    ">>> x\n"
    "array([       -inf, -0.81341985, -0.47693628, -0.22531206,  0.        ,\n"
    "        0.22531206,  0.47693628,  0.81341985,         inf])\n"
    "\n"
    "Verify that ``erf(erfinv(y))`` is ``y``.\n"
    "\n"
    ">>> erf(x)\n"
    "array([-1.  , -0.75, -0.5 , -0.25,  0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n"
    "\n"
    "Plot the function:\n"
    "\n"
    ">>> y = np.linspace(-1, 1, 200)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(y, erfinv(y))\n"
    ">>> ax.grid(True)\n"
    ">>> ax.set_xlabel('y')\n"
    ">>> ax.set_title('erfinv(y)')\n"
    ">>> plt.show()")
ufunc_erfinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_f__As_f_f
ufunc_erfinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfinv_types[0] = <char>NPY_FLOAT
ufunc_erfinv_types[1] = <char>NPY_FLOAT
ufunc_erfinv_types[2] = <char>NPY_DOUBLE
ufunc_erfinv_types[3] = <char>NPY_DOUBLE
ufunc_erfinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_erfinv_float
ufunc_erfinv_ptr[2*0+1] = <void*>(<char*>"erfinv")
ufunc_erfinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_erfinv_double
ufunc_erfinv_ptr[2*1+1] = <void*>(<char*>"erfinv")
ufunc_erfinv_data[0] = &ufunc_erfinv_ptr[2*0]
ufunc_erfinv_data[1] = &ufunc_erfinv_ptr[2*1]
erfinv = np.PyUFunc_FromFuncAndData(ufunc_erfinv_loops, ufunc_erfinv_data, ufunc_erfinv_types, 2, 1, 1, 0, "erfinv", ufunc_erfinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyc_loops[5]
cdef void *ufunc_eval_chebyc_ptr[10]
cdef void *ufunc_eval_chebyc_data[5]
cdef char ufunc_eval_chebyc_types[15]
cdef char *ufunc_eval_chebyc_doc = (
    "eval_chebyc(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    C_n(x) = 2 T_n(x/2)\n"
    "\n"
    "where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n"
    "22.5.11 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyt`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "C : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyc : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the first kind on [-2, 2]\n"
    "chebyc : Chebyshev polynomial object\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "eval_chebyt : evaluate Chebycshev polynomials of the first kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "They are a scaled version of the Chebyshev polynomials of the\n"
    "first kind.\n"
    "\n"
    ">>> x = np.linspace(-2, 2, 6)\n"
    ">>> sc.eval_chebyc(3, x)\n"
    "array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])\n"
    ">>> 2 * sc.eval_chebyt(3, x / 2)\n"
    "array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])")
ufunc_eval_chebyc_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_chebyc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyc_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyc_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyc_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyc_types[0] = <char>NPY_INTP
ufunc_eval_chebyc_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyc_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyc_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyc_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyc_ptr[2*0] = <void*>_func_eval_chebyc_l
ufunc_eval_chebyc_ptr[2*0+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*1] = <void*>_func_eval_chebyc[double]
ufunc_eval_chebyc_ptr[2*1+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*2] = <void*>_func_eval_chebyc[double_complex]
ufunc_eval_chebyc_ptr[2*2+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*3] = <void*>_func_eval_chebyc[double]
ufunc_eval_chebyc_ptr[2*3+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*4] = <void*>_func_eval_chebyc[double_complex]
ufunc_eval_chebyc_ptr[2*4+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_data[0] = &ufunc_eval_chebyc_ptr[2*0]
ufunc_eval_chebyc_data[1] = &ufunc_eval_chebyc_ptr[2*1]
ufunc_eval_chebyc_data[2] = &ufunc_eval_chebyc_ptr[2*2]
ufunc_eval_chebyc_data[3] = &ufunc_eval_chebyc_ptr[2*3]
ufunc_eval_chebyc_data[4] = &ufunc_eval_chebyc_ptr[2*4]
eval_chebyc = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyc_loops, ufunc_eval_chebyc_data, ufunc_eval_chebyc_types, 5, 2, 1, 0, "eval_chebyc", ufunc_eval_chebyc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebys_loops[5]
cdef void *ufunc_eval_chebys_ptr[10]
cdef void *ufunc_eval_chebys_data[5]
cdef char ufunc_eval_chebys_types[15]
cdef char *ufunc_eval_chebys_doc = (
    "eval_chebys(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    S_n(x) = U_n(x/2)\n"
    "\n"
    "where :math:`U_n` is a Chebyshev polynomial of the second\n"
    "kind. See 22.5.13 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyu`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "S : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebys : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the second kind on [-2, 2]\n"
    "chebys : Chebyshev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "They are a scaled version of the Chebyshev polynomials of the\n"
    "second kind.\n"
    "\n"
    ">>> x = np.linspace(-2, 2, 6)\n"
    ">>> sc.eval_chebys(3, x)\n"
    "array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])\n"
    ">>> sc.eval_chebyu(3, x / 2)\n"
    "array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])")
ufunc_eval_chebys_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_chebys_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebys_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebys_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebys_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebys_types[0] = <char>NPY_INTP
ufunc_eval_chebys_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[3] = <char>NPY_FLOAT
ufunc_eval_chebys_types[4] = <char>NPY_FLOAT
ufunc_eval_chebys_types[5] = <char>NPY_FLOAT
ufunc_eval_chebys_types[6] = <char>NPY_FLOAT
ufunc_eval_chebys_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebys_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebys_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebys_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebys_ptr[2*0] = <void*>_func_eval_chebys_l
ufunc_eval_chebys_ptr[2*0+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*1] = <void*>_func_eval_chebys[double]
ufunc_eval_chebys_ptr[2*1+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*2] = <void*>_func_eval_chebys[double_complex]
ufunc_eval_chebys_ptr[2*2+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*3] = <void*>_func_eval_chebys[double]
ufunc_eval_chebys_ptr[2*3+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*4] = <void*>_func_eval_chebys[double_complex]
ufunc_eval_chebys_ptr[2*4+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_data[0] = &ufunc_eval_chebys_ptr[2*0]
ufunc_eval_chebys_data[1] = &ufunc_eval_chebys_ptr[2*1]
ufunc_eval_chebys_data[2] = &ufunc_eval_chebys_ptr[2*2]
ufunc_eval_chebys_data[3] = &ufunc_eval_chebys_ptr[2*3]
ufunc_eval_chebys_data[4] = &ufunc_eval_chebys_ptr[2*4]
eval_chebys = np.PyUFunc_FromFuncAndData(ufunc_eval_chebys_loops, ufunc_eval_chebys_data, ufunc_eval_chebys_types, 5, 2, 1, 0, "eval_chebys", ufunc_eval_chebys_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyt_loops[5]
cdef void *ufunc_eval_chebyt_ptr[10]
cdef void *ufunc_eval_chebyt_data[5]
cdef char ufunc_eval_chebyt_types[15]
cdef char *ufunc_eval_chebyt_doc = (
    "eval_chebyt(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the first kind at a point.\n"
    "\n"
    "The Chebyshev polynomials of the first kind can be defined via the\n"
    "Gauss hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.47 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "T : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyt : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the first kind\n"
    "chebyu : Chebychev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This routine is numerically stable for `x` in ``[-1, 1]`` at least\n"
    "up to order ``10000``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_chebyt_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_chebyt_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyt_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyt_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyt_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyt_types[0] = <char>NPY_INTP
ufunc_eval_chebyt_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyt_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyt_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyt_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyt_ptr[2*0] = <void*>_func_eval_chebyt_l
ufunc_eval_chebyt_ptr[2*0+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*1] = <void*>_func_eval_chebyt[double]
ufunc_eval_chebyt_ptr[2*1+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*2] = <void*>_func_eval_chebyt[double_complex]
ufunc_eval_chebyt_ptr[2*2+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*3] = <void*>_func_eval_chebyt[double]
ufunc_eval_chebyt_ptr[2*3+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*4] = <void*>_func_eval_chebyt[double_complex]
ufunc_eval_chebyt_ptr[2*4+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_data[0] = &ufunc_eval_chebyt_ptr[2*0]
ufunc_eval_chebyt_data[1] = &ufunc_eval_chebyt_ptr[2*1]
ufunc_eval_chebyt_data[2] = &ufunc_eval_chebyt_ptr[2*2]
ufunc_eval_chebyt_data[3] = &ufunc_eval_chebyt_ptr[2*3]
ufunc_eval_chebyt_data[4] = &ufunc_eval_chebyt_ptr[2*4]
eval_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyt_loops, ufunc_eval_chebyt_data, ufunc_eval_chebyt_types, 5, 2, 1, 0, "eval_chebyt", ufunc_eval_chebyt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyu_loops[5]
cdef void *ufunc_eval_chebyu_ptr[10]
cdef void *ufunc_eval_chebyu_data[5]
cdef char ufunc_eval_chebyu_types[15]
cdef char *ufunc_eval_chebyu_doc = (
    "eval_chebyu(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the second kind at a point.\n"
    "\n"
    "The Chebyshev polynomials of the second kind can be defined via\n"
    "the Gauss hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.48 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "U : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyu : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the second kind\n"
    "chebyu : Chebyshev polynomial object\n"
    "eval_chebyt : evaluate Chebyshev polynomials of the first kind\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_chebyu_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_chebyu_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyu_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyu_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyu_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyu_types[0] = <char>NPY_INTP
ufunc_eval_chebyu_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyu_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyu_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyu_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyu_ptr[2*0] = <void*>_func_eval_chebyu_l
ufunc_eval_chebyu_ptr[2*0+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*1] = <void*>_func_eval_chebyu[double]
ufunc_eval_chebyu_ptr[2*1+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*2] = <void*>_func_eval_chebyu[double_complex]
ufunc_eval_chebyu_ptr[2*2+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*3] = <void*>_func_eval_chebyu[double]
ufunc_eval_chebyu_ptr[2*3+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*4] = <void*>_func_eval_chebyu[double_complex]
ufunc_eval_chebyu_ptr[2*4+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_data[0] = &ufunc_eval_chebyu_ptr[2*0]
ufunc_eval_chebyu_data[1] = &ufunc_eval_chebyu_ptr[2*1]
ufunc_eval_chebyu_data[2] = &ufunc_eval_chebyu_ptr[2*2]
ufunc_eval_chebyu_data[3] = &ufunc_eval_chebyu_ptr[2*3]
ufunc_eval_chebyu_data[4] = &ufunc_eval_chebyu_ptr[2*4]
eval_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyu_loops, ufunc_eval_chebyu_data, ufunc_eval_chebyu_types, 5, 2, 1, 0, "eval_chebyu", ufunc_eval_chebyu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_gegenbauer_loops[5]
cdef void *ufunc_eval_gegenbauer_ptr[10]
cdef void *ufunc_eval_gegenbauer_data[5]
cdef char ufunc_eval_gegenbauer_types[20]
cdef char *ufunc_eval_gegenbauer_doc = (
    "eval_gegenbauer(n, alpha, x, out=None)\n"
    "\n"
    "Evaluate Gegenbauer polynomial at a point.\n"
    "\n"
    "The Gegenbauer polynomials can be defined via the Gauss\n"
    "hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    C_n^{(\\alpha)} = \\frac{(2\\alpha)_n}{\\Gamma(n + 1)}\n"
    "      {}_2F_1(-n, 2\\alpha + n; \\alpha + 1/2; (1 - z)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.46 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter\n"
    "x : array_like\n"
    "    Points at which to evaluate the Gegenbauer polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "C : scalar or ndarray\n"
    "    Values of the Gegenbauer polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_gegenbauer : roots and quadrature weights of Gegenbauer\n"
    "                   polynomials\n"
    "gegenbauer : Gegenbauer polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_gegenbauer_loops[0] = <np.PyUFuncGenericFunction>loop_d_pdd__As_pdd_d
ufunc_eval_gegenbauer_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_eval_gegenbauer_loops[2] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_eval_gegenbauer_loops[3] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_eval_gegenbauer_loops[4] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_eval_gegenbauer_types[0] = <char>NPY_INTP
ufunc_eval_gegenbauer_types[1] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[2] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[3] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[4] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[5] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[6] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[7] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[8] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[9] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[10] = <char>NPY_CFLOAT
ufunc_eval_gegenbauer_types[11] = <char>NPY_CFLOAT
ufunc_eval_gegenbauer_types[12] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[13] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[14] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[15] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[16] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[17] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[18] = <char>NPY_CDOUBLE
ufunc_eval_gegenbauer_types[19] = <char>NPY_CDOUBLE
ufunc_eval_gegenbauer_ptr[2*0] = <void*>_func_eval_gegenbauer_l
ufunc_eval_gegenbauer_ptr[2*0+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*1] = <void*>_func_eval_gegenbauer[double]
ufunc_eval_gegenbauer_ptr[2*1+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*2] = <void*>_func_eval_gegenbauer[double_complex]
ufunc_eval_gegenbauer_ptr[2*2+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*3] = <void*>_func_eval_gegenbauer[double]
ufunc_eval_gegenbauer_ptr[2*3+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*4] = <void*>_func_eval_gegenbauer[double_complex]
ufunc_eval_gegenbauer_ptr[2*4+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_data[0] = &ufunc_eval_gegenbauer_ptr[2*0]
ufunc_eval_gegenbauer_data[1] = &ufunc_eval_gegenbauer_ptr[2*1]
ufunc_eval_gegenbauer_data[2] = &ufunc_eval_gegenbauer_ptr[2*2]
ufunc_eval_gegenbauer_data[3] = &ufunc_eval_gegenbauer_ptr[2*3]
ufunc_eval_gegenbauer_data[4] = &ufunc_eval_gegenbauer_ptr[2*4]
eval_gegenbauer = np.PyUFunc_FromFuncAndData(ufunc_eval_gegenbauer_loops, ufunc_eval_gegenbauer_data, ufunc_eval_gegenbauer_types, 5, 3, 1, 0, "eval_gegenbauer", ufunc_eval_gegenbauer_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_genlaguerre_loops[5]
cdef void *ufunc_eval_genlaguerre_ptr[10]
cdef void *ufunc_eval_genlaguerre_data[5]
cdef char ufunc_eval_genlaguerre_types[20]
cdef char *ufunc_eval_genlaguerre_doc = (
    "eval_genlaguerre(n, alpha, x, out=None)\n"
    "\n"
    "Evaluate generalized Laguerre polynomial at a point.\n"
    "\n"
    "The generalized Laguerre polynomials can be defined via the\n"
    "confluent hypergeometric function :math:`{}_1F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    L_n^{(\\alpha)}(x) = \\binom{n + \\alpha}{n}\n"
    "      {}_1F_1(-n, \\alpha + 1, x).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.54 in [AS]_ for details. The Laguerre\n"
    "polynomials are the special case where :math:`\\alpha = 0`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the confluent hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter; must have ``alpha > -1``\n"
    "x : array_like\n"
    "    Points at which to evaluate the generalized Laguerre\n"
    "    polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : scalar or ndarray\n"
    "    Values of the generalized Laguerre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_genlaguerre : roots and quadrature weights of generalized\n"
    "                    Laguerre polynomials\n"
    "genlaguerre : generalized Laguerre polynomial object\n"
    "hyp1f1 : confluent hypergeometric function\n"
    "eval_laguerre : evaluate Laguerre polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_genlaguerre_loops[0] = <np.PyUFuncGenericFunction>loop_d_pdd__As_pdd_d
ufunc_eval_genlaguerre_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_eval_genlaguerre_loops[2] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_eval_genlaguerre_loops[3] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_eval_genlaguerre_loops[4] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_eval_genlaguerre_types[0] = <char>NPY_INTP
ufunc_eval_genlaguerre_types[1] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[2] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[3] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[4] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[5] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[6] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[7] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[8] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[9] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[10] = <char>NPY_CFLOAT
ufunc_eval_genlaguerre_types[11] = <char>NPY_CFLOAT
ufunc_eval_genlaguerre_types[12] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[13] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[14] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[15] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[16] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[17] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[18] = <char>NPY_CDOUBLE
ufunc_eval_genlaguerre_types[19] = <char>NPY_CDOUBLE
ufunc_eval_genlaguerre_ptr[2*0] = <void*>_func_eval_genlaguerre_l
ufunc_eval_genlaguerre_ptr[2*0+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*1] = <void*>_func_eval_genlaguerre[double]
ufunc_eval_genlaguerre_ptr[2*1+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*2] = <void*>_func_eval_genlaguerre[double_complex]
ufunc_eval_genlaguerre_ptr[2*2+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*3] = <void*>_func_eval_genlaguerre[double]
ufunc_eval_genlaguerre_ptr[2*3+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*4] = <void*>_func_eval_genlaguerre[double_complex]
ufunc_eval_genlaguerre_ptr[2*4+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_data[0] = &ufunc_eval_genlaguerre_ptr[2*0]
ufunc_eval_genlaguerre_data[1] = &ufunc_eval_genlaguerre_ptr[2*1]
ufunc_eval_genlaguerre_data[2] = &ufunc_eval_genlaguerre_ptr[2*2]
ufunc_eval_genlaguerre_data[3] = &ufunc_eval_genlaguerre_ptr[2*3]
ufunc_eval_genlaguerre_data[4] = &ufunc_eval_genlaguerre_ptr[2*4]
eval_genlaguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_genlaguerre_loops, ufunc_eval_genlaguerre_data, ufunc_eval_genlaguerre_types, 5, 3, 1, 0, "eval_genlaguerre", ufunc_eval_genlaguerre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_hermite_loops[1]
cdef void *ufunc_eval_hermite_ptr[2]
cdef void *ufunc_eval_hermite_data[1]
cdef char ufunc_eval_hermite_types[3]
cdef char *ufunc_eval_hermite_doc = (
    "eval_hermite(n, x, out=None)\n"
    "\n"
    "Evaluate physicist's Hermite polynomial at a point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2};\n"
    "\n"
    ":math:`H_n` is a polynomial of degree :math:`n`. See 22.11.7 in\n"
    "[AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial\n"
    "x : array_like\n"
    "    Points at which to evaluate the Hermite polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "H : scalar or ndarray\n"
    "    Values of the Hermite polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_hermite : roots and quadrature weights of physicist's\n"
    "                Hermite polynomials\n"
    "hermite : physicist's Hermite polynomial object\n"
    "numpy.polynomial.hermite.Hermite : Physicist's Hermite series\n"
    "eval_hermitenorm : evaluate Probabilist's Hermite polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_hermite_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_hermite_types[0] = <char>NPY_INTP
ufunc_eval_hermite_types[1] = <char>NPY_DOUBLE
ufunc_eval_hermite_types[2] = <char>NPY_DOUBLE
ufunc_eval_hermite_ptr[2*0] = <void*>_func_eval_hermite
ufunc_eval_hermite_ptr[2*0+1] = <void*>(<char*>"eval_hermite")
ufunc_eval_hermite_data[0] = &ufunc_eval_hermite_ptr[2*0]
eval_hermite = np.PyUFunc_FromFuncAndData(ufunc_eval_hermite_loops, ufunc_eval_hermite_data, ufunc_eval_hermite_types, 1, 2, 1, 0, "eval_hermite", ufunc_eval_hermite_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_hermitenorm_loops[1]
cdef void *ufunc_eval_hermitenorm_ptr[2]
cdef void *ufunc_eval_hermitenorm_data[1]
cdef char ufunc_eval_hermitenorm_types[3]
cdef char *ufunc_eval_hermitenorm_doc = (
    "eval_hermitenorm(n, x, out=None)\n"
    "\n"
    "Evaluate probabilist's (normalized) Hermite polynomial at a\n"
    "point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    He_n(x) = (-1)^n e^{x^2/2} \\frac{d^n}{dx^n} e^{-x^2/2};\n"
    "\n"
    ":math:`He_n` is a polynomial of degree :math:`n`. See 22.11.8 in\n"
    "[AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial\n"
    "x : array_like\n"
    "    Points at which to evaluate the Hermite polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "He : scalar or ndarray\n"
    "    Values of the Hermite polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_hermitenorm : roots and quadrature weights of probabilist's\n"
    "                    Hermite polynomials\n"
    "hermitenorm : probabilist's Hermite polynomial object\n"
    "numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series\n"
    "eval_hermite : evaluate physicist's Hermite polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_hermitenorm_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_hermitenorm_types[0] = <char>NPY_INTP
ufunc_eval_hermitenorm_types[1] = <char>NPY_DOUBLE
ufunc_eval_hermitenorm_types[2] = <char>NPY_DOUBLE
ufunc_eval_hermitenorm_ptr[2*0] = <void*>_func_eval_hermitenorm
ufunc_eval_hermitenorm_ptr[2*0+1] = <void*>(<char*>"eval_hermitenorm")
ufunc_eval_hermitenorm_data[0] = &ufunc_eval_hermitenorm_ptr[2*0]
eval_hermitenorm = np.PyUFunc_FromFuncAndData(ufunc_eval_hermitenorm_loops, ufunc_eval_hermitenorm_data, ufunc_eval_hermitenorm_types, 1, 2, 1, 0, "eval_hermitenorm", ufunc_eval_hermitenorm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_jacobi_loops[5]
cdef void *ufunc_eval_jacobi_ptr[10]
cdef void *ufunc_eval_jacobi_data[5]
cdef char ufunc_eval_jacobi_types[25]
cdef char *ufunc_eval_jacobi_doc = (
    "eval_jacobi(n, alpha, beta, x, out=None)\n"
    "\n"
    "Evaluate Jacobi polynomial at a point.\n"
    "\n"
    "The Jacobi polynomials can be defined via the Gauss hypergeometric\n"
    "function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n^{(\\alpha, \\beta)}(x) = \\frac{(\\alpha + 1)_n}{\\Gamma(n + 1)}\n"
    "      {}_2F_1(-n, 1 + \\alpha + \\beta + n; \\alpha + 1; (1 - z)/2)\n"
    "\n"
    "where :math:`(\\cdot)_n` is the Pochhammer symbol; see `poch`. When\n"
    ":math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.42 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter\n"
    "beta : array_like\n"
    "    Parameter\n"
    "x : array_like\n"
    "    Points at which to evaluate the polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : scalar or ndarray\n"
    "    Values of the Jacobi polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_jacobi : roots and quadrature weights of Jacobi polynomials\n"
    "jacobi : Jacobi polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_jacobi_loops[0] = <np.PyUFuncGenericFunction>loop_d_pddd__As_pddd_d
ufunc_eval_jacobi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_eval_jacobi_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_eval_jacobi_loops[3] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_eval_jacobi_loops[4] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_eval_jacobi_types[0] = <char>NPY_INTP
ufunc_eval_jacobi_types[1] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[2] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[3] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[4] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[5] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[6] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[7] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[8] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[9] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[10] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[11] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[12] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[13] = <char>NPY_CFLOAT
ufunc_eval_jacobi_types[14] = <char>NPY_CFLOAT
ufunc_eval_jacobi_types[15] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[16] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[17] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[18] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[19] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[20] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[21] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[22] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[23] = <char>NPY_CDOUBLE
ufunc_eval_jacobi_types[24] = <char>NPY_CDOUBLE
ufunc_eval_jacobi_ptr[2*0] = <void*>_func_eval_jacobi_l
ufunc_eval_jacobi_ptr[2*0+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*1] = <void*>_func_eval_jacobi[double]
ufunc_eval_jacobi_ptr[2*1+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*2] = <void*>_func_eval_jacobi[double_complex]
ufunc_eval_jacobi_ptr[2*2+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*3] = <void*>_func_eval_jacobi[double]
ufunc_eval_jacobi_ptr[2*3+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*4] = <void*>_func_eval_jacobi[double_complex]
ufunc_eval_jacobi_ptr[2*4+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_data[0] = &ufunc_eval_jacobi_ptr[2*0]
ufunc_eval_jacobi_data[1] = &ufunc_eval_jacobi_ptr[2*1]
ufunc_eval_jacobi_data[2] = &ufunc_eval_jacobi_ptr[2*2]
ufunc_eval_jacobi_data[3] = &ufunc_eval_jacobi_ptr[2*3]
ufunc_eval_jacobi_data[4] = &ufunc_eval_jacobi_ptr[2*4]
eval_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_jacobi_loops, ufunc_eval_jacobi_data, ufunc_eval_jacobi_types, 5, 4, 1, 0, "eval_jacobi", ufunc_eval_jacobi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_laguerre_loops[5]
cdef void *ufunc_eval_laguerre_ptr[10]
cdef void *ufunc_eval_laguerre_data[5]
cdef char ufunc_eval_laguerre_types[15]
cdef char *ufunc_eval_laguerre_doc = (
    "eval_laguerre(n, x, out=None)\n"
    "\n"
    "Evaluate Laguerre polynomial at a point.\n"
    "\n"
    "The Laguerre polynomials can be defined via the confluent\n"
    "hypergeometric function :math:`{}_1F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    L_n(x) = {}_1F_1(-n, 1, x).\n"
    "\n"
    "See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:`n` is an\n"
    "integer the result is a polynomial of degree :math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer the result is\n"
    "    determined via the relation to the confluent hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Laguerre polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : scalar or ndarray\n"
    "    Values of the Laguerre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_laguerre : roots and quadrature weights of Laguerre\n"
    "                 polynomials\n"
    "laguerre : Laguerre polynomial object\n"
    "numpy.polynomial.laguerre.Laguerre : Laguerre series\n"
    "eval_genlaguerre : evaluate generalized Laguerre polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_laguerre_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_laguerre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_laguerre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_laguerre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_laguerre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_laguerre_types[0] = <char>NPY_INTP
ufunc_eval_laguerre_types[1] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[2] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[3] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[4] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[5] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[6] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[7] = <char>NPY_CFLOAT
ufunc_eval_laguerre_types[8] = <char>NPY_CFLOAT
ufunc_eval_laguerre_types[9] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[10] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[11] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[12] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_laguerre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_laguerre_ptr[2*0] = <void*>_func_eval_laguerre_l
ufunc_eval_laguerre_ptr[2*0+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*1] = <void*>_func_eval_laguerre[double]
ufunc_eval_laguerre_ptr[2*1+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*2] = <void*>_func_eval_laguerre[double_complex]
ufunc_eval_laguerre_ptr[2*2+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*3] = <void*>_func_eval_laguerre[double]
ufunc_eval_laguerre_ptr[2*3+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*4] = <void*>_func_eval_laguerre[double_complex]
ufunc_eval_laguerre_ptr[2*4+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_data[0] = &ufunc_eval_laguerre_ptr[2*0]
ufunc_eval_laguerre_data[1] = &ufunc_eval_laguerre_ptr[2*1]
ufunc_eval_laguerre_data[2] = &ufunc_eval_laguerre_ptr[2*2]
ufunc_eval_laguerre_data[3] = &ufunc_eval_laguerre_ptr[2*3]
ufunc_eval_laguerre_data[4] = &ufunc_eval_laguerre_ptr[2*4]
eval_laguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_laguerre_loops, ufunc_eval_laguerre_data, ufunc_eval_laguerre_types, 5, 2, 1, 0, "eval_laguerre", ufunc_eval_laguerre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_legendre_loops[5]
cdef void *ufunc_eval_legendre_ptr[10]
cdef void *ufunc_eval_legendre_data[5]
cdef char ufunc_eval_legendre_types[15]
cdef char *ufunc_eval_legendre_doc = (
    "eval_legendre(n, x, out=None)\n"
    "\n"
    "Evaluate Legendre polynomial at a point.\n"
    "\n"
    "The Legendre polynomials can be defined via the Gauss\n"
    "hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.49 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Legendre polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : scalar or ndarray\n"
    "    Values of the Legendre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_legendre : roots and quadrature weights of Legendre\n"
    "                 polynomials\n"
    "legendre : Legendre polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "numpy.polynomial.legendre.Legendre : Legendre series\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import eval_legendre\n"
    "\n"
    "Evaluate the zero-order Legendre polynomial at x = 0\n"
    "\n"
    ">>> eval_legendre(0, 0)\n"
    "1.0\n"
    "\n"
    "Evaluate the first-order Legendre polynomial between -1 and 1\n"
    "\n"
    ">>> X = np.linspace(-1, 1, 5)  # Domain of Legendre polynomials\n"
    ">>> eval_legendre(1, X)\n"
    "array([-1. , -0.5,  0. ,  0.5,  1. ])\n"
    "\n"
    "Evaluate Legendre polynomials of order 0 through 4 at x = 0\n"
    "\n"
    ">>> N = range(0, 5)\n"
    ">>> eval_legendre(N, 0)\n"
    "array([ 1.   ,  0.   , -0.5  ,  0.   ,  0.375])\n"
    "\n"
    "Plot Legendre polynomials of order 0 through 4\n"
    "\n"
    ">>> X = np.linspace(-1, 1)\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> for n in range(0, 5):\n"
    "...     y = eval_legendre(n, X)\n"
    "...     plt.plot(X, y, label=r'$P_{}(x)$'.format(n))\n"
    "\n"
    ">>> plt.title(\"Legendre Polynomials\")\n"
    ">>> plt.xlabel(\"x\")\n"
    ">>> plt.ylabel(r'$P_n(x)$')\n"
    ">>> plt.legend(loc='lower right')\n"
    ">>> plt.show()")
ufunc_eval_legendre_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_legendre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_legendre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_legendre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_legendre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_legendre_types[0] = <char>NPY_INTP
ufunc_eval_legendre_types[1] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[2] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[3] = <char>NPY_FLOAT
ufunc_eval_legendre_types[4] = <char>NPY_FLOAT
ufunc_eval_legendre_types[5] = <char>NPY_FLOAT
ufunc_eval_legendre_types[6] = <char>NPY_FLOAT
ufunc_eval_legendre_types[7] = <char>NPY_CFLOAT
ufunc_eval_legendre_types[8] = <char>NPY_CFLOAT
ufunc_eval_legendre_types[9] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[10] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[11] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[12] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_legendre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_legendre_ptr[2*0] = <void*>_func_eval_legendre_l
ufunc_eval_legendre_ptr[2*0+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*1] = <void*>_func_eval_legendre[double]
ufunc_eval_legendre_ptr[2*1+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*2] = <void*>_func_eval_legendre[double_complex]
ufunc_eval_legendre_ptr[2*2+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*3] = <void*>_func_eval_legendre[double]
ufunc_eval_legendre_ptr[2*3+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*4] = <void*>_func_eval_legendre[double_complex]
ufunc_eval_legendre_ptr[2*4+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_data[0] = &ufunc_eval_legendre_ptr[2*0]
ufunc_eval_legendre_data[1] = &ufunc_eval_legendre_ptr[2*1]
ufunc_eval_legendre_data[2] = &ufunc_eval_legendre_ptr[2*2]
ufunc_eval_legendre_data[3] = &ufunc_eval_legendre_ptr[2*3]
ufunc_eval_legendre_data[4] = &ufunc_eval_legendre_ptr[2*4]
eval_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_legendre_loops, ufunc_eval_legendre_data, ufunc_eval_legendre_types, 5, 2, 1, 0, "eval_legendre", ufunc_eval_legendre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyt_loops[5]
cdef void *ufunc_eval_sh_chebyt_ptr[10]
cdef void *ufunc_eval_sh_chebyt_data[5]
cdef char ufunc_eval_sh_chebyt_types[15]
cdef char *ufunc_eval_sh_chebyt_doc = (
    "eval_sh_chebyt(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Chebyshev polynomial of the first kind at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    T_n^*(x) = T_n(2x - 1)\n"
    "\n"
    "where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n"
    "22.5.14 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyt`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "T : scalar or ndarray\n"
    "    Values of the shifted Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_chebyt : roots and quadrature weights of shifted\n"
    "                  Chebyshev polynomials of the first kind\n"
    "sh_chebyt : shifted Chebyshev polynomial object\n"
    "eval_chebyt : evaluate Chebyshev polynomials of the first kind\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_chebyt_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_sh_chebyt_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_chebyt_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_chebyt_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_chebyt_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_chebyt_types[0] = <char>NPY_INTP
ufunc_eval_sh_chebyt_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyt_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyt_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyt_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyt_ptr[2*0] = <void*>_func_eval_sh_chebyt_l
ufunc_eval_sh_chebyt_ptr[2*0+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*1] = <void*>_func_eval_sh_chebyt[double]
ufunc_eval_sh_chebyt_ptr[2*1+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*2] = <void*>_func_eval_sh_chebyt[double_complex]
ufunc_eval_sh_chebyt_ptr[2*2+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*3] = <void*>_func_eval_sh_chebyt[double]
ufunc_eval_sh_chebyt_ptr[2*3+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*4] = <void*>_func_eval_sh_chebyt[double_complex]
ufunc_eval_sh_chebyt_ptr[2*4+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_data[0] = &ufunc_eval_sh_chebyt_ptr[2*0]
ufunc_eval_sh_chebyt_data[1] = &ufunc_eval_sh_chebyt_ptr[2*1]
ufunc_eval_sh_chebyt_data[2] = &ufunc_eval_sh_chebyt_ptr[2*2]
ufunc_eval_sh_chebyt_data[3] = &ufunc_eval_sh_chebyt_ptr[2*3]
ufunc_eval_sh_chebyt_data[4] = &ufunc_eval_sh_chebyt_ptr[2*4]
eval_sh_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyt_loops, ufunc_eval_sh_chebyt_data, ufunc_eval_sh_chebyt_types, 5, 2, 1, 0, "eval_sh_chebyt", ufunc_eval_sh_chebyt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyu_loops[5]
cdef void *ufunc_eval_sh_chebyu_ptr[10]
cdef void *ufunc_eval_sh_chebyu_data[5]
cdef char ufunc_eval_sh_chebyu_types[15]
cdef char *ufunc_eval_sh_chebyu_doc = (
    "eval_sh_chebyu(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Chebyshev polynomial of the second kind at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    U_n^*(x) = U_n(2x - 1)\n"
    "\n"
    "where :math:`U_n` is a Chebyshev polynomial of the first kind. See\n"
    "22.5.15 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyu`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "U : scalar or ndarray\n"
    "    Values of the shifted Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_chebyu : roots and quadrature weights of shifted\n"
    "                  Chebychev polynomials of the second kind\n"
    "sh_chebyu : shifted Chebyshev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_chebyu_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_sh_chebyu_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_chebyu_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_chebyu_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_chebyu_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_chebyu_types[0] = <char>NPY_INTP
ufunc_eval_sh_chebyu_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyu_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyu_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyu_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyu_ptr[2*0] = <void*>_func_eval_sh_chebyu_l
ufunc_eval_sh_chebyu_ptr[2*0+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*1] = <void*>_func_eval_sh_chebyu[double]
ufunc_eval_sh_chebyu_ptr[2*1+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*2] = <void*>_func_eval_sh_chebyu[double_complex]
ufunc_eval_sh_chebyu_ptr[2*2+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*3] = <void*>_func_eval_sh_chebyu[double]
ufunc_eval_sh_chebyu_ptr[2*3+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*4] = <void*>_func_eval_sh_chebyu[double_complex]
ufunc_eval_sh_chebyu_ptr[2*4+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_data[0] = &ufunc_eval_sh_chebyu_ptr[2*0]
ufunc_eval_sh_chebyu_data[1] = &ufunc_eval_sh_chebyu_ptr[2*1]
ufunc_eval_sh_chebyu_data[2] = &ufunc_eval_sh_chebyu_ptr[2*2]
ufunc_eval_sh_chebyu_data[3] = &ufunc_eval_sh_chebyu_ptr[2*3]
ufunc_eval_sh_chebyu_data[4] = &ufunc_eval_sh_chebyu_ptr[2*4]
eval_sh_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyu_loops, ufunc_eval_sh_chebyu_data, ufunc_eval_sh_chebyu_types, 5, 2, 1, 0, "eval_sh_chebyu", ufunc_eval_sh_chebyu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_jacobi_loops[5]
cdef void *ufunc_eval_sh_jacobi_ptr[10]
cdef void *ufunc_eval_sh_jacobi_data[5]
cdef char ufunc_eval_sh_jacobi_types[25]
cdef char *ufunc_eval_sh_jacobi_doc = (
    "eval_sh_jacobi(n, p, q, x, out=None)\n"
    "\n"
    "Evaluate shifted Jacobi polynomial at a point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    G_n^{(p, q)}(x)\n"
    "      = \\binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),\n"
    "\n"
    "where :math:`P_n^{(\\cdot, \\cdot)}` is the n-th Jacobi\n"
    "polynomial. See 22.5.2 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : int\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `binom` and `eval_jacobi`.\n"
    "p : float\n"
    "    Parameter\n"
    "q : float\n"
    "    Parameter\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "G : scalar or ndarray\n"
    "    Values of the shifted Jacobi polynomial.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_jacobi : roots and quadrature weights of shifted Jacobi\n"
    "                  polynomials\n"
    "sh_jacobi : shifted Jacobi polynomial object\n"
    "eval_jacobi : evaluate Jacobi polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_jacobi_loops[0] = <np.PyUFuncGenericFunction>loop_d_pddd__As_pddd_d
ufunc_eval_sh_jacobi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_eval_sh_jacobi_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_eval_sh_jacobi_loops[3] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_eval_sh_jacobi_loops[4] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_eval_sh_jacobi_types[0] = <char>NPY_INTP
ufunc_eval_sh_jacobi_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[3] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[4] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[7] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[8] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[9] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[10] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[11] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[12] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[13] = <char>NPY_CFLOAT
ufunc_eval_sh_jacobi_types[14] = <char>NPY_CFLOAT
ufunc_eval_sh_jacobi_types[15] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[16] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[17] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[18] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[19] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[20] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[21] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[22] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[23] = <char>NPY_CDOUBLE
ufunc_eval_sh_jacobi_types[24] = <char>NPY_CDOUBLE
ufunc_eval_sh_jacobi_ptr[2*0] = <void*>_func_eval_sh_jacobi_l
ufunc_eval_sh_jacobi_ptr[2*0+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*1] = <void*>_func_eval_sh_jacobi[double]
ufunc_eval_sh_jacobi_ptr[2*1+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*2] = <void*>_func_eval_sh_jacobi[double_complex]
ufunc_eval_sh_jacobi_ptr[2*2+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*3] = <void*>_func_eval_sh_jacobi[double]
ufunc_eval_sh_jacobi_ptr[2*3+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*4] = <void*>_func_eval_sh_jacobi[double_complex]
ufunc_eval_sh_jacobi_ptr[2*4+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_data[0] = &ufunc_eval_sh_jacobi_ptr[2*0]
ufunc_eval_sh_jacobi_data[1] = &ufunc_eval_sh_jacobi_ptr[2*1]
ufunc_eval_sh_jacobi_data[2] = &ufunc_eval_sh_jacobi_ptr[2*2]
ufunc_eval_sh_jacobi_data[3] = &ufunc_eval_sh_jacobi_ptr[2*3]
ufunc_eval_sh_jacobi_data[4] = &ufunc_eval_sh_jacobi_ptr[2*4]
eval_sh_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_jacobi_loops, ufunc_eval_sh_jacobi_data, ufunc_eval_sh_jacobi_types, 5, 4, 1, 0, "eval_sh_jacobi", ufunc_eval_sh_jacobi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_legendre_loops[5]
cdef void *ufunc_eval_sh_legendre_ptr[10]
cdef void *ufunc_eval_sh_legendre_data[5]
cdef char ufunc_eval_sh_legendre_types[15]
cdef char *ufunc_eval_sh_legendre_doc = (
    "eval_sh_legendre(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Legendre polynomial at a point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n^*(x) = P_n(2x - 1)\n"
    "\n"
    "where :math:`P_n` is a Legendre polynomial. See 2.2.11 in [AS]_\n"
    "for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the value is\n"
    "    determined via the relation to `eval_legendre`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Legendre polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : scalar or ndarray\n"
    "    Values of the shifted Legendre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_legendre : roots and quadrature weights of shifted\n"
    "                    Legendre polynomials\n"
    "sh_legendre : shifted Legendre polynomial object\n"
    "eval_legendre : evaluate Legendre polynomials\n"
    "numpy.polynomial.legendre.Legendre : Legendre series\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_legendre_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_eval_sh_legendre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_legendre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_legendre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_legendre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_legendre_types[0] = <char>NPY_INTP
ufunc_eval_sh_legendre_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_legendre_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_legendre_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_legendre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_legendre_ptr[2*0] = <void*>_func_eval_sh_legendre_l
ufunc_eval_sh_legendre_ptr[2*0+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*1] = <void*>_func_eval_sh_legendre[double]
ufunc_eval_sh_legendre_ptr[2*1+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*2] = <void*>_func_eval_sh_legendre[double_complex]
ufunc_eval_sh_legendre_ptr[2*2+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*3] = <void*>_func_eval_sh_legendre[double]
ufunc_eval_sh_legendre_ptr[2*3+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*4] = <void*>_func_eval_sh_legendre[double_complex]
ufunc_eval_sh_legendre_ptr[2*4+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_data[0] = &ufunc_eval_sh_legendre_ptr[2*0]
ufunc_eval_sh_legendre_data[1] = &ufunc_eval_sh_legendre_ptr[2*1]
ufunc_eval_sh_legendre_data[2] = &ufunc_eval_sh_legendre_ptr[2*2]
ufunc_eval_sh_legendre_data[3] = &ufunc_eval_sh_legendre_ptr[2*3]
ufunc_eval_sh_legendre_data[4] = &ufunc_eval_sh_legendre_ptr[2*4]
eval_sh_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_legendre_loops, ufunc_eval_sh_legendre_data, ufunc_eval_sh_legendre_types, 5, 2, 1, 0, "eval_sh_legendre", ufunc_eval_sh_legendre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp10_loops[2]
cdef void *ufunc_exp10_ptr[4]
cdef void *ufunc_exp10_data[2]
cdef char ufunc_exp10_types[4]
cdef char *ufunc_exp10_doc = (
    "exp10(x, out=None)\n"
    "\n"
    "Compute ``10**x`` element-wise.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    ``10**x``, computed element-wise.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import exp10\n"
    "\n"
    ">>> exp10(3)\n"
    "1000.0\n"
    ">>> x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n"
    ">>> exp10(x)\n"
    "array([[  0.1       ,   0.31622777,   1.        ],\n"
    "       [  3.16227766,  10.        ,  31.6227766 ]])")
ufunc_exp10_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp10_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp10_types[0] = <char>NPY_FLOAT
ufunc_exp10_types[1] = <char>NPY_FLOAT
ufunc_exp10_types[2] = <char>NPY_DOUBLE
ufunc_exp10_types[3] = <char>NPY_DOUBLE
ufunc_exp10_ptr[2*0] = <void*>_func_cephes_exp10
ufunc_exp10_ptr[2*0+1] = <void*>(<char*>"exp10")
ufunc_exp10_ptr[2*1] = <void*>_func_cephes_exp10
ufunc_exp10_ptr[2*1+1] = <void*>(<char*>"exp10")
ufunc_exp10_data[0] = &ufunc_exp10_ptr[2*0]
ufunc_exp10_data[1] = &ufunc_exp10_ptr[2*1]
exp10 = np.PyUFunc_FromFuncAndData(ufunc_exp10_loops, ufunc_exp10_data, ufunc_exp10_types, 2, 1, 1, 0, "exp10", ufunc_exp10_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp2_loops[2]
cdef void *ufunc_exp2_ptr[4]
cdef void *ufunc_exp2_data[2]
cdef char ufunc_exp2_types[4]
cdef char *ufunc_exp2_doc = (
    "exp2(x, out=None)\n"
    "\n"
    "Compute ``2**x`` element-wise.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    ``2**x``, computed element-wise.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import exp2\n"
    "\n"
    ">>> exp2(3)\n"
    "8.0\n"
    ">>> x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n"
    ">>> exp2(x)\n"
    "array([[ 0.5       ,  0.70710678,  1.        ],\n"
    "       [ 1.41421356,  2.        ,  2.82842712]])")
ufunc_exp2_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp2_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp2_types[0] = <char>NPY_FLOAT
ufunc_exp2_types[1] = <char>NPY_FLOAT
ufunc_exp2_types[2] = <char>NPY_DOUBLE
ufunc_exp2_types[3] = <char>NPY_DOUBLE
ufunc_exp2_ptr[2*0] = <void*>_func_cephes_exp2
ufunc_exp2_ptr[2*0+1] = <void*>(<char*>"exp2")
ufunc_exp2_ptr[2*1] = <void*>_func_cephes_exp2
ufunc_exp2_ptr[2*1+1] = <void*>(<char*>"exp2")
ufunc_exp2_data[0] = &ufunc_exp2_ptr[2*0]
ufunc_exp2_data[1] = &ufunc_exp2_ptr[2*1]
exp2 = np.PyUFunc_FromFuncAndData(ufunc_exp2_loops, ufunc_exp2_data, ufunc_exp2_types, 2, 1, 1, 0, "exp2", ufunc_exp2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expm1_loops[4]
cdef void *ufunc_expm1_ptr[8]
cdef void *ufunc_expm1_data[4]
cdef char ufunc_expm1_types[8]
cdef char *ufunc_expm1_doc = (
    "expm1(x, out=None)\n"
    "\n"
    "Compute ``exp(x) - 1``.\n"
    "\n"
    "When `x` is near zero, ``exp(x)`` is near 1, so the numerical calculation\n"
    "of ``exp(x) - 1`` can suffer from catastrophic loss of precision.\n"
    "``expm1(x)`` is implemented to avoid the loss of precision that occurs when\n"
    "`x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    ``exp(x) - 1`` computed element-wise.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import expm1\n"
    "\n"
    ">>> expm1(1.0)\n"
    "1.7182818284590451\n"
    ">>> expm1([-0.2, -0.1, 0, 0.1, 0.2])\n"
    "array([-0.18126925, -0.09516258,  0.        ,  0.10517092,  0.22140276])\n"
    "\n"
    "The exact value of ``exp(7.5e-13) - 1`` is::\n"
    "\n"
    "    7.5000000000028125000000007031250000001318...*10**-13.\n"
    "\n"
    "Here is what ``expm1(7.5e-13)`` gives:\n"
    "\n"
    ">>> expm1(7.5e-13)\n"
    "7.5000000000028135e-13\n"
    "\n"
    "Compare that to ``exp(7.5e-13) - 1``, where the subtraction results in\n"
    "a \"catastrophic\" loss of precision:\n"
    "\n"
    ">>> np.exp(7.5e-13) - 1\n"
    "7.5006667543675576e-13")
ufunc_expm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_expm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_expm1_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_expm1_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_expm1_types[0] = <char>NPY_FLOAT
ufunc_expm1_types[1] = <char>NPY_FLOAT
ufunc_expm1_types[2] = <char>NPY_DOUBLE
ufunc_expm1_types[3] = <char>NPY_DOUBLE
ufunc_expm1_types[4] = <char>NPY_CFLOAT
ufunc_expm1_types[5] = <char>NPY_CFLOAT
ufunc_expm1_types[6] = <char>NPY_CDOUBLE
ufunc_expm1_types[7] = <char>NPY_CDOUBLE
ufunc_expm1_ptr[2*0] = <void*>_func_cephes_expm1
ufunc_expm1_ptr[2*0+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*1] = <void*>_func_cephes_expm1
ufunc_expm1_ptr[2*1+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*2] = <void*>_func_cexpm1
ufunc_expm1_ptr[2*2+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*3] = <void*>_func_cexpm1
ufunc_expm1_ptr[2*3+1] = <void*>(<char*>"expm1")
ufunc_expm1_data[0] = &ufunc_expm1_ptr[2*0]
ufunc_expm1_data[1] = &ufunc_expm1_ptr[2*1]
ufunc_expm1_data[2] = &ufunc_expm1_ptr[2*2]
ufunc_expm1_data[3] = &ufunc_expm1_ptr[2*3]
expm1 = np.PyUFunc_FromFuncAndData(ufunc_expm1_loops, ufunc_expm1_data, ufunc_expm1_types, 4, 1, 1, 0, "expm1", ufunc_expm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expn_loops[3]
cdef void *ufunc_expn_ptr[6]
cdef void *ufunc_expn_data[3]
cdef char ufunc_expn_types[9]
cdef char *ufunc_expn_doc = (
    "expn(n, x, out=None)\n"
    "\n"
    "Generalized exponential integral En.\n"
    "\n"
    "For integer :math:`n \\geq 0` and real :math:`x \\geq 0` the\n"
    "generalized exponential integral is defined as [dlmf]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    E_n(x) = x^{n - 1} \\int_x^\\infty \\frac{e^{-t}}{t^n} dt.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Non-negative integers\n"
    "x : array_like\n"
    "    Real argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the generalized exponential integral\n"
    "\n"
    "See Also\n"
    "--------\n"
    "exp1 : special case of :math:`E_n` for :math:`n = 1`\n"
    "expi : related to :math:`E_n` when :math:`n = 1`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] Digital Library of Mathematical Functions, 8.19.2\n"
    "          https://dlmf.nist.gov/8.19#E2\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "Its domain is nonnegative n and x.\n"
    "\n"
    ">>> sc.expn(-1, 1.0), sc.expn(1, -1.0)\n"
    "(nan, nan)\n"
    "\n"
    "It has a pole at ``x = 0`` for ``n = 1, 2``; for larger ``n`` it\n"
    "is equal to ``1 / (n - 1)``.\n"
    "\n"
    ">>> sc.expn([0, 1, 2, 3, 4], 0)\n"
    "array([       inf,        inf, 1.        , 0.5       , 0.33333333])\n"
    "\n"
    "For n equal to 0 it reduces to ``exp(-x) / x``.\n"
    "\n"
    ">>> x = np.array([1, 2, 3, 4])\n"
    ">>> sc.expn(0, x)\n"
    "array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n"
    ">>> np.exp(-x) / x\n"
    "array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n"
    "\n"
    "For n equal to 1 it reduces to `exp1`.\n"
    "\n"
    ">>> sc.expn(1, x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n"
    ">>> sc.exp1(x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])")
ufunc_expn_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_expn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_expn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_expn_types[0] = <char>NPY_INTP
ufunc_expn_types[1] = <char>NPY_DOUBLE
ufunc_expn_types[2] = <char>NPY_DOUBLE
ufunc_expn_types[3] = <char>NPY_FLOAT
ufunc_expn_types[4] = <char>NPY_FLOAT
ufunc_expn_types[5] = <char>NPY_FLOAT
ufunc_expn_types[6] = <char>NPY_DOUBLE
ufunc_expn_types[7] = <char>NPY_DOUBLE
ufunc_expn_types[8] = <char>NPY_DOUBLE
ufunc_expn_ptr[2*0] = <void*>_func_cephes_expn_wrap
ufunc_expn_ptr[2*0+1] = <void*>(<char*>"expn")
ufunc_expn_ptr[2*1] = <void*>_func_expn_unsafe
ufunc_expn_ptr[2*1+1] = <void*>(<char*>"expn")
ufunc_expn_ptr[2*2] = <void*>_func_expn_unsafe
ufunc_expn_ptr[2*2+1] = <void*>(<char*>"expn")
ufunc_expn_data[0] = &ufunc_expn_ptr[2*0]
ufunc_expn_data[1] = &ufunc_expn_ptr[2*1]
ufunc_expn_data[2] = &ufunc_expn_ptr[2*2]
expn = np.PyUFunc_FromFuncAndData(ufunc_expn_loops, ufunc_expn_data, ufunc_expn_types, 3, 2, 1, 0, "expn", ufunc_expn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtr_loops[2]
cdef void *ufunc_fdtr_ptr[4]
cdef void *ufunc_fdtr_data[2]
cdef char ufunc_fdtr_types[8]
cdef char *ufunc_fdtr_doc = (
    "fdtr(dfn, dfd, x, out=None)\n"
    "\n"
    "F cumulative distribution function.\n"
    "\n"
    "Returns the value of the cumulative distribution function of the\n"
    "F-distribution, also known as Snedecor's F-distribution or the\n"
    "Fisher-Snedecor distribution.\n"
    "\n"
    "The F-distribution with parameters :math:`d_n` and :math:`d_d` is the\n"
    "distribution of the random variable,\n"
    "\n"
    ".. math::\n"
    "    X = \\frac{U_n/d_n}{U_d/d_d},\n"
    "\n"
    "where :math:`U_n` and :math:`U_d` are random variables distributed\n"
    ":math:`\\chi^2`, with :math:`d_n` and :math:`d_d` degrees of freedom,\n"
    "respectively.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    The CDF of the F-distribution with parameters `dfn` and `dfd` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtrc : F distribution survival function\n"
    "fdtri : F distribution inverse cumulative distribution\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The regularized incomplete beta function is used, according to the\n"
    "formula,\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtr`. The F distribution is also\n"
    "available as `scipy.stats.f`. Calling `fdtr` directly can improve\n"
    "performance compared to the ``cdf`` method of `scipy.stats.f` (see last\n"
    "example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import fdtr\n"
    ">>> fdtr(1, 2, 1)\n"
    "0.5773502691896258\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array for\n"
    "`x`.\n"
    "\n"
    ">>> x = np.array([0.5, 2., 3.])\n"
    ">>> fdtr(1, 2, x)\n"
    "array([0.4472136 , 0.70710678, 0.77459667])\n"
    "\n"
    "Plot the function for several parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> dfn_parameters = [1, 5, 10, 50]\n"
    ">>> dfd_parameters = [1, 1, 2, 3]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(dfn_parameters, dfd_parameters,\n"
    "...                            linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     dfn, dfd, style = parameter_set\n"
    "...     fdtr_vals = fdtr(dfn, dfd, x)\n"
    "...     ax.plot(x, fdtr_vals, label=rf\"$d_n={dfn},\\, d_d={dfd}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"F distribution cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Using `fdtr`\n"
    "directly can be much faster than calling the ``cdf`` method of\n"
    "`scipy.stats.f`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.f(dfn, dfd).cdf(x)=fdtr(dfn, dfd, x)``.\n"
    "\n"
    ">>> from scipy.stats import f\n"
    ">>> dfn, dfd = 1, 2\n"
    ">>> x = 1\n"
    ">>> fdtr_res = fdtr(dfn, dfd, x)  # this will often be faster than below\n"
    ">>> f_dist_res = f(dfn, dfd).cdf(x)\n"
    ">>> fdtr_res == f_dist_res  # test that results are equal\n"
    "True")
ufunc_fdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtr_types[0] = <char>NPY_FLOAT
ufunc_fdtr_types[1] = <char>NPY_FLOAT
ufunc_fdtr_types[2] = <char>NPY_FLOAT
ufunc_fdtr_types[3] = <char>NPY_FLOAT
ufunc_fdtr_types[4] = <char>NPY_DOUBLE
ufunc_fdtr_types[5] = <char>NPY_DOUBLE
ufunc_fdtr_types[6] = <char>NPY_DOUBLE
ufunc_fdtr_types[7] = <char>NPY_DOUBLE
ufunc_fdtr_ptr[2*0] = <void*>_func_xsf_fdtr
ufunc_fdtr_ptr[2*0+1] = <void*>(<char*>"fdtr")
ufunc_fdtr_ptr[2*1] = <void*>_func_xsf_fdtr
ufunc_fdtr_ptr[2*1+1] = <void*>(<char*>"fdtr")
ufunc_fdtr_data[0] = &ufunc_fdtr_ptr[2*0]
ufunc_fdtr_data[1] = &ufunc_fdtr_ptr[2*1]
fdtr = np.PyUFunc_FromFuncAndData(ufunc_fdtr_loops, ufunc_fdtr_data, ufunc_fdtr_types, 2, 3, 1, 0, "fdtr", ufunc_fdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtrc_loops[2]
cdef void *ufunc_fdtrc_ptr[4]
cdef void *ufunc_fdtrc_data[2]
cdef char ufunc_fdtrc_types[8]
cdef char *ufunc_fdtrc_doc = (
    "fdtrc(dfn, dfd, x, out=None)\n"
    "\n"
    "F survival function.\n"
    "\n"
    "Returns the complemented F-distribution function (the integral of the\n"
    "density from `x` to infinity).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    The complemented F-distribution function with parameters `dfn` and\n"
    "    `dfd` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtr : F distribution cumulative distribution function\n"
    "fdtri : F distribution inverse cumulative distribution function\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The regularized incomplete beta function is used, according to the\n"
    "formula,\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtrc`. The F distribution is also\n"
    "available as `scipy.stats.f`. Calling `fdtrc` directly can improve\n"
    "performance compared to the ``sf`` method of `scipy.stats.f` (see last\n"
    "example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import fdtrc\n"
    ">>> fdtrc(1, 2, 1)\n"
    "0.42264973081037427\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array for\n"
    "`x`.\n"
    "\n"
    ">>> x = np.array([0.5, 2., 3.])\n"
    ">>> fdtrc(1, 2, x)\n"
    "array([0.5527864 , 0.29289322, 0.22540333])\n"
    "\n"
    "Plot the function for several parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> dfn_parameters = [1, 5, 10, 50]\n"
    ">>> dfd_parameters = [1, 1, 2, 3]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(dfn_parameters, dfd_parameters,\n"
    "...                            linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     dfn, dfd, style = parameter_set\n"
    "...     fdtrc_vals = fdtrc(dfn, dfd, x)\n"
    "...     ax.plot(x, fdtrc_vals, label=rf\"$d_n={dfn},\\, d_d={dfd}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"F distribution survival function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Using `fdtrc`\n"
    "directly can be much faster than calling the ``sf`` method of\n"
    "`scipy.stats.f`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.f(dfn, dfd).sf(x)=fdtrc(dfn, dfd, x)``.\n"
    "\n"
    ">>> from scipy.stats import f\n"
    ">>> dfn, dfd = 1, 2\n"
    ">>> x = 1\n"
    ">>> fdtrc_res = fdtrc(dfn, dfd, x)  # this will often be faster than below\n"
    ">>> f_dist_res = f(dfn, dfd).sf(x)\n"
    ">>> f_dist_res == fdtrc_res  # test that results are equal\n"
    "True")
ufunc_fdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtrc_types[0] = <char>NPY_FLOAT
ufunc_fdtrc_types[1] = <char>NPY_FLOAT
ufunc_fdtrc_types[2] = <char>NPY_FLOAT
ufunc_fdtrc_types[3] = <char>NPY_FLOAT
ufunc_fdtrc_types[4] = <char>NPY_DOUBLE
ufunc_fdtrc_types[5] = <char>NPY_DOUBLE
ufunc_fdtrc_types[6] = <char>NPY_DOUBLE
ufunc_fdtrc_types[7] = <char>NPY_DOUBLE
ufunc_fdtrc_ptr[2*0] = <void*>_func_xsf_fdtrc
ufunc_fdtrc_ptr[2*0+1] = <void*>(<char*>"fdtrc")
ufunc_fdtrc_ptr[2*1] = <void*>_func_xsf_fdtrc
ufunc_fdtrc_ptr[2*1+1] = <void*>(<char*>"fdtrc")
ufunc_fdtrc_data[0] = &ufunc_fdtrc_ptr[2*0]
ufunc_fdtrc_data[1] = &ufunc_fdtrc_ptr[2*1]
fdtrc = np.PyUFunc_FromFuncAndData(ufunc_fdtrc_loops, ufunc_fdtrc_data, ufunc_fdtrc_types, 2, 3, 1, 0, "fdtrc", ufunc_fdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtri_loops[2]
cdef void *ufunc_fdtri_ptr[4]
cdef void *ufunc_fdtri_data[2]
cdef char ufunc_fdtri_types[8]
cdef char *ufunc_fdtri_doc = (
    "fdtri(dfn, dfd, p, out=None)\n"
    "\n"
    "The `p`-th quantile of the F-distribution.\n"
    "\n"
    "This function is the inverse of the F-distribution CDF, `fdtr`, returning\n"
    "the `x` such that `fdtr(dfn, dfd, x) = p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    The quantile corresponding to `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtr : F distribution cumulative distribution function\n"
    "fdtrc : F distribution survival function\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the relation to the inverse\n"
    "regularized beta function, :math:`I^{-1}_x(a, b)`.  Let\n"
    ":math:`z = I^{-1}_p(d_d/2, d_n/2).`  Then,\n"
    "\n"
    ".. math::\n"
    "    x = \\frac{d_d (1 - z)}{d_n z}.\n"
    "\n"
    "If `p` is such that :math:`x < 0.5`, the following relation is used\n"
    "instead for improved stability: let\n"
    ":math:`z' = I^{-1}_{1 - p}(d_n/2, d_d/2).` Then,\n"
    "\n"
    ".. math::\n"
    "    x = \\frac{d_d z'}{d_n (1 - z')}.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtri`.\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Calling\n"
    "`fdtri` directly can improve performance compared to the ``ppf``\n"
    "method of `scipy.stats.f` (see last example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`fdtri` represents the inverse of the F distribution CDF which is\n"
    "available as `fdtr`. Here, we calculate the CDF for ``df1=1``, ``df2=2``\n"
    "at ``x=3``. `fdtri` then returns ``3`` given the same values for `df1`,\n"
    "`df2` and the computed CDF value.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import fdtri, fdtr\n"
    ">>> df1, df2 = 1, 2\n"
    ">>> x = 3\n"
    ">>> cdf_value =  fdtr(df1, df2, x)\n"
    ">>> fdtri(df1, df2, cdf_value)\n"
    "3.000000000000006\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array for\n"
    "`x`.\n"
    "\n"
    ">>> x = np.array([0.1, 0.4, 0.7])\n"
    ">>> fdtri(1, 2, x)\n"
    "array([0.02020202, 0.38095238, 1.92156863])\n"
    "\n"
    "Plot the function for several parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> dfn_parameters = [50, 10, 1, 50]\n"
    ">>> dfd_parameters = [0.5, 1, 1, 5]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(dfn_parameters, dfd_parameters,\n"
    "...                            linestyles))\n"
    ">>> x = np.linspace(0, 1, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     dfn, dfd, style = parameter_set\n"
    "...     fdtri_vals = fdtri(dfn, dfd, x)\n"
    "...     ax.plot(x, fdtri_vals, label=rf\"$d_n={dfn},\\, d_d={dfd}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> title = \"F distribution inverse cumulative distribution function\"\n"
    ">>> ax.set_title(title)\n"
    ">>> ax.set_ylim(0, 30)\n"
    ">>> plt.show()\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Using `fdtri`\n"
    "directly can be much faster than calling the ``ppf`` method of\n"
    "`scipy.stats.f`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.f(dfn, dfd).ppf(x)=fdtri(dfn, dfd, x)``.\n"
    "\n"
    ">>> from scipy.stats import f\n"
    ">>> dfn, dfd = 1, 2\n"
    ">>> x = 0.7\n"
    ">>> fdtri_res = fdtri(dfn, dfd, x)  # this will often be faster than below\n"
    ">>> f_dist_res = f(dfn, dfd).ppf(x)\n"
    ">>> f_dist_res == fdtri_res  # test that results are equal\n"
    "True")
ufunc_fdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtri_types[0] = <char>NPY_FLOAT
ufunc_fdtri_types[1] = <char>NPY_FLOAT
ufunc_fdtri_types[2] = <char>NPY_FLOAT
ufunc_fdtri_types[3] = <char>NPY_FLOAT
ufunc_fdtri_types[4] = <char>NPY_DOUBLE
ufunc_fdtri_types[5] = <char>NPY_DOUBLE
ufunc_fdtri_types[6] = <char>NPY_DOUBLE
ufunc_fdtri_types[7] = <char>NPY_DOUBLE
ufunc_fdtri_ptr[2*0] = <void*>_func_xsf_fdtri
ufunc_fdtri_ptr[2*0+1] = <void*>(<char*>"fdtri")
ufunc_fdtri_ptr[2*1] = <void*>_func_xsf_fdtri
ufunc_fdtri_ptr[2*1+1] = <void*>(<char*>"fdtri")
ufunc_fdtri_data[0] = &ufunc_fdtri_ptr[2*0]
ufunc_fdtri_data[1] = &ufunc_fdtri_ptr[2*1]
fdtri = np.PyUFunc_FromFuncAndData(ufunc_fdtri_loops, ufunc_fdtri_data, ufunc_fdtri_types, 2, 3, 1, 0, "fdtri", ufunc_fdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtridfd_loops[2]
cdef void *ufunc_fdtridfd_ptr[4]
cdef void *ufunc_fdtridfd_data[2]
cdef char ufunc_fdtridfd_types[8]
cdef char *ufunc_fdtridfd_doc = (
    "fdtridfd(dfn, p, x, out=None)\n"
    "\n"
    "Inverse to `fdtr` vs dfd\n"
    "\n"
    "Finds the F density argument dfd such that ``fdtr(dfn, dfd, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "dfd : scalar or ndarray\n"
    "    `dfd` such that ``fdtr(dfn, dfd, x) == p``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtr : F distribution cumulative distribution function\n"
    "fdtrc : F distribution survival function\n"
    "fdtri : F distribution quantile function\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the F distribution cumulative distribution function for one\n"
    "parameter set.\n"
    "\n"
    ">>> from scipy.special import fdtridfd, fdtr\n"
    ">>> dfn, dfd, x = 10, 5, 2\n"
    ">>> cdf_value = fdtr(dfn, dfd, x)\n"
    ">>> cdf_value\n"
    "0.7700248806501017\n"
    "\n"
    "Verify that `fdtridfd` recovers the original value for `dfd`:\n"
    "\n"
    ">>> fdtridfd(dfn, cdf_value, x)\n"
    "5.0")
ufunc_fdtridfd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtridfd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtridfd_types[0] = <char>NPY_FLOAT
ufunc_fdtridfd_types[1] = <char>NPY_FLOAT
ufunc_fdtridfd_types[2] = <char>NPY_FLOAT
ufunc_fdtridfd_types[3] = <char>NPY_FLOAT
ufunc_fdtridfd_types[4] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[5] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[6] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[7] = <char>NPY_DOUBLE
ufunc_fdtridfd_ptr[2*0] = <void*>_func_fdtridfd
ufunc_fdtridfd_ptr[2*0+1] = <void*>(<char*>"fdtridfd")
ufunc_fdtridfd_ptr[2*1] = <void*>_func_fdtridfd
ufunc_fdtridfd_ptr[2*1+1] = <void*>(<char*>"fdtridfd")
ufunc_fdtridfd_data[0] = &ufunc_fdtridfd_ptr[2*0]
ufunc_fdtridfd_data[1] = &ufunc_fdtridfd_ptr[2*1]
fdtridfd = np.PyUFunc_FromFuncAndData(ufunc_fdtridfd_loops, ufunc_fdtridfd_data, ufunc_fdtridfd_types, 2, 3, 1, 0, "fdtridfd", ufunc_fdtridfd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtr_loops[2]
cdef void *ufunc_gdtr_ptr[4]
cdef void *ufunc_gdtr_data[2]
cdef char ufunc_gdtr_types[8]
cdef char *ufunc_gdtr_doc = (
    "gdtr(a, b, x, out=None)\n"
    "\n"
    "Gamma distribution cumulative distribution function.\n"
    "\n"
    "Returns the integral from zero to `x` of the gamma probability density\n"
    "function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\int_0^x \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    The rate parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\beta` (float).  It is also the reciprocal of the scale\n"
    "    parameter :math:`\\theta`.\n"
    "b : array_like\n"
    "    The shape parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\alpha` (float).\n"
    "x : array_like\n"
    "    The quantile (upper limit of integration; float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The CDF of the gamma distribution with parameters `a` and `b`\n"
    "    evaluated at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtrc : 1 - CDF of the gamma distribution.\n"
    "scipy.stats.gamma: Gamma distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The evaluation is carried out using the relation to the incomplete gamma\n"
    "integral (regularized gamma function).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `gdtr`. Calling `gdtr` directly can\n"
    "improve performance compared to the ``cdf`` method of `scipy.stats.gamma`\n"
    "(see last example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``a=1``, ``b=2`` at ``x=5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import gdtr\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> gdtr(1., 2., 5.)\n"
    "0.9595723180054873\n"
    "\n"
    "Compute the function for ``a=1`` and ``b=2`` at several points by\n"
    "providing a NumPy array for `x`.\n"
    "\n"
    ">>> xvalues = np.array([1., 2., 3., 4])\n"
    ">>> gdtr(1., 1., xvalues)\n"
    "array([0.63212056, 0.86466472, 0.95021293, 0.98168436])\n"
    "\n"
    "`gdtr` can evaluate different parameter sets by providing arrays with\n"
    "broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n"
    "function for three different `a` at four positions `x` and ``b=3``,\n"
    "resulting in a 3x4 array.\n"
    "\n"
    ">>> a = np.array([[0.5], [1.5], [2.5]])\n"
    ">>> x = np.array([1., 2., 3., 4])\n"
    ">>> a.shape, x.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> gdtr(a, 3., x)\n"
    "array([[0.01438768, 0.0803014 , 0.19115317, 0.32332358],\n"
    "       [0.19115317, 0.57680992, 0.82642193, 0.9380312 ],\n"
    "       [0.45618688, 0.87534798, 0.97974328, 0.9972306 ]])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> a_parameters = [0.3, 1, 2, 6]\n"
    ">>> b_parameters = [2, 10, 15, 20]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     a, b, style = parameter_set\n"
    "...     gdtr_vals = gdtr(a, b, x)\n"
    "...     ax.plot(x, gdtr_vals, label=fr\"$a= {a},\\, b={b}$\", ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"Gamma distribution cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The gamma distribution is also available as `scipy.stats.gamma`. Using\n"
    "`gdtr` directly can be much faster than calling the ``cdf`` method of\n"
    "`scipy.stats.gamma`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.gamma(b, scale=1/a).cdf(x)=gdtr(a, b, x)``.\n"
    "\n"
    ">>> from scipy.stats import gamma\n"
    ">>> a = 2.\n"
    ">>> b = 3\n"
    ">>> x = 1.\n"
    ">>> gdtr_result = gdtr(a, b, x)  # this will often be faster than below\n"
    ">>> gamma_dist_result = gamma(b, scale=1/a).cdf(x)\n"
    ">>> gdtr_result == gamma_dist_result  # test that results are equal\n"
    "True")
ufunc_gdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtr_types[0] = <char>NPY_FLOAT
ufunc_gdtr_types[1] = <char>NPY_FLOAT
ufunc_gdtr_types[2] = <char>NPY_FLOAT
ufunc_gdtr_types[3] = <char>NPY_FLOAT
ufunc_gdtr_types[4] = <char>NPY_DOUBLE
ufunc_gdtr_types[5] = <char>NPY_DOUBLE
ufunc_gdtr_types[6] = <char>NPY_DOUBLE
ufunc_gdtr_types[7] = <char>NPY_DOUBLE
ufunc_gdtr_ptr[2*0] = <void*>_func_xsf_gdtr
ufunc_gdtr_ptr[2*0+1] = <void*>(<char*>"gdtr")
ufunc_gdtr_ptr[2*1] = <void*>_func_xsf_gdtr
ufunc_gdtr_ptr[2*1+1] = <void*>(<char*>"gdtr")
ufunc_gdtr_data[0] = &ufunc_gdtr_ptr[2*0]
ufunc_gdtr_data[1] = &ufunc_gdtr_ptr[2*1]
gdtr = np.PyUFunc_FromFuncAndData(ufunc_gdtr_loops, ufunc_gdtr_data, ufunc_gdtr_types, 2, 3, 1, 0, "gdtr", ufunc_gdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrc_loops[2]
cdef void *ufunc_gdtrc_ptr[4]
cdef void *ufunc_gdtrc_data[2]
cdef char ufunc_gdtrc_types[8]
cdef char *ufunc_gdtrc_doc = (
    "gdtrc(a, b, x, out=None)\n"
    "\n"
    "Gamma distribution survival function.\n"
    "\n"
    "Integral from `x` to infinity of the gamma probability density function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\int_x^\\infty \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    The rate parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\beta` (float). It is also the reciprocal of the scale\n"
    "    parameter :math:`\\theta`.\n"
    "b : array_like\n"
    "    The shape parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\alpha` (float).\n"
    "x : array_like\n"
    "    The quantile (lower limit of integration; float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The survival function of the gamma distribution with parameters `a`\n"
    "    and `b` evaluated at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr: Gamma distribution cumulative distribution function\n"
    "scipy.stats.gamma: Gamma distribution\n"
    "gdtrix\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The evaluation is carried out using the relation to the incomplete gamma\n"
    "integral (regularized gamma function).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `gdtrc`. Calling `gdtrc` directly can\n"
    "improve performance compared to the ``sf`` method of `scipy.stats.gamma`\n"
    "(see last example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``a=1`` and ``b=2`` at ``x=5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import gdtrc\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> gdtrc(1., 2., 5.)\n"
    "0.04042768199451279\n"
    "\n"
    "Compute the function for ``a=1``, ``b=2`` at several points by providing\n"
    "a NumPy array for `x`.\n"
    "\n"
    ">>> xvalues = np.array([1., 2., 3., 4])\n"
    ">>> gdtrc(1., 1., xvalues)\n"
    "array([0.36787944, 0.13533528, 0.04978707, 0.01831564])\n"
    "\n"
    "`gdtrc` can evaluate different parameter sets by providing arrays with\n"
    "broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n"
    "function for three different `a` at four positions `x` and ``b=3``,\n"
    "resulting in a 3x4 array.\n"
    "\n"
    ">>> a = np.array([[0.5], [1.5], [2.5]])\n"
    ">>> x = np.array([1., 2., 3., 4])\n"
    ">>> a.shape, x.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> gdtrc(a, 3., x)\n"
    "array([[0.98561232, 0.9196986 , 0.80884683, 0.67667642],\n"
    "       [0.80884683, 0.42319008, 0.17357807, 0.0619688 ],\n"
    "       [0.54381312, 0.12465202, 0.02025672, 0.0027694 ]])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> a_parameters = [0.3, 1, 2, 6]\n"
    ">>> b_parameters = [2, 10, 15, 20]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     a, b, style = parameter_set\n"
    "...     gdtrc_vals = gdtrc(a, b, x)\n"
    "...     ax.plot(x, gdtrc_vals, label=fr\"$a= {a},\\, b={b}$\", ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"Gamma distribution survival function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The gamma distribution is also available as `scipy.stats.gamma`.\n"
    "Using `gdtrc` directly can be much faster than calling the ``sf`` method\n"
    "of `scipy.stats.gamma`, especially for small arrays or individual\n"
    "values. To get the same results one must use the following parametrization:\n"
    "``stats.gamma(b, scale=1/a).sf(x)=gdtrc(a, b, x)``.\n"
    "\n"
    ">>> from scipy.stats import gamma\n"
    ">>> a = 2\n"
    ">>> b = 3\n"
    ">>> x = 1.\n"
    ">>> gdtrc_result = gdtrc(a, b, x)  # this will often be faster than below\n"
    ">>> gamma_dist_result = gamma(b, scale=1/a).sf(x)\n"
    ">>> gdtrc_result == gamma_dist_result  # test that results are equal\n"
    "True")
ufunc_gdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrc_types[0] = <char>NPY_FLOAT
ufunc_gdtrc_types[1] = <char>NPY_FLOAT
ufunc_gdtrc_types[2] = <char>NPY_FLOAT
ufunc_gdtrc_types[3] = <char>NPY_FLOAT
ufunc_gdtrc_types[4] = <char>NPY_DOUBLE
ufunc_gdtrc_types[5] = <char>NPY_DOUBLE
ufunc_gdtrc_types[6] = <char>NPY_DOUBLE
ufunc_gdtrc_types[7] = <char>NPY_DOUBLE
ufunc_gdtrc_ptr[2*0] = <void*>_func_xsf_gdtrc
ufunc_gdtrc_ptr[2*0+1] = <void*>(<char*>"gdtrc")
ufunc_gdtrc_ptr[2*1] = <void*>_func_xsf_gdtrc
ufunc_gdtrc_ptr[2*1+1] = <void*>(<char*>"gdtrc")
ufunc_gdtrc_data[0] = &ufunc_gdtrc_ptr[2*0]
ufunc_gdtrc_data[1] = &ufunc_gdtrc_ptr[2*1]
gdtrc = np.PyUFunc_FromFuncAndData(ufunc_gdtrc_loops, ufunc_gdtrc_data, ufunc_gdtrc_types, 2, 3, 1, 0, "gdtrc", ufunc_gdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtria_loops[2]
cdef void *ufunc_gdtria_ptr[4]
cdef void *ufunc_gdtria_data[2]
cdef char ufunc_gdtria_types[8]
cdef char *ufunc_gdtria_doc = (
    "gdtria(p, b, x, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs a.\n"
    "\n"
    "Returns the inverse with respect to the parameter `a` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability values.\n"
    "b : array_like\n"
    "    `b` parameter values of `gdtr(a, b, x)`. `b` is the \"shape\" parameter\n"
    "    of the gamma distribution.\n"
    "x : array_like\n"
    "    Nonnegative real values, from the domain of the gamma distribution.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : scalar or ndarray\n"
    "    Values of the `a` parameter such that ``p = gdtr(a, b, x)`.  ``1/a``\n"
    "    is the \"scale\" parameter of the gamma distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n"
    "gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtria\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtria(p, 3.4, 5.6)\n"
    "1.2")
ufunc_gdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtria_types[0] = <char>NPY_FLOAT
ufunc_gdtria_types[1] = <char>NPY_FLOAT
ufunc_gdtria_types[2] = <char>NPY_FLOAT
ufunc_gdtria_types[3] = <char>NPY_FLOAT
ufunc_gdtria_types[4] = <char>NPY_DOUBLE
ufunc_gdtria_types[5] = <char>NPY_DOUBLE
ufunc_gdtria_types[6] = <char>NPY_DOUBLE
ufunc_gdtria_types[7] = <char>NPY_DOUBLE
ufunc_gdtria_ptr[2*0] = <void*>_func_gdtria
ufunc_gdtria_ptr[2*0+1] = <void*>(<char*>"gdtria")
ufunc_gdtria_ptr[2*1] = <void*>_func_gdtria
ufunc_gdtria_ptr[2*1+1] = <void*>(<char*>"gdtria")
ufunc_gdtria_data[0] = &ufunc_gdtria_ptr[2*0]
ufunc_gdtria_data[1] = &ufunc_gdtria_ptr[2*1]
gdtria = np.PyUFunc_FromFuncAndData(ufunc_gdtria_loops, ufunc_gdtria_data, ufunc_gdtria_types, 2, 3, 1, 0, "gdtria", ufunc_gdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrib_loops[2]
cdef void *ufunc_gdtrib_ptr[4]
cdef void *ufunc_gdtrib_data[2]
cdef char ufunc_gdtrib_types[8]
cdef char *ufunc_gdtrib_doc = (
    "gdtrib(a, p, x, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs b.\n"
    "\n"
    "Returns the inverse with respect to the parameter `b` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    `a` parameter values of ``gdtr(a, b, x)`. ``1/a`` is the \"scale\"\n"
    "    parameter of the gamma distribution.\n"
    "p : array_like\n"
    "    Probability values.\n"
    "x : array_like\n"
    "    Nonnegative real values, from the domain of the gamma distribution.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : scalar or ndarray\n"
    "    Values of the `b` parameter such that `p = gdtr(a, b, x)`.  `b` is\n"
    "    the \"shape\" parameter of the gamma distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n"
    "gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    "The cumulative distribution function `p` is computed using the Cephes [1]_\n"
    "routines `igam` and `igamc`. Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p` using Chandrupatla's bracketing\n"
    "root finding algorithm [2]_.\n"
    "\n"
    "Note that there are some edge cases where `gdtrib` is extended by taking\n"
    "limits where they are uniquely defined. In particular\n"
    "``x == 0`` with ``p > 0`` and ``p == 0`` with ``x > 0``.\n"
    "For these edge cases, a numerical result will be returned for\n"
    "``gdtrib(a, p, x)`` even though ``gdtr(a, gdtrib(a, p, x), x)`` is\n"
    "undefined.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Chandrupatla, Tirupathi R.\n"
    "       \"A new hybrid quadratic/bisection algorithm for finding the zero of a\n"
    "       nonlinear function without using derivatives\".\n"
    "       Advances in Engineering Software, 28(3), 145-149.\n"
    "       https://doi.org/10.1016/s0965-9978(96)00051-8\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtrib\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtrib(1.2, p, 5.6)\n"
    "3.3999999999999995")
ufunc_gdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrib_types[0] = <char>NPY_FLOAT
ufunc_gdtrib_types[1] = <char>NPY_FLOAT
ufunc_gdtrib_types[2] = <char>NPY_FLOAT
ufunc_gdtrib_types[3] = <char>NPY_FLOAT
ufunc_gdtrib_types[4] = <char>NPY_DOUBLE
ufunc_gdtrib_types[5] = <char>NPY_DOUBLE
ufunc_gdtrib_types[6] = <char>NPY_DOUBLE
ufunc_gdtrib_types[7] = <char>NPY_DOUBLE
ufunc_gdtrib_ptr[2*0] = <void*>_func_xsf_gdtrib
ufunc_gdtrib_ptr[2*0+1] = <void*>(<char*>"gdtrib")
ufunc_gdtrib_ptr[2*1] = <void*>_func_xsf_gdtrib
ufunc_gdtrib_ptr[2*1+1] = <void*>(<char*>"gdtrib")
ufunc_gdtrib_data[0] = &ufunc_gdtrib_ptr[2*0]
ufunc_gdtrib_data[1] = &ufunc_gdtrib_ptr[2*1]
gdtrib = np.PyUFunc_FromFuncAndData(ufunc_gdtrib_loops, ufunc_gdtrib_data, ufunc_gdtrib_types, 2, 3, 1, 0, "gdtrib", ufunc_gdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrix_loops[2]
cdef void *ufunc_gdtrix_ptr[4]
cdef void *ufunc_gdtrix_data[2]
cdef char ufunc_gdtrix_types[8]
cdef char *ufunc_gdtrix_doc = (
    "gdtrix(a, b, p, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs x.\n"
    "\n"
    "Returns the inverse with respect to the parameter `x` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution. This is also known as the pth quantile of the\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    `a` parameter values of ``gdtr(a, b, x)``. ``1/a`` is the \"scale\"\n"
    "    parameter of the gamma distribution.\n"
    "b : array_like\n"
    "    `b` parameter values of ``gdtr(a, b, x)``. `b` is the \"shape\" parameter\n"
    "    of the gamma distribution.\n"
    "p : array_like\n"
    "    Probability values.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`. `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Values of the `x` parameter such that `p = gdtr(a, b, x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtria : Inverse with respect to `a` of ``gdtr(a, b, x)``.\n"
    "gdtrib : Inverse with respect to `b` of ``gdtr(a, b, x)``.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `x` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `x`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtrix\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtrix(1.2, 3.4, p)\n"
    "5.5999999999999996")
ufunc_gdtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrix_types[0] = <char>NPY_FLOAT
ufunc_gdtrix_types[1] = <char>NPY_FLOAT
ufunc_gdtrix_types[2] = <char>NPY_FLOAT
ufunc_gdtrix_types[3] = <char>NPY_FLOAT
ufunc_gdtrix_types[4] = <char>NPY_DOUBLE
ufunc_gdtrix_types[5] = <char>NPY_DOUBLE
ufunc_gdtrix_types[6] = <char>NPY_DOUBLE
ufunc_gdtrix_types[7] = <char>NPY_DOUBLE
ufunc_gdtrix_ptr[2*0] = <void*>_func_gdtrix
ufunc_gdtrix_ptr[2*0+1] = <void*>(<char*>"gdtrix")
ufunc_gdtrix_ptr[2*1] = <void*>_func_gdtrix
ufunc_gdtrix_ptr[2*1+1] = <void*>(<char*>"gdtrix")
ufunc_gdtrix_data[0] = &ufunc_gdtrix_ptr[2*0]
ufunc_gdtrix_data[1] = &ufunc_gdtrix_ptr[2*1]
gdtrix = np.PyUFunc_FromFuncAndData(ufunc_gdtrix_loops, ufunc_gdtrix_data, ufunc_gdtrix_types, 2, 3, 1, 0, "gdtrix", ufunc_gdtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_huber_loops[2]
cdef void *ufunc_huber_ptr[4]
cdef void *ufunc_huber_data[2]
cdef char ufunc_huber_types[6]
cdef char *ufunc_huber_doc = (
    "huber(delta, r, out=None)\n"
    "\n"
    "Huber loss function.\n"
    "\n"
    ".. math:: \\text{huber}(\\delta, r) = \\begin{cases} \\infty & \\delta < 0  \\\\\n"
    "          \\frac{1}{2}r^2 & 0 \\le \\delta, | r | \\le \\delta \\\\\n"
    "          \\delta ( |r| - \\frac{1}{2}\\delta ) & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "delta : ndarray\n"
    "    Input array, indicating the quadratic vs. linear loss changepoint.\n"
    "r : ndarray\n"
    "    Input array, possibly representing residuals.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The computed Huber loss function values.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pseudo_huber : smooth approximation of this function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`huber` is useful as a loss function in robust statistics or machine\n"
    "learning to reduce the influence of outliers as compared to the common\n"
    "squared error loss, residuals with a magnitude higher than `delta` are\n"
    "not squared [1]_.\n"
    "\n"
    "Typically, `r` represents residuals, the difference\n"
    "between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n"
    "`huber` resembles the squared error and for :math:`|r|>\\delta` the\n"
    "absolute error. This way, the Huber loss often achieves\n"
    "a fast convergence in model fitting for small residuals like the squared\n"
    "error loss function and still reduces the influence of outliers\n"
    "(:math:`|r|>\\delta`) like the absolute error loss. As :math:`\\delta` is\n"
    "the cutoff between squared and absolute error regimes, it has\n"
    "to be tuned carefully for each problem. `huber` is also\n"
    "convex, making it suitable for gradient based optimization.\n"
    "\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Peter Huber. \"Robust Estimation of a Location Parameter\",\n"
    "       1964. Annals of Statistics. 53 (1): 73 - 101.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Import all necessary modules.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import huber\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Compute the function for ``delta=1`` at ``r=2``\n"
    "\n"
    ">>> huber(1., 2.)\n"
    "1.5\n"
    "\n"
    "Compute the function for different `delta` by providing a NumPy array or\n"
    "list for `delta`.\n"
    "\n"
    ">>> huber([1., 3., 5.], 4.)\n"
    "array([3.5, 7.5, 8. ])\n"
    "\n"
    "Compute the function at different points by providing a NumPy array or\n"
    "list for `r`.\n"
    "\n"
    ">>> huber(2., np.array([1., 1.5, 3.]))\n"
    "array([0.5  , 1.125, 4.   ])\n"
    "\n"
    "The function can be calculated for different `delta` and `r` by\n"
    "providing arrays for both with compatible shapes for broadcasting.\n"
    "\n"
    ">>> r = np.array([1., 2.5, 8., 10.])\n"
    ">>> deltas = np.array([[1.], [5.], [9.]])\n"
    ">>> print(r.shape, deltas.shape)\n"
    "(4,) (3, 1)\n"
    "\n"
    ">>> huber(deltas, r)\n"
    "array([[ 0.5  ,  2.   ,  7.5  ,  9.5  ],\n"
    "       [ 0.5  ,  3.125, 27.5  , 37.5  ],\n"
    "       [ 0.5  ,  3.125, 32.   , 49.5  ]])\n"
    "\n"
    "Plot the function for different `delta`.\n"
    "\n"
    ">>> x = np.linspace(-4, 4, 500)\n"
    ">>> deltas = [1, 2, 3]\n"
    ">>> linestyles = [\"dashed\", \"dotted\", \"dashdot\"]\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> combined_plot_parameters = list(zip(deltas, linestyles))\n"
    ">>> for delta, style in combined_plot_parameters:\n"
    "...     ax.plot(x, huber(delta, x), label=fr\"$\\delta={delta}$\", ls=style)\n"
    ">>> ax.legend(loc=\"upper center\")\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(r\"Huber loss function $h_{\\delta}(x)$\")\n"
    ">>> ax.set_xlim(-4, 4)\n"
    ">>> ax.set_ylim(0, 8)\n"
    ">>> plt.show()")
ufunc_huber_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_huber_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_huber_types[0] = <char>NPY_FLOAT
ufunc_huber_types[1] = <char>NPY_FLOAT
ufunc_huber_types[2] = <char>NPY_FLOAT
ufunc_huber_types[3] = <char>NPY_DOUBLE
ufunc_huber_types[4] = <char>NPY_DOUBLE
ufunc_huber_types[5] = <char>NPY_DOUBLE
ufunc_huber_ptr[2*0] = <void*>_func_huber
ufunc_huber_ptr[2*0+1] = <void*>(<char*>"huber")
ufunc_huber_ptr[2*1] = <void*>_func_huber
ufunc_huber_ptr[2*1+1] = <void*>(<char*>"huber")
ufunc_huber_data[0] = &ufunc_huber_ptr[2*0]
ufunc_huber_data[1] = &ufunc_huber_ptr[2*1]
huber = np.PyUFunc_FromFuncAndData(ufunc_huber_loops, ufunc_huber_data, ufunc_huber_types, 2, 2, 1, 0, "huber", ufunc_huber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp0f1_loops[4]
cdef void *ufunc_hyp0f1_ptr[8]
cdef void *ufunc_hyp0f1_data[4]
cdef char ufunc_hyp0f1_types[12]
cdef char *ufunc_hyp0f1_doc = (
    "hyp0f1(v, z, out=None)\n"
    "\n"
    "Confluent hypergeometric limit function 0F1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Real-valued parameter\n"
    "z : array_like\n"
    "    Real- or complex-valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The confluent hypergeometric limit function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is defined as:\n"
    "\n"
    ".. math:: _0F_1(v, z) = \\sum_{k=0}^{\\infty}\\frac{z^k}{(v)_k k!}.\n"
    "\n"
    "It's also the limit as :math:`q \\to \\infty` of :math:`_1F_1(q; v; z/q)`,\n"
    "and satisfies the differential equation :math:`f''(z) + vf'(z) =\n"
    "f(z)`. See [1]_ for more information.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Wolfram MathWorld, \"Confluent Hypergeometric Limit Function\",\n"
    "       http://mathworld.wolfram.com/ConfluentHypergeometricLimitFunction.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is one when `z` is zero.\n"
    "\n"
    ">>> sc.hyp0f1(1, 0)\n"
    "1.0\n"
    "\n"
    "It is the limit of the confluent hypergeometric function as `q`\n"
    "goes to infinity.\n"
    "\n"
    ">>> q = np.array([1, 10, 100, 1000])\n"
    ">>> v = 1\n"
    ">>> z = 1\n"
    ">>> sc.hyp1f1(q, v, z / q)\n"
    "array([2.71828183, 2.31481985, 2.28303778, 2.27992985])\n"
    ">>> sc.hyp0f1(v, z)\n"
    "2.2795853023360673\n"
    "\n"
    "It is related to Bessel functions.\n"
    "\n"
    ">>> n = 1\n"
    ">>> x = np.linspace(0, 1, 5)\n"
    ">>> sc.jv(n, x)\n"
    "array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])\n"
    ">>> (0.5 * x)**n / sc.factorial(n) * sc.hyp0f1(n + 1, -0.25 * x**2)\n"
    "array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])")
ufunc_hyp0f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_hyp0f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hyp0f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_hyp0f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hyp0f1_types[0] = <char>NPY_FLOAT
ufunc_hyp0f1_types[1] = <char>NPY_FLOAT
ufunc_hyp0f1_types[2] = <char>NPY_FLOAT
ufunc_hyp0f1_types[3] = <char>NPY_FLOAT
ufunc_hyp0f1_types[4] = <char>NPY_CFLOAT
ufunc_hyp0f1_types[5] = <char>NPY_CFLOAT
ufunc_hyp0f1_types[6] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[7] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[8] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[9] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[10] = <char>NPY_CDOUBLE
ufunc_hyp0f1_types[11] = <char>NPY_CDOUBLE
ufunc_hyp0f1_ptr[2*0] = <void*>_func__hyp0f1_real
ufunc_hyp0f1_ptr[2*0+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*1] = <void*>_func__hyp0f1_cmplx
ufunc_hyp0f1_ptr[2*1+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*2] = <void*>_func__hyp0f1_real
ufunc_hyp0f1_ptr[2*2+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*3] = <void*>_func__hyp0f1_cmplx
ufunc_hyp0f1_ptr[2*3+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_data[0] = &ufunc_hyp0f1_ptr[2*0]
ufunc_hyp0f1_data[1] = &ufunc_hyp0f1_ptr[2*1]
ufunc_hyp0f1_data[2] = &ufunc_hyp0f1_ptr[2*2]
ufunc_hyp0f1_data[3] = &ufunc_hyp0f1_ptr[2*3]
hyp0f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp0f1_loops, ufunc_hyp0f1_data, ufunc_hyp0f1_types, 4, 2, 1, 0, "hyp0f1", ufunc_hyp0f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp1f1_loops[4]
cdef void *ufunc_hyp1f1_ptr[8]
cdef void *ufunc_hyp1f1_data[4]
cdef char ufunc_hyp1f1_types[16]
cdef char *ufunc_hyp1f1_doc = (
    "hyp1f1(a, b, x, out=None)\n"
    "\n"
    "Confluent hypergeometric function 1F1.\n"
    "\n"
    "The confluent hypergeometric function is defined by the series\n"
    "\n"
    ".. math::\n"
    "\n"
    "   {}_1F_1(a; b; x) = \\sum_{k = 0}^\\infty \\frac{(a)_k}{(b)_k k!} x^k.\n"
    "\n"
    "See [dlmf]_ for more details. Here :math:`(\\cdot)_k` is the\n"
    "Pochhammer symbol; see `poch`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real parameters\n"
    "x : array_like\n"
    "    Real or complex argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the confluent hypergeometric function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "hyperu : another confluent hypergeometric function\n"
    "hyp0f1 : confluent hypergeometric limit function\n"
    "hyp2f1 : Gaussian hypergeometric function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real values, this function uses the ``hyp1f1`` routine from the C++ Boost\n"
    "library [2]_, for complex values a C translation of the specfun\n"
    "Fortran library [3]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/13.2#E2\n"
    ".. [2] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    ".. [3] Zhang, Jin, \"Computation of Special Functions\", John Wiley\n"
    "       and Sons, Inc, 1996.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is one when `x` is zero:\n"
    "\n"
    ">>> sc.hyp1f1(0.5, 0.5, 0)\n"
    "1.0\n"
    "\n"
    "It is singular when `b` is a nonpositive integer.\n"
    "\n"
    ">>> sc.hyp1f1(0.5, -1, 0)\n"
    "inf\n"
    "\n"
    "It is a polynomial when `a` is a nonpositive integer.\n"
    "\n"
    ">>> a, b, x = -1, 0.5, np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.hyp1f1(a, b, x)\n"
    "array([-1., -3., -5., -7.])\n"
    ">>> 1 + (a / b) * x\n"
    "array([-1., -3., -5., -7.])\n"
    "\n"
    "It reduces to the exponential function when ``a = b``.\n"
    "\n"
    ">>> sc.hyp1f1(2, 2, [1, 2, 3, 4])\n"
    "array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])\n"
    ">>> np.exp([1, 2, 3, 4])\n"
    "array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])")
ufunc_hyp1f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_hyp1f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_hyp1f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_hyp1f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_hyp1f1_types[0] = <char>NPY_FLOAT
ufunc_hyp1f1_types[1] = <char>NPY_FLOAT
ufunc_hyp1f1_types[2] = <char>NPY_FLOAT
ufunc_hyp1f1_types[3] = <char>NPY_FLOAT
ufunc_hyp1f1_types[4] = <char>NPY_FLOAT
ufunc_hyp1f1_types[5] = <char>NPY_FLOAT
ufunc_hyp1f1_types[6] = <char>NPY_CFLOAT
ufunc_hyp1f1_types[7] = <char>NPY_CFLOAT
ufunc_hyp1f1_types[8] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[9] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[10] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[11] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[12] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[13] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[14] = <char>NPY_CDOUBLE
ufunc_hyp1f1_types[15] = <char>NPY_CDOUBLE
ufunc_hyp1f1_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hyp1f1_double
ufunc_hyp1f1_ptr[2*0+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*1] = <void*>_func_chyp1f1_wrap
ufunc_hyp1f1_ptr[2*1+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_hyp1f1_double
ufunc_hyp1f1_ptr[2*2+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*3] = <void*>_func_chyp1f1_wrap
ufunc_hyp1f1_ptr[2*3+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_data[0] = &ufunc_hyp1f1_ptr[2*0]
ufunc_hyp1f1_data[1] = &ufunc_hyp1f1_ptr[2*1]
ufunc_hyp1f1_data[2] = &ufunc_hyp1f1_ptr[2*2]
ufunc_hyp1f1_data[3] = &ufunc_hyp1f1_ptr[2*3]
hyp1f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp1f1_loops, ufunc_hyp1f1_data, ufunc_hyp1f1_types, 4, 3, 1, 0, "hyp1f1", ufunc_hyp1f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyperu_loops[2]
cdef void *ufunc_hyperu_ptr[4]
cdef void *ufunc_hyperu_data[2]
cdef char ufunc_hyperu_types[8]
cdef char *ufunc_hyperu_doc = (
    "hyperu(a, b, x, out=None)\n"
    "\n"
    "Confluent hypergeometric function U\n"
    "\n"
    "It is defined as the solution to the equation\n"
    "\n"
    ".. math::\n"
    "\n"
    "   x \\frac{d^2w}{dx^2} + (b - x) \\frac{dw}{dx} - aw = 0\n"
    "\n"
    "which satisfies the property\n"
    "\n"
    ".. math::\n"
    "\n"
    "   U(a, b, x) \\sim x^{-a}\n"
    "\n"
    "as :math:`x \\to \\infty`. See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of `U`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematics Functions\n"
    "          https://dlmf.nist.gov/13.2#E6\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It has a branch cut along the negative `x` axis.\n"
    "\n"
    ">>> x = np.linspace(-0.1, -10, 5)\n"
    ">>> sc.hyperu(1, 1, x)\n"
    "array([nan, nan, nan, nan, nan])\n"
    "\n"
    "It approaches zero as `x` goes to infinity.\n"
    "\n"
    ">>> x = np.array([1, 10, 100])\n"
    ">>> sc.hyperu(1, 1, x)\n"
    "array([0.59634736, 0.09156333, 0.00990194])\n"
    "\n"
    "It satisfies Kummer's transformation.\n"
    "\n"
    ">>> a, b, x = 2, 1, 1\n"
    ">>> sc.hyperu(a, b, x)\n"
    "0.1926947246463881\n"
    ">>> x**(1 - b) * sc.hyperu(a - b + 1, 2 - b, x)\n"
    "0.1926947246463881")
ufunc_hyperu_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_hyperu_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_hyperu_types[0] = <char>NPY_FLOAT
ufunc_hyperu_types[1] = <char>NPY_FLOAT
ufunc_hyperu_types[2] = <char>NPY_FLOAT
ufunc_hyperu_types[3] = <char>NPY_FLOAT
ufunc_hyperu_types[4] = <char>NPY_DOUBLE
ufunc_hyperu_types[5] = <char>NPY_DOUBLE
ufunc_hyperu_types[6] = <char>NPY_DOUBLE
ufunc_hyperu_types[7] = <char>NPY_DOUBLE
ufunc_hyperu_ptr[2*0] = <void*>_func_hyperu
ufunc_hyperu_ptr[2*0+1] = <void*>(<char*>"hyperu")
ufunc_hyperu_ptr[2*1] = <void*>_func_hyperu
ufunc_hyperu_ptr[2*1+1] = <void*>(<char*>"hyperu")
ufunc_hyperu_data[0] = &ufunc_hyperu_ptr[2*0]
ufunc_hyperu_data[1] = &ufunc_hyperu_ptr[2*1]
hyperu = np.PyUFunc_FromFuncAndData(ufunc_hyperu_loops, ufunc_hyperu_data, ufunc_hyperu_types, 2, 3, 1, 0, "hyperu", ufunc_hyperu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_inv_boxcox_loops[2]
cdef void *ufunc_inv_boxcox_ptr[4]
cdef void *ufunc_inv_boxcox_data[2]
cdef char ufunc_inv_boxcox_types[6]
cdef char *ufunc_inv_boxcox_doc = (
    "inv_boxcox(y, lmbda, out=None)\n"
    "\n"
    "Compute the inverse of the Box-Cox transformation.\n"
    "\n"
    "Find ``x`` such that::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.16.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox, inv_boxcox\n"
    ">>> y = boxcox([1, 4, 10], 2.5)\n"
    ">>> inv_boxcox(y, 2.5)\n"
    "array([1., 4., 10.])")
ufunc_inv_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_inv_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_inv_boxcox_types[0] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[1] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[2] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_inv_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_inv_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_inv_boxcox_ptr[2*0] = <void*>_func_inv_boxcox
ufunc_inv_boxcox_ptr[2*0+1] = <void*>(<char*>"inv_boxcox")
ufunc_inv_boxcox_ptr[2*1] = <void*>_func_inv_boxcox
ufunc_inv_boxcox_ptr[2*1+1] = <void*>(<char*>"inv_boxcox")
ufunc_inv_boxcox_data[0] = &ufunc_inv_boxcox_ptr[2*0]
ufunc_inv_boxcox_data[1] = &ufunc_inv_boxcox_ptr[2*1]
inv_boxcox = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox_loops, ufunc_inv_boxcox_data, ufunc_inv_boxcox_types, 2, 2, 1, 0, "inv_boxcox", ufunc_inv_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_inv_boxcox1p_loops[2]
cdef void *ufunc_inv_boxcox1p_ptr[4]
cdef void *ufunc_inv_boxcox1p_data[2]
cdef char ufunc_inv_boxcox1p_types[6]
cdef char *ufunc_inv_boxcox1p_doc = (
    "inv_boxcox1p(y, lmbda, out=None)\n"
    "\n"
    "Compute the inverse of the Box-Cox transformation.\n"
    "\n"
    "Find ``x`` such that::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.16.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p, inv_boxcox1p\n"
    ">>> y = boxcox1p([1, 4, 10], 2.5)\n"
    ">>> inv_boxcox1p(y, 2.5)\n"
    "array([1., 4., 10.])")
ufunc_inv_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_inv_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_inv_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_ptr[2*0] = <void*>_func_inv_boxcox1p
ufunc_inv_boxcox1p_ptr[2*0+1] = <void*>(<char*>"inv_boxcox1p")
ufunc_inv_boxcox1p_ptr[2*1] = <void*>_func_inv_boxcox1p
ufunc_inv_boxcox1p_ptr[2*1+1] = <void*>(<char*>"inv_boxcox1p")
ufunc_inv_boxcox1p_data[0] = &ufunc_inv_boxcox1p_ptr[2*0]
ufunc_inv_boxcox1p_data[1] = &ufunc_inv_boxcox1p_ptr[2*1]
inv_boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox1p_loops, ufunc_inv_boxcox1p_data, ufunc_inv_boxcox1p_types, 2, 2, 1, 0, "inv_boxcox1p", ufunc_inv_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kl_div_loops[2]
cdef void *ufunc_kl_div_ptr[4]
cdef void *ufunc_kl_div_data[2]
cdef char ufunc_kl_div_types[6]
cdef char *ufunc_kl_div_doc = (
    "kl_div(x, y, out=None)\n"
    "\n"
    "Elementwise function for computing Kullback-Leibler divergence.\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{kl\\_div}(x, y) =\n"
    "      \\begin{cases}\n"
    "        x \\log(x / y) - x + y & x > 0, y > 0 \\\\\n"
    "        y & x = 0, y \\ge 0 \\\\\n"
    "        \\infty & \\text{otherwise}\n"
    "      \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y : array_like\n"
    "    Real arguments\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kullback-Liebler divergence.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "entr, rel_entr, scipy.stats.entropy\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "This function is non-negative and is jointly convex in `x` and `y`.\n"
    "\n"
    "The origin of this function is in convex programming; see [1]_ for\n"
    "details. This is why the function contains the extra :math:`-x\n"
    "+ y` terms over what might be expected from the Kullback-Leibler\n"
    "divergence. For a version of the function without the extra terms,\n"
    "see `rel_entr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n"
    "       Cambridge University Press, 2004.\n"
    "       :doi:`https://doi.org/10.1017/CBO9780511804441`")
ufunc_kl_div_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kl_div_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kl_div_types[0] = <char>NPY_FLOAT
ufunc_kl_div_types[1] = <char>NPY_FLOAT
ufunc_kl_div_types[2] = <char>NPY_FLOAT
ufunc_kl_div_types[3] = <char>NPY_DOUBLE
ufunc_kl_div_types[4] = <char>NPY_DOUBLE
ufunc_kl_div_types[5] = <char>NPY_DOUBLE
ufunc_kl_div_ptr[2*0] = <void*>_func_kl_div
ufunc_kl_div_ptr[2*0+1] = <void*>(<char*>"kl_div")
ufunc_kl_div_ptr[2*1] = <void*>_func_kl_div
ufunc_kl_div_ptr[2*1+1] = <void*>(<char*>"kl_div")
ufunc_kl_div_data[0] = &ufunc_kl_div_ptr[2*0]
ufunc_kl_div_data[1] = &ufunc_kl_div_ptr[2*1]
kl_div = np.PyUFunc_FromFuncAndData(ufunc_kl_div_loops, ufunc_kl_div_data, ufunc_kl_div_types, 2, 2, 1, 0, "kl_div", ufunc_kl_div_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kn_loops[3]
cdef void *ufunc_kn_ptr[6]
cdef void *ufunc_kn_data[3]
cdef char ufunc_kn_types[9]
cdef char *ufunc_kn_doc = (
    "kn(n, x, out=None)\n"
    "\n"
    "Modified Bessel function of the second kind of integer order `n`\n"
    "\n"
    "Returns the modified Bessel function of the second kind for integer order\n"
    "`n` at real `z`.\n"
    "\n"
    "These are also sometimes called functions of the third kind, Basset\n"
    "functions, or Macdonald functions.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like of int\n"
    "    Order of Bessel functions (floats will truncate with a warning)\n"
    "x : array_like of float\n"
    "    Argument at which to evaluate the Bessel functions\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the Modified Bessel function of the second kind,\n"
    "    :math:`K_n(x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv : Same function, but accepts real order and complex argument\n"
    "kvp : Derivative of this function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n"
    "algorithm used, see [2]_ and the references therein.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    ".. [2] Donald E. Amos, \"Algorithm 644: A portable package for Bessel\n"
    "       functions of a complex argument and nonnegative order\", ACM\n"
    "       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Plot the function of several orders for real input:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import kn\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0, 5, 1000)\n"
    ">>> for N in range(6):\n"
    "...     plt.plot(x, kn(N, x), label='$K_{}(x)$'.format(N))\n"
    ">>> plt.ylim(0, 10)\n"
    ">>> plt.legend()\n"
    ">>> plt.title(r'Modified Bessel function of the second kind $K_n(x)$')\n"
    ">>> plt.show()\n"
    "\n"
    "Calculate for a single value at multiple orders:\n"
    "\n"
    ">>> kn([4, 5, 6], 1)\n"
    "array([   44.23241585,   360.9605896 ,  3653.83831186])")
ufunc_kn_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_kn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kn_types[0] = <char>NPY_INTP
ufunc_kn_types[1] = <char>NPY_DOUBLE
ufunc_kn_types[2] = <char>NPY_DOUBLE
ufunc_kn_types[3] = <char>NPY_FLOAT
ufunc_kn_types[4] = <char>NPY_FLOAT
ufunc_kn_types[5] = <char>NPY_FLOAT
ufunc_kn_types[6] = <char>NPY_DOUBLE
ufunc_kn_types[7] = <char>NPY_DOUBLE
ufunc_kn_types[8] = <char>NPY_DOUBLE
ufunc_kn_ptr[2*0] = <void*>_func_special_cyl_bessel_k_int
ufunc_kn_ptr[2*0+1] = <void*>(<char*>"kn")
ufunc_kn_ptr[2*1] = <void*>_func_kn_unsafe
ufunc_kn_ptr[2*1+1] = <void*>(<char*>"kn")
ufunc_kn_ptr[2*2] = <void*>_func_kn_unsafe
ufunc_kn_ptr[2*2+1] = <void*>(<char*>"kn")
ufunc_kn_data[0] = &ufunc_kn_ptr[2*0]
ufunc_kn_data[1] = &ufunc_kn_ptr[2*1]
ufunc_kn_data[2] = &ufunc_kn_ptr[2*2]
kn = np.PyUFunc_FromFuncAndData(ufunc_kn_loops, ufunc_kn_data, ufunc_kn_types, 3, 2, 1, 0, "kn", ufunc_kn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kolmogi_loops[2]
cdef void *ufunc_kolmogi_ptr[4]
cdef void *ufunc_kolmogi_data[2]
cdef char ufunc_kolmogi_types[4]
cdef char *ufunc_kolmogi_doc = (
    "kolmogi(p, out=None)\n"
    "\n"
    "Inverse Survival Function of Kolmogorov distribution\n"
    "\n"
    "It is the inverse function to `kolmogorov`.\n"
    "Returns y such that ``kolmogorov(y) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : float array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of kolmogi(p)\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kolmogorov : The Survival Function for the distribution\n"
    "scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n"
    "smirnov, smirnovi : Functions for the one-sided distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`kolmogorov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.kstwobign` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import kolmogi\n"
    ">>> kolmogi([0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0])\n"
    "array([        inf,  1.22384787,  1.01918472,  0.82757356,  0.67644769,\n"
    "        0.57117327,  0.        ])")
ufunc_kolmogi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kolmogi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kolmogi_types[0] = <char>NPY_FLOAT
ufunc_kolmogi_types[1] = <char>NPY_FLOAT
ufunc_kolmogi_types[2] = <char>NPY_DOUBLE
ufunc_kolmogi_types[3] = <char>NPY_DOUBLE
ufunc_kolmogi_ptr[2*0] = <void*>_func_xsf_kolmogi
ufunc_kolmogi_ptr[2*0+1] = <void*>(<char*>"kolmogi")
ufunc_kolmogi_ptr[2*1] = <void*>_func_xsf_kolmogi
ufunc_kolmogi_ptr[2*1+1] = <void*>(<char*>"kolmogi")
ufunc_kolmogi_data[0] = &ufunc_kolmogi_ptr[2*0]
ufunc_kolmogi_data[1] = &ufunc_kolmogi_ptr[2*1]
kolmogi = np.PyUFunc_FromFuncAndData(ufunc_kolmogi_loops, ufunc_kolmogi_data, ufunc_kolmogi_types, 2, 1, 1, 0, "kolmogi", ufunc_kolmogi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kolmogorov_loops[2]
cdef void *ufunc_kolmogorov_ptr[4]
cdef void *ufunc_kolmogorov_data[2]
cdef char ufunc_kolmogorov_types[4]
cdef char *ufunc_kolmogorov_doc = (
    "kolmogorov(y, out=None)\n"
    "\n"
    "Complementary cumulative distribution (Survival Function) function of\n"
    "Kolmogorov distribution.\n"
    "\n"
    "Returns the complementary cumulative distribution function of\n"
    "Kolmogorov's limiting distribution (``D_n*\\sqrt(n)`` as n goes to infinity)\n"
    "of a two-sided test for equality between an empirical and a theoretical\n"
    "distribution. It is equal to the (limit as n->infinity of the)\n"
    "probability that ``sqrt(n) * max absolute deviation > y``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : float array_like\n"
    "  Absolute deviation between the Empirical CDF (ECDF) and the target CDF,\n"
    "  multiplied by sqrt(n).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of kolmogorov(y)\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kolmogi : The Inverse Survival Function for the distribution\n"
    "scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n"
    "smirnov, smirnovi : Functions for the one-sided distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`kolmogorov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.kstwobign` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Show the probability of a gap at least as big as 0, 0.5 and 1.0.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import kolmogorov\n"
    ">>> from scipy.stats import kstwobign\n"
    ">>> kolmogorov([0, 0.5, 1.0])\n"
    "array([ 1.        ,  0.96394524,  0.26999967])\n"
    "\n"
    "Compare a sample of size 1000 drawn from a Laplace(0, 1) distribution against\n"
    "the target distribution, a Normal(0, 1) distribution.\n"
    "\n"
    ">>> from scipy.stats import norm, laplace\n"
    ">>> rng = np.random.default_rng()\n"
    ">>> n = 1000\n"
    ">>> lap01 = laplace(0, 1)\n"
    ">>> x = np.sort(lap01.rvs(n, random_state=rng))\n"
    ">>> np.mean(x), np.std(x)\n"
    "(-0.05841730131499543, 1.3968109101997568)\n"
    "\n"
    "Construct the Empirical CDF and the K-S statistic Dn.\n"
    "\n"
    ">>> target = norm(0,1)  # Normal mean 0, stddev 1\n"
    ">>> cdfs = target.cdf(x)\n"
    ">>> ecdfs = np.arange(n+1, dtype=float)/n\n"
    ">>> gaps = np.column_stack([cdfs - ecdfs[:n], ecdfs[1:] - cdfs])\n"
    ">>> Dn = np.max(gaps)\n"
    ">>> Kn = np.sqrt(n) * Dn\n"
    ">>> print('Dn=%f, sqrt(n)*Dn=%f' % (Dn, Kn))\n"
    "Dn=0.043363, sqrt(n)*Dn=1.371265\n"
    ">>> print(chr(10).join(['For a sample of size n drawn from a N(0, 1) distribution:',\n"
    "...   ' the approximate Kolmogorov probability that sqrt(n)*Dn>=%f is %f' %\n"
    "...    (Kn, kolmogorov(Kn)),\n"
    "...   ' the approximate Kolmogorov probability that sqrt(n)*Dn<=%f is %f' %\n"
    "...    (Kn, kstwobign.cdf(Kn))]))\n"
    "For a sample of size n drawn from a N(0, 1) distribution:\n"
    " the approximate Kolmogorov probability that sqrt(n)*Dn>=1.371265 is 0.046533\n"
    " the approximate Kolmogorov probability that sqrt(n)*Dn<=1.371265 is 0.953467\n"
    "\n"
    "Plot the Empirical CDF against the target N(0, 1) CDF.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')\n"
    ">>> x3 = np.linspace(-3, 3, 100)\n"
    ">>> plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')\n"
    ">>> plt.ylim([0, 1]); plt.grid(True); plt.legend();\n"
    ">>> # Add vertical lines marking Dn+ and Dn-\n"
    ">>> iminus, iplus = np.argmax(gaps, axis=0)\n"
    ">>> plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus],\n"
    "...            color='r', linestyle='dashed', lw=4)\n"
    ">>> plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1],\n"
    "...            color='r', linestyle='dashed', lw=4)\n"
    ">>> plt.show()")
ufunc_kolmogorov_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kolmogorov_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kolmogorov_types[0] = <char>NPY_FLOAT
ufunc_kolmogorov_types[1] = <char>NPY_FLOAT
ufunc_kolmogorov_types[2] = <char>NPY_DOUBLE
ufunc_kolmogorov_types[3] = <char>NPY_DOUBLE
ufunc_kolmogorov_ptr[2*0] = <void*>_func_xsf_kolmogorov
ufunc_kolmogorov_ptr[2*0+1] = <void*>(<char*>"kolmogorov")
ufunc_kolmogorov_ptr[2*1] = <void*>_func_xsf_kolmogorov
ufunc_kolmogorov_ptr[2*1+1] = <void*>(<char*>"kolmogorov")
ufunc_kolmogorov_data[0] = &ufunc_kolmogorov_ptr[2*0]
ufunc_kolmogorov_data[1] = &ufunc_kolmogorov_ptr[2*1]
kolmogorov = np.PyUFunc_FromFuncAndData(ufunc_kolmogorov_loops, ufunc_kolmogorov_data, ufunc_kolmogorov_types, 2, 1, 1, 0, "kolmogorov", ufunc_kolmogorov_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_log1p_loops[4]
cdef void *ufunc_log1p_ptr[8]
cdef void *ufunc_log1p_data[4]
cdef char ufunc_log1p_types[8]
cdef char *ufunc_log1p_doc = (
    "log1p(x, out=None)\n"
    "\n"
    "Calculates log(1 + x) for use when `x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex valued input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of ``log(1 + x)``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expm1, cosm1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using ``log(1 + x)`` directly for ``x``\n"
    "near 0. Note that in the below example ``1 + 1e-17 == 1`` to\n"
    "double precision.\n"
    "\n"
    ">>> sc.log1p(1e-17)\n"
    "1e-17\n"
    ">>> np.log(1 + 1e-17)\n"
    "0.0")
ufunc_log1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_log1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_log1p_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_log1p_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_log1p_types[0] = <char>NPY_FLOAT
ufunc_log1p_types[1] = <char>NPY_FLOAT
ufunc_log1p_types[2] = <char>NPY_DOUBLE
ufunc_log1p_types[3] = <char>NPY_DOUBLE
ufunc_log1p_types[4] = <char>NPY_CFLOAT
ufunc_log1p_types[5] = <char>NPY_CFLOAT
ufunc_log1p_types[6] = <char>NPY_CDOUBLE
ufunc_log1p_types[7] = <char>NPY_CDOUBLE
ufunc_log1p_ptr[2*0] = <void*>_func_cephes_log1p
ufunc_log1p_ptr[2*0+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*1] = <void*>_func_cephes_log1p
ufunc_log1p_ptr[2*1+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*2] = <void*>_func_clog1p
ufunc_log1p_ptr[2*2+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*3] = <void*>_func_clog1p
ufunc_log1p_ptr[2*3+1] = <void*>(<char*>"log1p")
ufunc_log1p_data[0] = &ufunc_log1p_ptr[2*0]
ufunc_log1p_data[1] = &ufunc_log1p_ptr[2*1]
ufunc_log1p_data[2] = &ufunc_log1p_ptr[2*2]
ufunc_log1p_data[3] = &ufunc_log1p_ptr[2*3]
log1p = np.PyUFunc_FromFuncAndData(ufunc_log1p_loops, ufunc_log1p_data, ufunc_log1p_types, 4, 1, 1, 0, "log1p", ufunc_log1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_log_ndtr_loops[4]
cdef void *ufunc_log_ndtr_ptr[8]
cdef void *ufunc_log_ndtr_data[4]
cdef char ufunc_log_ndtr_types[8]
cdef char *ufunc_log_ndtr_doc = (
    "log_ndtr(x, out=None)\n"
    "\n"
    "Logarithm of Gaussian cumulative distribution function.\n"
    "\n"
    "Returns the log of the area under the standard Gaussian probability\n"
    "density function, integrated from minus infinity to `x`::\n"
    "\n"
    "    log(1/sqrt(2*pi) * integral(exp(-t**2 / 2), t=-inf..x))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like, real or complex\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value of the log of the normal CDF evaluated at `x`\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf\n"
    "erfc\n"
    "scipy.stats.norm\n"
    "ndtr\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import log_ndtr, ndtr\n"
    "\n"
    "The benefit of ``log_ndtr(x)`` over the naive implementation\n"
    "``np.log(ndtr(x))`` is most evident with moderate to large positive\n"
    "values of ``x``:\n"
    "\n"
    ">>> x = np.array([6, 7, 9, 12, 15, 25])\n"
    ">>> log_ndtr(x)\n"
    "array([-9.86587646e-010, -1.27981254e-012, -1.12858841e-019,\n"
    "       -1.77648211e-033, -3.67096620e-051, -3.05669671e-138])\n"
    "\n"
    "The results of the naive calculation for the moderate ``x`` values\n"
    "have only 5 or 6 correct significant digits. For values of ``x``\n"
    "greater than approximately 8.3, the naive expression returns 0:\n"
    "\n"
    ">>> np.log(ndtr(x))\n"
    "array([-9.86587701e-10, -1.27986510e-12,  0.00000000e+00,\n"
    "        0.00000000e+00,  0.00000000e+00,  0.00000000e+00])")
ufunc_log_ndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_log_ndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_log_ndtr_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_log_ndtr_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_log_ndtr_types[0] = <char>NPY_FLOAT
ufunc_log_ndtr_types[1] = <char>NPY_FLOAT
ufunc_log_ndtr_types[2] = <char>NPY_DOUBLE
ufunc_log_ndtr_types[3] = <char>NPY_DOUBLE
ufunc_log_ndtr_types[4] = <char>NPY_CFLOAT
ufunc_log_ndtr_types[5] = <char>NPY_CFLOAT
ufunc_log_ndtr_types[6] = <char>NPY_CDOUBLE
ufunc_log_ndtr_types[7] = <char>NPY_CDOUBLE
ufunc_log_ndtr_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr
ufunc_log_ndtr_ptr[2*0+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr
ufunc_log_ndtr_ptr[2*1+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex
ufunc_log_ndtr_ptr[2*2+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex
ufunc_log_ndtr_ptr[2*3+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_data[0] = &ufunc_log_ndtr_ptr[2*0]
ufunc_log_ndtr_data[1] = &ufunc_log_ndtr_ptr[2*1]
ufunc_log_ndtr_data[2] = &ufunc_log_ndtr_ptr[2*2]
ufunc_log_ndtr_data[3] = &ufunc_log_ndtr_ptr[2*3]
log_ndtr = np.PyUFunc_FromFuncAndData(ufunc_log_ndtr_loops, ufunc_log_ndtr_data, ufunc_log_ndtr_types, 4, 1, 1, 0, "log_ndtr", ufunc_log_ndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_lpmv_loops[2]
cdef void *ufunc_lpmv_ptr[4]
cdef void *ufunc_lpmv_data[2]
cdef char ufunc_lpmv_types[8]
cdef char *ufunc_lpmv_doc = (
    "lpmv(m, v, x, out=None)\n"
    "\n"
    "Associated Legendre function of integer order and real degree.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_v^m = (-1)^m (1 - x^2)^{m/2} \\frac{d^m}{dx^m} P_v(x)\n"
    "\n"
    "where\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_v = \\sum_{k = 0}^\\infty \\frac{(-v)_k (v + 1)_k}{(k!)^2}\n"
    "            \\left(\\frac{1 - x}{2}\\right)^k\n"
    "\n"
    "is the Legendre function of the first kind. Here :math:`(\\cdot)_k`\n"
    "is the Pochhammer symbol; see `poch`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order (int or float). If passed a float not equal to an\n"
    "    integer the function returns NaN.\n"
    "v : array_like\n"
    "    Degree (float).\n"
    "x : array_like\n"
    "    Argument (float). Must have ``|x| <= 1``.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "pmv : scalar or ndarray\n"
    "    Value of the associated Legendre function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "lpmn : Compute the associated Legendre function for all orders\n"
    "       ``0, ..., m`` and degrees ``0, ..., n``.\n"
    "clpmn : Compute the associated Legendre function at complex\n"
    "        arguments.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Note that this implementation includes the Condon-Shortley phase.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Jin, \"Computation of Special Functions\", John Wiley\n"
    "       and Sons, Inc, 1996.")
ufunc_lpmv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_lpmv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_lpmv_types[0] = <char>NPY_FLOAT
ufunc_lpmv_types[1] = <char>NPY_FLOAT
ufunc_lpmv_types[2] = <char>NPY_FLOAT
ufunc_lpmv_types[3] = <char>NPY_FLOAT
ufunc_lpmv_types[4] = <char>NPY_DOUBLE
ufunc_lpmv_types[5] = <char>NPY_DOUBLE
ufunc_lpmv_types[6] = <char>NPY_DOUBLE
ufunc_lpmv_types[7] = <char>NPY_DOUBLE
ufunc_lpmv_ptr[2*0] = <void*>_func_pmv_wrap
ufunc_lpmv_ptr[2*0+1] = <void*>(<char*>"lpmv")
ufunc_lpmv_ptr[2*1] = <void*>_func_pmv_wrap
ufunc_lpmv_ptr[2*1+1] = <void*>(<char*>"lpmv")
ufunc_lpmv_data[0] = &ufunc_lpmv_ptr[2*0]
ufunc_lpmv_data[1] = &ufunc_lpmv_ptr[2*1]
lpmv = np.PyUFunc_FromFuncAndData(ufunc_lpmv_loops, ufunc_lpmv_data, ufunc_lpmv_types, 2, 3, 1, 0, "lpmv", ufunc_lpmv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtr_loops[3]
cdef void *ufunc_nbdtr_ptr[6]
cdef void *ufunc_nbdtr_data[3]
cdef char ufunc_nbdtr_types[12]
cdef char *ufunc_nbdtr_doc = (
    "nbdtr(k, n, p, out=None)\n"
    "\n"
    "Negative binomial cumulative distribution function.\n"
    "\n"
    "Returns the sum of the terms 0 through `k` of the negative binomial\n"
    "distribution probability mass function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\sum_{j=0}^k {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n"
    "\n"
    "In a sequence of Bernoulli trials with individual success probabilities\n"
    "`p`, this is the probability that `k` or fewer failures precede the nth\n"
    "success.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The probability of `k` or fewer failures before `n` successes in a\n"
    "    sequence of events with individual success probability `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtrc : Negative binomial survival function\n"
    "nbdtrik : Negative binomial quantile function\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "If floating point values are passed for `k` or `n`, they will be truncated\n"
    "to integers.\n"
    "\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `nbdtr`.\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtr` directly can improve performance\n"
    "compared to the ``cdf`` method of `scipy.stats.nbinom` (see last example).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtr\n"
    ">>> nbdtr(10, 5, 0.5)\n"
    "0.940765380859375\n"
    "\n"
    "Compute the function for ``n=10`` and ``p=0.5`` at several points by\n"
    "providing a NumPy array or list for `k`.\n"
    "\n"
    ">>> nbdtr([5, 10, 15], 10, 0.5)\n"
    "array([0.15087891, 0.58809853, 0.88523853])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> k = np.arange(130)\n"
    ">>> n_parameters = [20, 20, 20, 80]\n"
    ">>> p_parameters = [0.2, 0.5, 0.8, 0.5]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(p_parameters, n_parameters,\n"
    "...                            linestyles))\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     p, n, style = parameter_set\n"
    "...     nbdtr_vals = nbdtr(k, n, p)\n"
    "...     ax.plot(k, nbdtr_vals, label=rf\"$n={n},\\, p={p}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$k$\")\n"
    ">>> ax.set_title(\"Negative binomial cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtr` directly can be much faster than\n"
    "calling the ``cdf`` method of `scipy.stats.nbinom`, especially for small\n"
    "arrays or individual values. To get the same results one must use the\n"
    "following parametrization: ``nbinom(n, p).cdf(k)=nbdtr(k, n, p)``.\n"
    "\n"
    ">>> from scipy.stats import nbinom\n"
    ">>> k, n, p = 5, 3, 0.5\n"
    ">>> nbdtr_res = nbdtr(k, n, p)  # this will often be faster than below\n"
    ">>> stats_res = nbinom(n, p).cdf(k)\n"
    ">>> stats_res, nbdtr_res  # test that results are equal\n"
    "(0.85546875, 0.85546875)\n"
    "\n"
    "`nbdtr` can evaluate different parameter sets by providing arrays with\n"
    "shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n"
    "the function for three different `k` at four locations `p`, resulting in\n"
    "a 3x4 array.\n"
    "\n"
    ">>> k = np.array([[5], [10], [15]])\n"
    ">>> p = np.array([0.3, 0.5, 0.7, 0.9])\n"
    ">>> k.shape, p.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> nbdtr(k, 5, p)\n"
    "array([[0.15026833, 0.62304687, 0.95265101, 0.9998531 ],\n"
    "       [0.48450894, 0.94076538, 0.99932777, 0.99999999],\n"
    "       [0.76249222, 0.99409103, 0.99999445, 1.        ]])")
ufunc_nbdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ppd__As_ppd_d
ufunc_nbdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtr_types[0] = <char>NPY_INTP
ufunc_nbdtr_types[1] = <char>NPY_INTP
ufunc_nbdtr_types[2] = <char>NPY_DOUBLE
ufunc_nbdtr_types[3] = <char>NPY_DOUBLE
ufunc_nbdtr_types[4] = <char>NPY_FLOAT
ufunc_nbdtr_types[5] = <char>NPY_FLOAT
ufunc_nbdtr_types[6] = <char>NPY_FLOAT
ufunc_nbdtr_types[7] = <char>NPY_FLOAT
ufunc_nbdtr_types[8] = <char>NPY_DOUBLE
ufunc_nbdtr_types[9] = <char>NPY_DOUBLE
ufunc_nbdtr_types[10] = <char>NPY_DOUBLE
ufunc_nbdtr_types[11] = <char>NPY_DOUBLE
ufunc_nbdtr_ptr[2*0] = <void*>_func_cephes_nbdtr_wrap
ufunc_nbdtr_ptr[2*0+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_ptr[2*1] = <void*>_func_nbdtr_unsafe
ufunc_nbdtr_ptr[2*1+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_ptr[2*2] = <void*>_func_nbdtr_unsafe
ufunc_nbdtr_ptr[2*2+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_data[0] = &ufunc_nbdtr_ptr[2*0]
ufunc_nbdtr_data[1] = &ufunc_nbdtr_ptr[2*1]
ufunc_nbdtr_data[2] = &ufunc_nbdtr_ptr[2*2]
nbdtr = np.PyUFunc_FromFuncAndData(ufunc_nbdtr_loops, ufunc_nbdtr_data, ufunc_nbdtr_types, 3, 3, 1, 0, "nbdtr", ufunc_nbdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrc_loops[3]
cdef void *ufunc_nbdtrc_ptr[6]
cdef void *ufunc_nbdtrc_data[3]
cdef char ufunc_nbdtrc_types[12]
cdef char *ufunc_nbdtrc_doc = (
    "nbdtrc(k, n, p, out=None)\n"
    "\n"
    "Negative binomial survival function.\n"
    "\n"
    "Returns the sum of the terms `k + 1` to infinity of the negative binomial\n"
    "distribution probability mass function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n"
    "\n"
    "In a sequence of Bernoulli trials with individual success probabilities\n"
    "`p`, this is the probability that more than `k` failures precede the nth\n"
    "success.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The probability of `k + 1` or more failures before `n` successes in a\n"
    "    sequence of events with individual success probability `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Negative binomial cumulative distribution function\n"
    "nbdtrik : Negative binomial percentile function\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "If floating point values are passed for `k` or `n`, they will be truncated\n"
    "to integers.\n"
    "\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `nbdtrc`.\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtrc` directly can improve performance\n"
    "compared to the ``sf`` method of `scipy.stats.nbinom` (see last example).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtrc\n"
    ">>> nbdtrc(10, 5, 0.5)\n"
    "0.059234619140624986\n"
    "\n"
    "Compute the function for ``n=10`` and ``p=0.5`` at several points by\n"
    "providing a NumPy array or list for `k`.\n"
    "\n"
    ">>> nbdtrc([5, 10, 15], 10, 0.5)\n"
    "array([0.84912109, 0.41190147, 0.11476147])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> k = np.arange(130)\n"
    ">>> n_parameters = [20, 20, 20, 80]\n"
    ">>> p_parameters = [0.2, 0.5, 0.8, 0.5]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(p_parameters, n_parameters,\n"
    "...                            linestyles))\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     p, n, style = parameter_set\n"
    "...     nbdtrc_vals = nbdtrc(k, n, p)\n"
    "...     ax.plot(k, nbdtrc_vals, label=rf\"$n={n},\\, p={p}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$k$\")\n"
    ">>> ax.set_title(\"Negative binomial distribution survival function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtrc` directly can be much faster than\n"
    "calling the ``sf`` method of `scipy.stats.nbinom`, especially for small\n"
    "arrays or individual values. To get the same results one must use the\n"
    "following parametrization: ``nbinom(n, p).sf(k)=nbdtrc(k, n, p)``.\n"
    "\n"
    ">>> from scipy.stats import nbinom\n"
    ">>> k, n, p = 3, 5, 0.5\n"
    ">>> nbdtr_res = nbdtrc(k, n, p)  # this will often be faster than below\n"
    ">>> stats_res = nbinom(n, p).sf(k)\n"
    ">>> stats_res, nbdtr_res  # test that results are equal\n"
    "(0.6367187499999999, 0.6367187499999999)\n"
    "\n"
    "`nbdtrc` can evaluate different parameter sets by providing arrays with\n"
    "shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n"
    "the function for three different `k` at four locations `p`, resulting in\n"
    "a 3x4 array.\n"
    "\n"
    ">>> k = np.array([[5], [10], [15]])\n"
    ">>> p = np.array([0.3, 0.5, 0.7, 0.9])\n"
    ">>> k.shape, p.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> nbdtrc(k, 5, p)\n"
    "array([[8.49731667e-01, 3.76953125e-01, 4.73489874e-02, 1.46902600e-04],\n"
    "       [5.15491059e-01, 5.92346191e-02, 6.72234070e-04, 9.29610100e-09],\n"
    "       [2.37507779e-01, 5.90896606e-03, 5.55025308e-06, 3.26346760e-13]])")
ufunc_nbdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ppd__As_ppd_d
ufunc_nbdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrc_types[0] = <char>NPY_INTP
ufunc_nbdtrc_types[1] = <char>NPY_INTP
ufunc_nbdtrc_types[2] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[3] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[4] = <char>NPY_FLOAT
ufunc_nbdtrc_types[5] = <char>NPY_FLOAT
ufunc_nbdtrc_types[6] = <char>NPY_FLOAT
ufunc_nbdtrc_types[7] = <char>NPY_FLOAT
ufunc_nbdtrc_types[8] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[9] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[10] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[11] = <char>NPY_DOUBLE
ufunc_nbdtrc_ptr[2*0] = <void*>_func_cephes_nbdtrc_wrap
ufunc_nbdtrc_ptr[2*0+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_ptr[2*1] = <void*>_func_nbdtrc_unsafe
ufunc_nbdtrc_ptr[2*1+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_ptr[2*2] = <void*>_func_nbdtrc_unsafe
ufunc_nbdtrc_ptr[2*2+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_data[0] = &ufunc_nbdtrc_ptr[2*0]
ufunc_nbdtrc_data[1] = &ufunc_nbdtrc_ptr[2*1]
ufunc_nbdtrc_data[2] = &ufunc_nbdtrc_ptr[2*2]
nbdtrc = np.PyUFunc_FromFuncAndData(ufunc_nbdtrc_loops, ufunc_nbdtrc_data, ufunc_nbdtrc_types, 3, 3, 1, 0, "nbdtrc", ufunc_nbdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtri_loops[3]
cdef void *ufunc_nbdtri_ptr[6]
cdef void *ufunc_nbdtri_data[3]
cdef char ufunc_nbdtri_types[12]
cdef char *ufunc_nbdtri_doc = (
    "nbdtri(k, n, y, out=None)\n"
    "\n"
    "Returns the inverse with respect to the parameter `p` of\n"
    "``y = nbdtr(k, n, p)``, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : scalar or ndarray\n"
    "    Probability of success in a single event (float) such that\n"
    "    `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtrc : Negative binomial survival function.\n"
    "scipy.stats.nbinom : negative binomial distribution.\n"
    "nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n"
    "nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `nbdtri`.\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtri` directly can improve performance\n"
    "compared to the ``ppf`` method of `scipy.stats.nbinom`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`nbdtri` is the inverse of `nbdtr` with respect to `p`.\n"
    "Up to floating point errors the following holds:\n"
    "``nbdtri(k, n, nbdtr(k, n, p))=p``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtri, nbdtr\n"
    ">>> k, n, y = 5, 10, 0.2\n"
    ">>> cdf_val = nbdtr(k, n, y)\n"
    ">>> nbdtri(k, n, cdf_val)\n"
    "0.20000000000000004\n"
    "\n"
    "Compute the function for ``k=10`` and ``n=5`` at several points by\n"
    "providing a NumPy array or list for `y`.\n"
    "\n"
    ">>> y = np.array([0.1, 0.4, 0.8])\n"
    ">>> nbdtri(3, 5, y)\n"
    "array([0.34462319, 0.51653095, 0.69677416])\n"
    "\n"
    "Plot the function for three different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> n_parameters = [5, 20, 30, 30]\n"
    ">>> k_parameters = [20, 20, 60, 80]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(n_parameters, k_parameters, linestyles))\n"
    ">>> cdf_vals = np.linspace(0, 1, 1000)\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     n, k, style = parameter_set\n"
    "...     nbdtri_vals = nbdtri(k, n, cdf_vals)\n"
    "...     ax.plot(cdf_vals, nbdtri_vals, label=rf\"$k={k},\\ n={n}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylabel(\"$p$\")\n"
    ">>> ax.set_xlabel(\"$CDF$\")\n"
    ">>> title = \"nbdtri: inverse of negative binomial CDF with respect to $p$\"\n"
    ">>> ax.set_title(title)\n"
    ">>> plt.show()\n"
    "\n"
    "`nbdtri` can evaluate different parameter sets by providing arrays with\n"
    "shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n"
    "the function for three different `k` at four locations `p`, resulting in\n"
    "a 3x4 array.\n"
    "\n"
    ">>> k = np.array([[5], [10], [15]])\n"
    ">>> y = np.array([0.3, 0.5, 0.7, 0.9])\n"
    ">>> k.shape, y.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> nbdtri(k, 5, y)\n"
    "array([[0.37258157, 0.45169416, 0.53249956, 0.64578407],\n"
    "       [0.24588501, 0.30451981, 0.36778453, 0.46397088],\n"
    "       [0.18362101, 0.22966758, 0.28054743, 0.36066188]])")
ufunc_nbdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ppd__As_ppd_d
ufunc_nbdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtri_types[0] = <char>NPY_INTP
ufunc_nbdtri_types[1] = <char>NPY_INTP
ufunc_nbdtri_types[2] = <char>NPY_DOUBLE
ufunc_nbdtri_types[3] = <char>NPY_DOUBLE
ufunc_nbdtri_types[4] = <char>NPY_FLOAT
ufunc_nbdtri_types[5] = <char>NPY_FLOAT
ufunc_nbdtri_types[6] = <char>NPY_FLOAT
ufunc_nbdtri_types[7] = <char>NPY_FLOAT
ufunc_nbdtri_types[8] = <char>NPY_DOUBLE
ufunc_nbdtri_types[9] = <char>NPY_DOUBLE
ufunc_nbdtri_types[10] = <char>NPY_DOUBLE
ufunc_nbdtri_types[11] = <char>NPY_DOUBLE
ufunc_nbdtri_ptr[2*0] = <void*>_func_cephes_nbdtri_wrap
ufunc_nbdtri_ptr[2*0+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_ptr[2*1] = <void*>_func_nbdtri_unsafe
ufunc_nbdtri_ptr[2*1+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_ptr[2*2] = <void*>_func_nbdtri_unsafe
ufunc_nbdtri_ptr[2*2+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_data[0] = &ufunc_nbdtri_ptr[2*0]
ufunc_nbdtri_data[1] = &ufunc_nbdtri_ptr[2*1]
ufunc_nbdtri_data[2] = &ufunc_nbdtri_ptr[2*2]
nbdtri = np.PyUFunc_FromFuncAndData(ufunc_nbdtri_loops, ufunc_nbdtri_data, ufunc_nbdtri_types, 3, 3, 1, 0, "nbdtri", ufunc_nbdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrik_loops[2]
cdef void *ufunc_nbdtrik_ptr[4]
cdef void *ufunc_nbdtrik_data[2]
cdef char ufunc_nbdtrik_types[8]
cdef char *ufunc_nbdtrik_doc = (
    "nbdtrik(y, n, p, out=None)\n"
    "\n"
    "Negative binomial percentile function.\n"
    "\n"
    "Returns the inverse with respect to the parameter `k` of\n"
    "``y = nbdtr(k, n, p)``, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : scalar or ndarray\n"
    "    The maximum number of allowed failures such that `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtrc : Survival function of the negative binomial.\n"
    "nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n"
    "nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n"
    "\n"
    "Formula 26.5.26 of [2]_,\n"
    "\n"
    ".. math::\n"
    "    \\sum_{j=k + 1}^\\infty {{n + j - 1}\n"
    "    \\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n"
    "\n"
    "is used to reduce calculation of the cumulative distribution function to\n"
    "that of a regularized incomplete beta :math:`I`.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the negative binomial cumulative distribution function for an\n"
    "exemplary parameter set.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtr, nbdtrik\n"
    ">>> k, n, p = 5, 2, 0.5\n"
    ">>> cdf_value = nbdtr(k, n, p)\n"
    ">>> cdf_value\n"
    "0.9375\n"
    "\n"
    "Verify that `nbdtrik` recovers the original value for `k`.\n"
    "\n"
    ">>> nbdtrik(cdf_value, n, p)\n"
    "5.0\n"
    "\n"
    "Plot the function for different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> p_parameters = [0.2, 0.5, 0.7, 0.5]\n"
    ">>> n_parameters = [30, 30, 30, 80]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(p_parameters, n_parameters, linestyles))\n"
    ">>> cdf_vals = np.linspace(0, 1, 1000)\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     p, n, style = parameter_set\n"
    "...     nbdtrik_vals = nbdtrik(cdf_vals, n, p)\n"
    "...     ax.plot(cdf_vals, nbdtrik_vals, label=rf\"$n={n},\\ p={p}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylabel(\"$k$\")\n"
    ">>> ax.set_xlabel(\"$CDF$\")\n"
    ">>> ax.set_title(\"Negative binomial percentile function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. The percentile function  method ``ppf``\n"
    "returns the result of `nbdtrik` rounded up to integers:\n"
    "\n"
    ">>> from scipy.stats import nbinom\n"
    ">>> q, n, p = 0.6, 5, 0.5\n"
    ">>> nbinom.ppf(q, n, p), nbdtrik(q, n, p)\n"
    "(5.0, 4.800428460273882)")
ufunc_nbdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrik_types[0] = <char>NPY_FLOAT
ufunc_nbdtrik_types[1] = <char>NPY_FLOAT
ufunc_nbdtrik_types[2] = <char>NPY_FLOAT
ufunc_nbdtrik_types[3] = <char>NPY_FLOAT
ufunc_nbdtrik_types[4] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[5] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[6] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[7] = <char>NPY_DOUBLE
ufunc_nbdtrik_ptr[2*0] = <void*>_func_nbdtrik
ufunc_nbdtrik_ptr[2*0+1] = <void*>(<char*>"nbdtrik")
ufunc_nbdtrik_ptr[2*1] = <void*>_func_nbdtrik
ufunc_nbdtrik_ptr[2*1+1] = <void*>(<char*>"nbdtrik")
ufunc_nbdtrik_data[0] = &ufunc_nbdtrik_ptr[2*0]
ufunc_nbdtrik_data[1] = &ufunc_nbdtrik_ptr[2*1]
nbdtrik = np.PyUFunc_FromFuncAndData(ufunc_nbdtrik_loops, ufunc_nbdtrik_data, ufunc_nbdtrik_types, 2, 3, 1, 0, "nbdtrik", ufunc_nbdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrin_loops[2]
cdef void *ufunc_nbdtrin_ptr[4]
cdef void *ufunc_nbdtrin_data[2]
cdef char ufunc_nbdtrin_types[8]
cdef char *ufunc_nbdtrin_doc = (
    "nbdtrin(k, y, p, out=None)\n"
    "\n"
    "Inverse of `nbdtr` vs `n`.\n"
    "\n"
    "Returns the inverse with respect to the parameter `n` of\n"
    "``y = nbdtr(k, n, p)``, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : scalar or ndarray\n"
    "    The number of successes `n` such that `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n"
    "nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n"
    "\n"
    "Formula 26.5.26 of [2]_,\n"
    "\n"
    ".. math::\n"
    "    \\sum_{j=k + 1}^\\infty {{n + j - 1}\n"
    "    \\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n"
    "\n"
    "is used to reduce calculation of the cumulative distribution function to\n"
    "that of a regularized incomplete beta :math:`I`.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the negative binomial cumulative distribution function for an\n"
    "exemplary parameter set.\n"
    "\n"
    ">>> from scipy.special import nbdtr, nbdtrin\n"
    ">>> k, n, p = 5, 2, 0.5\n"
    ">>> cdf_value = nbdtr(k, n, p)\n"
    ">>> cdf_value\n"
    "0.9375\n"
    "\n"
    "Verify that `nbdtrin` recovers the original value for `n` up to floating\n"
    "point accuracy.\n"
    "\n"
    ">>> nbdtrin(k, cdf_value, p)\n"
    "1.999999999998137")
ufunc_nbdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrin_types[0] = <char>NPY_FLOAT
ufunc_nbdtrin_types[1] = <char>NPY_FLOAT
ufunc_nbdtrin_types[2] = <char>NPY_FLOAT
ufunc_nbdtrin_types[3] = <char>NPY_FLOAT
ufunc_nbdtrin_types[4] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[5] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[6] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[7] = <char>NPY_DOUBLE
ufunc_nbdtrin_ptr[2*0] = <void*>_func_nbdtrin
ufunc_nbdtrin_ptr[2*0+1] = <void*>(<char*>"nbdtrin")
ufunc_nbdtrin_ptr[2*1] = <void*>_func_nbdtrin
ufunc_nbdtrin_ptr[2*1+1] = <void*>(<char*>"nbdtrin")
ufunc_nbdtrin_data[0] = &ufunc_nbdtrin_ptr[2*0]
ufunc_nbdtrin_data[1] = &ufunc_nbdtrin_ptr[2*1]
nbdtrin = np.PyUFunc_FromFuncAndData(ufunc_nbdtrin_loops, ufunc_nbdtrin_data, ufunc_nbdtrin_types, 2, 3, 1, 0, "nbdtrin", ufunc_nbdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtr_loops[2]
cdef void *ufunc_ncfdtr_ptr[4]
cdef void *ufunc_ncfdtr_data[2]
cdef char ufunc_ncfdtr_types[10]
cdef char *ufunc_ncfdtr_doc = (
    "ncfdtr(dfn, dfd, nc, f, out=None)\n"
    "\n"
    "Cumulative distribution function of the non-central F distribution.\n"
    "\n"
    "The non-central F describes the distribution of,\n"
    "\n"
    ".. math::\n"
    "    Z = \\frac{X/d_n}{Y/d_d}\n"
    "\n"
    "where :math:`X` and :math:`Y` are independently distributed, with\n"
    ":math:`X` distributed non-central :math:`\\chi^2` with noncentrality\n"
    "parameter `nc` and :math:`d_n` degrees of freedom, and :math:`Y`\n"
    "distributed :math:`\\chi^2` with :math:`d_d` degrees of freedom.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Range [0, inf).\n"
    "f : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : scalar or ndarray\n"
    "    The calculated CDF.  If all inputs are scalar, the return will be a\n"
    "    float.  Otherwise it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "scipy.stats.ncf : Non-central F distribution.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function calculates the CDF of the non-central f distribution using\n"
    "the Boost Math C++ library [1]_.\n"
    "\n"
    "The cumulative distribution function is computed using Formula 26.6.20 of\n"
    "[2]_:\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d, n_c, f) = \\sum_{j=0}^\\infty e^{-n_c/2}\n"
    "    \\frac{(n_c/2)^j}{j!} I_{x}(\\frac{d_n}{2} + j, \\frac{d_d}{2}),\n"
    "\n"
    "where :math:`I` is the regularized incomplete beta function, and\n"
    ":math:`x = f d_n/(f d_n + d_d)`.\n"
    "\n"
    "Note that argument order of `ncfdtr` is different from that of the\n"
    "similar ``cdf`` method of `scipy.stats.ncf`: `f` is the last\n"
    "parameter of `ncfdtr` but the first parameter of ``scipy.stats.ncf.cdf``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> from scipy import stats\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Plot the CDF of the non-central F distribution, for nc=0.  Compare with the\n"
    "F-distribution from scipy.stats:\n"
    "\n"
    ">>> x = np.linspace(-1, 8, num=500)\n"
    ">>> dfn = 3\n"
    ">>> dfd = 2\n"
    ">>> ncf_stats = stats.f.cdf(x, dfn, dfd)\n"
    ">>> ncf_special = special.ncfdtr(dfn, dfd, 0, x)\n"
    "\n"
    ">>> fig = plt.figure()\n"
    ">>> ax = fig.add_subplot(111)\n"
    ">>> ax.plot(x, ncf_stats, 'b-', lw=3)\n"
    ">>> ax.plot(x, ncf_special, 'r-')\n"
    ">>> plt.show()")
ufunc_ncfdtr_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc_ncfdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtr_types[0] = <char>NPY_FLOAT
ufunc_ncfdtr_types[1] = <char>NPY_FLOAT
ufunc_ncfdtr_types[2] = <char>NPY_FLOAT
ufunc_ncfdtr_types[3] = <char>NPY_FLOAT
ufunc_ncfdtr_types[4] = <char>NPY_FLOAT
ufunc_ncfdtr_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtr_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_cdf_float
ufunc_ncfdtr_ptr[2*0+1] = <void*>(<char*>"ncfdtr")
ufunc_ncfdtr_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_cdf_double
ufunc_ncfdtr_ptr[2*1+1] = <void*>(<char*>"ncfdtr")
ufunc_ncfdtr_data[0] = &ufunc_ncfdtr_ptr[2*0]
ufunc_ncfdtr_data[1] = &ufunc_ncfdtr_ptr[2*1]
ncfdtr = np.PyUFunc_FromFuncAndData(ufunc_ncfdtr_loops, ufunc_ncfdtr_data, ufunc_ncfdtr_types, 2, 4, 1, 0, "ncfdtr", ufunc_ncfdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtri_loops[2]
cdef void *ufunc_ncfdtri_ptr[4]
cdef void *ufunc_ncfdtri_data[2]
cdef char ufunc_ncfdtri_types[10]
cdef char *ufunc_ncfdtri_doc = (
    "ncfdtri(dfn, dfd, nc, p, out=None)\n"
    "\n"
    "Inverse with respect to `f` of the CDF of the non-central F distribution.\n"
    "\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Range [0, inf).\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function.  Must be in the\n"
    "    range [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "f : scalar or ndarray\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "scipy.stats.ncf : Non-central F distribution.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function calculates the Quantile of the non-central f distribution\n"
    "using the Boost Math C++ library [1]_.\n"
    "\n"
    "Note that argument order of `ncfdtri` is different from that of the\n"
    "similar ``ppf`` method of `scipy.stats.ncf`. `p` is the last parameter\n"
    "of `ncfdtri` but the first parameter of ``scipy.stats.ncf.ppf``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtri\n"
    "\n"
    "Compute the CDF for several values of `f`:\n"
    "\n"
    ">>> f = [0.5, 1, 1.5]\n"
    ">>> p = ncfdtr(2, 3, 1.5, f)\n"
    ">>> p\n"
    "array([ 0.20782291,  0.36107392,  0.47345752])\n"
    "\n"
    "Compute the inverse.  We recover the values of `f`, as expected:\n"
    "\n"
    ">>> ncfdtri(2, 3, 1.5, p)\n"
    "array([ 0.5,  1. ,  1.5])")
ufunc_ncfdtri_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc_ncfdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtri_types[0] = <char>NPY_FLOAT
ufunc_ncfdtri_types[1] = <char>NPY_FLOAT
ufunc_ncfdtri_types[2] = <char>NPY_FLOAT
ufunc_ncfdtri_types[3] = <char>NPY_FLOAT
ufunc_ncfdtri_types[4] = <char>NPY_FLOAT
ufunc_ncfdtri_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtri_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_ppf_float
ufunc_ncfdtri_ptr[2*0+1] = <void*>(<char*>"ncfdtri")
ufunc_ncfdtri_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_ppf_double
ufunc_ncfdtri_ptr[2*1+1] = <void*>(<char*>"ncfdtri")
ufunc_ncfdtri_data[0] = &ufunc_ncfdtri_ptr[2*0]
ufunc_ncfdtri_data[1] = &ufunc_ncfdtri_ptr[2*1]
ncfdtri = np.PyUFunc_FromFuncAndData(ufunc_ncfdtri_loops, ufunc_ncfdtri_data, ufunc_ncfdtri_types, 2, 4, 1, 0, "ncfdtri", ufunc_ncfdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtridfd_loops[2]
cdef void *ufunc_ncfdtridfd_ptr[4]
cdef void *ufunc_ncfdtridfd_data[2]
cdef char ufunc_ncfdtridfd_types[10]
cdef char *ufunc_ncfdtridfd_doc = (
    "ncfdtridfd(dfn, p, nc, f, out=None)\n"
    "\n"
    "Calculate degrees of freedom (denominator) for the noncentral F-distribution.\n"
    "\n"
    "This is the inverse with respect to `dfd` of `ncfdtr`.\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function.  Must be in the\n"
    "    range [0, 1].\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (0, 1e4).\n"
    "f : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "dfd : scalar or ndarray\n"
    "    Degrees of freedom of the denominator sum of squares.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of the cumulative noncentral F distribution is not necessarily\n"
    "monotone in either degrees of freedom. There thus may be two values that\n"
    "provide a given CDF value. This routine assumes monotonicity and will\n"
    "find an arbitrary one of the two values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtridfd\n"
    "\n"
    "Compute the CDF for several values of `dfd`:\n"
    "\n"
    ">>> dfd = [1, 2, 3]\n"
    ">>> p = ncfdtr(2, dfd, 0.25, 15)\n"
    ">>> p\n"
    "array([ 0.8097138 ,  0.93020416,  0.96787852])\n"
    "\n"
    "Compute the inverse.  We recover the values of `dfd`, as expected:\n"
    "\n"
    ">>> ncfdtridfd(2, p, 0.25, 15)\n"
    "array([ 1.,  2.,  3.])")
ufunc_ncfdtridfd_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtridfd_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtridfd_types[0] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[1] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[2] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[3] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[4] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_ptr[2*0] = <void*>_func_ncfdtridfd
ufunc_ncfdtridfd_ptr[2*0+1] = <void*>(<char*>"ncfdtridfd")
ufunc_ncfdtridfd_ptr[2*1] = <void*>_func_ncfdtridfd
ufunc_ncfdtridfd_ptr[2*1+1] = <void*>(<char*>"ncfdtridfd")
ufunc_ncfdtridfd_data[0] = &ufunc_ncfdtridfd_ptr[2*0]
ufunc_ncfdtridfd_data[1] = &ufunc_ncfdtridfd_ptr[2*1]
ncfdtridfd = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfd_loops, ufunc_ncfdtridfd_data, ufunc_ncfdtridfd_types, 2, 4, 1, 0, "ncfdtridfd", ufunc_ncfdtridfd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtridfn_loops[2]
cdef void *ufunc_ncfdtridfn_ptr[4]
cdef void *ufunc_ncfdtridfn_data[2]
cdef char ufunc_ncfdtridfn_types[10]
cdef char *ufunc_ncfdtridfn_doc = (
    "ncfdtridfn(p, dfd, nc, f, out=None)\n"
    "\n"
    "Calculate degrees of freedom (numerator) for the noncentral F-distribution.\n"
    "\n"
    "This is the inverse with respect to `dfn` of `ncfdtr`.\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function. Must be in the\n"
    "    range [0, 1].\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (0, 1e4).\n"
    "f : float\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "dfn : scalar or ndarray\n"
    "    Degrees of freedom of the numerator sum of squares.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of the cumulative noncentral F distribution is not necessarily\n"
    "monotone in either degrees of freedom. There thus may be two values that\n"
    "provide a given CDF value. This routine assumes monotonicity and will\n"
    "find an arbitrary one of the two values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtridfn\n"
    "\n"
    "Compute the CDF for several values of `dfn`:\n"
    "\n"
    ">>> dfn = [1, 2, 3]\n"
    ">>> p = ncfdtr(dfn, 2, 0.25, 15)\n"
    ">>> p\n"
    "array([ 0.92562363,  0.93020416,  0.93188394])\n"
    "\n"
    "Compute the inverse. We recover the values of `dfn`, as expected:\n"
    "\n"
    ">>> ncfdtridfn(p, 2, 0.25, 15)\n"
    "array([ 1.,  2.,  3.])")
ufunc_ncfdtridfn_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtridfn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtridfn_types[0] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[1] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[2] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[3] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[4] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_ptr[2*0] = <void*>_func_ncfdtridfn
ufunc_ncfdtridfn_ptr[2*0+1] = <void*>(<char*>"ncfdtridfn")
ufunc_ncfdtridfn_ptr[2*1] = <void*>_func_ncfdtridfn
ufunc_ncfdtridfn_ptr[2*1+1] = <void*>(<char*>"ncfdtridfn")
ufunc_ncfdtridfn_data[0] = &ufunc_ncfdtridfn_ptr[2*0]
ufunc_ncfdtridfn_data[1] = &ufunc_ncfdtridfn_ptr[2*1]
ncfdtridfn = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfn_loops, ufunc_ncfdtridfn_data, ufunc_ncfdtridfn_types, 2, 4, 1, 0, "ncfdtridfn", ufunc_ncfdtridfn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtrinc_loops[2]
cdef void *ufunc_ncfdtrinc_ptr[4]
cdef void *ufunc_ncfdtrinc_data[2]
cdef char ufunc_ncfdtrinc_types[10]
cdef char *ufunc_ncfdtrinc_doc = (
    "ncfdtrinc(dfn, dfd, p, f, out=None)\n"
    "\n"
    "Calculate non-centrality parameter for non-central F distribution.\n"
    "\n"
    "This is the inverse with respect to `nc` of `ncfdtr`.\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares. Range (0, inf).\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function. Must be in the\n"
    "    range [0, 1].\n"
    "f : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Noncentrality parameter.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtrinc\n"
    "\n"
    "Compute the CDF for several values of `nc`:\n"
    "\n"
    ">>> nc = [0.5, 1.5, 2.0]\n"
    ">>> p = ncfdtr(2, 3, nc, 15)\n"
    ">>> p\n"
    "array([ 0.96309246,  0.94327955,  0.93304098])\n"
    "\n"
    "Compute the inverse. We recover the values of `nc`, as expected:\n"
    "\n"
    ">>> ncfdtrinc(2, 3, p, 15)\n"
    "array([ 0.5,  1.5,  2. ])")
ufunc_ncfdtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtrinc_types[0] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[1] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[2] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[3] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[4] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_ptr[2*0] = <void*>_func_ncfdtrinc
ufunc_ncfdtrinc_ptr[2*0+1] = <void*>(<char*>"ncfdtrinc")
ufunc_ncfdtrinc_ptr[2*1] = <void*>_func_ncfdtrinc
ufunc_ncfdtrinc_ptr[2*1+1] = <void*>(<char*>"ncfdtrinc")
ufunc_ncfdtrinc_data[0] = &ufunc_ncfdtrinc_ptr[2*0]
ufunc_ncfdtrinc_data[1] = &ufunc_ncfdtrinc_ptr[2*1]
ncfdtrinc = np.PyUFunc_FromFuncAndData(ufunc_ncfdtrinc_loops, ufunc_ncfdtrinc_data, ufunc_ncfdtrinc_types, 2, 4, 1, 0, "ncfdtrinc", ufunc_ncfdtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtr_loops[2]
cdef void *ufunc_nctdtr_ptr[4]
cdef void *ufunc_nctdtr_data[2]
cdef char ufunc_nctdtr_types[8]
cdef char *ufunc_nctdtr_doc = (
    "nctdtr(df, nc, t, out=None)\n"
    "\n"
    "Cumulative distribution function of the non-central `t` distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution. Should be in range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.\n"
    "t : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : scalar or ndarray\n"
    "    The calculated CDF. If all inputs are scalar, the return will be a\n"
    "    float. Otherwise, it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n"
    "nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n"
    "nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function calculates the CDF of the non-central t distribution using\n"
    "the Boost Math C++ library [1]_.\n"
    "\n"
    "Note that the argument order of `nctdtr` is different from that of the\n"
    "similar ``cdf`` method of `scipy.stats.nct`: `t` is the last\n"
    "parameter of `nctdtr` but the first parameter of ``scipy.stats.nct.cdf``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> from scipy import stats\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Plot the CDF of the non-central t distribution, for nc=0. Compare with the\n"
    "t-distribution from scipy.stats:\n"
    "\n"
    ">>> x = np.linspace(-5, 5, num=500)\n"
    ">>> df = 3\n"
    ">>> nct_stats = stats.t.cdf(x, df)\n"
    ">>> nct_special = special.nctdtr(df, 0, x)\n"
    "\n"
    ">>> fig = plt.figure()\n"
    ">>> ax = fig.add_subplot(111)\n"
    ">>> ax.plot(x, nct_stats, 'b-', lw=3)\n"
    ">>> ax.plot(x, nct_special, 'r-')\n"
    ">>> plt.show()")
ufunc_nctdtr_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_nctdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtr_types[0] = <char>NPY_FLOAT
ufunc_nctdtr_types[1] = <char>NPY_FLOAT
ufunc_nctdtr_types[2] = <char>NPY_FLOAT
ufunc_nctdtr_types[3] = <char>NPY_FLOAT
ufunc_nctdtr_types[4] = <char>NPY_DOUBLE
ufunc_nctdtr_types[5] = <char>NPY_DOUBLE
ufunc_nctdtr_types[6] = <char>NPY_DOUBLE
ufunc_nctdtr_types[7] = <char>NPY_DOUBLE
ufunc_nctdtr_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_cdf_float
ufunc_nctdtr_ptr[2*0+1] = <void*>(<char*>"nctdtr")
ufunc_nctdtr_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_cdf_double
ufunc_nctdtr_ptr[2*1+1] = <void*>(<char*>"nctdtr")
ufunc_nctdtr_data[0] = &ufunc_nctdtr_ptr[2*0]
ufunc_nctdtr_data[1] = &ufunc_nctdtr_ptr[2*1]
nctdtr = np.PyUFunc_FromFuncAndData(ufunc_nctdtr_loops, ufunc_nctdtr_data, ufunc_nctdtr_types, 2, 3, 1, 0, "nctdtr", ufunc_nctdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtridf_loops[2]
cdef void *ufunc_nctdtridf_ptr[4]
cdef void *ufunc_nctdtridf_data[2]
cdef char ufunc_nctdtridf_types[8]
cdef char *ufunc_nctdtridf_doc = (
    "nctdtridf(p, nc, t, out=None)\n"
    "\n"
    "Calculate degrees of freedom for non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "nc : array_like\n"
    "    Noncentrality parameter. Should be in range (-1e6, 1e6).\n"
    "t : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "df : scalar or ndarray\n"
    "    The degrees of freedom. If all inputs are scalar, the return will be a\n"
    "    float. Otherwise, it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtr :  CDF of the non-central `t` distribution.\n"
    "nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n"
    "nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import nctdtr, nctdtridf\n"
    "\n"
    "Compute the CDF for several values of `df`:\n"
    "\n"
    ">>> df = [1, 2, 3]\n"
    ">>> p = nctdtr(df, 0.25, 1)\n"
    ">>> p\n"
    "array([0.67491974, 0.716464  , 0.73349456])\n"
    "\n"
    "Compute the inverse. We recover the values of `df`, as expected:\n"
    "\n"
    ">>> nctdtridf(p, 0.25, 1)\n"
    "array([1., 2., 3.])")
ufunc_nctdtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtridf_types[0] = <char>NPY_FLOAT
ufunc_nctdtridf_types[1] = <char>NPY_FLOAT
ufunc_nctdtridf_types[2] = <char>NPY_FLOAT
ufunc_nctdtridf_types[3] = <char>NPY_FLOAT
ufunc_nctdtridf_types[4] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[5] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[6] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[7] = <char>NPY_DOUBLE
ufunc_nctdtridf_ptr[2*0] = <void*>_func_nctdtridf
ufunc_nctdtridf_ptr[2*0+1] = <void*>(<char*>"nctdtridf")
ufunc_nctdtridf_ptr[2*1] = <void*>_func_nctdtridf
ufunc_nctdtridf_ptr[2*1+1] = <void*>(<char*>"nctdtridf")
ufunc_nctdtridf_data[0] = &ufunc_nctdtridf_ptr[2*0]
ufunc_nctdtridf_data[1] = &ufunc_nctdtridf_ptr[2*1]
nctdtridf = np.PyUFunc_FromFuncAndData(ufunc_nctdtridf_loops, ufunc_nctdtridf_data, ufunc_nctdtridf_types, 2, 3, 1, 0, "nctdtridf", ufunc_nctdtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtrinc_loops[2]
cdef void *ufunc_nctdtrinc_ptr[4]
cdef void *ufunc_nctdtrinc_data[2]
cdef char ufunc_nctdtrinc_types[8]
cdef char *ufunc_nctdtrinc_doc = (
    "nctdtrinc(df, p, t, out=None)\n"
    "\n"
    "Calculate non-centrality parameter for non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution. Should be in range (0, inf).\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "t : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Noncentrality parameter\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtr :  CDF of the non-central `t` distribution.\n"
    "nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n"
    "nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import nctdtr, nctdtrinc\n"
    "\n"
    "Compute the CDF for several values of `nc`:\n"
    "\n"
    ">>> nc = [0.5, 1.5, 2.5]\n"
    ">>> p = nctdtr(3, nc, 1.5)\n"
    ">>> p\n"
    "array([0.77569497, 0.45524533, 0.1668691 ])\n"
    "\n"
    "Compute the inverse. We recover the values of `nc`, as expected:\n"
    "\n"
    ">>> nctdtrinc(3, p, 1.5)\n"
    "array([0.5, 1.5, 2.5])")
ufunc_nctdtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtrinc_types[0] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[1] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[2] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[3] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[4] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[5] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[6] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[7] = <char>NPY_DOUBLE
ufunc_nctdtrinc_ptr[2*0] = <void*>_func_nctdtrinc
ufunc_nctdtrinc_ptr[2*0+1] = <void*>(<char*>"nctdtrinc")
ufunc_nctdtrinc_ptr[2*1] = <void*>_func_nctdtrinc
ufunc_nctdtrinc_ptr[2*1+1] = <void*>(<char*>"nctdtrinc")
ufunc_nctdtrinc_data[0] = &ufunc_nctdtrinc_ptr[2*0]
ufunc_nctdtrinc_data[1] = &ufunc_nctdtrinc_ptr[2*1]
nctdtrinc = np.PyUFunc_FromFuncAndData(ufunc_nctdtrinc_loops, ufunc_nctdtrinc_data, ufunc_nctdtrinc_types, 2, 3, 1, 0, "nctdtrinc", ufunc_nctdtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtrit_loops[2]
cdef void *ufunc_nctdtrit_ptr[4]
cdef void *ufunc_nctdtrit_data[2]
cdef char ufunc_nctdtrit_types[8]
cdef char *ufunc_nctdtrit_doc = (
    "nctdtrit(df, nc, p, out=None)\n"
    "\n"
    "Inverse cumulative distribution function of the non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution. Should be in range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter. Should be in range (-1e6, 1e6).\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "t : scalar or ndarray\n"
    "    Quantiles\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtr :  CDF of the non-central `t` distribution.\n"
    "nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n"
    "nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import nctdtr, nctdtrit\n"
    "\n"
    "Compute the CDF for several values of `t`:\n"
    "\n"
    ">>> t = [0.5, 1, 1.5]\n"
    ">>> p = nctdtr(3, 1, t)\n"
    ">>> p\n"
    "array([0.29811049, 0.46922687, 0.6257559 ])\n"
    "\n"
    "Compute the inverse. We recover the values of `t`, as expected:\n"
    "\n"
    ">>> nctdtrit(3, 1, p)\n"
    "array([0.5, 1. , 1.5])")
ufunc_nctdtrit_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtrit_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtrit_types[0] = <char>NPY_FLOAT
ufunc_nctdtrit_types[1] = <char>NPY_FLOAT
ufunc_nctdtrit_types[2] = <char>NPY_FLOAT
ufunc_nctdtrit_types[3] = <char>NPY_FLOAT
ufunc_nctdtrit_types[4] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[5] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[6] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[7] = <char>NPY_DOUBLE
ufunc_nctdtrit_ptr[2*0] = <void*>_func_nctdtrit
ufunc_nctdtrit_ptr[2*0+1] = <void*>(<char*>"nctdtrit")
ufunc_nctdtrit_ptr[2*1] = <void*>_func_nctdtrit
ufunc_nctdtrit_ptr[2*1+1] = <void*>(<char*>"nctdtrit")
ufunc_nctdtrit_data[0] = &ufunc_nctdtrit_ptr[2*0]
ufunc_nctdtrit_data[1] = &ufunc_nctdtrit_ptr[2*1]
nctdtrit = np.PyUFunc_FromFuncAndData(ufunc_nctdtrit_loops, ufunc_nctdtrit_data, ufunc_nctdtrit_types, 2, 3, 1, 0, "nctdtrit", ufunc_nctdtrit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtr_loops[4]
cdef void *ufunc_ndtr_ptr[8]
cdef void *ufunc_ndtr_data[4]
cdef char ufunc_ndtr_types[8]
cdef char *ufunc_ndtr_doc = (
    "ndtr(x, out=None)\n"
    "\n"
    "Cumulative distribution of the standard normal distribution.\n"
    "\n"
    "Returns the area under the standard Gaussian probability\n"
    "density function, integrated from minus infinity to `x`\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^x \\exp(-t^2/2) dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like, real or complex\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value of the normal CDF evaluated at `x`\n"
    "\n"
    "See Also\n"
    "--------\n"
    "log_ndtr : Logarithm of ndtr\n"
    "ndtri : Inverse of ndtr, standard normal percentile function\n"
    "erf : Error function\n"
    "erfc : 1 - erf\n"
    "scipy.stats.norm : Normal distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate `ndtr` at one point.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import ndtr\n"
    ">>> ndtr(0.5)\n"
    "0.6914624612740131\n"
    "\n"
    "Evaluate the function at several points by providing a NumPy array\n"
    "or list for `x`.\n"
    "\n"
    ">>> ndtr([0, 0.5, 2])\n"
    "array([0.5       , 0.69146246, 0.97724987])\n"
    "\n"
    "Plot the function.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-5, 5, 100)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, ndtr(x))\n"
    ">>> ax.set_title(r\"Standard normal cumulative distribution function $\\Phi$\")\n"
    ">>> plt.show()")
ufunc_ndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtr_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_ndtr_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_ndtr_types[0] = <char>NPY_FLOAT
ufunc_ndtr_types[1] = <char>NPY_FLOAT
ufunc_ndtr_types[2] = <char>NPY_DOUBLE
ufunc_ndtr_types[3] = <char>NPY_DOUBLE
ufunc_ndtr_types[4] = <char>NPY_CFLOAT
ufunc_ndtr_types[5] = <char>NPY_CFLOAT
ufunc_ndtr_types[6] = <char>NPY_CDOUBLE
ufunc_ndtr_types[7] = <char>NPY_CDOUBLE
ufunc_ndtr_ptr[2*0] = <void*>_func_xsf_ndtr
ufunc_ndtr_ptr[2*0+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*1] = <void*>_func_xsf_ndtr
ufunc_ndtr_ptr[2*1+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_ndtr
ufunc_ndtr_ptr[2*2+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_ndtr
ufunc_ndtr_ptr[2*3+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_data[0] = &ufunc_ndtr_ptr[2*0]
ufunc_ndtr_data[1] = &ufunc_ndtr_ptr[2*1]
ufunc_ndtr_data[2] = &ufunc_ndtr_ptr[2*2]
ufunc_ndtr_data[3] = &ufunc_ndtr_ptr[2*3]
ndtr = np.PyUFunc_FromFuncAndData(ufunc_ndtr_loops, ufunc_ndtr_data, ufunc_ndtr_types, 4, 1, 1, 0, "ndtr", ufunc_ndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtri_loops[2]
cdef void *ufunc_ndtri_ptr[4]
cdef void *ufunc_ndtri_data[2]
cdef char ufunc_ndtri_types[4]
cdef char *ufunc_ndtri_doc = (
    "ndtri(y, out=None)\n"
    "\n"
    "Inverse of `ndtr` vs x\n"
    "\n"
    "Returns the argument x for which the area under the standard normal\n"
    "probability density function (integrated from minus infinity to `x`)\n"
    "is equal to y.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value of x such that ``ndtr(x) == p``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ndtr : Standard normal cumulative probability distribution\n"
    "ndtri_exp : Inverse of log_ndtr\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`ndtri` is the percentile function of the standard normal distribution.\n"
    "This means it returns the inverse of the cumulative density `ndtr`. First,\n"
    "let us compute a cumulative density value.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import ndtri, ndtr\n"
    ">>> cdf_val = ndtr(2)\n"
    ">>> cdf_val\n"
    "0.9772498680518208\n"
    "\n"
    "Verify that `ndtri` yields the original value for `x` up to floating point\n"
    "errors.\n"
    "\n"
    ">>> ndtri(cdf_val)\n"
    "2.0000000000000004\n"
    "\n"
    "Plot the function. For that purpose, we provide a NumPy array as argument.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0.01, 1, 200)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, ndtri(x))\n"
    ">>> ax.set_title(\"Standard normal percentile function\")\n"
    ">>> plt.show()")
ufunc_ndtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtri_types[0] = <char>NPY_FLOAT
ufunc_ndtri_types[1] = <char>NPY_FLOAT
ufunc_ndtri_types[2] = <char>NPY_DOUBLE
ufunc_ndtri_types[3] = <char>NPY_DOUBLE
ufunc_ndtri_ptr[2*0] = <void*>_func_xsf_ndtri
ufunc_ndtri_ptr[2*0+1] = <void*>(<char*>"ndtri")
ufunc_ndtri_ptr[2*1] = <void*>_func_xsf_ndtri
ufunc_ndtri_ptr[2*1+1] = <void*>(<char*>"ndtri")
ufunc_ndtri_data[0] = &ufunc_ndtri_ptr[2*0]
ufunc_ndtri_data[1] = &ufunc_ndtri_ptr[2*1]
ndtri = np.PyUFunc_FromFuncAndData(ufunc_ndtri_loops, ufunc_ndtri_data, ufunc_ndtri_types, 2, 1, 1, 0, "ndtri", ufunc_ndtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtri_exp_loops[2]
cdef void *ufunc_ndtri_exp_ptr[4]
cdef void *ufunc_ndtri_exp_data[2]
cdef char ufunc_ndtri_exp_types[4]
cdef char *ufunc_ndtri_exp_doc = (
    "ndtri_exp(y, out=None)\n"
    "\n"
    "Inverse of `log_ndtr` vs x. Allows for greater precision than\n"
    "`ndtri` composed with `numpy.exp` for very small values of y and for\n"
    "y close to 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like of float\n"
    "    Function argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Inverse of the log CDF of the standard normal distribution, evaluated\n"
    "    at y.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "log_ndtr : log of the standard normal cumulative distribution function\n"
    "ndtr : standard normal cumulative distribution function\n"
    "ndtri : standard normal percentile function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "`ndtri_exp` agrees with the naive implementation when the latter does\n"
    "not suffer from underflow.\n"
    "\n"
    ">>> sc.ndtri_exp(-1)\n"
    "-0.33747496376420244\n"
    ">>> sc.ndtri(np.exp(-1))\n"
    "-0.33747496376420244\n"
    "\n"
    "For extreme values of y, the naive approach fails\n"
    "\n"
    ">>> sc.ndtri(np.exp(-800))\n"
    "-inf\n"
    ">>> sc.ndtri(np.exp(-1e-20))\n"
    "inf\n"
    "\n"
    "whereas `ndtri_exp` is still able to compute the result to high precision.\n"
    "\n"
    ">>> sc.ndtri_exp(-800)\n"
    "-39.88469483825668\n"
    ">>> sc.ndtri_exp(-1e-20)\n"
    "9.262340089798409")
ufunc_ndtri_exp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtri_exp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtri_exp_types[0] = <char>NPY_FLOAT
ufunc_ndtri_exp_types[1] = <char>NPY_FLOAT
ufunc_ndtri_exp_types[2] = <char>NPY_DOUBLE
ufunc_ndtri_exp_types[3] = <char>NPY_DOUBLE
ufunc_ndtri_exp_ptr[2*0] = <void*>_func_ndtri_exp
ufunc_ndtri_exp_ptr[2*0+1] = <void*>(<char*>"ndtri_exp")
ufunc_ndtri_exp_ptr[2*1] = <void*>_func_ndtri_exp
ufunc_ndtri_exp_ptr[2*1+1] = <void*>(<char*>"ndtri_exp")
ufunc_ndtri_exp_data[0] = &ufunc_ndtri_exp_ptr[2*0]
ufunc_ndtri_exp_data[1] = &ufunc_ndtri_exp_ptr[2*1]
ndtri_exp = np.PyUFunc_FromFuncAndData(ufunc_ndtri_exp_loops, ufunc_ndtri_exp_data, ufunc_ndtri_exp_types, 2, 1, 1, 0, "ndtri_exp", ufunc_ndtri_exp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nrdtrimn_loops[2]
cdef void *ufunc_nrdtrimn_ptr[4]
cdef void *ufunc_nrdtrimn_data[2]
cdef char ufunc_nrdtrimn_types[8]
cdef char *ufunc_nrdtrimn_doc = (
    "nrdtrimn(p, std, x, out=None)\n"
    "\n"
    "Calculate mean of normal distribution given other params.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "std : array_like\n"
    "    Standard deviation.\n"
    "x : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "mn : scalar or ndarray\n"
    "    The mean of the normal distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "scipy.stats.norm : Normal distribution\n"
    "ndtr : Standard normal cumulative probability distribution\n"
    "ndtri : Inverse of standard normal CDF with respect to quantile\n"
    "nrdtrisd : Inverse of normal distribution CDF with respect to\n"
    "           standard deviation\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`nrdtrimn` can be used to recover the mean of a normal distribution\n"
    "if we know the CDF value `p` for a given quantile `x` and the\n"
    "standard deviation `std`. First, we calculate\n"
    "the normal distribution CDF for an exemplary parameter set.\n"
    "\n"
    ">>> from scipy.stats import norm\n"
    ">>> mean = 3.\n"
    ">>> std = 2.\n"
    ">>> x = 6.\n"
    ">>> p = norm.cdf(x, loc=mean, scale=std)\n"
    ">>> p\n"
    "0.9331927987311419\n"
    "\n"
    "Verify that `nrdtrimn` returns the original value for `mean`.\n"
    "\n"
    ">>> from scipy.special import nrdtrimn\n"
    ">>> nrdtrimn(p, std, x)\n"
    "3.0000000000000004")
ufunc_nrdtrimn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nrdtrimn_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nrdtrimn_types[0] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[1] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[2] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[3] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[4] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[5] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[6] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[7] = <char>NPY_DOUBLE
ufunc_nrdtrimn_ptr[2*0] = <void*>_func_nrdtrimn
ufunc_nrdtrimn_ptr[2*0+1] = <void*>(<char*>"nrdtrimn")
ufunc_nrdtrimn_ptr[2*1] = <void*>_func_nrdtrimn
ufunc_nrdtrimn_ptr[2*1+1] = <void*>(<char*>"nrdtrimn")
ufunc_nrdtrimn_data[0] = &ufunc_nrdtrimn_ptr[2*0]
ufunc_nrdtrimn_data[1] = &ufunc_nrdtrimn_ptr[2*1]
nrdtrimn = np.PyUFunc_FromFuncAndData(ufunc_nrdtrimn_loops, ufunc_nrdtrimn_data, ufunc_nrdtrimn_types, 2, 3, 1, 0, "nrdtrimn", ufunc_nrdtrimn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nrdtrisd_loops[2]
cdef void *ufunc_nrdtrisd_ptr[4]
cdef void *ufunc_nrdtrisd_data[2]
cdef char ufunc_nrdtrisd_types[8]
cdef char *ufunc_nrdtrisd_doc = (
    "nrdtrisd(mn, p, x, out=None)\n"
    "\n"
    "Calculate standard deviation of normal distribution given other params.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "mn : scalar or ndarray\n"
    "    The mean of the normal distribution.\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "x : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "std : scalar or ndarray\n"
    "    Standard deviation.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "scipy.stats.norm : Normal distribution\n"
    "ndtr : Standard normal cumulative probability distribution\n"
    "ndtri : Inverse of standard normal CDF with respect to quantile\n"
    "nrdtrimn : Inverse of normal distribution CDF with respect to\n"
    "           mean\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`nrdtrisd` can be used to recover the standard deviation of a normal\n"
    "distribution if we know the CDF value `p` for a given quantile `x` and\n"
    "the mean `mn`. First, we calculate the normal distribution CDF for an\n"
    "exemplary parameter set.\n"
    "\n"
    ">>> from scipy.stats import norm\n"
    ">>> mean = 3.\n"
    ">>> std = 2.\n"
    ">>> x = 6.\n"
    ">>> p = norm.cdf(x, loc=mean, scale=std)\n"
    ">>> p\n"
    "0.9331927987311419\n"
    "\n"
    "Verify that `nrdtrisd` returns the original value for `std`.\n"
    "\n"
    ">>> from scipy.special import nrdtrisd\n"
    ">>> nrdtrisd(mean, p, x)\n"
    "2.0000000000000004")
ufunc_nrdtrisd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nrdtrisd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nrdtrisd_types[0] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[1] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[2] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[3] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[4] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[5] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[6] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[7] = <char>NPY_DOUBLE
ufunc_nrdtrisd_ptr[2*0] = <void*>_func_nrdtrisd
ufunc_nrdtrisd_ptr[2*0+1] = <void*>(<char*>"nrdtrisd")
ufunc_nrdtrisd_ptr[2*1] = <void*>_func_nrdtrisd
ufunc_nrdtrisd_ptr[2*1+1] = <void*>(<char*>"nrdtrisd")
ufunc_nrdtrisd_data[0] = &ufunc_nrdtrisd_ptr[2*0]
ufunc_nrdtrisd_data[1] = &ufunc_nrdtrisd_ptr[2*1]
nrdtrisd = np.PyUFunc_FromFuncAndData(ufunc_nrdtrisd_loops, ufunc_nrdtrisd_data, ufunc_nrdtrisd_types, 2, 3, 1, 0, "nrdtrisd", ufunc_nrdtrisd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_owens_t_loops[2]
cdef void *ufunc_owens_t_ptr[4]
cdef void *ufunc_owens_t_data[2]
cdef char ufunc_owens_t_types[6]
cdef char *ufunc_owens_t_doc = (
    "owens_t(h, a, out=None)\n"
    "\n"
    "Owen's T Function.\n"
    "\n"
    "The function T(h, a) gives the probability of the event\n"
    "(X > h and 0 < Y < a * X) where X and Y are independent\n"
    "standard normal random variables.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "h: array_like\n"
    "    Input value.\n"
    "a: array_like\n"
    "    Input value.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "t: scalar or ndarray\n"
    "    Probability of the event (X > h and 0 < Y < a * X),\n"
    "    where X and Y are independent standard normal random variables.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] M. Patefield and D. Tandy, \"Fast and accurate calculation of\n"
    "       Owen's T Function\", Statistical Software vol. 5, pp. 1-25, 2000.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> a = 3.5\n"
    ">>> h = 0.78\n"
    ">>> special.owens_t(h, a)\n"
    "0.10877216734852274")
ufunc_owens_t_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_owens_t_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_owens_t_types[0] = <char>NPY_FLOAT
ufunc_owens_t_types[1] = <char>NPY_FLOAT
ufunc_owens_t_types[2] = <char>NPY_FLOAT
ufunc_owens_t_types[3] = <char>NPY_DOUBLE
ufunc_owens_t_types[4] = <char>NPY_DOUBLE
ufunc_owens_t_types[5] = <char>NPY_DOUBLE
ufunc_owens_t_ptr[2*0] = <void*>_func_xsf_owens_t
ufunc_owens_t_ptr[2*0+1] = <void*>(<char*>"owens_t")
ufunc_owens_t_ptr[2*1] = <void*>_func_xsf_owens_t
ufunc_owens_t_ptr[2*1+1] = <void*>(<char*>"owens_t")
ufunc_owens_t_data[0] = &ufunc_owens_t_ptr[2*0]
ufunc_owens_t_data[1] = &ufunc_owens_t_ptr[2*1]
owens_t = np.PyUFunc_FromFuncAndData(ufunc_owens_t_loops, ufunc_owens_t_data, ufunc_owens_t_types, 2, 2, 1, 0, "owens_t", ufunc_owens_t_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtr_loops[2]
cdef void *ufunc_pdtr_ptr[4]
cdef void *ufunc_pdtr_data[2]
cdef char ufunc_pdtr_types[6]
cdef char *ufunc_pdtr_doc = (
    "pdtr(k, m, out=None)\n"
    "\n"
    "Poisson cumulative distribution function.\n"
    "\n"
    "Defined as the probability that a Poisson-distributed random\n"
    "variable with event rate :math:`m` is less than or equal to\n"
    ":math:`k`. More concretely, this works out to be [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\exp(-m) \\sum_{j = 0}^{\\lfloor{k}\\rfloor} \\frac{m^j}{j!}.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of occurrences (nonnegative, real)\n"
    "m : array_like\n"
    "    Shape parameter (nonnegative, real)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Poisson cumulative distribution function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtrc : Poisson survival function\n"
    "pdtrik : inverse of `pdtr` with respect to `k`\n"
    "pdtri : inverse of `pdtr` with respect to `m`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Poisson_distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is a cumulative distribution function, so it converges to 1\n"
    "monotonically as `k` goes to infinity.\n"
    "\n"
    ">>> sc.pdtr([1, 10, 100, np.inf], 1)\n"
    "array([0.73575888, 0.99999999, 1.        , 1.        ])\n"
    "\n"
    "It is discontinuous at integers and constant between integers.\n"
    "\n"
    ">>> sc.pdtr([1, 1.5, 1.9, 2], 1)\n"
    "array([0.73575888, 0.73575888, 0.73575888, 0.9196986 ])")
ufunc_pdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtr_types[0] = <char>NPY_FLOAT
ufunc_pdtr_types[1] = <char>NPY_FLOAT
ufunc_pdtr_types[2] = <char>NPY_FLOAT
ufunc_pdtr_types[3] = <char>NPY_DOUBLE
ufunc_pdtr_types[4] = <char>NPY_DOUBLE
ufunc_pdtr_types[5] = <char>NPY_DOUBLE
ufunc_pdtr_ptr[2*0] = <void*>_func_xsf_pdtr
ufunc_pdtr_ptr[2*0+1] = <void*>(<char*>"pdtr")
ufunc_pdtr_ptr[2*1] = <void*>_func_xsf_pdtr
ufunc_pdtr_ptr[2*1+1] = <void*>(<char*>"pdtr")
ufunc_pdtr_data[0] = &ufunc_pdtr_ptr[2*0]
ufunc_pdtr_data[1] = &ufunc_pdtr_ptr[2*1]
pdtr = np.PyUFunc_FromFuncAndData(ufunc_pdtr_loops, ufunc_pdtr_data, ufunc_pdtr_types, 2, 2, 1, 0, "pdtr", ufunc_pdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtrc_loops[2]
cdef void *ufunc_pdtrc_ptr[4]
cdef void *ufunc_pdtrc_data[2]
cdef char ufunc_pdtrc_types[6]
cdef char *ufunc_pdtrc_doc = (
    "pdtrc(k, m, out=None)\n"
    "\n"
    "Poisson survival function\n"
    "\n"
    "Returns the sum of the terms from k+1 to infinity of the Poisson\n"
    "distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc(\n"
    "k+1, m). Arguments must both be non-negative doubles.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of occurrences (nonnegative, real)\n"
    "m : array_like\n"
    "    Shape parameter (nonnegative, real)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Poisson survival function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtr : Poisson cumulative distribution function\n"
    "pdtrik : inverse of `pdtr` with respect to `k`\n"
    "pdtri : inverse of `pdtr` with respect to `m`\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is a survival function, so it decreases to 0\n"
    "monotonically as `k` goes to infinity.\n"
    "\n"
    ">>> k = np.array([1, 10, 100, np.inf])\n"
    ">>> sc.pdtrc(k, 1)\n"
    "array([2.64241118e-001, 1.00477664e-008, 3.94147589e-161, 0.00000000e+000])\n"
    "\n"
    "It can be expressed in terms of the lower incomplete gamma\n"
    "function `gammainc`.\n"
    "\n"
    ">>> sc.gammainc(k + 1, 1)\n"
    "array([2.64241118e-001, 1.00477664e-008, 3.94147589e-161, 0.00000000e+000])")
ufunc_pdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtrc_types[0] = <char>NPY_FLOAT
ufunc_pdtrc_types[1] = <char>NPY_FLOAT
ufunc_pdtrc_types[2] = <char>NPY_FLOAT
ufunc_pdtrc_types[3] = <char>NPY_DOUBLE
ufunc_pdtrc_types[4] = <char>NPY_DOUBLE
ufunc_pdtrc_types[5] = <char>NPY_DOUBLE
ufunc_pdtrc_ptr[2*0] = <void*>_func_xsf_pdtrc
ufunc_pdtrc_ptr[2*0+1] = <void*>(<char*>"pdtrc")
ufunc_pdtrc_ptr[2*1] = <void*>_func_xsf_pdtrc
ufunc_pdtrc_ptr[2*1+1] = <void*>(<char*>"pdtrc")
ufunc_pdtrc_data[0] = &ufunc_pdtrc_ptr[2*0]
ufunc_pdtrc_data[1] = &ufunc_pdtrc_ptr[2*1]
pdtrc = np.PyUFunc_FromFuncAndData(ufunc_pdtrc_loops, ufunc_pdtrc_data, ufunc_pdtrc_types, 2, 2, 1, 0, "pdtrc", ufunc_pdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtri_loops[3]
cdef void *ufunc_pdtri_ptr[6]
cdef void *ufunc_pdtri_data[3]
cdef char ufunc_pdtri_types[9]
cdef char *ufunc_pdtri_doc = (
    "pdtri(k, y, out=None)\n"
    "\n"
    "Inverse to `pdtr` vs m\n"
    "\n"
    "Returns the Poisson variable `m` such that the sum from 0 to `k` of\n"
    "the Poisson density is equal to the given probability `y`:\n"
    "calculated by ``gammaincinv(k + 1, y)``. `k` must be a nonnegative\n"
    "integer and `y` between 0 and 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of occurrences (nonnegative, real)\n"
    "y : array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the shape parameter `m` such that ``pdtr(k, m) = p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtr : Poisson cumulative distribution function\n"
    "pdtrc : Poisson survival function\n"
    "pdtrik : inverse of `pdtr` with respect to `k`\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "Compute the CDF for several values of `m`:\n"
    "\n"
    ">>> m = [0.5, 1, 1.5]\n"
    ">>> p = sc.pdtr(1, m)\n"
    ">>> p\n"
    "array([0.90979599, 0.73575888, 0.5578254 ])\n"
    "\n"
    "Compute the inverse. We recover the values of `m`, as expected:\n"
    "\n"
    ">>> sc.pdtri(1, p)\n"
    "array([0.5, 1. , 1.5])")
ufunc_pdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_pdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtri_types[0] = <char>NPY_INTP
ufunc_pdtri_types[1] = <char>NPY_DOUBLE
ufunc_pdtri_types[2] = <char>NPY_DOUBLE
ufunc_pdtri_types[3] = <char>NPY_FLOAT
ufunc_pdtri_types[4] = <char>NPY_FLOAT
ufunc_pdtri_types[5] = <char>NPY_FLOAT
ufunc_pdtri_types[6] = <char>NPY_DOUBLE
ufunc_pdtri_types[7] = <char>NPY_DOUBLE
ufunc_pdtri_types[8] = <char>NPY_DOUBLE
ufunc_pdtri_ptr[2*0] = <void*>_func_cephes_pdtri_wrap
ufunc_pdtri_ptr[2*0+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_ptr[2*1] = <void*>_func_pdtri_unsafe
ufunc_pdtri_ptr[2*1+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_ptr[2*2] = <void*>_func_pdtri_unsafe
ufunc_pdtri_ptr[2*2+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_data[0] = &ufunc_pdtri_ptr[2*0]
ufunc_pdtri_data[1] = &ufunc_pdtri_ptr[2*1]
ufunc_pdtri_data[2] = &ufunc_pdtri_ptr[2*2]
pdtri = np.PyUFunc_FromFuncAndData(ufunc_pdtri_loops, ufunc_pdtri_data, ufunc_pdtri_types, 3, 2, 1, 0, "pdtri", ufunc_pdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtrik_loops[2]
cdef void *ufunc_pdtrik_ptr[4]
cdef void *ufunc_pdtrik_data[2]
cdef char ufunc_pdtrik_types[6]
cdef char *ufunc_pdtrik_doc = (
    "pdtrik(p, m, out=None)\n"
    "\n"
    "Inverse to `pdtr` vs `k`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability\n"
    "m : array_like\n"
    "    Shape parameter (nonnegative, real)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The number of occurrences `k` such that ``pdtr(k, m) = p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtr : Poisson cumulative distribution function\n"
    "pdtrc : Poisson survival function\n"
    "pdtri : inverse of `pdtr` with respect to `m`\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "Compute the CDF for several values of `k`:\n"
    "\n"
    ">>> k = [1, 2, 3]\n"
    ">>> p = sc.pdtr(k, 2)\n"
    ">>> p\n"
    "array([0.40600585, 0.67667642, 0.85712346])\n"
    "\n"
    "Compute the inverse. We recover the values of `k`, as expected:\n"
    "\n"
    ">>> sc.pdtrik(p, 2)\n"
    "array([1., 2., 3.])")
ufunc_pdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtrik_types[0] = <char>NPY_FLOAT
ufunc_pdtrik_types[1] = <char>NPY_FLOAT
ufunc_pdtrik_types[2] = <char>NPY_FLOAT
ufunc_pdtrik_types[3] = <char>NPY_DOUBLE
ufunc_pdtrik_types[4] = <char>NPY_DOUBLE
ufunc_pdtrik_types[5] = <char>NPY_DOUBLE
ufunc_pdtrik_ptr[2*0] = <void*>_func_pdtrik
ufunc_pdtrik_ptr[2*0+1] = <void*>(<char*>"pdtrik")
ufunc_pdtrik_ptr[2*1] = <void*>_func_pdtrik
ufunc_pdtrik_ptr[2*1+1] = <void*>(<char*>"pdtrik")
ufunc_pdtrik_data[0] = &ufunc_pdtrik_ptr[2*0]
ufunc_pdtrik_data[1] = &ufunc_pdtrik_ptr[2*1]
pdtrik = np.PyUFunc_FromFuncAndData(ufunc_pdtrik_loops, ufunc_pdtrik_data, ufunc_pdtrik_types, 2, 2, 1, 0, "pdtrik", ufunc_pdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_poch_loops[2]
cdef void *ufunc_poch_ptr[4]
cdef void *ufunc_poch_data[2]
cdef char ufunc_poch_types[6]
cdef char *ufunc_poch_doc = (
    "poch(z, m, out=None)\n"
    "\n"
    "Pochhammer symbol.\n"
    "\n"
    "The Pochhammer symbol (rising factorial) is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    (z)_m = \\frac{\\Gamma(z + m)}{\\Gamma(z)}\n"
    "\n"
    "For positive integer `m` it reads\n"
    "\n"
    ".. math::\n"
    "\n"
    "    (z)_m = z (z + 1) ... (z + m - 1)\n"
    "\n"
    "See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z, m : array_like\n"
    "    Real-valued arguments.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value of the function.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] Nist, Digital Library of Mathematical Functions\n"
    "    https://dlmf.nist.gov/5.2#iii\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is 1 when m is 0.\n"
    "\n"
    ">>> sc.poch([1, 2, 3, 4], 0)\n"
    "array([1., 1., 1., 1.])\n"
    "\n"
    "For z equal to 1 it reduces to the factorial function.\n"
    "\n"
    ">>> sc.poch(1, 5)\n"
    "120.0\n"
    ">>> 1 * 2 * 3 * 4 * 5\n"
    "120\n"
    "\n"
    "It can be expressed in terms of the gamma function.\n"
    "\n"
    ">>> z, m = 3.7, 2.1\n"
    ">>> sc.poch(z, m)\n"
    "20.529581933776953\n"
    ">>> sc.gamma(z + m) / sc.gamma(z)\n"
    "20.52958193377696")
ufunc_poch_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_poch_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_poch_types[0] = <char>NPY_FLOAT
ufunc_poch_types[1] = <char>NPY_FLOAT
ufunc_poch_types[2] = <char>NPY_FLOAT
ufunc_poch_types[3] = <char>NPY_DOUBLE
ufunc_poch_types[4] = <char>NPY_DOUBLE
ufunc_poch_types[5] = <char>NPY_DOUBLE
ufunc_poch_ptr[2*0] = <void*>_func_cephes_poch
ufunc_poch_ptr[2*0+1] = <void*>(<char*>"poch")
ufunc_poch_ptr[2*1] = <void*>_func_cephes_poch
ufunc_poch_ptr[2*1+1] = <void*>(<char*>"poch")
ufunc_poch_data[0] = &ufunc_poch_ptr[2*0]
ufunc_poch_data[1] = &ufunc_poch_ptr[2*1]
poch = np.PyUFunc_FromFuncAndData(ufunc_poch_loops, ufunc_poch_data, ufunc_poch_types, 2, 2, 1, 0, "poch", ufunc_poch_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_powm1_loops[2]
cdef void *ufunc_powm1_ptr[4]
cdef void *ufunc_powm1_data[2]
cdef char ufunc_powm1_types[6]
cdef char *ufunc_powm1_doc = (
    "powm1(x, y, out=None)\n"
    "\n"
    "Computes ``x**y - 1``.\n"
    "\n"
    "This function is useful when `y` is near 0, or when `x` is near 1.\n"
    "\n"
    "The function is implemented for real types only (unlike ``numpy.power``,\n"
    "which accepts complex inputs).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    The base. Must be a real type (i.e. integer or float, not complex).\n"
    "y : array_like\n"
    "    The exponent. Must be a real type (i.e. integer or float, not complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "array_like\n"
    "    Result of the calculation\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.10.0\n"
    "\n"
    "The underlying code is implemented for single precision and double\n"
    "precision floats only.  Unlike `numpy.power`, integer inputs to\n"
    "`powm1` are converted to floating point, and complex inputs are\n"
    "not accepted.\n"
    "\n"
    "Note the following edge cases:\n"
    "\n"
    "* ``powm1(x, 0)`` returns 0 for any ``x``, including 0, ``inf``\n"
    "  and ``nan``.\n"
    "* ``powm1(1, y)`` returns 0 for any ``y``, including ``nan``\n"
    "  and ``inf``.\n"
    "\n"
    "This function wraps the ``powm1`` routine from the\n"
    "Boost Math C++ library [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] The Boost Developers. \"Boost C++ Libraries\". https://www.boost.org/.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import powm1\n"
    "\n"
    ">>> x = np.array([1.2, 10.0, 0.9999999975])\n"
    ">>> y = np.array([1e-9, 1e-11, 0.1875])\n"
    ">>> powm1(x, y)\n"
    "array([ 1.82321557e-10,  2.30258509e-11, -4.68749998e-10])\n"
    "\n"
    "It can be verified that the relative errors in those results\n"
    "are less than 2.5e-16.\n"
    "\n"
    "Compare that to the result of ``x**y - 1``, where the\n"
    "relative errors are all larger than 8e-8:\n"
    "\n"
    ">>> x**y - 1\n"
    "array([ 1.82321491e-10,  2.30258035e-11, -4.68750039e-10])")
ufunc_powm1_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc_powm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_powm1_types[0] = <char>NPY_FLOAT
ufunc_powm1_types[1] = <char>NPY_FLOAT
ufunc_powm1_types[2] = <char>NPY_FLOAT
ufunc_powm1_types[3] = <char>NPY_DOUBLE
ufunc_powm1_types[4] = <char>NPY_DOUBLE
ufunc_powm1_types[5] = <char>NPY_DOUBLE
ufunc_powm1_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_powm1_float
ufunc_powm1_ptr[2*0+1] = <void*>(<char*>"powm1")
ufunc_powm1_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_powm1_double
ufunc_powm1_ptr[2*1+1] = <void*>(<char*>"powm1")
ufunc_powm1_data[0] = &ufunc_powm1_ptr[2*0]
ufunc_powm1_data[1] = &ufunc_powm1_ptr[2*1]
powm1 = np.PyUFunc_FromFuncAndData(ufunc_powm1_loops, ufunc_powm1_data, ufunc_powm1_types, 2, 2, 1, 0, "powm1", ufunc_powm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pseudo_huber_loops[2]
cdef void *ufunc_pseudo_huber_ptr[4]
cdef void *ufunc_pseudo_huber_data[2]
cdef char ufunc_pseudo_huber_types[6]
cdef char *ufunc_pseudo_huber_doc = (
    "pseudo_huber(delta, r, out=None)\n"
    "\n"
    "Pseudo-Huber loss function.\n"
    "\n"
    ".. math:: \\mathrm{pseudo\\_huber}(\\delta, r) =\n"
    "          \\delta^2 \\left( \\sqrt{ 1 + \\left( \\frac{r}{\\delta} \\right)^2 } - 1 \\right)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "delta : array_like\n"
    "    Input array, indicating the soft quadratic vs. linear loss changepoint.\n"
    "r : array_like\n"
    "    Input array, possibly representing residuals.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : scalar or ndarray\n"
    "    The computed Pseudo-Huber loss function values.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "huber: Similar function which this function approximates\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Like `huber`, `pseudo_huber` often serves as a robust loss function\n"
    "in statistics or machine learning to reduce the influence of outliers.\n"
    "Unlike `huber`, `pseudo_huber` is smooth.\n"
    "\n"
    "Typically, `r` represents residuals, the difference\n"
    "between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n"
    "`pseudo_huber` resembles the squared error and for :math:`|r|>\\delta` the\n"
    "absolute error. This way, the Pseudo-Huber loss often achieves\n"
    "a fast convergence in model fitting for small residuals like the squared\n"
    "error loss function and still reduces the influence of outliers\n"
    "(:math:`|r|>\\delta`) like the absolute error loss. As :math:`\\delta` is\n"
    "the cutoff between squared and absolute error regimes, it has\n"
    "to be tuned carefully for each problem. `pseudo_huber` is also\n"
    "convex, making it suitable for gradient based optimization. [1]_ [2]_\n"
    "\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Hartley, Zisserman, \"Multiple View Geometry in Computer Vision\".\n"
    "       2003. Cambridge University Press. p. 619\n"
    ".. [2] Charbonnier et al. \"Deterministic edge-preserving regularization\n"
    "       in computed imaging\". 1997. IEEE Trans. Image Processing.\n"
    "       6 (2): 298 - 311.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Import all necessary modules.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import pseudo_huber, huber\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Calculate the function for ``delta=1`` at ``r=2``.\n"
    "\n"
    ">>> pseudo_huber(1., 2.)\n"
    "1.2360679774997898\n"
    "\n"
    "Calculate the function at ``r=2`` for different `delta` by providing\n"
    "a list or NumPy array for `delta`.\n"
    "\n"
    ">>> pseudo_huber([1., 2., 4.], 3.)\n"
    "array([2.16227766, 3.21110255, 4.        ])\n"
    "\n"
    "Calculate the function for ``delta=1`` at several points by providing\n"
    "a list or NumPy array for `r`.\n"
    "\n"
    ">>> pseudo_huber(2., np.array([1., 1.5, 3., 4.]))\n"
    "array([0.47213595, 1.        , 3.21110255, 4.94427191])\n"
    "\n"
    "The function can be calculated for different `delta` and `r` by\n"
    "providing arrays for both with compatible shapes for broadcasting.\n"
    "\n"
    ">>> r = np.array([1., 2.5, 8., 10.])\n"
    ">>> deltas = np.array([[1.], [5.], [9.]])\n"
    ">>> print(r.shape, deltas.shape)\n"
    "(4,) (3, 1)\n"
    "\n"
    ">>> pseudo_huber(deltas, r)\n"
    "array([[ 0.41421356,  1.6925824 ,  7.06225775,  9.04987562],\n"
    "       [ 0.49509757,  2.95084972, 22.16990566, 30.90169944],\n"
    "       [ 0.49846624,  3.06693762, 27.37435121, 40.08261642]])\n"
    "\n"
    "Plot the function for different `delta`.\n"
    "\n"
    ">>> x = np.linspace(-4, 4, 500)\n"
    ">>> deltas = [1, 2, 3]\n"
    ">>> linestyles = [\"dashed\", \"dotted\", \"dashdot\"]\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> combined_plot_parameters = list(zip(deltas, linestyles))\n"
    ">>> for delta, style in combined_plot_parameters:\n"
    "...     ax.plot(x, pseudo_huber(delta, x), label=rf\"$\\delta={delta}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend(loc=\"upper center\")\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(r\"Pseudo-Huber loss function $h_{\\delta}(x)$\")\n"
    ">>> ax.set_xlim(-4, 4)\n"
    ">>> ax.set_ylim(0, 8)\n"
    ">>> plt.show()\n"
    "\n"
    "Finally, illustrate the difference between `huber` and `pseudo_huber` by\n"
    "plotting them and their gradients with respect to `r`. The plot shows\n"
    "that `pseudo_huber` is continuously differentiable while `huber` is not\n"
    "at the points :math:`\\pm\\delta`.\n"
    "\n"
    ">>> def huber_grad(delta, x):\n"
    "...     grad = np.copy(x)\n"
    "...     linear_area = np.argwhere(np.abs(x) > delta)\n"
    "...     grad[linear_area]=delta*np.sign(x[linear_area])\n"
    "...     return grad\n"
    ">>> def pseudo_huber_grad(delta, x):\n"
    "...     return x* (1+(x/delta)**2)**(-0.5)\n"
    ">>> x=np.linspace(-3, 3, 500)\n"
    ">>> delta = 1.\n"
    ">>> fig, ax = plt.subplots(figsize=(7, 7))\n"
    ">>> ax.plot(x, huber(delta, x), label=\"Huber\", ls=\"dashed\")\n"
    ">>> ax.plot(x, huber_grad(delta, x), label=\"Huber Gradient\", ls=\"dashdot\")\n"
    ">>> ax.plot(x, pseudo_huber(delta, x), label=\"Pseudo-Huber\", ls=\"dotted\")\n"
    ">>> ax.plot(x, pseudo_huber_grad(delta, x), label=\"Pseudo-Huber Gradient\",\n"
    "...         ls=\"solid\")\n"
    ">>> ax.legend(loc=\"upper center\")\n"
    ">>> plt.show()")
ufunc_pseudo_huber_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pseudo_huber_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pseudo_huber_types[0] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[1] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[2] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[3] = <char>NPY_DOUBLE
ufunc_pseudo_huber_types[4] = <char>NPY_DOUBLE
ufunc_pseudo_huber_types[5] = <char>NPY_DOUBLE
ufunc_pseudo_huber_ptr[2*0] = <void*>_func_pseudo_huber
ufunc_pseudo_huber_ptr[2*0+1] = <void*>(<char*>"pseudo_huber")
ufunc_pseudo_huber_ptr[2*1] = <void*>_func_pseudo_huber
ufunc_pseudo_huber_ptr[2*1+1] = <void*>(<char*>"pseudo_huber")
ufunc_pseudo_huber_data[0] = &ufunc_pseudo_huber_ptr[2*0]
ufunc_pseudo_huber_data[1] = &ufunc_pseudo_huber_ptr[2*1]
pseudo_huber = np.PyUFunc_FromFuncAndData(ufunc_pseudo_huber_loops, ufunc_pseudo_huber_data, ufunc_pseudo_huber_types, 2, 2, 1, 0, "pseudo_huber", ufunc_pseudo_huber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_rel_entr_loops[2]
cdef void *ufunc_rel_entr_ptr[4]
cdef void *ufunc_rel_entr_data[2]
cdef char ufunc_rel_entr_types[6]
cdef char *ufunc_rel_entr_doc = (
    "rel_entr(x, y, out=None)\n"
    "\n"
    "Elementwise function for computing relative entropy.\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{rel\\_entr}(x, y) =\n"
    "        \\begin{cases}\n"
    "            x \\log(x / y) & x > 0, y > 0 \\\\\n"
    "            0 & x = 0, y \\ge 0 \\\\\n"
    "            \\infty & \\text{otherwise}\n"
    "        \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y : array_like\n"
    "    Input arrays\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Relative entropy of the inputs\n"
    "\n"
    "See Also\n"
    "--------\n"
    "entr, kl_div, scipy.stats.entropy\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "This function is jointly convex in x and y.\n"
    "\n"
    "The origin of this function is in convex programming; see\n"
    "[1]_. Given two discrete probability distributions :math:`p_1,\n"
    "\\ldots, p_n` and :math:`q_1, \\ldots, q_n`, the definition of relative\n"
    "entropy in the context of *information theory* is\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\sum_{i = 1}^n \\mathrm{rel\\_entr}(p_i, q_i).\n"
    "\n"
    "To compute the latter quantity, use `scipy.stats.entropy`.\n"
    "\n"
    "See [2]_ for details.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n"
    "       Cambridge University Press, 2004.\n"
    "       :doi:`https://doi.org/10.1017/CBO9780511804441`\n"
    ".. [2] Kullback-Leibler divergence,\n"
    "       https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence")
ufunc_rel_entr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_rel_entr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_rel_entr_types[0] = <char>NPY_FLOAT
ufunc_rel_entr_types[1] = <char>NPY_FLOAT
ufunc_rel_entr_types[2] = <char>NPY_FLOAT
ufunc_rel_entr_types[3] = <char>NPY_DOUBLE
ufunc_rel_entr_types[4] = <char>NPY_DOUBLE
ufunc_rel_entr_types[5] = <char>NPY_DOUBLE
ufunc_rel_entr_ptr[2*0] = <void*>_func_rel_entr
ufunc_rel_entr_ptr[2*0+1] = <void*>(<char*>"rel_entr")
ufunc_rel_entr_ptr[2*1] = <void*>_func_rel_entr
ufunc_rel_entr_ptr[2*1+1] = <void*>(<char*>"rel_entr")
ufunc_rel_entr_data[0] = &ufunc_rel_entr_ptr[2*0]
ufunc_rel_entr_data[1] = &ufunc_rel_entr_ptr[2*1]
rel_entr = np.PyUFunc_FromFuncAndData(ufunc_rel_entr_loops, ufunc_rel_entr_data, ufunc_rel_entr_types, 2, 2, 1, 0, "rel_entr", ufunc_rel_entr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_round_loops[2]
cdef void *ufunc_round_ptr[4]
cdef void *ufunc_round_data[2]
cdef char ufunc_round_types[4]
cdef char *ufunc_round_doc = (
    "round(x, out=None)\n"
    "\n"
    "Round to the nearest integer.\n"
    "\n"
    "Returns the nearest integer to `x`.  If `x` ends in 0.5 exactly,\n"
    "the nearest even integer is chosen.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real valued input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The nearest integers to the elements of `x`. The result is of\n"
    "    floating type, not integer type.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It rounds to even.\n"
    "\n"
    ">>> sc.round([0.5, 1.5])\n"
    "array([0., 2.])")
ufunc_round_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_round_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_round_types[0] = <char>NPY_FLOAT
ufunc_round_types[1] = <char>NPY_FLOAT
ufunc_round_types[2] = <char>NPY_DOUBLE
ufunc_round_types[3] = <char>NPY_DOUBLE
ufunc_round_ptr[2*0] = <void*>_func_cephes_round
ufunc_round_ptr[2*0+1] = <void*>(<char*>"round")
ufunc_round_ptr[2*1] = <void*>_func_cephes_round
ufunc_round_ptr[2*1+1] = <void*>(<char*>"round")
ufunc_round_data[0] = &ufunc_round_ptr[2*0]
ufunc_round_data[1] = &ufunc_round_ptr[2*1]
round = np.PyUFunc_FromFuncAndData(ufunc_round_loops, ufunc_round_data, ufunc_round_types, 2, 1, 1, 0, "round", ufunc_round_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_shichi_loops[4]
cdef void *ufunc_shichi_ptr[8]
cdef void *ufunc_shichi_data[4]
cdef char ufunc_shichi_types[12]
cdef char *ufunc_shichi_doc = (
    "shichi(x, out=None)\n"
    "\n"
    "Hyperbolic sine and cosine integrals.\n"
    "\n"
    "The hyperbolic sine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\int_0^x \\frac{\\sinh{t}}{t}dt\n"
    "\n"
    "and the hyperbolic cosine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\gamma + \\log(x) + \\int_0^x \\frac{\\cosh{t} - 1}{t} dt\n"
    "\n"
    "where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n"
    "principal branch of the logarithm [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex points at which to compute the hyperbolic sine\n"
    "    and cosine integrals.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "si : scalar or ndarray\n"
    "    Hyperbolic sine integral at ``x``\n"
    "ci : scalar or ndarray\n"
    "    Hyperbolic cosine integral at ``x``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sici : Sine and cosine integrals.\n"
    "exp1 : Exponential integral E1.\n"
    "expi : Exponential integral Ei.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real arguments with ``x < 0``, ``chi`` is the real part of the\n"
    "hyperbolic cosine integral. For such points ``chi(x)`` and ``chi(x\n"
    "+ 0j)`` differ by a factor of ``1j*pi``.\n"
    "\n"
    "For real arguments the function is computed by calling Cephes'\n"
    "[2]_ *shichi* routine. For complex arguments the algorithm is based\n"
    "on Mpmath's [3]_ *shi* and *chi* routines.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "       (See Section 5.2.)\n"
    ".. [2] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [3] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point\n"
    "       arithmetic\" (Version 0.19) http://mpmath.org/\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import shichi, sici\n"
    "\n"
    "`shichi` accepts real or complex input:\n"
    "\n"
    ">>> shichi(0.5)\n"
    "(0.5069967498196671, -0.05277684495649357)\n"
    ">>> shichi(0.5 + 2.5j)\n"
    "((0.11772029666668238+1.831091777729851j),\n"
    " (0.29912435887648825+1.7395351121166562j))\n"
    "\n"
    "The hyperbolic sine and cosine integrals Shi(z) and Chi(z) are\n"
    "related to the sine and cosine integrals Si(z) and Ci(z) by\n"
    "\n"
    "* Shi(z) = -i*Si(i*z)\n"
    "* Chi(z) = Ci(-i*z) + i*pi/2\n"
    "\n"
    ">>> z = 0.25 + 5j\n"
    ">>> shi, chi = shichi(z)\n"
    ">>> shi, -1j*sici(1j*z)[0]            # Should be the same.\n"
    "((-0.04834719325101729+1.5469354086921228j),\n"
    " (-0.04834719325101729+1.5469354086921228j))\n"
    ">>> chi, sici(-1j*z)[1] + 1j*np.pi/2  # Should be the same.\n"
    "((-0.19568708973868087+1.556276312103824j),\n"
    " (-0.19568708973868087+1.556276312103824j))\n"
    "\n"
    "Plot the functions evaluated on the real axis:\n"
    "\n"
    ">>> xp = np.geomspace(1e-8, 4.0, 250)\n"
    ">>> x = np.concatenate((-xp[::-1], xp))\n"
    ">>> shi, chi = shichi(x)\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, shi, label='Shi(x)')\n"
    ">>> ax.plot(x, chi, '--', label='Chi(x)')\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.set_title('Hyperbolic Sine and Cosine Integrals')\n"
    ">>> ax.legend(shadow=True, framealpha=1, loc='lower right')\n"
    ">>> ax.grid(True)\n"
    ">>> plt.show()")
ufunc_shichi_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_shichi_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_shichi_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_shichi_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_shichi_types[0] = <char>NPY_FLOAT
ufunc_shichi_types[1] = <char>NPY_FLOAT
ufunc_shichi_types[2] = <char>NPY_FLOAT
ufunc_shichi_types[3] = <char>NPY_DOUBLE
ufunc_shichi_types[4] = <char>NPY_DOUBLE
ufunc_shichi_types[5] = <char>NPY_DOUBLE
ufunc_shichi_types[6] = <char>NPY_CFLOAT
ufunc_shichi_types[7] = <char>NPY_CFLOAT
ufunc_shichi_types[8] = <char>NPY_CFLOAT
ufunc_shichi_types[9] = <char>NPY_CDOUBLE
ufunc_shichi_types[10] = <char>NPY_CDOUBLE
ufunc_shichi_types[11] = <char>NPY_CDOUBLE
ufunc_shichi_ptr[2*0] = <void*>_func_xsf_shichi
ufunc_shichi_ptr[2*0+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*1] = <void*>_func_xsf_shichi
ufunc_shichi_ptr[2*1+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*2] = <void*>_func_xsf_cshichi
ufunc_shichi_ptr[2*2+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*3] = <void*>_func_xsf_cshichi
ufunc_shichi_ptr[2*3+1] = <void*>(<char*>"shichi")
ufunc_shichi_data[0] = &ufunc_shichi_ptr[2*0]
ufunc_shichi_data[1] = &ufunc_shichi_ptr[2*1]
ufunc_shichi_data[2] = &ufunc_shichi_ptr[2*2]
ufunc_shichi_data[3] = &ufunc_shichi_ptr[2*3]
shichi = np.PyUFunc_FromFuncAndData(ufunc_shichi_loops, ufunc_shichi_data, ufunc_shichi_types, 4, 1, 2, 0, "shichi", ufunc_shichi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_sici_loops[4]
cdef void *ufunc_sici_ptr[8]
cdef void *ufunc_sici_data[4]
cdef char ufunc_sici_types[12]
cdef char *ufunc_sici_doc = (
    "sici(x, out=None)\n"
    "\n"
    "Sine and cosine integrals.\n"
    "\n"
    "The sine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\int_0^x \\frac{\\sin{t}}{t}dt\n"
    "\n"
    "and the cosine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\gamma + \\log(x) + \\int_0^x \\frac{\\cos{t} - 1}{t}dt\n"
    "\n"
    "where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n"
    "principal branch of the logarithm [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex points at which to compute the sine and cosine\n"
    "    integrals.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "si : scalar or ndarray\n"
    "    Sine integral at ``x``\n"
    "ci : scalar or ndarray\n"
    "    Cosine integral at ``x``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "shichi : Hyperbolic sine and cosine integrals.\n"
    "exp1 : Exponential integral E1.\n"
    "expi : Exponential integral Ei.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real arguments with ``x < 0``, ``ci`` is the real part of the\n"
    "cosine integral. For such points ``ci(x)`` and ``ci(x + 0j)``\n"
    "differ by a factor of ``1j*pi``.\n"
    "\n"
    "For real arguments the function is computed by calling Cephes'\n"
    "[2]_ *sici* routine. For complex arguments the algorithm is based\n"
    "on Mpmath's [3]_ *si* and *ci* routines.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "       (See Section 5.2.)\n"
    ".. [2] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [3] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point\n"
    "       arithmetic\" (Version 0.19) http://mpmath.org/\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import sici, exp1\n"
    "\n"
    "`sici` accepts real or complex input:\n"
    "\n"
    ">>> sici(2.5)\n"
    "(1.7785201734438267, 0.2858711963653835)\n"
    ">>> sici(2.5 + 3j)\n"
    "((4.505735874563953+0.06863305018999577j),\n"
    "(0.0793644206906966-2.935510262937543j))\n"
    "\n"
    "For z in the right half plane, the sine and cosine integrals are\n"
    "related to the exponential integral E1 (implemented in SciPy as\n"
    "`scipy.special.exp1`) by\n"
    "\n"
    "* Si(z) = (E1(i*z) - E1(-i*z))/2i + pi/2\n"
    "* Ci(z) = -(E1(i*z) + E1(-i*z))/2\n"
    "\n"
    "See [1]_ (equations 5.2.21 and 5.2.23).\n"
    "\n"
    "We can verify these relations:\n"
    "\n"
    ">>> z = 2 - 3j\n"
    ">>> sici(z)\n"
    "((4.54751388956229-1.3991965806460565j),\n"
    "(1.408292501520851+2.9836177420296055j))\n"
    "\n"
    ">>> (exp1(1j*z) - exp1(-1j*z))/2j + np.pi/2  # Same as sine integral\n"
    "(4.54751388956229-1.3991965806460565j)\n"
    "\n"
    ">>> -(exp1(1j*z) + exp1(-1j*z))/2            # Same as cosine integral\n"
    "(1.408292501520851+2.9836177420296055j)\n"
    "\n"
    "Plot the functions evaluated on the real axis; the dotted horizontal\n"
    "lines are at pi/2 and -pi/2:\n"
    "\n"
    ">>> x = np.linspace(-16, 16, 150)\n"
    ">>> si, ci = sici(x)\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, si, label='Si(x)')\n"
    ">>> ax.plot(x, ci, '--', label='Ci(x)')\n"
    ">>> ax.legend(shadow=True, framealpha=1, loc='upper left')\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.set_title('Sine and Cosine Integrals')\n"
    ">>> ax.axhline(np.pi/2, linestyle=':', alpha=0.5, color='k')\n"
    ">>> ax.axhline(-np.pi/2, linestyle=':', alpha=0.5, color='k')\n"
    ">>> ax.grid(True)\n"
    ">>> plt.show()")
ufunc_sici_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_sici_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_sici_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_sici_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_sici_types[0] = <char>NPY_FLOAT
ufunc_sici_types[1] = <char>NPY_FLOAT
ufunc_sici_types[2] = <char>NPY_FLOAT
ufunc_sici_types[3] = <char>NPY_DOUBLE
ufunc_sici_types[4] = <char>NPY_DOUBLE
ufunc_sici_types[5] = <char>NPY_DOUBLE
ufunc_sici_types[6] = <char>NPY_CFLOAT
ufunc_sici_types[7] = <char>NPY_CFLOAT
ufunc_sici_types[8] = <char>NPY_CFLOAT
ufunc_sici_types[9] = <char>NPY_CDOUBLE
ufunc_sici_types[10] = <char>NPY_CDOUBLE
ufunc_sici_types[11] = <char>NPY_CDOUBLE
ufunc_sici_ptr[2*0] = <void*>_func_xsf_sici
ufunc_sici_ptr[2*0+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*1] = <void*>_func_xsf_sici
ufunc_sici_ptr[2*1+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*2] = <void*>_func_xsf_csici
ufunc_sici_ptr[2*2+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*3] = <void*>_func_xsf_csici
ufunc_sici_ptr[2*3+1] = <void*>(<char*>"sici")
ufunc_sici_data[0] = &ufunc_sici_ptr[2*0]
ufunc_sici_data[1] = &ufunc_sici_ptr[2*1]
ufunc_sici_data[2] = &ufunc_sici_ptr[2*2]
ufunc_sici_data[3] = &ufunc_sici_ptr[2*3]
sici = np.PyUFunc_FromFuncAndData(ufunc_sici_loops, ufunc_sici_data, ufunc_sici_types, 4, 1, 2, 0, "sici", ufunc_sici_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_smirnov_loops[3]
cdef void *ufunc_smirnov_ptr[6]
cdef void *ufunc_smirnov_data[3]
cdef char ufunc_smirnov_types[9]
cdef char *ufunc_smirnov_doc = (
    "smirnov(n, d, out=None)\n"
    "\n"
    "Kolmogorov-Smirnov complementary cumulative distribution function\n"
    "\n"
    "Returns the exact Kolmogorov-Smirnov complementary cumulative\n"
    "distribution function,(aka the Survival Function) of Dn+ (or Dn-)\n"
    "for a one-sided test of equality between an empirical and a\n"
    "theoretical distribution. It is equal to the probability that the\n"
    "maximum difference between a theoretical distribution and an empirical\n"
    "one based on `n` samples is greater than d.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : int\n"
    "  Number of samples\n"
    "d : float array_like\n"
    "  Deviation between the Empirical CDF (ECDF) and the target CDF.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of smirnov(n, d), Prob(Dn+ >= d) (Also Prob(Dn- >= d))\n"
    "\n"
    "See Also\n"
    "--------\n"
    "smirnovi : The Inverse Survival Function for the distribution\n"
    "scipy.stats.ksone : Provides the functionality as a continuous distribution\n"
    "kolmogorov, kolmogi : Functions for the two-sided distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`smirnov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.ksone` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import smirnov\n"
    ">>> from scipy.stats import norm\n"
    "\n"
    "Show the probability of a gap at least as big as 0, 0.5 and 1.0 for a\n"
    "sample of size 5.\n"
    "\n"
    ">>> smirnov(5, [0, 0.5, 1.0])\n"
    "array([ 1.   ,  0.056,  0.   ])\n"
    "\n"
    "Compare a sample of size 5 against N(0, 1), the standard normal\n"
    "distribution with mean 0 and standard deviation 1.\n"
    "\n"
    "`x` is the sample.\n"
    "\n"
    ">>> x = np.array([-1.392, -0.135, 0.114, 0.190, 1.82])\n"
    "\n"
    ">>> target = norm(0, 1)\n"
    ">>> cdfs = target.cdf(x)\n"
    ">>> cdfs\n"
    "array([0.0819612 , 0.44630594, 0.5453811 , 0.57534543, 0.9656205 ])\n"
    "\n"
    "Construct the empirical CDF and the K-S statistics (Dn+, Dn-, Dn).\n"
    "\n"
    ">>> n = len(x)\n"
    ">>> ecdfs = np.arange(n+1, dtype=float)/n\n"
    ">>> cols = np.column_stack([x, ecdfs[1:], cdfs, cdfs - ecdfs[:n],\n"
    "...                        ecdfs[1:] - cdfs])\n"
    ">>> with np.printoptions(precision=3):\n"
    "...    print(cols)\n"
    "[[-1.392  0.2    0.082  0.082  0.118]\n"
    " [-0.135  0.4    0.446  0.246 -0.046]\n"
    " [ 0.114  0.6    0.545  0.145  0.055]\n"
    " [ 0.19   0.8    0.575 -0.025  0.225]\n"
    " [ 1.82   1.     0.966  0.166  0.034]]\n"
    ">>> gaps = cols[:, -2:]\n"
    ">>> Dnpm = np.max(gaps, axis=0)\n"
    ">>> print(f'Dn-={Dnpm[0]:f}, Dn+={Dnpm[1]:f}')\n"
    "Dn-=0.246306, Dn+=0.224655\n"
    ">>> probs = smirnov(n, Dnpm)\n"
    ">>> print(f'For a sample of size {n} drawn from N(0, 1):',\n"
    "...       f' Smirnov n={n}: Prob(Dn- >= {Dnpm[0]:f}) = {probs[0]:.4f}',\n"
    "...       f' Smirnov n={n}: Prob(Dn+ >= {Dnpm[1]:f}) = {probs[1]:.4f}',\n"
    "...       sep='\\n')\n"
    "For a sample of size 5 drawn from N(0, 1):\n"
    " Smirnov n=5: Prob(Dn- >= 0.246306) = 0.4711\n"
    " Smirnov n=5: Prob(Dn+ >= 0.224655) = 0.5245\n"
    "\n"
    "Plot the empirical CDF and the standard normal CDF.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.step(np.concatenate(([-2.5], x, [2.5])),\n"
    "...          np.concatenate((ecdfs, [1])),\n"
    "...          where='post', label='Empirical CDF')\n"
    ">>> xx = np.linspace(-2.5, 2.5, 100)\n"
    ">>> plt.plot(xx, target.cdf(xx), '--', label='CDF for N(0, 1)')\n"
    "\n"
    "Add vertical lines marking Dn+ and Dn-.\n"
    "\n"
    ">>> iminus, iplus = np.argmax(gaps, axis=0)\n"
    ">>> plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r',\n"
    "...            alpha=0.5, lw=4)\n"
    ">>> plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='m',\n"
    "...            alpha=0.5, lw=4)\n"
    "\n"
    ">>> plt.grid(True)\n"
    ">>> plt.legend(framealpha=1, shadow=True)\n"
    ">>> plt.show()")
ufunc_smirnov_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_smirnov_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_smirnov_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_smirnov_types[0] = <char>NPY_INTP
ufunc_smirnov_types[1] = <char>NPY_DOUBLE
ufunc_smirnov_types[2] = <char>NPY_DOUBLE
ufunc_smirnov_types[3] = <char>NPY_FLOAT
ufunc_smirnov_types[4] = <char>NPY_FLOAT
ufunc_smirnov_types[5] = <char>NPY_FLOAT
ufunc_smirnov_types[6] = <char>NPY_DOUBLE
ufunc_smirnov_types[7] = <char>NPY_DOUBLE
ufunc_smirnov_types[8] = <char>NPY_DOUBLE
ufunc_smirnov_ptr[2*0] = <void*>_func_cephes_smirnov_wrap
ufunc_smirnov_ptr[2*0+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_ptr[2*1] = <void*>_func_smirnov_unsafe
ufunc_smirnov_ptr[2*1+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_ptr[2*2] = <void*>_func_smirnov_unsafe
ufunc_smirnov_ptr[2*2+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_data[0] = &ufunc_smirnov_ptr[2*0]
ufunc_smirnov_data[1] = &ufunc_smirnov_ptr[2*1]
ufunc_smirnov_data[2] = &ufunc_smirnov_ptr[2*2]
smirnov = np.PyUFunc_FromFuncAndData(ufunc_smirnov_loops, ufunc_smirnov_data, ufunc_smirnov_types, 3, 2, 1, 0, "smirnov", ufunc_smirnov_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_smirnovi_loops[3]
cdef void *ufunc_smirnovi_ptr[6]
cdef void *ufunc_smirnovi_data[3]
cdef char ufunc_smirnovi_types[9]
cdef char *ufunc_smirnovi_doc = (
    "smirnovi(n, p, out=None)\n"
    "\n"
    "Inverse to `smirnov`\n"
    "\n"
    "Returns `d` such that ``smirnov(n, d) == p``, the critical value\n"
    "corresponding to `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : int\n"
    "  Number of samples\n"
    "p : float array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of smirnovi(n, p), the critical values.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "smirnov : The Survival Function (SF) for the distribution\n"
    "scipy.stats.ksone : Provides the functionality as a continuous distribution\n"
    "kolmogorov, kolmogi : Functions for the two-sided distribution\n"
    "scipy.stats.kstwobign : Two-sided Kolmogorov-Smirnov distribution, large n\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`smirnov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.ksone` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import smirnovi, smirnov\n"
    "\n"
    ">>> n = 24\n"
    ">>> deviations = [0.1, 0.2, 0.3]\n"
    "\n"
    "Use `smirnov` to compute the complementary CDF of the Smirnov\n"
    "distribution for the given number of samples and deviations.\n"
    "\n"
    ">>> p = smirnov(n, deviations)\n"
    ">>> p\n"
    "array([0.58105083, 0.12826832, 0.01032231])\n"
    "\n"
    "The inverse function ``smirnovi(n, p)`` returns ``deviations``.\n"
    "\n"
    ">>> smirnovi(n, p)\n"
    "array([0.1, 0.2, 0.3])")
ufunc_smirnovi_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_smirnovi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_smirnovi_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_smirnovi_types[0] = <char>NPY_INTP
ufunc_smirnovi_types[1] = <char>NPY_DOUBLE
ufunc_smirnovi_types[2] = <char>NPY_DOUBLE
ufunc_smirnovi_types[3] = <char>NPY_FLOAT
ufunc_smirnovi_types[4] = <char>NPY_FLOAT
ufunc_smirnovi_types[5] = <char>NPY_FLOAT
ufunc_smirnovi_types[6] = <char>NPY_DOUBLE
ufunc_smirnovi_types[7] = <char>NPY_DOUBLE
ufunc_smirnovi_types[8] = <char>NPY_DOUBLE
ufunc_smirnovi_ptr[2*0] = <void*>_func_cephes_smirnovi_wrap
ufunc_smirnovi_ptr[2*0+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_ptr[2*1] = <void*>_func_smirnovi_unsafe
ufunc_smirnovi_ptr[2*1+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_ptr[2*2] = <void*>_func_smirnovi_unsafe
ufunc_smirnovi_ptr[2*2+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_data[0] = &ufunc_smirnovi_ptr[2*0]
ufunc_smirnovi_data[1] = &ufunc_smirnovi_ptr[2*1]
ufunc_smirnovi_data[2] = &ufunc_smirnovi_ptr[2*2]
smirnovi = np.PyUFunc_FromFuncAndData(ufunc_smirnovi_loops, ufunc_smirnovi_data, ufunc_smirnovi_types, 3, 2, 1, 0, "smirnovi", ufunc_smirnovi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_spence_loops[4]
cdef void *ufunc_spence_ptr[8]
cdef void *ufunc_spence_data[4]
cdef char ufunc_spence_types[8]
cdef char *ufunc_spence_doc = (
    "spence(z, out=None)\n"
    "\n"
    "Spence's function, also known as the dilogarithm.\n"
    "\n"
    "It is defined to be\n"
    "\n"
    ".. math::\n"
    "  \\int_1^z \\frac{\\log(t)}{1 - t}dt\n"
    "\n"
    "for complex :math:`z`, where the contour of integration is taken\n"
    "to avoid the branch cut of the logarithm. Spence's function is\n"
    "analytic everywhere except the negative real axis where it has a\n"
    "branch cut.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Points at which to evaluate Spence's function\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Computed values of Spence's function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "There is a different convention which defines Spence's function by\n"
    "the integral\n"
    "\n"
    ".. math::\n"
    "  -\\int_0^z \\frac{\\log(1 - t)}{t}dt;\n"
    "\n"
    "this is our ``spence(1 - z)``.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import spence\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "The function is defined for complex inputs:\n"
    "\n"
    ">>> spence([1-1j, 1.5+2j, 3j, -10-5j])\n"
    "array([-0.20561676+0.91596559j, -0.86766909-1.39560134j,\n"
    "       -0.59422064-2.49129918j, -1.14044398+6.80075924j])\n"
    "\n"
    "For complex inputs on the branch cut, which is the negative real axis,\n"
    "the function returns the limit for ``z`` with positive imaginary part.\n"
    "For example, in the following, note the sign change of the imaginary\n"
    "part of the output for ``z = -2`` and ``z = -2 - 1e-8j``:\n"
    "\n"
    ">>> spence([-2 + 1e-8j, -2, -2 - 1e-8j])\n"
    "array([2.32018041-3.45139229j, 2.32018042-3.4513923j ,\n"
    "       2.32018041+3.45139229j])\n"
    "\n"
    "The function returns ``nan`` for real inputs on the branch cut:\n"
    "\n"
    ">>> spence(-1.5)\n"
    "nan\n"
    "\n"
    "Verify some particular values: ``spence(0) = pi**2/6``,\n"
    "``spence(1) = 0`` and ``spence(2) = -pi**2/12``.\n"
    "\n"
    ">>> spence([0, 1, 2])\n"
    "array([ 1.64493407,  0.        , -0.82246703])\n"
    ">>> np.pi**2/6, -np.pi**2/12\n"
    "(1.6449340668482264, -0.8224670334241132)\n"
    "\n"
    "Verify the identity::\n"
    "\n"
    "    spence(z) + spence(1 - z) = pi**2/6 - log(z)*log(1 - z)\n"
    "\n"
    ">>> z = 3 + 4j\n"
    ">>> spence(z) + spence(1 - z)\n"
    "(-2.6523186143876067+1.8853470951513935j)\n"
    ">>> np.pi**2/6 - np.log(z)*np.log(1 - z)\n"
    "(-2.652318614387606+1.885347095151394j)\n"
    "\n"
    "Plot the function for positive real input.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0, 6, 400)\n"
    ">>> ax.plot(x, spence(x))\n"
    ">>> ax.grid()\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.set_title('spence(x)')\n"
    ">>> plt.show()")
ufunc_spence_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_spence_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_spence_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_spence_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_spence_types[0] = <char>NPY_FLOAT
ufunc_spence_types[1] = <char>NPY_FLOAT
ufunc_spence_types[2] = <char>NPY_DOUBLE
ufunc_spence_types[3] = <char>NPY_DOUBLE
ufunc_spence_types[4] = <char>NPY_CFLOAT
ufunc_spence_types[5] = <char>NPY_CFLOAT
ufunc_spence_types[6] = <char>NPY_CDOUBLE
ufunc_spence_types[7] = <char>NPY_CDOUBLE
ufunc_spence_ptr[2*0] = <void*>_func_cephes_spence
ufunc_spence_ptr[2*0+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*1] = <void*>_func_cephes_spence
ufunc_spence_ptr[2*1+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*2] = <void*>_func_cspence
ufunc_spence_ptr[2*2+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*3] = <void*>_func_cspence
ufunc_spence_ptr[2*3+1] = <void*>(<char*>"spence")
ufunc_spence_data[0] = &ufunc_spence_ptr[2*0]
ufunc_spence_data[1] = &ufunc_spence_ptr[2*1]
ufunc_spence_data[2] = &ufunc_spence_ptr[2*2]
ufunc_spence_data[3] = &ufunc_spence_ptr[2*3]
spence = np.PyUFunc_FromFuncAndData(ufunc_spence_loops, ufunc_spence_data, ufunc_spence_types, 4, 1, 1, 0, "spence", ufunc_spence_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtr_loops[2]
cdef void *ufunc_stdtr_ptr[4]
cdef void *ufunc_stdtr_data[2]
cdef char ufunc_stdtr_types[6]
cdef char *ufunc_stdtr_doc = (
    "stdtr(df, t, out=None)\n"
    "\n"
    "Student t distribution cumulative distribution function\n"
    "\n"
    "Returns the integral:\n"
    "\n"
    ".. math::\n"
    "    \\frac{\\Gamma((df+1)/2)}{\\sqrt{\\pi df} \\Gamma(df/2)}\n"
    "    \\int_{-\\infty}^t (1+x^2/df)^{-(df+1)/2}\\, dx\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom\n"
    "t : array_like\n"
    "    Upper bound of the integral\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the Student t CDF at t\n"
    "\n"
    "See Also\n"
    "--------\n"
    "stdtridf : inverse of stdtr with respect to `df`\n"
    "stdtrit : inverse of stdtr with respect to `t`\n"
    "scipy.stats.t : student t distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The student t distribution is also available as `scipy.stats.t`.\n"
    "Calling `stdtr` directly can improve performance compared to the\n"
    "``cdf`` method of `scipy.stats.t` (see last example below).\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function for ``df=3`` at ``t=1``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import stdtr\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> stdtr(3, 1)\n"
    "0.8044988905221148\n"
    "\n"
    "Plot the function for three different degrees of freedom.\n"
    "\n"
    ">>> x = np.linspace(-10, 10, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> parameters = [(1, \"solid\"), (3, \"dashed\"), (10, \"dotted\")]\n"
    ">>> for (df, linestyle) in parameters:\n"
    "...     ax.plot(x, stdtr(df, x), ls=linestyle, label=f\"$df={df}$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_title(\"Student t distribution cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The function can be computed for several degrees of freedom at the same\n"
    "time by providing a NumPy array or list for `df`:\n"
    "\n"
    ">>> stdtr([1, 2, 3], 1)\n"
    "array([0.75      , 0.78867513, 0.80449889])\n"
    "\n"
    "It is possible to calculate the function at several points for several\n"
    "different degrees of freedom simultaneously by providing arrays for `df`\n"
    "and `t` with shapes compatible for broadcasting. Compute `stdtr` at\n"
    "4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n"
    "\n"
    ">>> dfs = np.array([[1], [2], [3]])\n"
    ">>> t = np.array([2, 4, 6, 8])\n"
    ">>> dfs.shape, t.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> stdtr(dfs, t)\n"
    "array([[0.85241638, 0.92202087, 0.94743154, 0.96041658],\n"
    "       [0.90824829, 0.97140452, 0.98666426, 0.99236596],\n"
    "       [0.93033702, 0.98599577, 0.99536364, 0.99796171]])\n"
    "\n"
    "The t distribution is also available as `scipy.stats.t`. Calling `stdtr`\n"
    "directly can be much faster than calling the ``cdf`` method of\n"
    "`scipy.stats.t`. To get the same results, one must use the following\n"
    "parametrization: ``scipy.stats.t(df).cdf(x) = stdtr(df, x)``.\n"
    "\n"
    ">>> from scipy.stats import t\n"
    ">>> df, x = 3, 1\n"
    ">>> stdtr_result = stdtr(df, x)  # this can be faster than below\n"
    ">>> stats_result = t(df).cdf(x)\n"
    ">>> stats_result == stdtr_result  # test that results are equal\n"
    "True")
ufunc_stdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtr_types[0] = <char>NPY_FLOAT
ufunc_stdtr_types[1] = <char>NPY_FLOAT
ufunc_stdtr_types[2] = <char>NPY_FLOAT
ufunc_stdtr_types[3] = <char>NPY_DOUBLE
ufunc_stdtr_types[4] = <char>NPY_DOUBLE
ufunc_stdtr_types[5] = <char>NPY_DOUBLE
ufunc_stdtr_ptr[2*0] = <void*>_func_stdtr
ufunc_stdtr_ptr[2*0+1] = <void*>(<char*>"stdtr")
ufunc_stdtr_ptr[2*1] = <void*>_func_stdtr
ufunc_stdtr_ptr[2*1+1] = <void*>(<char*>"stdtr")
ufunc_stdtr_data[0] = &ufunc_stdtr_ptr[2*0]
ufunc_stdtr_data[1] = &ufunc_stdtr_ptr[2*1]
stdtr = np.PyUFunc_FromFuncAndData(ufunc_stdtr_loops, ufunc_stdtr_data, ufunc_stdtr_types, 2, 2, 1, 0, "stdtr", ufunc_stdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtridf_loops[2]
cdef void *ufunc_stdtridf_ptr[4]
cdef void *ufunc_stdtridf_data[2]
cdef char ufunc_stdtridf_types[6]
cdef char *ufunc_stdtridf_doc = (
    "stdtridf(p, t, out=None)\n"
    "\n"
    "Inverse of `stdtr` vs df\n"
    "\n"
    "Returns the argument df such that stdtr(df, t) is equal to `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability\n"
    "t : array_like\n"
    "    Upper bound of the integral\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "df : scalar or ndarray\n"
    "    Value of `df` such that ``stdtr(df, t) == p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "stdtr : Student t CDF\n"
    "stdtrit : inverse of stdtr with respect to `t`\n"
    "scipy.stats.t : Student t distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the student t cumulative distribution function for one\n"
    "parameter set.\n"
    "\n"
    ">>> from scipy.special import stdtr, stdtridf\n"
    ">>> df, x = 5, 2\n"
    ">>> cdf_value = stdtr(df, x)\n"
    ">>> cdf_value\n"
    "0.9490302605850709\n"
    "\n"
    "Verify that `stdtridf` recovers the original value for `df` given\n"
    "the CDF value and `x`.\n"
    "\n"
    ">>> stdtridf(cdf_value, x)\n"
    "5.0")
ufunc_stdtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtridf_types[0] = <char>NPY_FLOAT
ufunc_stdtridf_types[1] = <char>NPY_FLOAT
ufunc_stdtridf_types[2] = <char>NPY_FLOAT
ufunc_stdtridf_types[3] = <char>NPY_DOUBLE
ufunc_stdtridf_types[4] = <char>NPY_DOUBLE
ufunc_stdtridf_types[5] = <char>NPY_DOUBLE
ufunc_stdtridf_ptr[2*0] = <void*>_func_stdtridf
ufunc_stdtridf_ptr[2*0+1] = <void*>(<char*>"stdtridf")
ufunc_stdtridf_ptr[2*1] = <void*>_func_stdtridf
ufunc_stdtridf_ptr[2*1+1] = <void*>(<char*>"stdtridf")
ufunc_stdtridf_data[0] = &ufunc_stdtridf_ptr[2*0]
ufunc_stdtridf_data[1] = &ufunc_stdtridf_ptr[2*1]
stdtridf = np.PyUFunc_FromFuncAndData(ufunc_stdtridf_loops, ufunc_stdtridf_data, ufunc_stdtridf_types, 2, 2, 1, 0, "stdtridf", ufunc_stdtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtrit_loops[2]
cdef void *ufunc_stdtrit_ptr[4]
cdef void *ufunc_stdtrit_data[2]
cdef char ufunc_stdtrit_types[6]
cdef char *ufunc_stdtrit_doc = (
    "stdtrit(df, p, out=None)\n"
    "\n"
    "The `p`-th quantile of the student t distribution.\n"
    "\n"
    "This function is the inverse of the student t distribution cumulative\n"
    "distribution function (CDF), returning `t` such that `stdtr(df, t) = p`.\n"
    "\n"
    "Returns the argument `t` such that stdtr(df, t) is equal to `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom\n"
    "p : array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "t : scalar or ndarray\n"
    "    Value of `t` such that ``stdtr(df, t) == p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "stdtr : Student t CDF\n"
    "stdtridf : inverse of stdtr with respect to `df`\n"
    "scipy.stats.t : Student t distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The student t distribution is also available as `scipy.stats.t`. Calling\n"
    "`stdtrit` directly can improve performance compared to the ``ppf``\n"
    "method of `scipy.stats.t` (see last example below).\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`stdtrit` represents the inverse of the student t distribution CDF which\n"
    "is available as `stdtr`. Here, we calculate the CDF for ``df`` at\n"
    "``x=1``. `stdtrit` then returns ``1`` up to floating point errors\n"
    "given the same value for `df` and the computed CDF value.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import stdtr, stdtrit\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> df = 3\n"
    ">>> x = 1\n"
    ">>> cdf_value = stdtr(df, x)\n"
    ">>> stdtrit(df, cdf_value)\n"
    "0.9999999994418539\n"
    "\n"
    "Plot the function for three different degrees of freedom.\n"
    "\n"
    ">>> x = np.linspace(0, 1, 1000)\n"
    ">>> parameters = [(1, \"solid\"), (2, \"dashed\"), (5, \"dotted\")]\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for (df, linestyle) in parameters:\n"
    "...     ax.plot(x, stdtrit(df, x), ls=linestyle, label=f\"$df={df}$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylim(-10, 10)\n"
    ">>> ax.set_title(\"Student t distribution quantile function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The function can be computed for several degrees of freedom at the same\n"
    "time by providing a NumPy array or list for `df`:\n"
    "\n"
    ">>> stdtrit([1, 2, 3], 0.7)\n"
    "array([0.72654253, 0.6172134 , 0.58438973])\n"
    "\n"
    "It is possible to calculate the function at several points for several\n"
    "different degrees of freedom simultaneously by providing arrays for `df`\n"
    "and `p` with shapes compatible for broadcasting. Compute `stdtrit` at\n"
    "4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n"
    "\n"
    ">>> dfs = np.array([[1], [2], [3]])\n"
    ">>> p = np.array([0.2, 0.4, 0.7, 0.8])\n"
    ">>> dfs.shape, p.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> stdtrit(dfs, p)\n"
    "array([[-1.37638192, -0.3249197 ,  0.72654253,  1.37638192],\n"
    "       [-1.06066017, -0.28867513,  0.6172134 ,  1.06066017],\n"
    "       [-0.97847231, -0.27667066,  0.58438973,  0.97847231]])\n"
    "\n"
    "The t distribution is also available as `scipy.stats.t`. Calling `stdtrit`\n"
    "directly can be much faster than calling the ``ppf`` method of\n"
    "`scipy.stats.t`. To get the same results, one must use the following\n"
    "parametrization: ``scipy.stats.t(df).ppf(x) = stdtrit(df, x)``.\n"
    "\n"
    ">>> from scipy.stats import t\n"
    ">>> df, x = 3, 0.5\n"
    ">>> stdtrit_result = stdtrit(df, x)  # this can be faster than below\n"
    ">>> stats_result = t(df).ppf(x)\n"
    ">>> stats_result == stdtrit_result  # test that results are equal\n"
    "True")
ufunc_stdtrit_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtrit_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtrit_types[0] = <char>NPY_FLOAT
ufunc_stdtrit_types[1] = <char>NPY_FLOAT
ufunc_stdtrit_types[2] = <char>NPY_FLOAT
ufunc_stdtrit_types[3] = <char>NPY_DOUBLE
ufunc_stdtrit_types[4] = <char>NPY_DOUBLE
ufunc_stdtrit_types[5] = <char>NPY_DOUBLE
ufunc_stdtrit_ptr[2*0] = <void*>_func_stdtrit
ufunc_stdtrit_ptr[2*0+1] = <void*>(<char*>"stdtrit")
ufunc_stdtrit_ptr[2*1] = <void*>_func_stdtrit
ufunc_stdtrit_ptr[2*1+1] = <void*>(<char*>"stdtrit")
ufunc_stdtrit_data[0] = &ufunc_stdtrit_ptr[2*0]
ufunc_stdtrit_data[1] = &ufunc_stdtrit_ptr[2*1]
stdtrit = np.PyUFunc_FromFuncAndData(ufunc_stdtrit_loops, ufunc_stdtrit_data, ufunc_stdtrit_types, 2, 2, 1, 0, "stdtrit", ufunc_stdtrit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_tklmbda_loops[2]
cdef void *ufunc_tklmbda_ptr[4]
cdef void *ufunc_tklmbda_data[2]
cdef char ufunc_tklmbda_types[6]
cdef char *ufunc_tklmbda_doc = (
    "tklmbda(x, lmbda, out=None)\n"
    "\n"
    "Cumulative distribution function of the Tukey lambda distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, lmbda : array_like\n"
    "    Parameters\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : scalar or ndarray\n"
    "    Value of the Tukey lambda CDF\n"
    "\n"
    "See Also\n"
    "--------\n"
    "scipy.stats.tukeylambda : Tukey lambda distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import tklmbda, expit\n"
    "\n"
    "Compute the cumulative distribution function (CDF) of the Tukey lambda\n"
    "distribution at several ``x`` values for `lmbda` = -1.5.\n"
    "\n"
    ">>> x = np.linspace(-2, 2, 9)\n"
    ">>> x\n"
    "array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ])\n"
    ">>> tklmbda(x, -1.5)\n"
    "array([0.34688734, 0.3786554 , 0.41528805, 0.45629737, 0.5       ,\n"
    "       0.54370263, 0.58471195, 0.6213446 , 0.65311266])\n"
    "\n"
    "When `lmbda` is 0, the function is the logistic sigmoid function,\n"
    "which is implemented in `scipy.special` as `expit`.\n"
    "\n"
    ">>> tklmbda(x, 0)\n"
    "array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n"
    "       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n"
    ">>> expit(x)\n"
    "array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n"
    "       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n"
    "\n"
    "When `lmbda` is 1, the Tukey lambda distribution is uniform on the\n"
    "interval [-1, 1], so the CDF increases linearly.\n"
    "\n"
    ">>> t = np.linspace(-1, 1, 9)\n"
    ">>> tklmbda(t, 1)\n"
    "array([0.   , 0.125, 0.25 , 0.375, 0.5  , 0.625, 0.75 , 0.875, 1.   ])\n"
    "\n"
    "In the following, we generate plots for several values of `lmbda`.\n"
    "\n"
    "The first figure shows graphs for `lmbda` <= 0.\n"
    "\n"
    ">>> styles = ['-', '-.', '--', ':']\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-12, 12, 500)\n"
    ">>> for k, lmbda in enumerate([-1.0, -0.5, 0.0]):\n"
    "...     y = tklmbda(x, lmbda)\n"
    "...     ax.plot(x, y, styles[k], label=rf'$\\lambda$ = {lmbda:-4.1f}')\n"
    "\n"
    ">>> ax.set_title(r'tklmbda(x, $\\lambda$)')\n"
    ">>> ax.set_label('x')\n"
    ">>> ax.legend(framealpha=1, shadow=True)\n"
    ">>> ax.grid(True)\n"
    "\n"
    "The second figure shows graphs for `lmbda` > 0.  The dots in the\n"
    "graphs show the bounds of the support of the distribution.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-4.2, 4.2, 500)\n"
    ">>> lmbdas = [0.25, 0.5, 1.0, 1.5]\n"
    ">>> for k, lmbda in enumerate(lmbdas):\n"
    "...     y = tklmbda(x, lmbda)\n"
    "...     ax.plot(x, y, styles[k], label=fr'$\\lambda$ = {lmbda}')\n"
    "\n"
    ">>> ax.set_prop_cycle(None)\n"
    ">>> for lmbda in lmbdas:\n"
    "...     ax.plot([-1/lmbda, 1/lmbda], [0, 1], '.', ms=8)\n"
    "\n"
    ">>> ax.set_title(r'tklmbda(x, $\\lambda$)')\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.legend(framealpha=1, shadow=True)\n"
    ">>> ax.grid(True)\n"
    "\n"
    ">>> plt.tight_layout()\n"
    ">>> plt.show()\n"
    "\n"
    "The CDF of the Tukey lambda distribution is also implemented as the\n"
    "``cdf`` method of `scipy.stats.tukeylambda`.  In the following,\n"
    "``tukeylambda.cdf(x, -0.5)`` and ``tklmbda(x, -0.5)`` compute the\n"
    "same values:\n"
    "\n"
    ">>> from scipy.stats import tukeylambda\n"
    ">>> x = np.linspace(-2, 2, 9)\n"
    "\n"
    ">>> tukeylambda.cdf(x, -0.5)\n"
    "array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n"
    "       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n"
    "\n"
    ">>> tklmbda(x, -0.5)\n"
    "array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n"
    "       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n"
    "\n"
    "The implementation in ``tukeylambda`` also provides location and scale\n"
    "parameters, and other methods such as ``pdf()`` (the probability\n"
    "density function) and ``ppf()`` (the inverse of the CDF), so for\n"
    "working with the Tukey lambda distribution, ``tukeylambda`` is more\n"
    "generally useful.  The primary advantage of ``tklmbda`` is that it is\n"
    "significantly faster than ``tukeylambda.cdf``.")
ufunc_tklmbda_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_tklmbda_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_tklmbda_types[0] = <char>NPY_FLOAT
ufunc_tklmbda_types[1] = <char>NPY_FLOAT
ufunc_tklmbda_types[2] = <char>NPY_FLOAT
ufunc_tklmbda_types[3] = <char>NPY_DOUBLE
ufunc_tklmbda_types[4] = <char>NPY_DOUBLE
ufunc_tklmbda_types[5] = <char>NPY_DOUBLE
ufunc_tklmbda_ptr[2*0] = <void*>_func_xsf_tukeylambdacdf
ufunc_tklmbda_ptr[2*0+1] = <void*>(<char*>"tklmbda")
ufunc_tklmbda_ptr[2*1] = <void*>_func_xsf_tukeylambdacdf
ufunc_tklmbda_ptr[2*1+1] = <void*>(<char*>"tklmbda")
ufunc_tklmbda_data[0] = &ufunc_tklmbda_ptr[2*0]
ufunc_tklmbda_data[1] = &ufunc_tklmbda_ptr[2*1]
tklmbda = np.PyUFunc_FromFuncAndData(ufunc_tklmbda_loops, ufunc_tklmbda_data, ufunc_tklmbda_types, 2, 2, 1, 0, "tklmbda", ufunc_tklmbda_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_voigt_profile_loops[2]
cdef void *ufunc_voigt_profile_ptr[4]
cdef void *ufunc_voigt_profile_data[2]
cdef char ufunc_voigt_profile_types[8]
cdef char *ufunc_voigt_profile_doc = (
    "voigt_profile(x, sigma, gamma, out=None)\n"
    "\n"
    "Voigt profile.\n"
    "\n"
    "The Voigt profile is a convolution of a 1-D Normal distribution with\n"
    "standard deviation ``sigma`` and a 1-D Cauchy distribution with half-width at\n"
    "half-maximum ``gamma``.\n"
    "\n"
    "If ``sigma = 0``, PDF of Cauchy distribution is returned.\n"
    "Conversely, if ``gamma = 0``, PDF of Normal distribution is returned.\n"
    "If ``sigma = gamma = 0``, the return value is ``Inf`` for ``x = 0``,\n"
    "and ``0`` for all other ``x``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument\n"
    "sigma : array_like\n"
    "    The standard deviation of the Normal distribution part\n"
    "gamma : array_like\n"
    "    The half-width at half-maximum of the Cauchy distribution part\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The Voigt profile at the given arguments\n"
    "\n"
    "See Also\n"
    "--------\n"
    "wofz : Faddeeva function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "It can be expressed in terms of Faddeeva function\n"
    "\n"
    ".. math:: V(x; \\sigma, \\gamma) = \\frac{Re[w(z)]}{\\sigma\\sqrt{2\\pi}},\n"
    ".. math:: z = \\frac{x + i\\gamma}{\\sqrt{2}\\sigma}\n"
    "\n"
    "where :math:`w(z)` is the Faddeeva function.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Voigt_profile\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at point 2 for ``sigma=1`` and ``gamma=1``.\n"
    "\n"
    ">>> from scipy.special import voigt_profile\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> voigt_profile(2, 1., 1.)\n"
    "0.09071519942627544\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array\n"
    "for `x`.\n"
    "\n"
    ">>> values = np.array([-2., 0., 5])\n"
    ">>> voigt_profile(values, 1., 1.)\n"
    "array([0.0907152 , 0.20870928, 0.01388492])\n"
    "\n"
    "Plot the function for different parameter sets.\n"
    "\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> x = np.linspace(-10, 10, 500)\n"
    ">>> parameters_list = [(1.5, 0., \"solid\"), (1.3, 0.5, \"dashed\"),\n"
    "...                    (0., 1.8, \"dotted\"), (1., 1., \"dashdot\")]\n"
    ">>> for params in parameters_list:\n"
    "...     sigma, gamma, linestyle = params\n"
    "...     voigt = voigt_profile(x, sigma, gamma)\n"
    "...     ax.plot(x, voigt, label=rf\"$\\sigma={sigma},\\, \\gamma={gamma}$\",\n"
    "...             ls=linestyle)\n"
    ">>> ax.legend()\n"
    ">>> plt.show()\n"
    "\n"
    "Verify visually that the Voigt profile indeed arises as the convolution\n"
    "of a normal and a Cauchy distribution.\n"
    "\n"
    ">>> from scipy.signal import convolve\n"
    ">>> x, dx = np.linspace(-10, 10, 500, retstep=True)\n"
    ">>> def gaussian(x, sigma):\n"
    "...     return np.exp(-0.5 * x**2/sigma**2)/(sigma * np.sqrt(2*np.pi))\n"
    ">>> def cauchy(x, gamma):\n"
    "...     return gamma/(np.pi * (np.square(x)+gamma**2))\n"
    ">>> sigma = 2\n"
    ">>> gamma = 1\n"
    ">>> gauss_profile = gaussian(x, sigma)\n"
    ">>> cauchy_profile = cauchy(x, gamma)\n"
    ">>> convolved = dx * convolve(cauchy_profile, gauss_profile, mode=\"same\")\n"
    ">>> voigt = voigt_profile(x, sigma, gamma)\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> ax.plot(x, gauss_profile, label=\"Gauss: $G$\", c='b')\n"
    ">>> ax.plot(x, cauchy_profile, label=\"Cauchy: $C$\", c='y', ls=\"dashed\")\n"
    ">>> xx = 0.5*(x[1:] + x[:-1])  # midpoints\n"
    ">>> ax.plot(xx, convolved[1:], label=\"Convolution: $G * C$\", ls='dashdot',\n"
    "...         c='k')\n"
    ">>> ax.plot(x, voigt, label=\"Voigt\", ls='dotted', c='r')\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_voigt_profile_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_voigt_profile_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_voigt_profile_types[0] = <char>NPY_FLOAT
ufunc_voigt_profile_types[1] = <char>NPY_FLOAT
ufunc_voigt_profile_types[2] = <char>NPY_FLOAT
ufunc_voigt_profile_types[3] = <char>NPY_FLOAT
ufunc_voigt_profile_types[4] = <char>NPY_DOUBLE
ufunc_voigt_profile_types[5] = <char>NPY_DOUBLE
ufunc_voigt_profile_types[6] = <char>NPY_DOUBLE
ufunc_voigt_profile_types[7] = <char>NPY_DOUBLE
ufunc_voigt_profile_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile
ufunc_voigt_profile_ptr[2*0+1] = <void*>(<char*>"voigt_profile")
ufunc_voigt_profile_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile
ufunc_voigt_profile_ptr[2*1+1] = <void*>(<char*>"voigt_profile")
ufunc_voigt_profile_data[0] = &ufunc_voigt_profile_ptr[2*0]
ufunc_voigt_profile_data[1] = &ufunc_voigt_profile_ptr[2*1]
voigt_profile = np.PyUFunc_FromFuncAndData(ufunc_voigt_profile_loops, ufunc_voigt_profile_data, ufunc_voigt_profile_types, 2, 3, 1, 0, "voigt_profile", ufunc_voigt_profile_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_wofz_loops[2]
cdef void *ufunc_wofz_ptr[4]
cdef void *ufunc_wofz_data[2]
cdef char ufunc_wofz_types[4]
cdef char *ufunc_wofz_doc = (
    "wofz(z, out=None)\n"
    "\n"
    "Faddeeva function\n"
    "\n"
    "Returns the value of the Faddeeva function for complex argument::\n"
    "\n"
    "    exp(-z**2) * erfc(-i*z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    complex argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the Faddeeva function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "dawsn, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> z = special.wofz(x)\n"
    "\n"
    ">>> plt.plot(x, z.real, label='wofz(x).real')\n"
    ">>> plt.plot(x, z.imag, label='wofz(x).imag')\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.legend(framealpha=1, shadow=True)\n"
    ">>> plt.grid(alpha=0.25)\n"
    ">>> plt.show()")
ufunc_wofz_loops[0] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_wofz_loops[1] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_wofz_types[0] = <char>NPY_CFLOAT
ufunc_wofz_types[1] = <char>NPY_CFLOAT
ufunc_wofz_types[2] = <char>NPY_CDOUBLE
ufunc_wofz_types[3] = <char>NPY_CDOUBLE
ufunc_wofz_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_w
ufunc_wofz_ptr[2*0+1] = <void*>(<char*>"wofz")
ufunc_wofz_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_w
ufunc_wofz_ptr[2*1+1] = <void*>(<char*>"wofz")
ufunc_wofz_data[0] = &ufunc_wofz_ptr[2*0]
ufunc_wofz_data[1] = &ufunc_wofz_ptr[2*1]
wofz = np.PyUFunc_FromFuncAndData(ufunc_wofz_loops, ufunc_wofz_data, ufunc_wofz_types, 2, 1, 1, 0, "wofz", ufunc_wofz_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_wrightomega_loops[4]
cdef void *ufunc_wrightomega_ptr[8]
cdef void *ufunc_wrightomega_data[4]
cdef char ufunc_wrightomega_types[8]
cdef char *ufunc_wrightomega_doc = (
    "wrightomega(z, out=None)\n"
    "\n"
    "Wright Omega function.\n"
    "\n"
    "Defined as the solution to\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\omega + \\log(\\omega) = z\n"
    "\n"
    "where :math:`\\log` is the principal branch of the complex logarithm.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Points at which to evaluate the Wright Omega function\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "omega : scalar or ndarray\n"
    "    Values of the Wright Omega function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "lambertw : The Lambert W function\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.19.0\n"
    "\n"
    "The function can also be defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\omega(z) = W_{K(z)}(e^z)\n"
    "\n"
    "where :math:`K(z) = \\lceil (\\Im(z) - \\pi)/(2\\pi) \\rceil` is the\n"
    "unwinding number and :math:`W` is the Lambert W function.\n"
    "\n"
    "The implementation here is taken from [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Lawrence, Corless, and Jeffrey, \"Algorithm 917: Complex\n"
    "       Double-Precision Evaluation of the Wright :math:`\\omega`\n"
    "       Function.\" ACM Transactions on Mathematical Software,\n"
    "       2012. :doi:`10.1145/2168773.2168779`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import wrightomega, lambertw\n"
    "\n"
    ">>> wrightomega([-2, -1, 0, 1, 2])\n"
    "array([0.12002824, 0.27846454, 0.56714329, 1.        , 1.5571456 ])\n"
    "\n"
    "Complex input:\n"
    "\n"
    ">>> wrightomega(3 + 5j)\n"
    "(1.5804428632097158+3.8213626783287937j)\n"
    "\n"
    "Verify that ``wrightomega(z)`` satisfies ``w + log(w) = z``:\n"
    "\n"
    ">>> w = -5 + 4j\n"
    ">>> wrightomega(w + np.log(w))\n"
    "(-5+4j)\n"
    "\n"
    "Verify the connection to ``lambertw``:\n"
    "\n"
    ">>> z = 0.5 + 3j\n"
    ">>> wrightomega(z)\n"
    "(0.0966015889280649+1.4937828458191993j)\n"
    ">>> lambertw(np.exp(z))\n"
    "(0.09660158892806493+1.4937828458191993j)\n"
    "\n"
    ">>> z = 0.5 + 4j\n"
    ">>> wrightomega(z)\n"
    "(-0.3362123489037213+2.282986001579032j)\n"
    ">>> lambertw(np.exp(z), k=1)\n"
    "(-0.33621234890372115+2.282986001579032j)")
ufunc_wrightomega_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_wrightomega_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_wrightomega_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_wrightomega_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_wrightomega_types[0] = <char>NPY_FLOAT
ufunc_wrightomega_types[1] = <char>NPY_FLOAT
ufunc_wrightomega_types[2] = <char>NPY_DOUBLE
ufunc_wrightomega_types[3] = <char>NPY_DOUBLE
ufunc_wrightomega_types[4] = <char>NPY_CFLOAT
ufunc_wrightomega_types[5] = <char>NPY_CFLOAT
ufunc_wrightomega_types[6] = <char>NPY_CDOUBLE
ufunc_wrightomega_types[7] = <char>NPY_CDOUBLE
ufunc_wrightomega_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_wrightomega_real
ufunc_wrightomega_ptr[2*0+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_wrightomega_real
ufunc_wrightomega_ptr[2*1+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_wrightomega
ufunc_wrightomega_ptr[2*2+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_wrightomega
ufunc_wrightomega_ptr[2*3+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_data[0] = &ufunc_wrightomega_ptr[2*0]
ufunc_wrightomega_data[1] = &ufunc_wrightomega_ptr[2*1]
ufunc_wrightomega_data[2] = &ufunc_wrightomega_ptr[2*2]
ufunc_wrightomega_data[3] = &ufunc_wrightomega_ptr[2*3]
wrightomega = np.PyUFunc_FromFuncAndData(ufunc_wrightomega_loops, ufunc_wrightomega_data, ufunc_wrightomega_types, 4, 1, 1, 0, "wrightomega", ufunc_wrightomega_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_xlog1py_loops[4]
cdef void *ufunc_xlog1py_ptr[8]
cdef void *ufunc_xlog1py_data[4]
cdef char ufunc_xlog1py_types[12]
cdef char *ufunc_xlog1py_doc = (
    "xlog1py(x, y, out=None)\n"
    "\n"
    "Compute ``x*log1p(y)`` so that the result is 0 if ``x = 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Multiplier\n"
    "y : array_like\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "z : scalar or ndarray\n"
    "    Computed x*log1p(y)\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.13.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    "This example shows how the function can be used to calculate the log of\n"
    "the probability mass function for a geometric discrete random variable.\n"
    "The probability mass function of the geometric distribution is defined\n"
    "as follows:\n"
    "\n"
    ".. math:: f(k) = (1-p)^{k-1} p\n"
    "\n"
    "where :math:`p` is the probability of a single success\n"
    "and :math:`1-p` is the probability of a single failure\n"
    "and :math:`k` is the number of trials to get the first success.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import xlog1py\n"
    ">>> p = 0.5\n"
    ">>> k = 100\n"
    ">>> _pmf = np.power(1 - p, k - 1) * p\n"
    ">>> _pmf\n"
    "7.888609052210118e-31\n"
    "\n"
    "If we take k as a relatively large number the value of the probability\n"
    "mass function can become very low. In such cases taking the log of the\n"
    "pmf would be more suitable as the log function can change the values\n"
    "to a scale that is more appropriate to work with.\n"
    "\n"
    ">>> _log_pmf = xlog1py(k - 1, -p) + np.log(p)\n"
    ">>> _log_pmf\n"
    "-69.31471805599453\n"
    "\n"
    "We can confirm that we get a value close to the original pmf value by\n"
    "taking the exponential of the log pmf.\n"
    "\n"
    ">>> _orig_pmf = np.exp(_log_pmf)\n"
    ">>> np.isclose(_pmf, _orig_pmf)\n"
    "True")
ufunc_xlog1py_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_xlog1py_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_xlog1py_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_xlog1py_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_xlog1py_types[0] = <char>NPY_FLOAT
ufunc_xlog1py_types[1] = <char>NPY_FLOAT
ufunc_xlog1py_types[2] = <char>NPY_FLOAT
ufunc_xlog1py_types[3] = <char>NPY_DOUBLE
ufunc_xlog1py_types[4] = <char>NPY_DOUBLE
ufunc_xlog1py_types[5] = <char>NPY_DOUBLE
ufunc_xlog1py_types[6] = <char>NPY_CFLOAT
ufunc_xlog1py_types[7] = <char>NPY_CFLOAT
ufunc_xlog1py_types[8] = <char>NPY_CFLOAT
ufunc_xlog1py_types[9] = <char>NPY_CDOUBLE
ufunc_xlog1py_types[10] = <char>NPY_CDOUBLE
ufunc_xlog1py_types[11] = <char>NPY_CDOUBLE
ufunc_xlog1py_ptr[2*0] = <void*>_func_xlog1py[double]
ufunc_xlog1py_ptr[2*0+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*1] = <void*>_func_xlog1py[double]
ufunc_xlog1py_ptr[2*1+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*2] = <void*>_func_xlog1py[double_complex]
ufunc_xlog1py_ptr[2*2+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*3] = <void*>_func_xlog1py[double_complex]
ufunc_xlog1py_ptr[2*3+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_data[0] = &ufunc_xlog1py_ptr[2*0]
ufunc_xlog1py_data[1] = &ufunc_xlog1py_ptr[2*1]
ufunc_xlog1py_data[2] = &ufunc_xlog1py_ptr[2*2]
ufunc_xlog1py_data[3] = &ufunc_xlog1py_ptr[2*3]
xlog1py = np.PyUFunc_FromFuncAndData(ufunc_xlog1py_loops, ufunc_xlog1py_data, ufunc_xlog1py_types, 4, 2, 1, 0, "xlog1py", ufunc_xlog1py_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_xlogy_loops[4]
cdef void *ufunc_xlogy_ptr[8]
cdef void *ufunc_xlogy_data[4]
cdef char ufunc_xlogy_types[12]
cdef char *ufunc_xlogy_doc = (
    "xlogy(x, y, out=None)\n"
    "\n"
    "Compute ``x*log(y)`` so that the result is 0 if ``x = 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Multiplier\n"
    "y : array_like\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "z : scalar or ndarray\n"
    "    Computed x*log(y)\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The log function used in the computation is the natural log.\n"
    "\n"
    ".. versionadded:: 0.13.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    "We can use this function to calculate the binary logistic loss also\n"
    "known as the binary cross entropy. This loss function is used for\n"
    "binary classification problems and is defined as:\n"
    "\n"
    ".. math::\n"
    "    L = 1/n * \\sum_{i=0}^n -(y_i*log(y\\_pred_i) + (1-y_i)*log(1-y\\_pred_i))\n"
    "\n"
    "We can define the parameters `x` and `y` as y and y_pred respectively.\n"
    "y is the array of the actual labels which over here can be either 0 or 1.\n"
    "y_pred is the array of the predicted probabilities with respect to\n"
    "the positive class (1).\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import xlogy\n"
    ">>> y = np.array([0, 1, 0, 1, 1, 0])\n"
    ">>> y_pred = np.array([0.3, 0.8, 0.4, 0.7, 0.9, 0.2])\n"
    ">>> n = len(y)\n"
    ">>> loss = -(xlogy(y, y_pred) + xlogy(1 - y, 1 - y_pred)).sum()\n"
    ">>> loss /= n\n"
    ">>> loss\n"
    "0.29597052165495025\n"
    "\n"
    "A lower loss is usually better as it indicates that the predictions are\n"
    "similar to the actual labels. In this example since our predicted\n"
    "probabilities are close to the actual labels, we get an overall loss\n"
    "that is reasonably low and appropriate.")
ufunc_xlogy_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_xlogy_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_xlogy_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_xlogy_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_xlogy_types[0] = <char>NPY_FLOAT
ufunc_xlogy_types[1] = <char>NPY_FLOAT
ufunc_xlogy_types[2] = <char>NPY_FLOAT
ufunc_xlogy_types[3] = <char>NPY_DOUBLE
ufunc_xlogy_types[4] = <char>NPY_DOUBLE
ufunc_xlogy_types[5] = <char>NPY_DOUBLE
ufunc_xlogy_types[6] = <char>NPY_CFLOAT
ufunc_xlogy_types[7] = <char>NPY_CFLOAT
ufunc_xlogy_types[8] = <char>NPY_CFLOAT
ufunc_xlogy_types[9] = <char>NPY_CDOUBLE
ufunc_xlogy_types[10] = <char>NPY_CDOUBLE
ufunc_xlogy_types[11] = <char>NPY_CDOUBLE
ufunc_xlogy_ptr[2*0] = <void*>_func_xlogy[double]
ufunc_xlogy_ptr[2*0+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*1] = <void*>_func_xlogy[double]
ufunc_xlogy_ptr[2*1+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*2] = <void*>_func_xlogy[double_complex]
ufunc_xlogy_ptr[2*2+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*3] = <void*>_func_xlogy[double_complex]
ufunc_xlogy_ptr[2*3+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_data[0] = &ufunc_xlogy_ptr[2*0]
ufunc_xlogy_data[1] = &ufunc_xlogy_ptr[2*1]
ufunc_xlogy_data[2] = &ufunc_xlogy_ptr[2*2]
ufunc_xlogy_data[3] = &ufunc_xlogy_ptr[2*3]
xlogy = np.PyUFunc_FromFuncAndData(ufunc_xlogy_loops, ufunc_xlogy_data, ufunc_xlogy_types, 4, 2, 1, 0, "xlogy", ufunc_xlogy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_yn_loops[3]
cdef void *ufunc_yn_ptr[6]
cdef void *ufunc_yn_data[3]
cdef char ufunc_yn_types[9]
cdef char *ufunc_yn_doc = (
    "yn(n, x, out=None)\n"
    "\n"
    "Bessel function of the second kind of integer order and real argument.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Order (integer).\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : scalar or ndarray\n"
    "    Value of the Bessel function, :math:`Y_n(x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "yv : For real order and real or complex argument.\n"
    "y0: faster implementation of this function for order 0\n"
    "y1: faster implementation of this function for order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `yn`.\n"
    "\n"
    "The function is evaluated by forward recurrence on `n`, starting with\n"
    "values computed by the Cephes routines `y0` and `y1`. If ``n = 0`` or 1,\n"
    "the routine for `y0` or `y1` is called directly.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function of order 0 at one point.\n"
    "\n"
    ">>> from scipy.special import yn\n"
    ">>> yn(0, 1.)\n"
    "0.08825696421567697\n"
    "\n"
    "Evaluate the function at one point for different orders.\n"
    "\n"
    ">>> yn(0, 1.), yn(1, 1.), yn(2, 1.)\n"
    "(0.08825696421567697, -0.7812128213002888, -1.6506826068162546)\n"
    "\n"
    "The evaluation for different orders can be carried out in one call by\n"
    "providing a list or NumPy array as argument for the `v` parameter:\n"
    "\n"
    ">>> yn([0, 1, 2], 1.)\n"
    "array([ 0.08825696, -0.78121282, -1.65068261])\n"
    "\n"
    "Evaluate the function at several points for order 0 by providing an\n"
    "array for `z`.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([0.5, 3., 8.])\n"
    ">>> yn(0, points)\n"
    "array([-0.44451873,  0.37685001,  0.22352149])\n"
    "\n"
    "If `z` is an array, the order parameter `v` must be broadcastable to\n"
    "the correct shape if different orders shall be computed in one call.\n"
    "To calculate the orders 0 and 1 for an 1D array:\n"
    "\n"
    ">>> orders = np.array([[0], [1]])\n"
    ">>> orders.shape\n"
    "(2, 1)\n"
    "\n"
    ">>> yn(orders, points)\n"
    "array([[-0.44451873,  0.37685001,  0.22352149],\n"
    "       [-1.47147239,  0.32467442, -0.15806046]])\n"
    "\n"
    "Plot the functions of order 0 to 3 from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, yn(i, x), label=f'$Y_{i!r}$')\n"
    ">>> ax.set_ylim(-3, 1)\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_yn_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc_yn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_yn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_yn_types[0] = <char>NPY_INTP
ufunc_yn_types[1] = <char>NPY_DOUBLE
ufunc_yn_types[2] = <char>NPY_DOUBLE
ufunc_yn_types[3] = <char>NPY_FLOAT
ufunc_yn_types[4] = <char>NPY_FLOAT
ufunc_yn_types[5] = <char>NPY_FLOAT
ufunc_yn_types[6] = <char>NPY_DOUBLE
ufunc_yn_types[7] = <char>NPY_DOUBLE
ufunc_yn_types[8] = <char>NPY_DOUBLE
ufunc_yn_ptr[2*0] = <void*>_func_cephes_yn_wrap
ufunc_yn_ptr[2*0+1] = <void*>(<char*>"yn")
ufunc_yn_ptr[2*1] = <void*>_func_yn_unsafe
ufunc_yn_ptr[2*1+1] = <void*>(<char*>"yn")
ufunc_yn_ptr[2*2] = <void*>_func_yn_unsafe
ufunc_yn_ptr[2*2+1] = <void*>(<char*>"yn")
ufunc_yn_data[0] = &ufunc_yn_ptr[2*0]
ufunc_yn_data[1] = &ufunc_yn_ptr[2*1]
ufunc_yn_data[2] = &ufunc_yn_ptr[2*2]
yn = np.PyUFunc_FromFuncAndData(ufunc_yn_loops, ufunc_yn_data, ufunc_yn_types, 3, 2, 1, 0, "yn", ufunc_yn_doc, 0)

from ._special_ufuncs import (_cospi, _lambertw, _scaled_exp1, _sinpi, _spherical_jn, _spherical_jn_d, _spherical_yn, _spherical_yn_d, _spherical_in, _spherical_in_d, _spherical_kn, _spherical_kn_d, airy, airye, bei, beip, ber, berp, binom, exp1, expi, expit, exprel, gamma, gammaln, hankel1, hankel1e, hankel2, hankel2e, hyp2f1, it2i0k0, it2j0y0, it2struve0, itairy, iti0k0, itj0y0, itmodstruve0, itstruve0, iv, _iv_ratio, _iv_ratio_c, ive, jv, jve, kei, keip, kelvin, ker, kerp, kv, kve, log_expit, log_wright_bessel, loggamma, logit, mathieu_a, mathieu_b, mathieu_cem, mathieu_modcem1, mathieu_modcem2, mathieu_modsem1, mathieu_modsem2, mathieu_sem, modfresnelm, modfresnelp, obl_ang1, obl_ang1_cv, obl_cv, obl_rad1, obl_rad1_cv, obl_rad2, obl_rad2_cv, pbdv, pbvv, pbwa, pro_ang1, pro_ang1_cv, pro_cv, pro_rad1, pro_rad1_cv, pro_rad2, pro_rad2_cv, psi, rgamma, sph_harm, wright_bessel, yv, yve, zetac, _zeta, sindg, cosdg, tandg, cotdg, i0, i0e, i1, i1e, k0, k0e, k1, k1e, y0, y1, j0, j1, struve, modstruve, beta, betaln, besselpoly, gammaln, gammasgn, cbrt, radian, cosm1, gammainc, gammaincinv, gammaincc, gammainccinv, fresnel, ellipe, ellipeinc, ellipk, ellipkinc, ellipkm1, ellipj, _riemann_zeta)

#
# Aliases
#
jn = jv
