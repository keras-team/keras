/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
#define GEN_PASS_DECL_CHLOLEGALIZETOHIGHLEVELMHLOPASS
#define GEN_PASS_DECL_CHLOLEGALIZETOHLOPASS
#define GEN_PASS_DECL_COLLAPSEELEMENTWISEMAPPASS
#define GEN_PASS_DECL_CONSTRAINTFUSIONPASS
#define GEN_PASS_DECL_CONVERTTOSIGNLESSPASS
#define GEN_PASS_DECL_EXPANDHLOTUPLESPASS
#define GEN_PASS_DECL_FLATTENTUPLEPASS
#define GEN_PASS_DECL_GROUPREDUCTIONDIMENSIONSPASS
#define GEN_PASS_DECL_HLOCANONICALIZEDOTPASS
#define GEN_PASS_DECL_HLOCANONICALIZEGATHERPASS
#define GEN_PASS_DECL_HLOCANONICALIZEREDUCTIONPASS
#define GEN_PASS_DECL_HLOCANONICALIZESCATTERPASS
#define GEN_PASS_DECL_HLOLEGALIZESHAPECOMPUTATIONSPASS
#define GEN_PASS_DECL_HLOLEGALIZESORTPASS
#define GEN_PASS_DECL_HLOLEGALIZETOARITHMETICPASS
#define GEN_PASS_DECL_HLOLEGALIZETOLINALGPASS
#define GEN_PASS_DECL_HLOLEGALIZETOMEMREFPASS
#define GEN_PASS_DECL_HLOLEGALIZETOSTABLEHLOPASS
#define GEN_PASS_DECL_LEGALIZEBROADCASTTOBROADCASTINDIMPASS
#define GEN_PASS_DECL_LEGALIZECONTROLFLOWPASS
#define GEN_PASS_DECL_LEGALIZECREATETOKENTOAFTERALLPASS
#define GEN_PASS_DECL_LEGALIZECROSSREPLICASUMTOALLREDUCEPASS
#define GEN_PASS_DECL_LEGALIZEDOTGENERALTODOTPASS
#define GEN_PASS_DECL_LEGALIZEDOTTODOTGENERALPASS
#define GEN_PASS_DECL_LEGALIZEEINSUMTODOTGENERALPASS
#define GEN_PASS_DECL_LEGALIZEGATHERTOTORCHINDEXSELECTPASS
#define GEN_PASS_DECL_LEGALIZEGENERALDOTPASS
#define GEN_PASS_DECL_LEGALIZETANHTOAPPROXIMATIONPASS
#define GEN_PASS_DECL_LEGALIZETOSTANDARDPASS
#define GEN_PASS_DECL_LEGALIZETORCHINDEXSELECTTOGATHERPASS
#define GEN_PASS_DECL_LOWERCOMPLEXPASS
#define GEN_PASS_DECL_MERGEASSUMINGOPSPASS
#define GEN_PASS_DECL_MHLOEXPANDOPSSIMPLIFIERPASS
#define GEN_PASS_DECL_OPTIMIZEMHLOPASS
#define GEN_PASS_DECL_PREPAREFOREXPORTPASS
#define GEN_PASS_DECL_RESTRICTMAXRANKPASS
#define GEN_PASS_DECL_SHAPELEGALIZETOHLOPASS
#define GEN_PASS_DECL_SHAPEREIFICATIONPASS
#define GEN_PASS_DECL_SHAPESIMPLIFICATION
#define GEN_PASS_DECL_SINKCONSTANTSTOCONTROLFLOWPASS
#define GEN_PASS_DECL_STABLEHLOLEGALIZETOHLOPASS
#define GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#define GEN_PASS_DECL_TESTINFERSHAPEDTYPEMETHODSPASS
#define GEN_PASS_DECL_TESTMATERIALIZEBROADCASTSPASS
#define GEN_PASS_DECL_TESTUNFUSEBATCHNORMPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// BroadcastPropagationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
#undef GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
#endif // GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
#ifdef GEN_PASS_DEF_BROADCASTPROPAGATIONPASS
namespace impl {

template <typename DerivedT>
class BroadcastPropagationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BroadcastPropagationPassBase;

  BroadcastPropagationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastPropagationPassBase(const BroadcastPropagationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BroadcastPropagationPassBase& operator=(const BroadcastPropagationPassBase &) = delete;
  BroadcastPropagationPassBase(BroadcastPropagationPassBase &&) = delete;
  BroadcastPropagationPassBase& operator=(BroadcastPropagationPassBase &&) = delete;
  ~BroadcastPropagationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-broadcast-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-broadcast-propagation"; }

  ::llvm::StringRef getDescription() const override { return "Move dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastPropagationPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastPropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastPropagationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BROADCASTPROPAGATIONPASS
#endif // GEN_PASS_DEF_BROADCASTPROPAGATIONPASS

//===----------------------------------------------------------------------===//
// ChloLegalizeToHighLevelMhloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CHLOLEGALIZETOHIGHLEVELMHLOPASS
std::unique_ptr<::mlir::Pass> createChloLegalizeToHighLevelMhloPass();
#undef GEN_PASS_DECL_CHLOLEGALIZETOHIGHLEVELMHLOPASS
#endif // GEN_PASS_DECL_CHLOLEGALIZETOHIGHLEVELMHLOPASS
#ifdef GEN_PASS_DEF_CHLOLEGALIZETOHIGHLEVELMHLOPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createChloLegalizeToHighLevelMhloPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ChloLegalizeToHighLevelMhloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ChloLegalizeToHighLevelMhloPassBase;

  ChloLegalizeToHighLevelMhloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ChloLegalizeToHighLevelMhloPassBase(const ChloLegalizeToHighLevelMhloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ChloLegalizeToHighLevelMhloPassBase& operator=(const ChloLegalizeToHighLevelMhloPassBase &) = delete;
  ChloLegalizeToHighLevelMhloPassBase(ChloLegalizeToHighLevelMhloPassBase &&) = delete;
  ChloLegalizeToHighLevelMhloPassBase& operator=(ChloLegalizeToHighLevelMhloPassBase &&) = delete;
  ~ChloLegalizeToHighLevelMhloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("chlo-legalize-to-high-level-mhlo");
  }
  ::llvm::StringRef getArgument() const override { return "chlo-legalize-to-high-level-mhlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize CHLO's with XLA counterparts, like TopK and Erf."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ChloLegalizeToHighLevelMhloPass");
  }
  ::llvm::StringRef getName() const override { return "ChloLegalizeToHighLevelMhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ChloLegalizeToHighLevelMhloPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createChloLegalizeToHighLevelMhloPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createChloLegalizeToHighLevelMhloPass() {
  return impl::createChloLegalizeToHighLevelMhloPass();
}
#undef GEN_PASS_DEF_CHLOLEGALIZETOHIGHLEVELMHLOPASS
#endif // GEN_PASS_DEF_CHLOLEGALIZETOHIGHLEVELMHLOPASS

//===----------------------------------------------------------------------===//
// ChloLegalizeToHloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CHLOLEGALIZETOHLOPASS
std::unique_ptr<::mlir::Pass> createChloLegalizeToHloPass();
#undef GEN_PASS_DECL_CHLOLEGALIZETOHLOPASS
#endif // GEN_PASS_DECL_CHLOLEGALIZETOHLOPASS
#ifdef GEN_PASS_DEF_CHLOLEGALIZETOHLOPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createChloLegalizeToHloPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ChloLegalizeToHloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ChloLegalizeToHloPassBase;

  ChloLegalizeToHloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ChloLegalizeToHloPassBase(const ChloLegalizeToHloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ChloLegalizeToHloPassBase& operator=(const ChloLegalizeToHloPassBase &) = delete;
  ChloLegalizeToHloPassBase(ChloLegalizeToHloPassBase &&) = delete;
  ChloLegalizeToHloPassBase& operator=(ChloLegalizeToHloPassBase &&) = delete;
  ~ChloLegalizeToHloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("chlo-legalize-to-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "chlo-legalize-to-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize CHLO to MHLO with XLA-supported ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ChloLegalizeToHloPass");
  }
  ::llvm::StringRef getName() const override { return "ChloLegalizeToHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<mlir::shape::ShapeDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ChloLegalizeToHloPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createChloLegalizeToHloPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createChloLegalizeToHloPass() {
  return impl::createChloLegalizeToHloPass();
}
#undef GEN_PASS_DEF_CHLOLEGALIZETOHLOPASS
#endif // GEN_PASS_DEF_CHLOLEGALIZETOHLOPASS

//===----------------------------------------------------------------------===//
// CollapseElementwiseMapPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COLLAPSEELEMENTWISEMAPPASS
#undef GEN_PASS_DECL_COLLAPSEELEMENTWISEMAPPASS
#endif // GEN_PASS_DECL_COLLAPSEELEMENTWISEMAPPASS
#ifdef GEN_PASS_DEF_COLLAPSEELEMENTWISEMAPPASS
namespace impl {

template <typename DerivedT>
class CollapseElementwiseMapPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = CollapseElementwiseMapPassBase;

  CollapseElementwiseMapPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseElementwiseMapPassBase(const CollapseElementwiseMapPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  CollapseElementwiseMapPassBase& operator=(const CollapseElementwiseMapPassBase &) = delete;
  CollapseElementwiseMapPassBase(CollapseElementwiseMapPassBase &&) = delete;
  CollapseElementwiseMapPassBase& operator=(CollapseElementwiseMapPassBase &&) = delete;
  ~CollapseElementwiseMapPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-collapse-elementwise-map");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-collapse-elementwise-map"; }

  ::llvm::StringRef getDescription() const override { return "Collapse the mhlo.map if the map only has elementwise ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseElementwiseMapPass");
  }
  ::llvm::StringRef getName() const override { return "CollapseElementwiseMapPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseElementwiseMapPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COLLAPSEELEMENTWISEMAPPASS
#endif // GEN_PASS_DEF_COLLAPSEELEMENTWISEMAPPASS

//===----------------------------------------------------------------------===//
// ConstraintFusionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONSTRAINTFUSIONPASS
#undef GEN_PASS_DECL_CONSTRAINTFUSIONPASS
#endif // GEN_PASS_DECL_CONSTRAINTFUSIONPASS
#ifdef GEN_PASS_DEF_CONSTRAINTFUSIONPASS
namespace impl {

template <typename DerivedT>
class ConstraintFusionPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ConstraintFusionPassBase;

  ConstraintFusionPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConstraintFusionPassBase(const ConstraintFusionPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ConstraintFusionPassBase& operator=(const ConstraintFusionPassBase &) = delete;
  ConstraintFusionPassBase(ConstraintFusionPassBase &&) = delete;
  ConstraintFusionPassBase& operator=(ConstraintFusionPassBase &&) = delete;
  ~ConstraintFusionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("constraint-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "constraint-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fuse shape constraints and merge all assuming regions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConstraintFusionPass");
  }
  ::llvm::StringRef getName() const override { return "ConstraintFusionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConstraintFusionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONSTRAINTFUSIONPASS
#endif // GEN_PASS_DEF_CONSTRAINTFUSIONPASS

//===----------------------------------------------------------------------===//
// ConvertToSignlessPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTOSIGNLESSPASS
#undef GEN_PASS_DECL_CONVERTTOSIGNLESSPASS
#endif // GEN_PASS_DECL_CONVERTTOSIGNLESSPASS
#ifdef GEN_PASS_DEF_CONVERTTOSIGNLESSPASS
namespace impl {

template <typename DerivedT>
class ConvertToSignlessPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertToSignlessPassBase;

  ConvertToSignlessPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToSignlessPassBase(const ConvertToSignlessPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertToSignlessPassBase& operator=(const ConvertToSignlessPassBase &) = delete;
  ConvertToSignlessPassBase(ConvertToSignlessPassBase &&) = delete;
  ConvertToSignlessPassBase& operator=(ConvertToSignlessPassBase &&) = delete;
  ~ConvertToSignlessPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-to-signless");
  }
  ::llvm::StringRef getArgument() const override { return "convert-to-signless"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform the IR to be on signless integers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToSignlessPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToSignlessPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToSignlessPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTTOSIGNLESSPASS
#endif // GEN_PASS_DEF_CONVERTTOSIGNLESSPASS

//===----------------------------------------------------------------------===//
// ExpandHloTuplesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXPANDHLOTUPLESPASS
struct ExpandHloTuplesPassOptions {
  std::string entry_function_name_;
};
#undef GEN_PASS_DECL_EXPANDHLOTUPLESPASS
#endif // GEN_PASS_DECL_EXPANDHLOTUPLESPASS
#ifdef GEN_PASS_DEF_EXPANDHLOTUPLESPASS
namespace impl {

template <typename DerivedT>
class ExpandHloTuplesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExpandHloTuplesPassBase;

  ExpandHloTuplesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandHloTuplesPassBase(const ExpandHloTuplesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExpandHloTuplesPassBase& operator=(const ExpandHloTuplesPassBase &) = delete;
  ExpandHloTuplesPassBase(ExpandHloTuplesPassBase &&) = delete;
  ExpandHloTuplesPassBase& operator=(ExpandHloTuplesPassBase &&) = delete;
  ~ExpandHloTuplesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("expand-hlo-tuples");
  }
  ::llvm::StringRef getArgument() const override { return "expand-hlo-tuples"; }

  ::llvm::StringRef getDescription() const override { return "Expand HLO tuple for the entry function of the module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandHloTuplesPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandHloTuplesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandHloTuplesPassBase<DerivedT>)

  ExpandHloTuplesPassBase(const ExpandHloTuplesPassOptions &options) : ExpandHloTuplesPassBase() {
    entry_function_name_ = options.entry_function_name_;
  }
protected:
  ::mlir::Pass::Option<std::string> entry_function_name_{*this, "entry-function", ::llvm::cl::desc("the name of entry function of the module")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXPANDHLOTUPLESPASS
#endif // GEN_PASS_DEF_EXPANDHLOTUPLESPASS

//===----------------------------------------------------------------------===//
// FlattenTuplePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FLATTENTUPLEPASS
#undef GEN_PASS_DECL_FLATTENTUPLEPASS
#endif // GEN_PASS_DECL_FLATTENTUPLEPASS
#ifdef GEN_PASS_DEF_FLATTENTUPLEPASS
namespace impl {

template <typename DerivedT>
class FlattenTuplePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = FlattenTuplePassBase;

  FlattenTuplePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenTuplePassBase(const FlattenTuplePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  FlattenTuplePassBase& operator=(const FlattenTuplePassBase &) = delete;
  FlattenTuplePassBase(FlattenTuplePassBase &&) = delete;
  FlattenTuplePassBase& operator=(FlattenTuplePassBase &&) = delete;
  ~FlattenTuplePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-flatten-tuple");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-flatten-tuple"; }

  ::llvm::StringRef getDescription() const override { return "Flatten tuples in operands and results of operators that support both tuple and variadic type."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenTuplePass");
  }
  ::llvm::StringRef getName() const override { return "FlattenTuplePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenTuplePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FLATTENTUPLEPASS
#endif // GEN_PASS_DEF_FLATTENTUPLEPASS

//===----------------------------------------------------------------------===//
// GroupReductionDimensionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GROUPREDUCTIONDIMENSIONSPASS
struct GroupReductionDimensionsPassOptions {
  bool prefer_columns_reductions_ = true;
};
#undef GEN_PASS_DECL_GROUPREDUCTIONDIMENSIONSPASS
#endif // GEN_PASS_DECL_GROUPREDUCTIONDIMENSIONSPASS
#ifdef GEN_PASS_DEF_GROUPREDUCTIONDIMENSIONSPASS
namespace impl {

template <typename DerivedT>
class GroupReductionDimensionsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = GroupReductionDimensionsPassBase;

  GroupReductionDimensionsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GroupReductionDimensionsPassBase(const GroupReductionDimensionsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  GroupReductionDimensionsPassBase& operator=(const GroupReductionDimensionsPassBase &) = delete;
  GroupReductionDimensionsPassBase(GroupReductionDimensionsPassBase &&) = delete;
  GroupReductionDimensionsPassBase& operator=(GroupReductionDimensionsPassBase &&) = delete;
  ~GroupReductionDimensionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("group-reduction-dimensions");
  }
  ::llvm::StringRef getArgument() const override { return "group-reduction-dimensions"; }

  ::llvm::StringRef getDescription() const override { return "Group dimensions of reduction operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GroupReductionDimensionsPass");
  }
  ::llvm::StringRef getName() const override { return "GroupReductionDimensionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GroupReductionDimensionsPassBase<DerivedT>)

  GroupReductionDimensionsPassBase(const GroupReductionDimensionsPassOptions &options) : GroupReductionDimensionsPassBase() {
    prefer_columns_reductions_ = options.prefer_columns_reductions_;
  }
protected:
  ::mlir::Pass::Option<bool> prefer_columns_reductions_{*this, "prefer-columns-reductions", ::llvm::cl::desc("When simplifying reductions, prefer to use column reductions over row reductions."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GROUPREDUCTIONDIMENSIONSPASS
#endif // GEN_PASS_DEF_GROUPREDUCTIONDIMENSIONSPASS

//===----------------------------------------------------------------------===//
// HloCanonicalizeDotPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOCANONICALIZEDOTPASS
#undef GEN_PASS_DECL_HLOCANONICALIZEDOTPASS
#endif // GEN_PASS_DECL_HLOCANONICALIZEDOTPASS
#ifdef GEN_PASS_DEF_HLOCANONICALIZEDOTPASS
namespace impl {

template <typename DerivedT>
class HloCanonicalizeDotPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeDotPassBase;

  HloCanonicalizeDotPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeDotPassBase(const HloCanonicalizeDotPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeDotPassBase& operator=(const HloCanonicalizeDotPassBase &) = delete;
  HloCanonicalizeDotPassBase(HloCanonicalizeDotPassBase &&) = delete;
  HloCanonicalizeDotPassBase& operator=(HloCanonicalizeDotPassBase &&) = delete;
  ~HloCanonicalizeDotPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-dot");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-dot"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites dot operands that contain unit dimension."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeDotPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeDotPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeDotPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOCANONICALIZEDOTPASS
#endif // GEN_PASS_DEF_HLOCANONICALIZEDOTPASS

//===----------------------------------------------------------------------===//
// HloCanonicalizeGatherPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOCANONICALIZEGATHERPASS
#undef GEN_PASS_DECL_HLOCANONICALIZEGATHERPASS
#endif // GEN_PASS_DECL_HLOCANONICALIZEGATHERPASS
#ifdef GEN_PASS_DEF_HLOCANONICALIZEGATHERPASS
namespace impl {

template <typename DerivedT>
class HloCanonicalizeGatherPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeGatherPassBase;

  HloCanonicalizeGatherPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeGatherPassBase(const HloCanonicalizeGatherPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeGatherPassBase& operator=(const HloCanonicalizeGatherPassBase &) = delete;
  HloCanonicalizeGatherPassBase(HloCanonicalizeGatherPassBase &&) = delete;
  HloCanonicalizeGatherPassBase& operator=(HloCanonicalizeGatherPassBase &&) = delete;
  ~HloCanonicalizeGatherPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-gather");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-gather"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites gather into transposes, reshapes and a simple gather."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeGatherPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeGatherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeGatherPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOCANONICALIZEGATHERPASS
#endif // GEN_PASS_DEF_HLOCANONICALIZEGATHERPASS

//===----------------------------------------------------------------------===//
// HloCanonicalizeReductionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOCANONICALIZEREDUCTIONPASS
#undef GEN_PASS_DECL_HLOCANONICALIZEREDUCTIONPASS
#endif // GEN_PASS_DECL_HLOCANONICALIZEREDUCTIONPASS
#ifdef GEN_PASS_DEF_HLOCANONICALIZEREDUCTIONPASS
namespace impl {

template <typename DerivedT>
class HloCanonicalizeReductionPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeReductionPassBase;

  HloCanonicalizeReductionPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeReductionPassBase(const HloCanonicalizeReductionPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeReductionPassBase& operator=(const HloCanonicalizeReductionPassBase &) = delete;
  HloCanonicalizeReductionPassBase(HloCanonicalizeReductionPassBase &&) = delete;
  HloCanonicalizeReductionPassBase& operator=(HloCanonicalizeReductionPassBase &&) = delete;
  ~HloCanonicalizeReductionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-reduction");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-reduction"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize reduction ops to be suitable for codegen."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeReductionPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeReductionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeReductionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOCANONICALIZEREDUCTIONPASS
#endif // GEN_PASS_DEF_HLOCANONICALIZEREDUCTIONPASS

//===----------------------------------------------------------------------===//
// HloCanonicalizeScatterPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOCANONICALIZESCATTERPASS
#undef GEN_PASS_DECL_HLOCANONICALIZESCATTERPASS
#endif // GEN_PASS_DECL_HLOCANONICALIZESCATTERPASS
#ifdef GEN_PASS_DEF_HLOCANONICALIZESCATTERPASS
namespace impl {

template <typename DerivedT>
class HloCanonicalizeScatterPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeScatterPassBase;

  HloCanonicalizeScatterPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeScatterPassBase(const HloCanonicalizeScatterPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeScatterPassBase& operator=(const HloCanonicalizeScatterPassBase &) = delete;
  HloCanonicalizeScatterPassBase(HloCanonicalizeScatterPassBase &&) = delete;
  HloCanonicalizeScatterPassBase& operator=(HloCanonicalizeScatterPassBase &&) = delete;
  ~HloCanonicalizeScatterPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-scatter");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-scatter"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites scatter into transposes, reshapes and a simple scatter."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeScatterPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeScatterPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeScatterPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOCANONICALIZESCATTERPASS
#endif // GEN_PASS_DEF_HLOCANONICALIZESCATTERPASS

//===----------------------------------------------------------------------===//
// HloLegalizeShapeComputationsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOLEGALIZESHAPECOMPUTATIONSPASS
#undef GEN_PASS_DECL_HLOLEGALIZESHAPECOMPUTATIONSPASS
#endif // GEN_PASS_DECL_HLOLEGALIZESHAPECOMPUTATIONSPASS
#ifdef GEN_PASS_DEF_HLOLEGALIZESHAPECOMPUTATIONSPASS
namespace impl {

template <typename DerivedT>
class HloLegalizeShapeComputationsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloLegalizeShapeComputationsPassBase;

  HloLegalizeShapeComputationsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeShapeComputationsPassBase(const HloLegalizeShapeComputationsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloLegalizeShapeComputationsPassBase& operator=(const HloLegalizeShapeComputationsPassBase &) = delete;
  HloLegalizeShapeComputationsPassBase(HloLegalizeShapeComputationsPassBase &&) = delete;
  HloLegalizeShapeComputationsPassBase& operator=(HloLegalizeShapeComputationsPassBase &&) = delete;
  ~HloLegalizeShapeComputationsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-shape-computations");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-shape-computations"; }

  ::llvm::StringRef getDescription() const override { return "Legalize HLOs shape operations to core-mlir operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeShapeComputationsPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeShapeComputationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeShapeComputationsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOLEGALIZESHAPECOMPUTATIONSPASS
#endif // GEN_PASS_DEF_HLOLEGALIZESHAPECOMPUTATIONSPASS

//===----------------------------------------------------------------------===//
// HloLegalizeSortPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOLEGALIZESORTPASS
#undef GEN_PASS_DECL_HLOLEGALIZESORTPASS
#endif // GEN_PASS_DECL_HLOLEGALIZESORTPASS
#ifdef GEN_PASS_DEF_HLOLEGALIZESORTPASS
namespace impl {

template <typename DerivedT>
class HloLegalizeSortPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloLegalizeSortPassBase;

  HloLegalizeSortPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeSortPassBase(const HloLegalizeSortPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloLegalizeSortPassBase& operator=(const HloLegalizeSortPassBase &) = delete;
  HloLegalizeSortPassBase(HloLegalizeSortPassBase &&) = delete;
  HloLegalizeSortPassBase& operator=(HloLegalizeSortPassBase &&) = delete;
  ~HloLegalizeSortPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-sort");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-sort"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from MHLO sort to SCF control flow."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeSortPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeSortPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeSortPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOLEGALIZESORTPASS
#endif // GEN_PASS_DEF_HLOLEGALIZESORTPASS

//===----------------------------------------------------------------------===//
// HloLegalizeToArithmeticPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOLEGALIZETOARITHMETICPASS
#undef GEN_PASS_DECL_HLOLEGALIZETOARITHMETICPASS
#endif // GEN_PASS_DECL_HLOLEGALIZETOARITHMETICPASS
#ifdef GEN_PASS_DEF_HLOLEGALIZETOARITHMETICPASS
namespace impl {

template <typename DerivedT>
class HloLegalizeToArithmeticPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = HloLegalizeToArithmeticPassBase;

  HloLegalizeToArithmeticPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToArithmeticPassBase(const HloLegalizeToArithmeticPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  HloLegalizeToArithmeticPassBase& operator=(const HloLegalizeToArithmeticPassBase &) = delete;
  HloLegalizeToArithmeticPassBase(HloLegalizeToArithmeticPassBase &&) = delete;
  HloLegalizeToArithmeticPassBase& operator=(HloLegalizeToArithmeticPassBase &&) = delete;
  ~HloLegalizeToArithmeticPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-arithmetic");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-arithmetic"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO dialect to arithmetic dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToArithmeticPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToArithmeticPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToArithmeticPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOLEGALIZETOARITHMETICPASS
#endif // GEN_PASS_DEF_HLOLEGALIZETOARITHMETICPASS

//===----------------------------------------------------------------------===//
// HloLegalizeToLinalgPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOLEGALIZETOLINALGPASS
struct HloLegalizeToLinalgPassOptions {
  bool enablePrimitiveOps = false;
};
#undef GEN_PASS_DECL_HLOLEGALIZETOLINALGPASS
#endif // GEN_PASS_DECL_HLOLEGALIZETOLINALGPASS
#ifdef GEN_PASS_DEF_HLOLEGALIZETOLINALGPASS
namespace impl {

template <typename DerivedT>
class HloLegalizeToLinalgPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloLegalizeToLinalgPassBase;

  HloLegalizeToLinalgPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToLinalgPassBase(const HloLegalizeToLinalgPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloLegalizeToLinalgPassBase& operator=(const HloLegalizeToLinalgPassBase &) = delete;
  HloLegalizeToLinalgPassBase(HloLegalizeToLinalgPassBase &&) = delete;
  HloLegalizeToLinalgPassBase& operator=(HloLegalizeToLinalgPassBase &&) = delete;
  ~HloLegalizeToLinalgPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO dialect to Linalg dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToLinalgPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToLinalgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToLinalgPassBase<DerivedT>)

  HloLegalizeToLinalgPassBase(const HloLegalizeToLinalgPassOptions &options) : HloLegalizeToLinalgPassBase() {
    enablePrimitiveOps = options.enablePrimitiveOps;
  }
protected:
  ::mlir::Pass::Option<bool> enablePrimitiveOps{*this, "enable-primitive-ops", ::llvm::cl::desc("Lower to primitive Linalg ops (map, reduce and transpose) when possible, instead of linalg.generic"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOLEGALIZETOLINALGPASS
#endif // GEN_PASS_DEF_HLOLEGALIZETOLINALGPASS

//===----------------------------------------------------------------------===//
// HloLegalizeToMemrefPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOLEGALIZETOMEMREFPASS
#undef GEN_PASS_DECL_HLOLEGALIZETOMEMREFPASS
#endif // GEN_PASS_DECL_HLOLEGALIZETOMEMREFPASS
#ifdef GEN_PASS_DEF_HLOLEGALIZETOMEMREFPASS
namespace impl {

template <typename DerivedT>
class HloLegalizeToMemrefPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = HloLegalizeToMemrefPassBase;

  HloLegalizeToMemrefPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToMemrefPassBase(const HloLegalizeToMemrefPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  HloLegalizeToMemrefPassBase& operator=(const HloLegalizeToMemrefPassBase &) = delete;
  HloLegalizeToMemrefPassBase(HloLegalizeToMemrefPassBase &&) = delete;
  HloLegalizeToMemrefPassBase& operator=(HloLegalizeToMemrefPassBase &&) = delete;
  ~HloLegalizeToMemrefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-memref");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-memref"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO dialect to memref dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToMemrefPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToMemrefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToMemrefPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOLEGALIZETOMEMREFPASS
#endif // GEN_PASS_DEF_HLOLEGALIZETOMEMREFPASS

//===----------------------------------------------------------------------===//
// HloLegalizeToStablehloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HLOLEGALIZETOSTABLEHLOPASS
struct HloLegalizeToStablehloPassOptions {
  bool allow_experimental_features_ = false;
};
#undef GEN_PASS_DECL_HLOLEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DECL_HLOLEGALIZETOSTABLEHLOPASS
#ifdef GEN_PASS_DEF_HLOLEGALIZETOSTABLEHLOPASS
namespace impl {

template <typename DerivedT>
class HloLegalizeToStablehloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = HloLegalizeToStablehloPassBase;

  HloLegalizeToStablehloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToStablehloPassBase(const HloLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  HloLegalizeToStablehloPassBase& operator=(const HloLegalizeToStablehloPassBase &) = delete;
  HloLegalizeToStablehloPassBase(HloLegalizeToStablehloPassBase &&) = delete;
  HloLegalizeToStablehloPassBase& operator=(HloLegalizeToStablehloPassBase &&) = delete;
  ~HloLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize HLO to StableHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToStablehloPassBase<DerivedT>)

  HloLegalizeToStablehloPassBase(const HloLegalizeToStablehloPassOptions &options) : HloLegalizeToStablehloPassBase() {
    allow_experimental_features_ = options.allow_experimental_features_;
  }
protected:
  ::mlir::Pass::Option<bool> allow_experimental_features_{*this, "allow-experimental-features", ::llvm::cl::desc("Allow legalization of experimental MHLO features via StableHLO custom_call"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HLOLEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DEF_HLOLEGALIZETOSTABLEHLOPASS

//===----------------------------------------------------------------------===//
// LegalizeBroadcastToBroadcastInDimPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEBROADCASTTOBROADCASTINDIMPASS
#undef GEN_PASS_DECL_LEGALIZEBROADCASTTOBROADCASTINDIMPASS
#endif // GEN_PASS_DECL_LEGALIZEBROADCASTTOBROADCASTINDIMPASS
#ifdef GEN_PASS_DEF_LEGALIZEBROADCASTTOBROADCASTINDIMPASS
namespace impl {

template <typename DerivedT>
class LegalizeBroadcastToBroadcastInDimPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeBroadcastToBroadcastInDimPassBase;

  LegalizeBroadcastToBroadcastInDimPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeBroadcastToBroadcastInDimPassBase(const LegalizeBroadcastToBroadcastInDimPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeBroadcastToBroadcastInDimPassBase& operator=(const LegalizeBroadcastToBroadcastInDimPassBase &) = delete;
  LegalizeBroadcastToBroadcastInDimPassBase(LegalizeBroadcastToBroadcastInDimPassBase &&) = delete;
  LegalizeBroadcastToBroadcastInDimPassBase& operator=(LegalizeBroadcastToBroadcastInDimPassBase &&) = delete;
  ~LegalizeBroadcastToBroadcastInDimPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-broadcast-to-broadcast-in-dim");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-broadcast-to-broadcast-in-dim"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes broadcast ops to broadcast_in_dim ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeBroadcastToBroadcastInDimPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeBroadcastToBroadcastInDimPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeBroadcastToBroadcastInDimPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEBROADCASTTOBROADCASTINDIMPASS
#endif // GEN_PASS_DEF_LEGALIZEBROADCASTTOBROADCASTINDIMPASS

//===----------------------------------------------------------------------===//
// LegalizeControlFlowPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZECONTROLFLOWPASS
#undef GEN_PASS_DECL_LEGALIZECONTROLFLOWPASS
#endif // GEN_PASS_DECL_LEGALIZECONTROLFLOWPASS
#ifdef GEN_PASS_DEF_LEGALIZECONTROLFLOWPASS
namespace impl {

template <typename DerivedT>
class LegalizeControlFlowPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeControlFlowPassBase;

  LegalizeControlFlowPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeControlFlowPassBase(const LegalizeControlFlowPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeControlFlowPassBase& operator=(const LegalizeControlFlowPassBase &) = delete;
  LegalizeControlFlowPassBase(LegalizeControlFlowPassBase &&) = delete;
  LegalizeControlFlowPassBase& operator=(LegalizeControlFlowPassBase &&) = delete;
  ~LegalizeControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from MHLO control flow to SCF control flow."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeControlFlowPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZECONTROLFLOWPASS
#endif // GEN_PASS_DEF_LEGALIZECONTROLFLOWPASS

//===----------------------------------------------------------------------===//
// LegalizeCreateTokenToAfterAllPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZECREATETOKENTOAFTERALLPASS
#undef GEN_PASS_DECL_LEGALIZECREATETOKENTOAFTERALLPASS
#endif // GEN_PASS_DECL_LEGALIZECREATETOKENTOAFTERALLPASS
#ifdef GEN_PASS_DEF_LEGALIZECREATETOKENTOAFTERALLPASS
namespace impl {

template <typename DerivedT>
class LegalizeCreateTokenToAfterAllPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeCreateTokenToAfterAllPassBase;

  LegalizeCreateTokenToAfterAllPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeCreateTokenToAfterAllPassBase(const LegalizeCreateTokenToAfterAllPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeCreateTokenToAfterAllPassBase& operator=(const LegalizeCreateTokenToAfterAllPassBase &) = delete;
  LegalizeCreateTokenToAfterAllPassBase(LegalizeCreateTokenToAfterAllPassBase &&) = delete;
  LegalizeCreateTokenToAfterAllPassBase& operator=(LegalizeCreateTokenToAfterAllPassBase &&) = delete;
  ~LegalizeCreateTokenToAfterAllPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-create-token-to-after-all");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-create-token-to-after-all"; }

  ::llvm::StringRef getDescription() const override { return "Legalize create_token ops to after_all ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeCreateTokenToAfterAllPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeCreateTokenToAfterAllPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeCreateTokenToAfterAllPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZECREATETOKENTOAFTERALLPASS
#endif // GEN_PASS_DEF_LEGALIZECREATETOKENTOAFTERALLPASS

//===----------------------------------------------------------------------===//
// LegalizeCrossReplicaSumToAllReducePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZECROSSREPLICASUMTOALLREDUCEPASS
#undef GEN_PASS_DECL_LEGALIZECROSSREPLICASUMTOALLREDUCEPASS
#endif // GEN_PASS_DECL_LEGALIZECROSSREPLICASUMTOALLREDUCEPASS
#ifdef GEN_PASS_DEF_LEGALIZECROSSREPLICASUMTOALLREDUCEPASS
namespace impl {

template <typename DerivedT>
class LegalizeCrossReplicaSumToAllReducePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeCrossReplicaSumToAllReducePassBase;

  LegalizeCrossReplicaSumToAllReducePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeCrossReplicaSumToAllReducePassBase(const LegalizeCrossReplicaSumToAllReducePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeCrossReplicaSumToAllReducePassBase& operator=(const LegalizeCrossReplicaSumToAllReducePassBase &) = delete;
  LegalizeCrossReplicaSumToAllReducePassBase(LegalizeCrossReplicaSumToAllReducePassBase &&) = delete;
  LegalizeCrossReplicaSumToAllReducePassBase& operator=(LegalizeCrossReplicaSumToAllReducePassBase &&) = delete;
  ~LegalizeCrossReplicaSumToAllReducePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-cross-replica-sum-to-all-reduce");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-cross-replica-sum-to-all-reduce"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes cross-replica-sum ops to all_reduce ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeCrossReplicaSumToAllReducePass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeCrossReplicaSumToAllReducePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeCrossReplicaSumToAllReducePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZECROSSREPLICASUMTOALLREDUCEPASS
#endif // GEN_PASS_DEF_LEGALIZECROSSREPLICASUMTOALLREDUCEPASS

//===----------------------------------------------------------------------===//
// LegalizeDotGeneralToDotPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEDOTGENERALTODOTPASS
#undef GEN_PASS_DECL_LEGALIZEDOTGENERALTODOTPASS
#endif // GEN_PASS_DECL_LEGALIZEDOTGENERALTODOTPASS
#ifdef GEN_PASS_DEF_LEGALIZEDOTGENERALTODOTPASS
namespace impl {

template <typename DerivedT>
class LegalizeDotGeneralToDotPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeDotGeneralToDotPassBase;

  LegalizeDotGeneralToDotPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeDotGeneralToDotPassBase(const LegalizeDotGeneralToDotPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeDotGeneralToDotPassBase& operator=(const LegalizeDotGeneralToDotPassBase &) = delete;
  LegalizeDotGeneralToDotPassBase(LegalizeDotGeneralToDotPassBase &&) = delete;
  LegalizeDotGeneralToDotPassBase& operator=(LegalizeDotGeneralToDotPassBase &&) = delete;
  ~LegalizeDotGeneralToDotPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-dot-general-to-dot");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-dot-general-to-dot"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes dot_general ops to dot ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeDotGeneralToDotPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeDotGeneralToDotPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeDotGeneralToDotPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEDOTGENERALTODOTPASS
#endif // GEN_PASS_DEF_LEGALIZEDOTGENERALTODOTPASS

//===----------------------------------------------------------------------===//
// LegalizeDotToDotGeneralPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEDOTTODOTGENERALPASS
#undef GEN_PASS_DECL_LEGALIZEDOTTODOTGENERALPASS
#endif // GEN_PASS_DECL_LEGALIZEDOTTODOTGENERALPASS
#ifdef GEN_PASS_DEF_LEGALIZEDOTTODOTGENERALPASS
namespace impl {

template <typename DerivedT>
class LegalizeDotToDotGeneralPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeDotToDotGeneralPassBase;

  LegalizeDotToDotGeneralPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeDotToDotGeneralPassBase(const LegalizeDotToDotGeneralPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeDotToDotGeneralPassBase& operator=(const LegalizeDotToDotGeneralPassBase &) = delete;
  LegalizeDotToDotGeneralPassBase(LegalizeDotToDotGeneralPassBase &&) = delete;
  LegalizeDotToDotGeneralPassBase& operator=(LegalizeDotToDotGeneralPassBase &&) = delete;
  ~LegalizeDotToDotGeneralPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-dot-to-dot-general");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-dot-to-dot-general"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes dot ops to dot_general ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeDotToDotGeneralPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeDotToDotGeneralPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeDotToDotGeneralPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEDOTTODOTGENERALPASS
#endif // GEN_PASS_DEF_LEGALIZEDOTTODOTGENERALPASS

//===----------------------------------------------------------------------===//
// LegalizeEinsumToDotGeneralPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEEINSUMTODOTGENERALPASS
#undef GEN_PASS_DECL_LEGALIZEEINSUMTODOTGENERALPASS
#endif // GEN_PASS_DECL_LEGALIZEEINSUMTODOTGENERALPASS
#ifdef GEN_PASS_DEF_LEGALIZEEINSUMTODOTGENERALPASS
namespace impl {

template <typename DerivedT>
class LegalizeEinsumToDotGeneralPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeEinsumToDotGeneralPassBase;

  LegalizeEinsumToDotGeneralPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeEinsumToDotGeneralPassBase(const LegalizeEinsumToDotGeneralPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeEinsumToDotGeneralPassBase& operator=(const LegalizeEinsumToDotGeneralPassBase &) = delete;
  LegalizeEinsumToDotGeneralPassBase(LegalizeEinsumToDotGeneralPassBase &&) = delete;
  LegalizeEinsumToDotGeneralPassBase& operator=(LegalizeEinsumToDotGeneralPassBase &&) = delete;
  ~LegalizeEinsumToDotGeneralPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-einsum-to-dot-general");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-einsum-to-dot-general"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes einsum ops to dot_general ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeEinsumToDotGeneralPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeEinsumToDotGeneralPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeEinsumToDotGeneralPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEEINSUMTODOTGENERALPASS
#endif // GEN_PASS_DEF_LEGALIZEEINSUMTODOTGENERALPASS

//===----------------------------------------------------------------------===//
// LegalizeGatherToTorchIndexSelectPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEGATHERTOTORCHINDEXSELECTPASS
#undef GEN_PASS_DECL_LEGALIZEGATHERTOTORCHINDEXSELECTPASS
#endif // GEN_PASS_DECL_LEGALIZEGATHERTOTORCHINDEXSELECTPASS
#ifdef GEN_PASS_DEF_LEGALIZEGATHERTOTORCHINDEXSELECTPASS
namespace impl {

template <typename DerivedT>
class LegalizeGatherToTorchIndexSelectPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeGatherToTorchIndexSelectPassBase;

  LegalizeGatherToTorchIndexSelectPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeGatherToTorchIndexSelectPassBase(const LegalizeGatherToTorchIndexSelectPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeGatherToTorchIndexSelectPassBase& operator=(const LegalizeGatherToTorchIndexSelectPassBase &) = delete;
  LegalizeGatherToTorchIndexSelectPassBase(LegalizeGatherToTorchIndexSelectPassBase &&) = delete;
  LegalizeGatherToTorchIndexSelectPassBase& operator=(LegalizeGatherToTorchIndexSelectPassBase &&) = delete;
  ~LegalizeGatherToTorchIndexSelectPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-gather-to-torch-index-select");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-gather-to-torch-index-select"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes gathers to a torch index select."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeGatherToTorchIndexSelectPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeGatherToTorchIndexSelectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeGatherToTorchIndexSelectPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEGATHERTOTORCHINDEXSELECTPASS
#endif // GEN_PASS_DEF_LEGALIZEGATHERTOTORCHINDEXSELECTPASS

//===----------------------------------------------------------------------===//
// LegalizeGeneralDotPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEGENERALDOTPASS
#undef GEN_PASS_DECL_LEGALIZEGENERALDOTPASS
#endif // GEN_PASS_DECL_LEGALIZEGENERALDOTPASS
#ifdef GEN_PASS_DEF_LEGALIZEGENERALDOTPASS
namespace impl {

template <typename DerivedT>
class LegalizeGeneralDotPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeGeneralDotPassBase;

  LegalizeGeneralDotPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeGeneralDotPassBase(const LegalizeGeneralDotPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeGeneralDotPassBase& operator=(const LegalizeGeneralDotPassBase &) = delete;
  LegalizeGeneralDotPassBase(LegalizeGeneralDotPassBase &&) = delete;
  LegalizeGeneralDotPassBase& operator=(LegalizeGeneralDotPassBase &&) = delete;
  ~LegalizeGeneralDotPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-lower-general-dot");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-lower-general-dot"; }

  ::llvm::StringRef getDescription() const override { return "Tests lowering general dot to a non-batched dot when possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeGeneralDotPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeGeneralDotPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeGeneralDotPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEGENERALDOTPASS
#endif // GEN_PASS_DEF_LEGALIZEGENERALDOTPASS

//===----------------------------------------------------------------------===//
// LegalizeTanhToApproximationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZETANHTOAPPROXIMATIONPASS
#undef GEN_PASS_DECL_LEGALIZETANHTOAPPROXIMATIONPASS
#endif // GEN_PASS_DECL_LEGALIZETANHTOAPPROXIMATIONPASS
#ifdef GEN_PASS_DEF_LEGALIZETANHTOAPPROXIMATIONPASS
namespace impl {

template <typename DerivedT>
class LegalizeTanhToApproximationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeTanhToApproximationPassBase;

  LegalizeTanhToApproximationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTanhToApproximationPassBase(const LegalizeTanhToApproximationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeTanhToApproximationPassBase& operator=(const LegalizeTanhToApproximationPassBase &) = delete;
  LegalizeTanhToApproximationPassBase(LegalizeTanhToApproximationPassBase &&) = delete;
  LegalizeTanhToApproximationPassBase& operator=(LegalizeTanhToApproximationPassBase &&) = delete;
  ~LegalizeTanhToApproximationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-trigonometric-to-approximation");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-trigonometric-to-approximation"; }

  ::llvm::StringRef getDescription() const override { return "Legalize trigonometric operations from standard dialect to an approximation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTanhToApproximationPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTanhToApproximationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTanhToApproximationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZETANHTOAPPROXIMATIONPASS
#endif // GEN_PASS_DEF_LEGALIZETANHTOAPPROXIMATIONPASS

//===----------------------------------------------------------------------===//
// LegalizeToStandardPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZETOSTANDARDPASS
#undef GEN_PASS_DECL_LEGALIZETOSTANDARDPASS
#endif // GEN_PASS_DECL_LEGALIZETOSTANDARDPASS
#ifdef GEN_PASS_DEF_LEGALIZETOSTANDARDPASS
namespace impl {

template <typename DerivedT>
class LegalizeToStandardPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeToStandardPassBase;

  LegalizeToStandardPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeToStandardPassBase(const LegalizeToStandardPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeToStandardPassBase& operator=(const LegalizeToStandardPassBase &) = delete;
  LegalizeToStandardPassBase(LegalizeToStandardPassBase &&) = delete;
  LegalizeToStandardPassBase& operator=(LegalizeToStandardPassBase &&) = delete;
  ~LegalizeToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-to-std");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-to-std"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from MHLO dialect to standard dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeToStandardPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZETOSTANDARDPASS
#endif // GEN_PASS_DEF_LEGALIZETOSTANDARDPASS

//===----------------------------------------------------------------------===//
// LegalizeTorchIndexSelectToGatherPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZETORCHINDEXSELECTTOGATHERPASS
#undef GEN_PASS_DECL_LEGALIZETORCHINDEXSELECTTOGATHERPASS
#endif // GEN_PASS_DECL_LEGALIZETORCHINDEXSELECTTOGATHERPASS
#ifdef GEN_PASS_DEF_LEGALIZETORCHINDEXSELECTTOGATHERPASS
namespace impl {

template <typename DerivedT>
class LegalizeTorchIndexSelectToGatherPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeTorchIndexSelectToGatherPassBase;

  LegalizeTorchIndexSelectToGatherPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTorchIndexSelectToGatherPassBase(const LegalizeTorchIndexSelectToGatherPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeTorchIndexSelectToGatherPassBase& operator=(const LegalizeTorchIndexSelectToGatherPassBase &) = delete;
  LegalizeTorchIndexSelectToGatherPassBase(LegalizeTorchIndexSelectToGatherPassBase &&) = delete;
  LegalizeTorchIndexSelectToGatherPassBase& operator=(LegalizeTorchIndexSelectToGatherPassBase &&) = delete;
  ~LegalizeTorchIndexSelectToGatherPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-torch-index-select-to-gather");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-torch-index-select-to-gather"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes torch index select to a gather."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTorchIndexSelectToGatherPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTorchIndexSelectToGatherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTorchIndexSelectToGatherPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZETORCHINDEXSELECTTOGATHERPASS
#endif // GEN_PASS_DEF_LEGALIZETORCHINDEXSELECTTOGATHERPASS

//===----------------------------------------------------------------------===//
// LowerComplexPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERCOMPLEXPASS
#undef GEN_PASS_DECL_LOWERCOMPLEXPASS
#endif // GEN_PASS_DECL_LOWERCOMPLEXPASS
#ifdef GEN_PASS_DEF_LOWERCOMPLEXPASS
namespace impl {

template <typename DerivedT>
class LowerComplexPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LowerComplexPassBase;

  LowerComplexPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerComplexPassBase(const LowerComplexPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LowerComplexPassBase& operator=(const LowerComplexPassBase &) = delete;
  LowerComplexPassBase(LowerComplexPassBase &&) = delete;
  LowerComplexPassBase& operator=(LowerComplexPassBase &&) = delete;
  ~LowerComplexPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-lower-complex");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-lower-complex"; }

  ::llvm::StringRef getDescription() const override { return "Lower complex operations into non-complex operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerComplexPass");
  }
  ::llvm::StringRef getName() const override { return "LowerComplexPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerComplexPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERCOMPLEXPASS
#endif // GEN_PASS_DEF_LOWERCOMPLEXPASS

//===----------------------------------------------------------------------===//
// MergeAssumingOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGEASSUMINGOPSPASS
#undef GEN_PASS_DECL_MERGEASSUMINGOPSPASS
#endif // GEN_PASS_DECL_MERGEASSUMINGOPSPASS
#ifdef GEN_PASS_DEF_MERGEASSUMINGOPSPASS
namespace impl {

template <typename DerivedT>
class MergeAssumingOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MergeAssumingOpsPassBase;

  MergeAssumingOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeAssumingOpsPassBase(const MergeAssumingOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  MergeAssumingOpsPassBase& operator=(const MergeAssumingOpsPassBase &) = delete;
  MergeAssumingOpsPassBase(MergeAssumingOpsPassBase &&) = delete;
  MergeAssumingOpsPassBase& operator=(MergeAssumingOpsPassBase &&) = delete;
  ~MergeAssumingOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-merge-assuming-ops");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-merge-assuming-ops"; }

  ::llvm::StringRef getDescription() const override { return "Prepare moving dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeAssumingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeAssumingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeAssumingOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MERGEASSUMINGOPSPASS
#endif // GEN_PASS_DEF_MERGEASSUMINGOPSPASS

//===----------------------------------------------------------------------===//
// MhloExpandOpsSimplifierPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MHLOEXPANDOPSSIMPLIFIERPASS
#undef GEN_PASS_DECL_MHLOEXPANDOPSSIMPLIFIERPASS
#endif // GEN_PASS_DECL_MHLOEXPANDOPSSIMPLIFIERPASS
#ifdef GEN_PASS_DEF_MHLOEXPANDOPSSIMPLIFIERPASS
namespace impl {

template <typename DerivedT>
class MhloExpandOpsSimplifierPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MhloExpandOpsSimplifierPassBase;

  MhloExpandOpsSimplifierPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MhloExpandOpsSimplifierPassBase(const MhloExpandOpsSimplifierPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  MhloExpandOpsSimplifierPassBase& operator=(const MhloExpandOpsSimplifierPassBase &) = delete;
  MhloExpandOpsSimplifierPassBase(MhloExpandOpsSimplifierPassBase &&) = delete;
  MhloExpandOpsSimplifierPassBase& operator=(MhloExpandOpsSimplifierPassBase &&) = delete;
  ~MhloExpandOpsSimplifierPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-expand-ops-simplifier");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-expand-ops-simplifier"; }

  ::llvm::StringRef getDescription() const override { return "Expand feature rich mhlo ops into a set of simpler mhlo ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MhloExpandOpsSimplifierPass");
  }
  ::llvm::StringRef getName() const override { return "MhloExpandOpsSimplifierPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MhloExpandOpsSimplifierPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MHLOEXPANDOPSSIMPLIFIERPASS
#endif // GEN_PASS_DEF_MHLOEXPANDOPSSIMPLIFIERPASS

//===----------------------------------------------------------------------===//
// OptimizeMhloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OPTIMIZEMHLOPASS
#undef GEN_PASS_DECL_OPTIMIZEMHLOPASS
#endif // GEN_PASS_DECL_OPTIMIZEMHLOPASS
#ifdef GEN_PASS_DEF_OPTIMIZEMHLOPASS
namespace impl {

template <typename DerivedT>
class OptimizeMhloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = OptimizeMhloPassBase;

  OptimizeMhloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeMhloPassBase(const OptimizeMhloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  OptimizeMhloPassBase& operator=(const OptimizeMhloPassBase &) = delete;
  OptimizeMhloPassBase(OptimizeMhloPassBase &&) = delete;
  OptimizeMhloPassBase& operator=(OptimizeMhloPassBase &&) = delete;
  ~OptimizeMhloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-optimize");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-optimize"; }

  ::llvm::StringRef getDescription() const override { return "Run optional HLO optimizations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeMhloPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeMhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeMhloPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OPTIMIZEMHLOPASS
#endif // GEN_PASS_DEF_OPTIMIZEMHLOPASS

//===----------------------------------------------------------------------===//
// PrepareForExportPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PREPAREFOREXPORTPASS
std::unique_ptr<::mlir::Pass> createPrepareForExportPass();
#undef GEN_PASS_DECL_PREPAREFOREXPORTPASS
#endif // GEN_PASS_DECL_PREPAREFOREXPORTPASS
#ifdef GEN_PASS_DEF_PREPAREFOREXPORTPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createPrepareForExportPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class PrepareForExportPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PrepareForExportPassBase;

  PrepareForExportPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrepareForExportPassBase(const PrepareForExportPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PrepareForExportPassBase& operator=(const PrepareForExportPassBase &) = delete;
  PrepareForExportPassBase(PrepareForExportPassBase &&) = delete;
  PrepareForExportPassBase& operator=(PrepareForExportPassBase &&) = delete;
  ~PrepareForExportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-prepare-for-export");
  }
  ::llvm::StringRef getArgument() const override { return "xla-prepare-for-export"; }

  ::llvm::StringRef getDescription() const override { return "Prepare for XLA export"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrepareForExportPass");
  }
  ::llvm::StringRef getName() const override { return "PrepareForExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrepareForExportPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createPrepareForExportPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createPrepareForExportPass() {
  return impl::createPrepareForExportPass();
}
#undef GEN_PASS_DEF_PREPAREFOREXPORTPASS
#endif // GEN_PASS_DEF_PREPAREFOREXPORTPASS

//===----------------------------------------------------------------------===//
// RestrictMaxRankPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_RESTRICTMAXRANKPASS
#undef GEN_PASS_DECL_RESTRICTMAXRANKPASS
#endif // GEN_PASS_DECL_RESTRICTMAXRANKPASS
#ifdef GEN_PASS_DEF_RESTRICTMAXRANKPASS
namespace impl {

template <typename DerivedT>
class RestrictMaxRankPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = RestrictMaxRankPassBase;

  RestrictMaxRankPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RestrictMaxRankPassBase(const RestrictMaxRankPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  RestrictMaxRankPassBase& operator=(const RestrictMaxRankPassBase &) = delete;
  RestrictMaxRankPassBase(RestrictMaxRankPassBase &&) = delete;
  RestrictMaxRankPassBase& operator=(RestrictMaxRankPassBase &&) = delete;
  ~RestrictMaxRankPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-restrict-max-rank");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-restrict-max-rank"; }

  ::llvm::StringRef getDescription() const override { return "Restrict maximum rank of any of the intermediate tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RestrictMaxRankPass");
  }
  ::llvm::StringRef getName() const override { return "RestrictMaxRankPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RestrictMaxRankPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_RESTRICTMAXRANKPASS
#endif // GEN_PASS_DEF_RESTRICTMAXRANKPASS

//===----------------------------------------------------------------------===//
// ShapeLegalizeToHloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPELEGALIZETOHLOPASS
struct ShapeLegalizeToHloPassOptions {
  bool legalize_constraints_ = false;
};
#undef GEN_PASS_DECL_SHAPELEGALIZETOHLOPASS
#endif // GEN_PASS_DECL_SHAPELEGALIZETOHLOPASS
#ifdef GEN_PASS_DEF_SHAPELEGALIZETOHLOPASS
namespace impl {

template <typename DerivedT>
class ShapeLegalizeToHloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ShapeLegalizeToHloPassBase;

  ShapeLegalizeToHloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeLegalizeToHloPassBase(const ShapeLegalizeToHloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ShapeLegalizeToHloPassBase& operator=(const ShapeLegalizeToHloPassBase &) = delete;
  ShapeLegalizeToHloPassBase(ShapeLegalizeToHloPassBase &&) = delete;
  ShapeLegalizeToHloPassBase& operator=(ShapeLegalizeToHloPassBase &&) = delete;
  ~ShapeLegalizeToHloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-legalize-to-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "shape-legalize-to-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize shape-related ops to HLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeLegalizeToHloPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeLegalizeToHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeLegalizeToHloPassBase<DerivedT>)

  ShapeLegalizeToHloPassBase(const ShapeLegalizeToHloPassOptions &options) : ShapeLegalizeToHloPassBase() {
    legalize_constraints_ = options.legalize_constraints_;
  }
protected:
  ::mlir::Pass::Option<bool> legalize_constraints_{*this, "legalize-constraints", ::llvm::cl::desc("Whether to legalize Cstr Ops to shape_assertion custom_call"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHAPELEGALIZETOHLOPASS
#endif // GEN_PASS_DEF_SHAPELEGALIZETOHLOPASS

//===----------------------------------------------------------------------===//
// ShapeReificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPEREIFICATIONPASS
#undef GEN_PASS_DECL_SHAPEREIFICATIONPASS
#endif // GEN_PASS_DECL_SHAPEREIFICATIONPASS
#ifdef GEN_PASS_DEF_SHAPEREIFICATIONPASS
namespace impl {

template <typename DerivedT>
class ShapeReificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ShapeReificationPassBase;

  ShapeReificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeReificationPassBase(const ShapeReificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ShapeReificationPassBase& operator=(const ShapeReificationPassBase &) = delete;
  ShapeReificationPassBase(ShapeReificationPassBase &&) = delete;
  ShapeReificationPassBase& operator=(ShapeReificationPassBase &&) = delete;
  ~ShapeReificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-reification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-reification"; }

  ::llvm::StringRef getDescription() const override { return "Iteratively reify all shape computations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeReificationPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeReificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeReificationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHAPEREIFICATIONPASS
#endif // GEN_PASS_DEF_SHAPEREIFICATIONPASS

//===----------------------------------------------------------------------===//
// ShapeSimplification
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPESIMPLIFICATION
#undef GEN_PASS_DECL_SHAPESIMPLIFICATION
#endif // GEN_PASS_DECL_SHAPESIMPLIFICATION
#ifdef GEN_PASS_DEF_SHAPESIMPLIFICATION
namespace impl {

template <typename DerivedT>
class ShapeSimplificationBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ShapeSimplificationBase;

  ShapeSimplificationBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeSimplificationBase(const ShapeSimplificationBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ShapeSimplificationBase& operator=(const ShapeSimplificationBase &) = delete;
  ShapeSimplificationBase(ShapeSimplificationBase &&) = delete;
  ShapeSimplificationBase& operator=(ShapeSimplificationBase &&) = delete;
  ~ShapeSimplificationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Simplify shape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeSimplification");
  }
  ::llvm::StringRef getName() const override { return "ShapeSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeSimplificationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHAPESIMPLIFICATION
#endif // GEN_PASS_DEF_SHAPESIMPLIFICATION

//===----------------------------------------------------------------------===//
// SinkConstantsToControlFlowPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SINKCONSTANTSTOCONTROLFLOWPASS
#undef GEN_PASS_DECL_SINKCONSTANTSTOCONTROLFLOWPASS
#endif // GEN_PASS_DECL_SINKCONSTANTSTOCONTROLFLOWPASS
#ifdef GEN_PASS_DEF_SINKCONSTANTSTOCONTROLFLOWPASS
namespace impl {

template <typename DerivedT>
class SinkConstantsToControlFlowPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = SinkConstantsToControlFlowPassBase;

  SinkConstantsToControlFlowPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SinkConstantsToControlFlowPassBase(const SinkConstantsToControlFlowPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  SinkConstantsToControlFlowPassBase& operator=(const SinkConstantsToControlFlowPassBase &) = delete;
  SinkConstantsToControlFlowPassBase(SinkConstantsToControlFlowPassBase &&) = delete;
  SinkConstantsToControlFlowPassBase& operator=(SinkConstantsToControlFlowPassBase &&) = delete;
  ~SinkConstantsToControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-sink-constants-to-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-sink-constants-to-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Sink constants implicitly captured in control flow regions. This is necessary to export to XLA."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SinkConstantsToControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "SinkConstantsToControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SinkConstantsToControlFlowPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SINKCONSTANTSTOCONTROLFLOWPASS
#endif // GEN_PASS_DEF_SINKCONSTANTSTOCONTROLFLOWPASS

//===----------------------------------------------------------------------===//
// StablehloLegalizeToHloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOLEGALIZETOHLOPASS
#undef GEN_PASS_DECL_STABLEHLOLEGALIZETOHLOPASS
#endif // GEN_PASS_DECL_STABLEHLOLEGALIZETOHLOPASS
#ifdef GEN_PASS_DEF_STABLEHLOLEGALIZETOHLOPASS
namespace impl {

template <typename DerivedT>
class StablehloLegalizeToHloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloLegalizeToHloPassBase;

  StablehloLegalizeToHloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeToHloPassBase(const StablehloLegalizeToHloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloLegalizeToHloPassBase& operator=(const StablehloLegalizeToHloPassBase &) = delete;
  StablehloLegalizeToHloPassBase(StablehloLegalizeToHloPassBase &&) = delete;
  StablehloLegalizeToHloPassBase& operator=(StablehloLegalizeToHloPassBase &&) = delete;
  ~StablehloLegalizeToHloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-to-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-to-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize StableHLO to HLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeToHloPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeToHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeToHloPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STABLEHLOLEGALIZETOHLOPASS
#endif // GEN_PASS_DEF_STABLEHLOLEGALIZETOHLOPASS

//===----------------------------------------------------------------------===//
// SymbolicShapeOptimization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#undef GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#endif // GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#ifdef GEN_PASS_DEF_SYMBOLICSHAPEOPTIMIZATION
namespace impl {

template <typename DerivedT>
class SymbolicShapeOptimizationBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = SymbolicShapeOptimizationBase;

  SymbolicShapeOptimizationBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SymbolicShapeOptimizationBase(const SymbolicShapeOptimizationBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  SymbolicShapeOptimizationBase& operator=(const SymbolicShapeOptimizationBase &) = delete;
  SymbolicShapeOptimizationBase(SymbolicShapeOptimizationBase &&) = delete;
  SymbolicShapeOptimizationBase& operator=(SymbolicShapeOptimizationBase &&) = delete;
  ~SymbolicShapeOptimizationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("symbolic-shape-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "symbolic-shape-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Analyzes shapes and performs shape-related optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SymbolicShapeOptimization");
  }
  ::llvm::StringRef getName() const override { return "SymbolicShapeOptimization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SymbolicShapeOptimizationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SYMBOLICSHAPEOPTIMIZATION
#endif // GEN_PASS_DEF_SYMBOLICSHAPEOPTIMIZATION

//===----------------------------------------------------------------------===//
// TestInferShapedTypeMethodsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TESTINFERSHAPEDTYPEMETHODSPASS
#undef GEN_PASS_DECL_TESTINFERSHAPEDTYPEMETHODSPASS
#endif // GEN_PASS_DECL_TESTINFERSHAPEDTYPEMETHODSPASS
#ifdef GEN_PASS_DEF_TESTINFERSHAPEDTYPEMETHODSPASS
namespace impl {

template <typename DerivedT>
class TestInferShapedTypeMethodsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestInferShapedTypeMethodsPassBase;

  TestInferShapedTypeMethodsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestInferShapedTypeMethodsPassBase(const TestInferShapedTypeMethodsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TestInferShapedTypeMethodsPassBase& operator=(const TestInferShapedTypeMethodsPassBase &) = delete;
  TestInferShapedTypeMethodsPassBase(TestInferShapedTypeMethodsPassBase &&) = delete;
  TestInferShapedTypeMethodsPassBase& operator=(TestInferShapedTypeMethodsPassBase &&) = delete;
  ~TestInferShapedTypeMethodsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-infer-shaped-type-methods");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-infer-shaped-type-methods"; }

  ::llvm::StringRef getDescription() const override { return "Uses test ops to invoke InferShapedTypeOpInterface methods."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestInferShapedTypeMethodsPass");
  }
  ::llvm::StringRef getName() const override { return "TestInferShapedTypeMethodsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestInferShapedTypeMethodsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TESTINFERSHAPEDTYPEMETHODSPASS
#endif // GEN_PASS_DEF_TESTINFERSHAPEDTYPEMETHODSPASS

//===----------------------------------------------------------------------===//
// TestMaterializeBroadcastsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TESTMATERIALIZEBROADCASTSPASS
#undef GEN_PASS_DECL_TESTMATERIALIZEBROADCASTSPASS
#endif // GEN_PASS_DECL_TESTMATERIALIZEBROADCASTSPASS
#ifdef GEN_PASS_DEF_TESTMATERIALIZEBROADCASTSPASS
namespace impl {

template <typename DerivedT>
class TestMaterializeBroadcastsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestMaterializeBroadcastsPassBase;

  TestMaterializeBroadcastsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestMaterializeBroadcastsPassBase(const TestMaterializeBroadcastsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TestMaterializeBroadcastsPassBase& operator=(const TestMaterializeBroadcastsPassBase &) = delete;
  TestMaterializeBroadcastsPassBase(TestMaterializeBroadcastsPassBase &&) = delete;
  TestMaterializeBroadcastsPassBase& operator=(TestMaterializeBroadcastsPassBase &&) = delete;
  ~TestMaterializeBroadcastsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-materialize-broadcasts");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-materialize-broadcasts"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for materializing 'broadcast_dimensions' attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestMaterializeBroadcastsPass");
  }
  ::llvm::StringRef getName() const override { return "TestMaterializeBroadcastsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestMaterializeBroadcastsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TESTMATERIALIZEBROADCASTSPASS
#endif // GEN_PASS_DEF_TESTMATERIALIZEBROADCASTSPASS

//===----------------------------------------------------------------------===//
// TestUnfuseBatchNormPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TESTUNFUSEBATCHNORMPASS
#undef GEN_PASS_DECL_TESTUNFUSEBATCHNORMPASS
#endif // GEN_PASS_DECL_TESTUNFUSEBATCHNORMPASS
#ifdef GEN_PASS_DEF_TESTUNFUSEBATCHNORMPASS
namespace impl {

template <typename DerivedT>
class TestUnfuseBatchNormPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestUnfuseBatchNormPassBase;

  TestUnfuseBatchNormPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestUnfuseBatchNormPassBase(const TestUnfuseBatchNormPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TestUnfuseBatchNormPassBase& operator=(const TestUnfuseBatchNormPassBase &) = delete;
  TestUnfuseBatchNormPassBase(TestUnfuseBatchNormPassBase &&) = delete;
  TestUnfuseBatchNormPassBase& operator=(TestUnfuseBatchNormPassBase &&) = delete;
  ~TestUnfuseBatchNormPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-unfuse-batch-norm");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-unfuse-batch-norm"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for materializing 'broadcast_dimensions' attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestUnfuseBatchNormPass");
  }
  ::llvm::StringRef getName() const override { return "TestUnfuseBatchNormPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<shape::ShapeDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestUnfuseBatchNormPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TESTUNFUSEBATCHNORMPASS
#endif // GEN_PASS_DEF_TESTUNFUSEBATCHNORMPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BroadcastPropagationPass Registration
//===----------------------------------------------------------------------===//

inline void registerBroadcastPropagationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBroadcastPropagationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBroadcastPropagationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBroadcastPropagationPass();
  });
}

//===----------------------------------------------------------------------===//
// ChloLegalizeToHighLevelMhloPass Registration
//===----------------------------------------------------------------------===//

inline void registerChloLegalizeToHighLevelMhloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createChloLegalizeToHighLevelMhloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerChloLegalizeToHighLevelMhloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createChloLegalizeToHighLevelMhloPass();
  });
}

//===----------------------------------------------------------------------===//
// ChloLegalizeToHloPass Registration
//===----------------------------------------------------------------------===//

inline void registerChloLegalizeToHloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createChloLegalizeToHloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerChloLegalizeToHloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createChloLegalizeToHloPass();
  });
}

//===----------------------------------------------------------------------===//
// CollapseElementwiseMapPass Registration
//===----------------------------------------------------------------------===//

inline void registerCollapseElementwiseMapPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCollapseElementwiseMapPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCollapseElementwiseMapPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCollapseElementwiseMapPass();
  });
}

//===----------------------------------------------------------------------===//
// ConstraintFusionPass Registration
//===----------------------------------------------------------------------===//

inline void registerConstraintFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConstraintFusionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConstraintFusionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConstraintFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertToSignlessPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertToSignlessPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertToSignlessPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertToSignlessPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertToSignlessPass();
  });
}

//===----------------------------------------------------------------------===//
// ExpandHloTuplesPass Registration
//===----------------------------------------------------------------------===//

inline void registerExpandHloTuplesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandHloTuplesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExpandHloTuplesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandHloTuplesPass();
  });
}

//===----------------------------------------------------------------------===//
// FlattenTuplePass Registration
//===----------------------------------------------------------------------===//

inline void registerFlattenTuplePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFlattenTuplePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFlattenTuplePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFlattenTuplePass();
  });
}

//===----------------------------------------------------------------------===//
// GroupReductionDimensionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerGroupReductionDimensionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGroupReductionDimensionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGroupReductionDimensionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGroupReductionDimensionsPass();
  });
}

//===----------------------------------------------------------------------===//
// HloCanonicalizeDotPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloCanonicalizeDotPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeDotPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloCanonicalizeDotPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeDotPass();
  });
}

//===----------------------------------------------------------------------===//
// HloCanonicalizeGatherPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloCanonicalizeGatherPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeGatherPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloCanonicalizeGatherPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeGatherPass();
  });
}

//===----------------------------------------------------------------------===//
// HloCanonicalizeReductionPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloCanonicalizeReductionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeReductionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloCanonicalizeReductionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeReductionPass();
  });
}

//===----------------------------------------------------------------------===//
// HloCanonicalizeScatterPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloCanonicalizeScatterPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeScatterPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloCanonicalizeScatterPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloCanonicalizeScatterPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeShapeComputationsPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeShapeComputationsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeShapeComputationsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloLegalizeShapeComputationsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeShapeComputationsPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeSortPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeSortPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeSortPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloLegalizeSortPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeSortPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeToArithmeticPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeToArithmeticPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToArithmeticPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloLegalizeToArithmeticPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToArithmeticPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeToLinalgPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeToLinalgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeHloToLinalgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloLegalizeToLinalgPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeHloToLinalgPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeToMemrefPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeToMemrefPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToMemrefPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloLegalizeToMemrefPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToMemrefPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeToStablehloPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeToStablehloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloLegalizeToStablehloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHloLegalizeToStablehloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createHloLegalizeToStablehloPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeBroadcastToBroadcastInDimPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeBroadcastToBroadcastInDimPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeBroadcastToBroadcastInDimPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeBroadcastToBroadcastInDimPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeBroadcastToBroadcastInDimPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeControlFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeControlFlowPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeControlFlowPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeCreateTokenToAfterAllPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeCreateTokenToAfterAllPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeCreateTokenToAfterAllPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeCreateTokenToAfterAllPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeCreateTokenToAfterAllPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeCrossReplicaSumToAllReducePass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeCrossReplicaSumToAllReducePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeCrossReplicaSumToAllReducePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeCrossReplicaSumToAllReducePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeCrossReplicaSumToAllReducePass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeDotGeneralToDotPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeDotGeneralToDotPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeDotGeneralToDotPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeDotGeneralToDotPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeDotGeneralToDotPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeDotToDotGeneralPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeDotToDotGeneralPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeDotToDotGeneralPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeDotToDotGeneralPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeDotToDotGeneralPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeEinsumToDotGeneralPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeEinsumToDotGeneralPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeEinsumToDotGeneralPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeEinsumToDotGeneralPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeEinsumToDotGeneralPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeGatherToTorchIndexSelectPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeGatherToTorchIndexSelectPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeGatherToTorchIndexSelectPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeGatherToTorchIndexSelectPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeGatherToTorchIndexSelectPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeGeneralDotPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeGeneralDotPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeGeneralDotPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeGeneralDotPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeGeneralDotPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTanhToApproximationPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTanhToApproximationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTrigonometricToApproximationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeTanhToApproximationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTrigonometricToApproximationPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeToStandardPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeToStandardPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToStdPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeToStandardPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToStdPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTorchIndexSelectToGatherPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTorchIndexSelectToGatherPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTorchIndexSelectToGatherPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeTorchIndexSelectToGatherPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTorchIndexSelectToGatherPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerComplexPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerComplexPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerComplexPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerComplexPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerComplexPass();
  });
}

//===----------------------------------------------------------------------===//
// MergeAssumingOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerMergeAssumingOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMergeAssumingOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergeAssumingOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMergeAssumingOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// MhloExpandOpsSimplifierPass Registration
//===----------------------------------------------------------------------===//

inline void registerMhloExpandOpsSimplifierPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMhloExpandOpsSimplifierPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMhloExpandOpsSimplifierPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMhloExpandOpsSimplifierPass();
  });
}

//===----------------------------------------------------------------------===//
// OptimizeMhloPass Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizeMhloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createOptimizeMhloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOptimizeMhloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createOptimizeMhloPass();
  });
}

//===----------------------------------------------------------------------===//
// PrepareForExportPass Registration
//===----------------------------------------------------------------------===//

inline void registerPrepareForExportPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createPrepareForExportPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPrepareForExportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createPrepareForExportPass();
  });
}

//===----------------------------------------------------------------------===//
// RestrictMaxRankPass Registration
//===----------------------------------------------------------------------===//

inline void registerRestrictMaxRankPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRestrictMaxRankPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRestrictMaxRankPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRestrictMaxRankPass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeLegalizeToHloPass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeLegalizeToHloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeLegalizeToHloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeLegalizeToHloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeLegalizeToHloPass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeReificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeReificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeReificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeReificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeReificationPass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeSimplification Registration
//===----------------------------------------------------------------------===//

inline void registerShapeSimplification() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeSimplification();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeSimplification();
  });
}

//===----------------------------------------------------------------------===//
// SinkConstantsToControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerSinkConstantsToControlFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSinkConstantsToControlFlowPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSinkConstantsToControlFlowPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSinkConstantsToControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloLegalizeToHloPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloLegalizeToHloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeToHloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloLegalizeToHloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeToHloPass();
  });
}

//===----------------------------------------------------------------------===//
// SymbolicShapeOptimization Registration
//===----------------------------------------------------------------------===//

inline void registerSymbolicShapeOptimization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSymbolicShapeOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSymbolicShapeOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSymbolicShapeOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// TestInferShapedTypeMethodsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTestInferShapedTypeMethodsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestInferShapedTypeMethodsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTestInferShapedTypeMethodsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestInferShapedTypeMethodsPass();
  });
}

//===----------------------------------------------------------------------===//
// TestMaterializeBroadcastsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTestMaterializeBroadcastsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestMaterializeBroadcastsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTestMaterializeBroadcastsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestMaterializeBroadcastsPass();
  });
}

//===----------------------------------------------------------------------===//
// TestUnfuseBatchNormPass Registration
//===----------------------------------------------------------------------===//

inline void registerTestUnfuseBatchNormPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestUnfuseBatchNormPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTestUnfuseBatchNormPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestUnfuseBatchNormPass();
  });
}

//===----------------------------------------------------------------------===//
// AllMhlo Registration
//===----------------------------------------------------------------------===//

inline void registerAllMhloPasses() {
  registerBroadcastPropagationPass();
  registerChloLegalizeToHighLevelMhloPass();
  registerChloLegalizeToHloPass();
  registerCollapseElementwiseMapPass();
  registerConstraintFusionPass();
  registerConvertToSignlessPass();
  registerExpandHloTuplesPass();
  registerFlattenTuplePass();
  registerGroupReductionDimensionsPass();
  registerHloCanonicalizeDotPass();
  registerHloCanonicalizeGatherPass();
  registerHloCanonicalizeReductionPass();
  registerHloCanonicalizeScatterPass();
  registerHloLegalizeShapeComputationsPass();
  registerHloLegalizeSortPass();
  registerHloLegalizeToArithmeticPass();
  registerHloLegalizeToLinalgPass();
  registerHloLegalizeToMemrefPass();
  registerHloLegalizeToStablehloPass();
  registerLegalizeBroadcastToBroadcastInDimPass();
  registerLegalizeControlFlowPass();
  registerLegalizeCreateTokenToAfterAllPass();
  registerLegalizeCrossReplicaSumToAllReducePass();
  registerLegalizeDotGeneralToDotPass();
  registerLegalizeDotToDotGeneralPass();
  registerLegalizeEinsumToDotGeneralPass();
  registerLegalizeGatherToTorchIndexSelectPass();
  registerLegalizeGeneralDotPass();
  registerLegalizeTanhToApproximationPass();
  registerLegalizeToStandardPass();
  registerLegalizeTorchIndexSelectToGatherPass();
  registerLowerComplexPass();
  registerMergeAssumingOpsPass();
  registerMhloExpandOpsSimplifierPass();
  registerOptimizeMhloPass();
  registerPrepareForExportPass();
  registerRestrictMaxRankPass();
  registerShapeLegalizeToHloPass();
  registerShapeReificationPass();
  registerShapeSimplification();
  registerSinkConstantsToControlFlowPass();
  registerStablehloLegalizeToHloPass();
  registerSymbolicShapeOptimization();
  registerTestInferShapedTypeMethodsPass();
  registerTestMaterializeBroadcastsPass();
  registerTestUnfuseBatchNormPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class BroadcastPropagationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BroadcastPropagationPassBase;

  BroadcastPropagationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastPropagationPassBase(const BroadcastPropagationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BroadcastPropagationPassBase& operator=(const BroadcastPropagationPassBase &) = delete;
  BroadcastPropagationPassBase(BroadcastPropagationPassBase &&) = delete;
  BroadcastPropagationPassBase& operator=(BroadcastPropagationPassBase &&) = delete;
  ~BroadcastPropagationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-broadcast-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-broadcast-propagation"; }

  ::llvm::StringRef getDescription() const override { return "Move dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastPropagationPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastPropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastPropagationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ChloLegalizeToHighLevelMhloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ChloLegalizeToHighLevelMhloPassBase;

  ChloLegalizeToHighLevelMhloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ChloLegalizeToHighLevelMhloPassBase(const ChloLegalizeToHighLevelMhloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ChloLegalizeToHighLevelMhloPassBase& operator=(const ChloLegalizeToHighLevelMhloPassBase &) = delete;
  ChloLegalizeToHighLevelMhloPassBase(ChloLegalizeToHighLevelMhloPassBase &&) = delete;
  ChloLegalizeToHighLevelMhloPassBase& operator=(ChloLegalizeToHighLevelMhloPassBase &&) = delete;
  ~ChloLegalizeToHighLevelMhloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("chlo-legalize-to-high-level-mhlo");
  }
  ::llvm::StringRef getArgument() const override { return "chlo-legalize-to-high-level-mhlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize CHLO's with XLA counterparts, like TopK and Erf."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ChloLegalizeToHighLevelMhloPass");
  }
  ::llvm::StringRef getName() const override { return "ChloLegalizeToHighLevelMhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ChloLegalizeToHighLevelMhloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ChloLegalizeToHloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ChloLegalizeToHloPassBase;

  ChloLegalizeToHloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ChloLegalizeToHloPassBase(const ChloLegalizeToHloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ChloLegalizeToHloPassBase& operator=(const ChloLegalizeToHloPassBase &) = delete;
  ChloLegalizeToHloPassBase(ChloLegalizeToHloPassBase &&) = delete;
  ChloLegalizeToHloPassBase& operator=(ChloLegalizeToHloPassBase &&) = delete;
  ~ChloLegalizeToHloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("chlo-legalize-to-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "chlo-legalize-to-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize CHLO to MHLO with XLA-supported ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ChloLegalizeToHloPass");
  }
  ::llvm::StringRef getName() const override { return "ChloLegalizeToHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<mlir::shape::ShapeDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ChloLegalizeToHloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CollapseElementwiseMapPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = CollapseElementwiseMapPassBase;

  CollapseElementwiseMapPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseElementwiseMapPassBase(const CollapseElementwiseMapPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  CollapseElementwiseMapPassBase& operator=(const CollapseElementwiseMapPassBase &) = delete;
  CollapseElementwiseMapPassBase(CollapseElementwiseMapPassBase &&) = delete;
  CollapseElementwiseMapPassBase& operator=(CollapseElementwiseMapPassBase &&) = delete;
  ~CollapseElementwiseMapPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-collapse-elementwise-map");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-collapse-elementwise-map"; }

  ::llvm::StringRef getDescription() const override { return "Collapse the mhlo.map if the map only has elementwise ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseElementwiseMapPass");
  }
  ::llvm::StringRef getName() const override { return "CollapseElementwiseMapPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseElementwiseMapPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConstraintFusionPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ConstraintFusionPassBase;

  ConstraintFusionPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConstraintFusionPassBase(const ConstraintFusionPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ConstraintFusionPassBase& operator=(const ConstraintFusionPassBase &) = delete;
  ConstraintFusionPassBase(ConstraintFusionPassBase &&) = delete;
  ConstraintFusionPassBase& operator=(ConstraintFusionPassBase &&) = delete;
  ~ConstraintFusionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("constraint-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "constraint-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fuse shape constraints and merge all assuming regions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConstraintFusionPass");
  }
  ::llvm::StringRef getName() const override { return "ConstraintFusionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConstraintFusionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertToSignlessPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertToSignlessPassBase;

  ConvertToSignlessPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToSignlessPassBase(const ConvertToSignlessPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertToSignlessPassBase& operator=(const ConvertToSignlessPassBase &) = delete;
  ConvertToSignlessPassBase(ConvertToSignlessPassBase &&) = delete;
  ConvertToSignlessPassBase& operator=(ConvertToSignlessPassBase &&) = delete;
  ~ConvertToSignlessPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-to-signless");
  }
  ::llvm::StringRef getArgument() const override { return "convert-to-signless"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform the IR to be on signless integers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToSignlessPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToSignlessPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToSignlessPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExpandHloTuplesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExpandHloTuplesPassBase;

  ExpandHloTuplesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandHloTuplesPassBase(const ExpandHloTuplesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExpandHloTuplesPassBase& operator=(const ExpandHloTuplesPassBase &) = delete;
  ExpandHloTuplesPassBase(ExpandHloTuplesPassBase &&) = delete;
  ExpandHloTuplesPassBase& operator=(ExpandHloTuplesPassBase &&) = delete;
  ~ExpandHloTuplesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("expand-hlo-tuples");
  }
  ::llvm::StringRef getArgument() const override { return "expand-hlo-tuples"; }

  ::llvm::StringRef getDescription() const override { return "Expand HLO tuple for the entry function of the module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandHloTuplesPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandHloTuplesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandHloTuplesPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> entry_function_name_{*this, "entry-function", ::llvm::cl::desc("the name of entry function of the module")};
};

template <typename DerivedT>
class FlattenTuplePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = FlattenTuplePassBase;

  FlattenTuplePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenTuplePassBase(const FlattenTuplePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  FlattenTuplePassBase& operator=(const FlattenTuplePassBase &) = delete;
  FlattenTuplePassBase(FlattenTuplePassBase &&) = delete;
  FlattenTuplePassBase& operator=(FlattenTuplePassBase &&) = delete;
  ~FlattenTuplePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-flatten-tuple");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-flatten-tuple"; }

  ::llvm::StringRef getDescription() const override { return "Flatten tuples in operands and results of operators that support both tuple and variadic type."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenTuplePass");
  }
  ::llvm::StringRef getName() const override { return "FlattenTuplePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenTuplePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GroupReductionDimensionsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = GroupReductionDimensionsPassBase;

  GroupReductionDimensionsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GroupReductionDimensionsPassBase(const GroupReductionDimensionsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  GroupReductionDimensionsPassBase& operator=(const GroupReductionDimensionsPassBase &) = delete;
  GroupReductionDimensionsPassBase(GroupReductionDimensionsPassBase &&) = delete;
  GroupReductionDimensionsPassBase& operator=(GroupReductionDimensionsPassBase &&) = delete;
  ~GroupReductionDimensionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("group-reduction-dimensions");
  }
  ::llvm::StringRef getArgument() const override { return "group-reduction-dimensions"; }

  ::llvm::StringRef getDescription() const override { return "Group dimensions of reduction operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GroupReductionDimensionsPass");
  }
  ::llvm::StringRef getName() const override { return "GroupReductionDimensionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GroupReductionDimensionsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> prefer_columns_reductions_{*this, "prefer-columns-reductions", ::llvm::cl::desc("When simplifying reductions, prefer to use column reductions over row reductions."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class HloCanonicalizeDotPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeDotPassBase;

  HloCanonicalizeDotPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeDotPassBase(const HloCanonicalizeDotPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeDotPassBase& operator=(const HloCanonicalizeDotPassBase &) = delete;
  HloCanonicalizeDotPassBase(HloCanonicalizeDotPassBase &&) = delete;
  HloCanonicalizeDotPassBase& operator=(HloCanonicalizeDotPassBase &&) = delete;
  ~HloCanonicalizeDotPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-dot");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-dot"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites dot operands that contain unit dimension."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeDotPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeDotPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeDotPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloCanonicalizeGatherPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeGatherPassBase;

  HloCanonicalizeGatherPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeGatherPassBase(const HloCanonicalizeGatherPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeGatherPassBase& operator=(const HloCanonicalizeGatherPassBase &) = delete;
  HloCanonicalizeGatherPassBase(HloCanonicalizeGatherPassBase &&) = delete;
  HloCanonicalizeGatherPassBase& operator=(HloCanonicalizeGatherPassBase &&) = delete;
  ~HloCanonicalizeGatherPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-gather");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-gather"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites gather into transposes, reshapes and a simple gather."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeGatherPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeGatherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeGatherPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloCanonicalizeReductionPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeReductionPassBase;

  HloCanonicalizeReductionPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeReductionPassBase(const HloCanonicalizeReductionPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeReductionPassBase& operator=(const HloCanonicalizeReductionPassBase &) = delete;
  HloCanonicalizeReductionPassBase(HloCanonicalizeReductionPassBase &&) = delete;
  HloCanonicalizeReductionPassBase& operator=(HloCanonicalizeReductionPassBase &&) = delete;
  ~HloCanonicalizeReductionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-reduction");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-reduction"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize reduction ops to be suitable for codegen."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeReductionPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeReductionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeReductionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloCanonicalizeScatterPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloCanonicalizeScatterPassBase;

  HloCanonicalizeScatterPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloCanonicalizeScatterPassBase(const HloCanonicalizeScatterPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloCanonicalizeScatterPassBase& operator=(const HloCanonicalizeScatterPassBase &) = delete;
  HloCanonicalizeScatterPassBase(HloCanonicalizeScatterPassBase &&) = delete;
  HloCanonicalizeScatterPassBase& operator=(HloCanonicalizeScatterPassBase &&) = delete;
  ~HloCanonicalizeScatterPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-canonicalize-scatter");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-canonicalize-scatter"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites scatter into transposes, reshapes and a simple scatter."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloCanonicalizeScatterPass");
  }
  ::llvm::StringRef getName() const override { return "HloCanonicalizeScatterPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloCanonicalizeScatterPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloLegalizeShapeComputationsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloLegalizeShapeComputationsPassBase;

  HloLegalizeShapeComputationsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeShapeComputationsPassBase(const HloLegalizeShapeComputationsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloLegalizeShapeComputationsPassBase& operator=(const HloLegalizeShapeComputationsPassBase &) = delete;
  HloLegalizeShapeComputationsPassBase(HloLegalizeShapeComputationsPassBase &&) = delete;
  HloLegalizeShapeComputationsPassBase& operator=(HloLegalizeShapeComputationsPassBase &&) = delete;
  ~HloLegalizeShapeComputationsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-shape-computations");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-shape-computations"; }

  ::llvm::StringRef getDescription() const override { return "Legalize HLOs shape operations to core-mlir operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeShapeComputationsPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeShapeComputationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeShapeComputationsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloLegalizeSortPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloLegalizeSortPassBase;

  HloLegalizeSortPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeSortPassBase(const HloLegalizeSortPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloLegalizeSortPassBase& operator=(const HloLegalizeSortPassBase &) = delete;
  HloLegalizeSortPassBase(HloLegalizeSortPassBase &&) = delete;
  HloLegalizeSortPassBase& operator=(HloLegalizeSortPassBase &&) = delete;
  ~HloLegalizeSortPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-sort");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-sort"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from MHLO sort to SCF control flow."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeSortPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeSortPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeSortPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloLegalizeToArithmeticPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = HloLegalizeToArithmeticPassBase;

  HloLegalizeToArithmeticPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToArithmeticPassBase(const HloLegalizeToArithmeticPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  HloLegalizeToArithmeticPassBase& operator=(const HloLegalizeToArithmeticPassBase &) = delete;
  HloLegalizeToArithmeticPassBase(HloLegalizeToArithmeticPassBase &&) = delete;
  HloLegalizeToArithmeticPassBase& operator=(HloLegalizeToArithmeticPassBase &&) = delete;
  ~HloLegalizeToArithmeticPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-arithmetic");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-arithmetic"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO dialect to arithmetic dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToArithmeticPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToArithmeticPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToArithmeticPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloLegalizeToLinalgPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = HloLegalizeToLinalgPassBase;

  HloLegalizeToLinalgPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToLinalgPassBase(const HloLegalizeToLinalgPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  HloLegalizeToLinalgPassBase& operator=(const HloLegalizeToLinalgPassBase &) = delete;
  HloLegalizeToLinalgPassBase(HloLegalizeToLinalgPassBase &&) = delete;
  HloLegalizeToLinalgPassBase& operator=(HloLegalizeToLinalgPassBase &&) = delete;
  ~HloLegalizeToLinalgPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO dialect to Linalg dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToLinalgPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToLinalgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToLinalgPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enablePrimitiveOps{*this, "enable-primitive-ops", ::llvm::cl::desc("Lower to primitive Linalg ops (map, reduce and transpose) when possible, instead of linalg.generic"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class HloLegalizeToMemrefPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = HloLegalizeToMemrefPassBase;

  HloLegalizeToMemrefPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToMemrefPassBase(const HloLegalizeToMemrefPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  HloLegalizeToMemrefPassBase& operator=(const HloLegalizeToMemrefPassBase &) = delete;
  HloLegalizeToMemrefPassBase(HloLegalizeToMemrefPassBase &&) = delete;
  HloLegalizeToMemrefPassBase& operator=(HloLegalizeToMemrefPassBase &&) = delete;
  ~HloLegalizeToMemrefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-memref");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-memref"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO dialect to memref dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToMemrefPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToMemrefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToMemrefPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HloLegalizeToStablehloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = HloLegalizeToStablehloPassBase;

  HloLegalizeToStablehloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToStablehloPassBase(const HloLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  HloLegalizeToStablehloPassBase& operator=(const HloLegalizeToStablehloPassBase &) = delete;
  HloLegalizeToStablehloPassBase(HloLegalizeToStablehloPassBase &&) = delete;
  HloLegalizeToStablehloPassBase& operator=(HloLegalizeToStablehloPassBase &&) = delete;
  ~HloLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize HLO to StableHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HloLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "HloLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HloLegalizeToStablehloPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> allow_experimental_features_{*this, "allow-experimental-features", ::llvm::cl::desc("Allow legalization of experimental MHLO features via StableHLO custom_call"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class LegalizeBroadcastToBroadcastInDimPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeBroadcastToBroadcastInDimPassBase;

  LegalizeBroadcastToBroadcastInDimPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeBroadcastToBroadcastInDimPassBase(const LegalizeBroadcastToBroadcastInDimPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeBroadcastToBroadcastInDimPassBase& operator=(const LegalizeBroadcastToBroadcastInDimPassBase &) = delete;
  LegalizeBroadcastToBroadcastInDimPassBase(LegalizeBroadcastToBroadcastInDimPassBase &&) = delete;
  LegalizeBroadcastToBroadcastInDimPassBase& operator=(LegalizeBroadcastToBroadcastInDimPassBase &&) = delete;
  ~LegalizeBroadcastToBroadcastInDimPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-broadcast-to-broadcast-in-dim");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-broadcast-to-broadcast-in-dim"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes broadcast ops to broadcast_in_dim ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeBroadcastToBroadcastInDimPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeBroadcastToBroadcastInDimPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeBroadcastToBroadcastInDimPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeControlFlowPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeControlFlowPassBase;

  LegalizeControlFlowPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeControlFlowPassBase(const LegalizeControlFlowPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeControlFlowPassBase& operator=(const LegalizeControlFlowPassBase &) = delete;
  LegalizeControlFlowPassBase(LegalizeControlFlowPassBase &&) = delete;
  LegalizeControlFlowPassBase& operator=(LegalizeControlFlowPassBase &&) = delete;
  ~LegalizeControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from MHLO control flow to SCF control flow."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeControlFlowPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeCreateTokenToAfterAllPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeCreateTokenToAfterAllPassBase;

  LegalizeCreateTokenToAfterAllPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeCreateTokenToAfterAllPassBase(const LegalizeCreateTokenToAfterAllPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeCreateTokenToAfterAllPassBase& operator=(const LegalizeCreateTokenToAfterAllPassBase &) = delete;
  LegalizeCreateTokenToAfterAllPassBase(LegalizeCreateTokenToAfterAllPassBase &&) = delete;
  LegalizeCreateTokenToAfterAllPassBase& operator=(LegalizeCreateTokenToAfterAllPassBase &&) = delete;
  ~LegalizeCreateTokenToAfterAllPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-create-token-to-after-all");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-create-token-to-after-all"; }

  ::llvm::StringRef getDescription() const override { return "Legalize create_token ops to after_all ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeCreateTokenToAfterAllPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeCreateTokenToAfterAllPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeCreateTokenToAfterAllPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeCrossReplicaSumToAllReducePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeCrossReplicaSumToAllReducePassBase;

  LegalizeCrossReplicaSumToAllReducePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeCrossReplicaSumToAllReducePassBase(const LegalizeCrossReplicaSumToAllReducePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeCrossReplicaSumToAllReducePassBase& operator=(const LegalizeCrossReplicaSumToAllReducePassBase &) = delete;
  LegalizeCrossReplicaSumToAllReducePassBase(LegalizeCrossReplicaSumToAllReducePassBase &&) = delete;
  LegalizeCrossReplicaSumToAllReducePassBase& operator=(LegalizeCrossReplicaSumToAllReducePassBase &&) = delete;
  ~LegalizeCrossReplicaSumToAllReducePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-cross-replica-sum-to-all-reduce");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-cross-replica-sum-to-all-reduce"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes cross-replica-sum ops to all_reduce ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeCrossReplicaSumToAllReducePass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeCrossReplicaSumToAllReducePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeCrossReplicaSumToAllReducePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeDotGeneralToDotPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeDotGeneralToDotPassBase;

  LegalizeDotGeneralToDotPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeDotGeneralToDotPassBase(const LegalizeDotGeneralToDotPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeDotGeneralToDotPassBase& operator=(const LegalizeDotGeneralToDotPassBase &) = delete;
  LegalizeDotGeneralToDotPassBase(LegalizeDotGeneralToDotPassBase &&) = delete;
  LegalizeDotGeneralToDotPassBase& operator=(LegalizeDotGeneralToDotPassBase &&) = delete;
  ~LegalizeDotGeneralToDotPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-dot-general-to-dot");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-dot-general-to-dot"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes dot_general ops to dot ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeDotGeneralToDotPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeDotGeneralToDotPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeDotGeneralToDotPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeDotToDotGeneralPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeDotToDotGeneralPassBase;

  LegalizeDotToDotGeneralPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeDotToDotGeneralPassBase(const LegalizeDotToDotGeneralPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeDotToDotGeneralPassBase& operator=(const LegalizeDotToDotGeneralPassBase &) = delete;
  LegalizeDotToDotGeneralPassBase(LegalizeDotToDotGeneralPassBase &&) = delete;
  LegalizeDotToDotGeneralPassBase& operator=(LegalizeDotToDotGeneralPassBase &&) = delete;
  ~LegalizeDotToDotGeneralPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-dot-to-dot-general");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-dot-to-dot-general"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes dot ops to dot_general ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeDotToDotGeneralPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeDotToDotGeneralPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeDotToDotGeneralPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeEinsumToDotGeneralPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeEinsumToDotGeneralPassBase;

  LegalizeEinsumToDotGeneralPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeEinsumToDotGeneralPassBase(const LegalizeEinsumToDotGeneralPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeEinsumToDotGeneralPassBase& operator=(const LegalizeEinsumToDotGeneralPassBase &) = delete;
  LegalizeEinsumToDotGeneralPassBase(LegalizeEinsumToDotGeneralPassBase &&) = delete;
  LegalizeEinsumToDotGeneralPassBase& operator=(LegalizeEinsumToDotGeneralPassBase &&) = delete;
  ~LegalizeEinsumToDotGeneralPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-einsum-to-dot-general");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-einsum-to-dot-general"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes einsum ops to dot_general ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeEinsumToDotGeneralPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeEinsumToDotGeneralPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeEinsumToDotGeneralPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeGatherToTorchIndexSelectPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeGatherToTorchIndexSelectPassBase;

  LegalizeGatherToTorchIndexSelectPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeGatherToTorchIndexSelectPassBase(const LegalizeGatherToTorchIndexSelectPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeGatherToTorchIndexSelectPassBase& operator=(const LegalizeGatherToTorchIndexSelectPassBase &) = delete;
  LegalizeGatherToTorchIndexSelectPassBase(LegalizeGatherToTorchIndexSelectPassBase &&) = delete;
  LegalizeGatherToTorchIndexSelectPassBase& operator=(LegalizeGatherToTorchIndexSelectPassBase &&) = delete;
  ~LegalizeGatherToTorchIndexSelectPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-gather-to-torch-index-select");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-gather-to-torch-index-select"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes gathers to a torch index select."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeGatherToTorchIndexSelectPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeGatherToTorchIndexSelectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeGatherToTorchIndexSelectPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeGeneralDotPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeGeneralDotPassBase;

  LegalizeGeneralDotPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeGeneralDotPassBase(const LegalizeGeneralDotPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeGeneralDotPassBase& operator=(const LegalizeGeneralDotPassBase &) = delete;
  LegalizeGeneralDotPassBase(LegalizeGeneralDotPassBase &&) = delete;
  LegalizeGeneralDotPassBase& operator=(LegalizeGeneralDotPassBase &&) = delete;
  ~LegalizeGeneralDotPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-lower-general-dot");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-lower-general-dot"; }

  ::llvm::StringRef getDescription() const override { return "Tests lowering general dot to a non-batched dot when possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeGeneralDotPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeGeneralDotPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeGeneralDotPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeTanhToApproximationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeTanhToApproximationPassBase;

  LegalizeTanhToApproximationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTanhToApproximationPassBase(const LegalizeTanhToApproximationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeTanhToApproximationPassBase& operator=(const LegalizeTanhToApproximationPassBase &) = delete;
  LegalizeTanhToApproximationPassBase(LegalizeTanhToApproximationPassBase &&) = delete;
  LegalizeTanhToApproximationPassBase& operator=(LegalizeTanhToApproximationPassBase &&) = delete;
  ~LegalizeTanhToApproximationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-trigonometric-to-approximation");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-trigonometric-to-approximation"; }

  ::llvm::StringRef getDescription() const override { return "Legalize trigonometric operations from standard dialect to an approximation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTanhToApproximationPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTanhToApproximationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTanhToApproximationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeToStandardPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeToStandardPassBase;

  LegalizeToStandardPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeToStandardPassBase(const LegalizeToStandardPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeToStandardPassBase& operator=(const LegalizeToStandardPassBase &) = delete;
  LegalizeToStandardPassBase(LegalizeToStandardPassBase &&) = delete;
  LegalizeToStandardPassBase& operator=(LegalizeToStandardPassBase &&) = delete;
  ~LegalizeToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-to-std");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-to-std"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from MHLO dialect to standard dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeToStandardPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeTorchIndexSelectToGatherPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeTorchIndexSelectToGatherPassBase;

  LegalizeTorchIndexSelectToGatherPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTorchIndexSelectToGatherPassBase(const LegalizeTorchIndexSelectToGatherPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LegalizeTorchIndexSelectToGatherPassBase& operator=(const LegalizeTorchIndexSelectToGatherPassBase &) = delete;
  LegalizeTorchIndexSelectToGatherPassBase(LegalizeTorchIndexSelectToGatherPassBase &&) = delete;
  LegalizeTorchIndexSelectToGatherPassBase& operator=(LegalizeTorchIndexSelectToGatherPassBase &&) = delete;
  ~LegalizeTorchIndexSelectToGatherPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-legalize-torch-index-select-to-gather");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-torch-index-select-to-gather"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes torch index select to a gather."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTorchIndexSelectToGatherPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTorchIndexSelectToGatherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTorchIndexSelectToGatherPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerComplexPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LowerComplexPassBase;

  LowerComplexPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerComplexPassBase(const LowerComplexPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  LowerComplexPassBase& operator=(const LowerComplexPassBase &) = delete;
  LowerComplexPassBase(LowerComplexPassBase &&) = delete;
  LowerComplexPassBase& operator=(LowerComplexPassBase &&) = delete;
  ~LowerComplexPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-lower-complex");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-lower-complex"; }

  ::llvm::StringRef getDescription() const override { return "Lower complex operations into non-complex operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerComplexPass");
  }
  ::llvm::StringRef getName() const override { return "LowerComplexPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerComplexPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergeAssumingOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MergeAssumingOpsPassBase;

  MergeAssumingOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeAssumingOpsPassBase(const MergeAssumingOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  MergeAssumingOpsPassBase& operator=(const MergeAssumingOpsPassBase &) = delete;
  MergeAssumingOpsPassBase(MergeAssumingOpsPassBase &&) = delete;
  MergeAssumingOpsPassBase& operator=(MergeAssumingOpsPassBase &&) = delete;
  ~MergeAssumingOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-merge-assuming-ops");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-merge-assuming-ops"; }

  ::llvm::StringRef getDescription() const override { return "Prepare moving dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeAssumingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeAssumingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeAssumingOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MhloExpandOpsSimplifierPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MhloExpandOpsSimplifierPassBase;

  MhloExpandOpsSimplifierPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MhloExpandOpsSimplifierPassBase(const MhloExpandOpsSimplifierPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  MhloExpandOpsSimplifierPassBase& operator=(const MhloExpandOpsSimplifierPassBase &) = delete;
  MhloExpandOpsSimplifierPassBase(MhloExpandOpsSimplifierPassBase &&) = delete;
  MhloExpandOpsSimplifierPassBase& operator=(MhloExpandOpsSimplifierPassBase &&) = delete;
  ~MhloExpandOpsSimplifierPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-expand-ops-simplifier");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-expand-ops-simplifier"; }

  ::llvm::StringRef getDescription() const override { return "Expand feature rich mhlo ops into a set of simpler mhlo ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MhloExpandOpsSimplifierPass");
  }
  ::llvm::StringRef getName() const override { return "MhloExpandOpsSimplifierPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MhloExpandOpsSimplifierPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OptimizeMhloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = OptimizeMhloPassBase;

  OptimizeMhloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeMhloPassBase(const OptimizeMhloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  OptimizeMhloPassBase& operator=(const OptimizeMhloPassBase &) = delete;
  OptimizeMhloPassBase(OptimizeMhloPassBase &&) = delete;
  OptimizeMhloPassBase& operator=(OptimizeMhloPassBase &&) = delete;
  ~OptimizeMhloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-optimize");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-optimize"; }

  ::llvm::StringRef getDescription() const override { return "Run optional HLO optimizations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeMhloPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeMhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeMhloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PrepareForExportPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PrepareForExportPassBase;

  PrepareForExportPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrepareForExportPassBase(const PrepareForExportPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PrepareForExportPassBase& operator=(const PrepareForExportPassBase &) = delete;
  PrepareForExportPassBase(PrepareForExportPassBase &&) = delete;
  PrepareForExportPassBase& operator=(PrepareForExportPassBase &&) = delete;
  ~PrepareForExportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-prepare-for-export");
  }
  ::llvm::StringRef getArgument() const override { return "xla-prepare-for-export"; }

  ::llvm::StringRef getDescription() const override { return "Prepare for XLA export"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrepareForExportPass");
  }
  ::llvm::StringRef getName() const override { return "PrepareForExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrepareForExportPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RestrictMaxRankPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = RestrictMaxRankPassBase;

  RestrictMaxRankPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RestrictMaxRankPassBase(const RestrictMaxRankPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  RestrictMaxRankPassBase& operator=(const RestrictMaxRankPassBase &) = delete;
  RestrictMaxRankPassBase(RestrictMaxRankPassBase &&) = delete;
  RestrictMaxRankPassBase& operator=(RestrictMaxRankPassBase &&) = delete;
  ~RestrictMaxRankPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-restrict-max-rank");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-restrict-max-rank"; }

  ::llvm::StringRef getDescription() const override { return "Restrict maximum rank of any of the intermediate tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RestrictMaxRankPass");
  }
  ::llvm::StringRef getName() const override { return "RestrictMaxRankPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RestrictMaxRankPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShapeLegalizeToHloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ShapeLegalizeToHloPassBase;

  ShapeLegalizeToHloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeLegalizeToHloPassBase(const ShapeLegalizeToHloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ShapeLegalizeToHloPassBase& operator=(const ShapeLegalizeToHloPassBase &) = delete;
  ShapeLegalizeToHloPassBase(ShapeLegalizeToHloPassBase &&) = delete;
  ShapeLegalizeToHloPassBase& operator=(ShapeLegalizeToHloPassBase &&) = delete;
  ~ShapeLegalizeToHloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-legalize-to-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "shape-legalize-to-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize shape-related ops to HLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeLegalizeToHloPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeLegalizeToHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeLegalizeToHloPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> legalize_constraints_{*this, "legalize-constraints", ::llvm::cl::desc("Whether to legalize Cstr Ops to shape_assertion custom_call"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ShapeReificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ShapeReificationPassBase;

  ShapeReificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeReificationPassBase(const ShapeReificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ShapeReificationPassBase& operator=(const ShapeReificationPassBase &) = delete;
  ShapeReificationPassBase(ShapeReificationPassBase &&) = delete;
  ShapeReificationPassBase& operator=(ShapeReificationPassBase &&) = delete;
  ~ShapeReificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-reification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-reification"; }

  ::llvm::StringRef getDescription() const override { return "Iteratively reify all shape computations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeReificationPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeReificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeReificationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShapeSimplificationBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ShapeSimplificationBase;

  ShapeSimplificationBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeSimplificationBase(const ShapeSimplificationBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ShapeSimplificationBase& operator=(const ShapeSimplificationBase &) = delete;
  ShapeSimplificationBase(ShapeSimplificationBase &&) = delete;
  ShapeSimplificationBase& operator=(ShapeSimplificationBase &&) = delete;
  ~ShapeSimplificationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Simplify shape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeSimplification");
  }
  ::llvm::StringRef getName() const override { return "ShapeSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeSimplificationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SinkConstantsToControlFlowPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = SinkConstantsToControlFlowPassBase;

  SinkConstantsToControlFlowPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SinkConstantsToControlFlowPassBase(const SinkConstantsToControlFlowPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  SinkConstantsToControlFlowPassBase& operator=(const SinkConstantsToControlFlowPassBase &) = delete;
  SinkConstantsToControlFlowPassBase(SinkConstantsToControlFlowPassBase &&) = delete;
  SinkConstantsToControlFlowPassBase& operator=(SinkConstantsToControlFlowPassBase &&) = delete;
  ~SinkConstantsToControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-sink-constants-to-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-sink-constants-to-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Sink constants implicitly captured in control flow regions. This is necessary to export to XLA."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SinkConstantsToControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "SinkConstantsToControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SinkConstantsToControlFlowPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StablehloLegalizeToHloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloLegalizeToHloPassBase;

  StablehloLegalizeToHloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeToHloPassBase(const StablehloLegalizeToHloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloLegalizeToHloPassBase& operator=(const StablehloLegalizeToHloPassBase &) = delete;
  StablehloLegalizeToHloPassBase(StablehloLegalizeToHloPassBase &&) = delete;
  StablehloLegalizeToHloPassBase& operator=(StablehloLegalizeToHloPassBase &&) = delete;
  ~StablehloLegalizeToHloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-to-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-to-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize StableHLO to HLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeToHloPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeToHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeToHloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SymbolicShapeOptimizationBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = SymbolicShapeOptimizationBase;

  SymbolicShapeOptimizationBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SymbolicShapeOptimizationBase(const SymbolicShapeOptimizationBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  SymbolicShapeOptimizationBase& operator=(const SymbolicShapeOptimizationBase &) = delete;
  SymbolicShapeOptimizationBase(SymbolicShapeOptimizationBase &&) = delete;
  SymbolicShapeOptimizationBase& operator=(SymbolicShapeOptimizationBase &&) = delete;
  ~SymbolicShapeOptimizationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("symbolic-shape-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "symbolic-shape-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Analyzes shapes and performs shape-related optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SymbolicShapeOptimization");
  }
  ::llvm::StringRef getName() const override { return "SymbolicShapeOptimization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SymbolicShapeOptimizationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TestInferShapedTypeMethodsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestInferShapedTypeMethodsPassBase;

  TestInferShapedTypeMethodsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestInferShapedTypeMethodsPassBase(const TestInferShapedTypeMethodsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TestInferShapedTypeMethodsPassBase& operator=(const TestInferShapedTypeMethodsPassBase &) = delete;
  TestInferShapedTypeMethodsPassBase(TestInferShapedTypeMethodsPassBase &&) = delete;
  TestInferShapedTypeMethodsPassBase& operator=(TestInferShapedTypeMethodsPassBase &&) = delete;
  ~TestInferShapedTypeMethodsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-infer-shaped-type-methods");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-infer-shaped-type-methods"; }

  ::llvm::StringRef getDescription() const override { return "Uses test ops to invoke InferShapedTypeOpInterface methods."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestInferShapedTypeMethodsPass");
  }
  ::llvm::StringRef getName() const override { return "TestInferShapedTypeMethodsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestInferShapedTypeMethodsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TestMaterializeBroadcastsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestMaterializeBroadcastsPassBase;

  TestMaterializeBroadcastsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestMaterializeBroadcastsPassBase(const TestMaterializeBroadcastsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TestMaterializeBroadcastsPassBase& operator=(const TestMaterializeBroadcastsPassBase &) = delete;
  TestMaterializeBroadcastsPassBase(TestMaterializeBroadcastsPassBase &&) = delete;
  TestMaterializeBroadcastsPassBase& operator=(TestMaterializeBroadcastsPassBase &&) = delete;
  ~TestMaterializeBroadcastsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-materialize-broadcasts");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-materialize-broadcasts"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for materializing 'broadcast_dimensions' attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestMaterializeBroadcastsPass");
  }
  ::llvm::StringRef getName() const override { return "TestMaterializeBroadcastsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestMaterializeBroadcastsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TestUnfuseBatchNormPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestUnfuseBatchNormPassBase;

  TestUnfuseBatchNormPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestUnfuseBatchNormPassBase(const TestUnfuseBatchNormPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TestUnfuseBatchNormPassBase& operator=(const TestUnfuseBatchNormPassBase &) = delete;
  TestUnfuseBatchNormPassBase(TestUnfuseBatchNormPassBase &&) = delete;
  TestUnfuseBatchNormPassBase& operator=(TestUnfuseBatchNormPassBase &&) = delete;
  ~TestUnfuseBatchNormPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-test-unfuse-batch-norm");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-test-unfuse-batch-norm"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for materializing 'broadcast_dimensions' attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestUnfuseBatchNormPass");
  }
  ::llvm::StringRef getName() const override { return "TestUnfuseBatchNormPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<shape::ShapeDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestUnfuseBatchNormPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
