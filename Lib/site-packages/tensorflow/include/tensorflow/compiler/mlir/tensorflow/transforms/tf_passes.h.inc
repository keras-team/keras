/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#define GEN_PASS_DECL_BREAKUPISLANDSPASS
#define GEN_PASS_DECL_BROADCASTFOLDPASS
#define GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#define GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#define GEN_PASS_DECL_CLUSTERFORMATIONPASS
#define GEN_PASS_DECL_CLUSTEROUTLININGPASS
#define GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#define GEN_PASS_DECL_COLOCATETPUCOPYWITHDYNAMICSHAPEPASS
#define GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#define GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#define GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#define GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#define GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#define GEN_PASS_DECL_DECOMPOSEOPTIONALSPASS
#define GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#define GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#define GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#define GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#define GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#define GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#define GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#define GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
#define GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#define GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#define GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#define GEN_PASS_DECL_EXTRACTTPUCOPYWITHDYNAMICSHAPEOPPASS
#define GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#define GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#define GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#define GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#define GEN_PASS_DECL_GROUPBYDIALECTPASS
#define GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#define GEN_PASS_DECL_HOISTLOOPINVARIANTPASS
#define GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#define GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
#define GEN_PASS_DECL_LAUNCHOUTLININGPASS
#define GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
#define GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#define GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#define GEN_PASS_DECL_LOWERQUANTIZEDPASS
#define GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#define GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#define GEN_PASS_DECL_MERGECONTROLFLOWPASS
#define GEN_PASS_DECL_MOVETPUCOMPILETOFRONTPASS
#define GEN_PASS_DECL_MOVETRANSPOSESPASS
#define GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#define GEN_PASS_DECL_ORDERBYDIALECTPASS
#define GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
#define GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#define GEN_PASS_DECL_PRINTPASS
#define GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
#define GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#define GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#define GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#define GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#define GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#define GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#define GEN_PASS_DECL_REPLICATETENSORLISTINITOPSPASS
#define GEN_PASS_DECL_REPLICATETOISLANDPASS
#define GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#define GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#define GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
#define GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#define GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#define GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#define GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#define GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#define GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#define GEN_PASS_DECL_TPUANNOTATEDYNAMICSHAPEINPUTSPASS
#define GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#define GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#define GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#define GEN_PASS_DECL_TPUCOLOCATESPLITSPASS
#define GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#define GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#define GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#define GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#define GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#define GEN_PASS_DECL_TPUPARTITIONEDOPCONVERSIONPASS
#define GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#define GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#define GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#define GEN_PASS_DECL_TPUSPACETODEPTHPASS
#define GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#define GEN_PASS_DECL_TPUVALIDATEINPUTSPASS
#define GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#define GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#define GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#define GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
#define GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#define GEN_PASS_DECL_TENSORFLOWGPUFUSION
#define GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#define GEN_PASS_DECL_TRANSFORMEINSUMPASS
#define GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#define GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#define GEN_PASS_DECL_XLACALLMODULEDESERIALIZATIONPASS
#define GEN_PASS_DECL_XLACALLMODULESERIALIZATIONPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// BatchMatMulToEinsumPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#undef GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#endif // GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#ifdef GEN_PASS_DEF_BATCHMATMULTOEINSUMPASS
namespace impl {

template <typename DerivedT>
class BatchMatMulToEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BatchMatMulToEinsumPassBase;

  BatchMatMulToEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BatchMatMulToEinsumPassBase(const BatchMatMulToEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BatchMatMulToEinsumPassBase& operator=(const BatchMatMulToEinsumPassBase &) = delete;
  BatchMatMulToEinsumPassBase(BatchMatMulToEinsumPassBase &&) = delete;
  BatchMatMulToEinsumPassBase& operator=(BatchMatMulToEinsumPassBase &&) = delete;
  ~BatchMatMulToEinsumPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-batch-matmul-to-tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-batch-matmul-to-tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Replace TF BatchMatMul op by TF Einsum op."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BatchMatMulToEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "BatchMatMulToEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BatchMatMulToEinsumPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BATCHMATMULTOEINSUMPASS
#endif // GEN_PASS_DEF_BATCHMATMULTOEINSUMPASS

//===----------------------------------------------------------------------===//
// BreakUpIslandsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BREAKUPISLANDSPASS
#undef GEN_PASS_DECL_BREAKUPISLANDSPASS
#endif // GEN_PASS_DECL_BREAKUPISLANDSPASS
#ifdef GEN_PASS_DEF_BREAKUPISLANDSPASS
namespace impl {

template <typename DerivedT>
class BreakUpIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BreakUpIslandsPassBase;

  BreakUpIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BreakUpIslandsPassBase(const BreakUpIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BreakUpIslandsPassBase& operator=(const BreakUpIslandsPassBase &) = delete;
  BreakUpIslandsPassBase(BreakUpIslandsPassBase &&) = delete;
  BreakUpIslandsPassBase& operator=(BreakUpIslandsPassBase &&) = delete;
  ~BreakUpIslandsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-break-up-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-break-up-islands"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BreakUpIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "BreakUpIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BreakUpIslandsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BREAKUPISLANDSPASS
#endif // GEN_PASS_DEF_BREAKUPISLANDSPASS

//===----------------------------------------------------------------------===//
// BroadcastFoldPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BROADCASTFOLDPASS
#undef GEN_PASS_DECL_BROADCASTFOLDPASS
#endif // GEN_PASS_DECL_BROADCASTFOLDPASS
#ifdef GEN_PASS_DEF_BROADCASTFOLDPASS
namespace impl {

template <typename DerivedT>
class BroadcastFoldPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BroadcastFoldPassBase;

  BroadcastFoldPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastFoldPassBase(const BroadcastFoldPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BroadcastFoldPassBase& operator=(const BroadcastFoldPassBase &) = delete;
  BroadcastFoldPassBase(BroadcastFoldPassBase &&) = delete;
  BroadcastFoldPassBase& operator=(BroadcastFoldPassBase &&) = delete;
  ~BroadcastFoldPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-broadcast-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tf-broadcast-fold"; }

  ::llvm::StringRef getDescription() const override { return "Fold explicit broadcasts into the following operations if they support implicit broadcasting on their operand."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastFoldPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastFoldPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BROADCASTFOLDPASS
#endif // GEN_PASS_DEF_BROADCASTFOLDPASS

//===----------------------------------------------------------------------===//
// CanonicalizeCompileAndReplicateAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#undef GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#ifdef GEN_PASS_DEF_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class CanonicalizeCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CanonicalizeCompileAndReplicateAttributesPassBase;

  CanonicalizeCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CanonicalizeCompileAndReplicateAttributesPassBase(const CanonicalizeCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  CanonicalizeCompileAndReplicateAttributesPassBase& operator=(const CanonicalizeCompileAndReplicateAttributesPassBase &) = delete;
  CanonicalizeCompileAndReplicateAttributesPassBase(CanonicalizeCompileAndReplicateAttributesPassBase &&) = delete;
  CanonicalizeCompileAndReplicateAttributesPassBase& operator=(CanonicalizeCompileAndReplicateAttributesPassBase &&) = delete;
  ~CanonicalizeCompileAndReplicateAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-canonicalize-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-canonicalize-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize compilation and replication attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CanonicalizeCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "CanonicalizeCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CanonicalizeCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DEF_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// ClusterConstantSinkingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#undef GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#endif // GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#ifdef GEN_PASS_DEF_CLUSTERCONSTANTSINKINGPASS
namespace impl {

template <typename DerivedT>
class ClusterConstantSinkingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterConstantSinkingPassBase;

  ClusterConstantSinkingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterConstantSinkingPassBase(const ClusterConstantSinkingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ClusterConstantSinkingPassBase& operator=(const ClusterConstantSinkingPassBase &) = delete;
  ClusterConstantSinkingPassBase(ClusterConstantSinkingPassBase &&) = delete;
  ClusterConstantSinkingPassBase& operator=(ClusterConstantSinkingPassBase &&) = delete;
  ~ClusterConstantSinkingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-constant-sinking");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-constant-sinking"; }

  ::llvm::StringRef getDescription() const override { return "Sinks constants implicitly captured in a tf_device.cluster region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterConstantSinkingPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterConstantSinkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterConstantSinkingPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTERCONSTANTSINKINGPASS
#endif // GEN_PASS_DEF_CLUSTERCONSTANTSINKINGPASS

//===----------------------------------------------------------------------===//
// ClusterFormationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTERFORMATIONPASS
#undef GEN_PASS_DECL_CLUSTERFORMATIONPASS
#endif // GEN_PASS_DECL_CLUSTERFORMATIONPASS
#ifdef GEN_PASS_DEF_CLUSTERFORMATIONPASS
namespace impl {

template <typename DerivedT>
class ClusterFormationPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ClusterFormationPassBase;

  ClusterFormationPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterFormationPassBase(const ClusterFormationPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ClusterFormationPassBase& operator=(const ClusterFormationPassBase &) = delete;
  ClusterFormationPassBase(ClusterFormationPassBase &&) = delete;
  ClusterFormationPassBase& operator=(ClusterFormationPassBase &&) = delete;
  ~ClusterFormationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Form clusters from instructions assigned to same device"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterFormationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTERFORMATIONPASS
#endif // GEN_PASS_DEF_CLUSTERFORMATIONPASS

//===----------------------------------------------------------------------===//
// ClusterOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTEROUTLININGPASS
#undef GEN_PASS_DECL_CLUSTEROUTLININGPASS
#endif // GEN_PASS_DECL_CLUSTEROUTLININGPASS
#ifdef GEN_PASS_DEF_CLUSTEROUTLININGPASS
namespace impl {

template <typename DerivedT>
class ClusterOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterOutliningPassBase;

  ClusterOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterOutliningPassBase(const ClusterOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ClusterOutliningPassBase& operator=(const ClusterOutliningPassBase &) = delete;
  ClusterOutliningPassBase(ClusterOutliningPassBase &&) = delete;
  ClusterOutliningPassBase& operator=(ClusterOutliningPassBase &&) = delete;
  ~ClusterOutliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.cluster operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterOutliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTEROUTLININGPASS
#endif // GEN_PASS_DEF_CLUSTEROUTLININGPASS

//===----------------------------------------------------------------------===//
// ClusterTFOpsByHostPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#undef GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#endif // GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#ifdef GEN_PASS_DEF_CLUSTERTFOPSBYHOSTPASS
namespace impl {

template <typename DerivedT>
class ClusterTFOpsByHostPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterTFOpsByHostPassBase;

  ClusterTFOpsByHostPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterTFOpsByHostPassBase(const ClusterTFOpsByHostPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ClusterTFOpsByHostPassBase& operator=(const ClusterTFOpsByHostPassBase &) = delete;
  ClusterTFOpsByHostPassBase(ClusterTFOpsByHostPassBase &&) = delete;
  ClusterTFOpsByHostPassBase& operator=(ClusterTFOpsByHostPassBase &&) = delete;
  ~ClusterTFOpsByHostPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cluster-tf-ops-by-host");
  }
  ::llvm::StringRef getArgument() const override { return "cluster-tf-ops-by-host"; }

  ::llvm::StringRef getDescription() const override { return "Cluster the TensorFlow ops by host so that each function only contains ops placed on the same host"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterTFOpsByHostPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterTFOpsByHostPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterTFOpsByHostPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTERTFOPSBYHOSTPASS
#endif // GEN_PASS_DEF_CLUSTERTFOPSBYHOSTPASS

//===----------------------------------------------------------------------===//
// ColocateTPUCopyWithDynamicShapePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COLOCATETPUCOPYWITHDYNAMICSHAPEPASS
#undef GEN_PASS_DECL_COLOCATETPUCOPYWITHDYNAMICSHAPEPASS
#endif // GEN_PASS_DECL_COLOCATETPUCOPYWITHDYNAMICSHAPEPASS
#ifdef GEN_PASS_DEF_COLOCATETPUCOPYWITHDYNAMICSHAPEPASS
namespace impl {

template <typename DerivedT>
class ColocateTPUCopyWithDynamicShapePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ColocateTPUCopyWithDynamicShapePassBase;

  ColocateTPUCopyWithDynamicShapePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ColocateTPUCopyWithDynamicShapePassBase(const ColocateTPUCopyWithDynamicShapePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ColocateTPUCopyWithDynamicShapePassBase& operator=(const ColocateTPUCopyWithDynamicShapePassBase &) = delete;
  ColocateTPUCopyWithDynamicShapePassBase(ColocateTPUCopyWithDynamicShapePassBase &&) = delete;
  ColocateTPUCopyWithDynamicShapePassBase& operator=(ColocateTPUCopyWithDynamicShapePassBase &&) = delete;
  ~ColocateTPUCopyWithDynamicShapePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-colocate-tpu-copy-with-dynamic-shape");
  }
  ::llvm::StringRef getArgument() const override { return "tf-colocate-tpu-copy-with-dynamic-shape"; }

  ::llvm::StringRef getDescription() const override { return "Adjusts the device annotation of TPUCopyWithDynamicShape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ColocateTPUCopyWithDynamicShapePass");
  }
  ::llvm::StringRef getName() const override { return "ColocateTPUCopyWithDynamicShapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ColocateTPUCopyWithDynamicShapePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COLOCATETPUCOPYWITHDYNAMICSHAPEPASS
#endif // GEN_PASS_DEF_COLOCATETPUCOPYWITHDYNAMICSHAPEPASS

//===----------------------------------------------------------------------===//
// ConstantOpDeviceAssignmentPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#undef GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#ifdef GEN_PASS_DEF_CONSTANTOPDEVICEASSIGNMENTPASS
namespace impl {

template <typename DerivedT>
class ConstantOpDeviceAssignmentPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConstantOpDeviceAssignmentPassBase;

  ConstantOpDeviceAssignmentPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConstantOpDeviceAssignmentPassBase(const ConstantOpDeviceAssignmentPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConstantOpDeviceAssignmentPassBase& operator=(const ConstantOpDeviceAssignmentPassBase &) = delete;
  ConstantOpDeviceAssignmentPassBase(ConstantOpDeviceAssignmentPassBase &&) = delete;
  ConstantOpDeviceAssignmentPassBase& operator=(ConstantOpDeviceAssignmentPassBase &&) = delete;
  ~ConstantOpDeviceAssignmentPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("constant-op-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "constant-op-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Assign device for tf.Const ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConstantOpDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "ConstantOpDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConstantOpDeviceAssignmentPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONSTANTOPDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DEF_CONSTANTOPDEVICEASSIGNMENTPASS

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToTFCallPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#undef GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#endif // GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#ifdef GEN_PASS_DEF_CONVERTLAUNCHFUNCTOTFCALLPASS
namespace impl {

template <typename DerivedT>
class ConvertLaunchFuncToTFCallPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertLaunchFuncToTFCallPassBase;

  ConvertLaunchFuncToTFCallPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLaunchFuncToTFCallPassBase(const ConvertLaunchFuncToTFCallPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertLaunchFuncToTFCallPassBase& operator=(const ConvertLaunchFuncToTFCallPassBase &) = delete;
  ConvertLaunchFuncToTFCallPassBase(ConvertLaunchFuncToTFCallPassBase &&) = delete;
  ConvertLaunchFuncToTFCallPassBase& operator=(ConvertLaunchFuncToTFCallPassBase &&) = delete;
  ~ConvertLaunchFuncToTFCallPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-convert-launch-func-to-tf-call");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-convert-launch-func-to-tf-call"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites tf_device::LaunchFuncOp to TF::PartitionedCallOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLaunchFuncToTFCallPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLaunchFuncToTFCallPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLaunchFuncToTFCallPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLAUNCHFUNCTOTFCALLPASS
#endif // GEN_PASS_DEF_CONVERTLAUNCHFUNCTOTFCALLPASS

//===----------------------------------------------------------------------===//
// ConvertReadonlyReferenceVariablesToResourceVariablesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#undef GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#endif // GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#ifdef GEN_PASS_DEF_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
namespace impl {

template <typename DerivedT>
class ConvertReadonlyReferenceVariablesToResourceVariablesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertReadonlyReferenceVariablesToResourceVariablesPassBase;

  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase(const ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase& operator=(const ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &) = delete;
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &&) = delete;
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase& operator=(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &&) = delete;
  ~ConvertReadonlyReferenceVariablesToResourceVariablesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-readonly-references-to-resources");
  }
  ::llvm::StringRef getArgument() const override { return "tf-readonly-references-to-resources"; }

  ::llvm::StringRef getDescription() const override { return "Convert readonly reference variables to resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertReadonlyReferenceVariablesToResourceVariablesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertReadonlyReferenceVariablesToResourceVariablesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#endif // GEN_PASS_DEF_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS

//===----------------------------------------------------------------------===//
// ConvertTfControlFlowToScfPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#undef GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#endif // GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#ifdef GEN_PASS_DEF_CONVERTTFCONTROLFLOWTOSCFPASS
namespace impl {

template <typename DerivedT>
class ConvertTfControlFlowToScfPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertTfControlFlowToScfPassBase;

  ConvertTfControlFlowToScfPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTfControlFlowToScfPassBase(const ConvertTfControlFlowToScfPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertTfControlFlowToScfPassBase& operator=(const ConvertTfControlFlowToScfPassBase &) = delete;
  ConvertTfControlFlowToScfPassBase(ConvertTfControlFlowToScfPassBase &&) = delete;
  ConvertTfControlFlowToScfPassBase& operator=(ConvertTfControlFlowToScfPassBase &&) = delete;
  ~ConvertTfControlFlowToScfPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tf-control-flow-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tf-control-flow-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Convert TensorFlow control flow to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTfControlFlowToScfPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTfControlFlowToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTfControlFlowToScfPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTTFCONTROLFLOWTOSCFPASS
#endif // GEN_PASS_DEF_CONVERTTFCONTROLFLOWTOSCFPASS

//===----------------------------------------------------------------------===//
// ConvertToLegacyCompileAndReplicateAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#undef GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#ifdef GEN_PASS_DEF_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class ConvertToLegacyCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertToLegacyCompileAndReplicateAttributesPassBase;

  ConvertToLegacyCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToLegacyCompileAndReplicateAttributesPassBase(const ConvertToLegacyCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ConvertToLegacyCompileAndReplicateAttributesPassBase& operator=(const ConvertToLegacyCompileAndReplicateAttributesPassBase &) = delete;
  ConvertToLegacyCompileAndReplicateAttributesPassBase(ConvertToLegacyCompileAndReplicateAttributesPassBase &&) = delete;
  ConvertToLegacyCompileAndReplicateAttributesPassBase& operator=(ConvertToLegacyCompileAndReplicateAttributesPassBase &&) = delete;
  ~ConvertToLegacyCompileAndReplicateAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-convert-to-legacy-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-convert-to-legacy-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Convert unified compilation and replication attributes back to legacy attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToLegacyCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToLegacyCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToLegacyCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DEF_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// DecomposeOptionalsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DECOMPOSEOPTIONALSPASS
#undef GEN_PASS_DECL_DECOMPOSEOPTIONALSPASS
#endif // GEN_PASS_DECL_DECOMPOSEOPTIONALSPASS
#ifdef GEN_PASS_DEF_DECOMPOSEOPTIONALSPASS
namespace impl {

template <typename DerivedT>
class DecomposeOptionalsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = DecomposeOptionalsPassBase;

  DecomposeOptionalsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeOptionalsPassBase(const DecomposeOptionalsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  DecomposeOptionalsPassBase& operator=(const DecomposeOptionalsPassBase &) = delete;
  DecomposeOptionalsPassBase(DecomposeOptionalsPassBase &&) = delete;
  DecomposeOptionalsPassBase& operator=(DecomposeOptionalsPassBase &&) = delete;
  ~DecomposeOptionalsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-decompose-optionals");
  }
  ::llvm::StringRef getArgument() const override { return "tf-decompose-optionals"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes ops of the 'Optional' family"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeOptionalsPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeOptionalsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeOptionalsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DECOMPOSEOPTIONALSPASS
#endif // GEN_PASS_DEF_DECOMPOSEOPTIONALSPASS

//===----------------------------------------------------------------------===//
// DecomposeReduceDatasetPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#undef GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#endif // GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#ifdef GEN_PASS_DEF_DECOMPOSEREDUCEDATASETPASS
namespace impl {

template <typename DerivedT>
class DecomposeReduceDatasetPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DecomposeReduceDatasetPassBase;

  DecomposeReduceDatasetPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeReduceDatasetPassBase(const DecomposeReduceDatasetPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DecomposeReduceDatasetPassBase& operator=(const DecomposeReduceDatasetPassBase &) = delete;
  DecomposeReduceDatasetPassBase(DecomposeReduceDatasetPassBase &&) = delete;
  DecomposeReduceDatasetPassBase& operator=(DecomposeReduceDatasetPassBase &&) = delete;
  ~DecomposeReduceDatasetPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-decompose-reduce-dataset");
  }
  ::llvm::StringRef getArgument() const override { return "tf-decompose-reduce-dataset"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes ReduceDataset op into dataset operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeReduceDatasetPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeReduceDatasetPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeReduceDatasetPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DECOMPOSEREDUCEDATASETPASS
#endif // GEN_PASS_DEF_DECOMPOSEREDUCEDATASETPASS

//===----------------------------------------------------------------------===//
// DeviceIndexSelectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#undef GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#endif // GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#ifdef GEN_PASS_DEF_DEVICEINDEXSELECTORPASS
namespace impl {

template <typename DerivedT>
class DeviceIndexSelectorPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeviceIndexSelectorPassBase;

  DeviceIndexSelectorPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeviceIndexSelectorPassBase(const DeviceIndexSelectorPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DeviceIndexSelectorPassBase& operator=(const DeviceIndexSelectorPassBase &) = delete;
  DeviceIndexSelectorPassBase(DeviceIndexSelectorPassBase &&) = delete;
  DeviceIndexSelectorPassBase& operator=(DeviceIndexSelectorPassBase &&) = delete;
  ~DeviceIndexSelectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-index-selector");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-index-selector"; }

  ::llvm::StringRef getDescription() const override { return "Fold tf.DeviceIndex to constant."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeviceIndexSelectorPass");
  }
  ::llvm::StringRef getName() const override { return "DeviceIndexSelectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeviceIndexSelectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DEVICEINDEXSELECTORPASS
#endif // GEN_PASS_DEF_DEVICEINDEXSELECTORPASS

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantInDeviceClusterPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#undef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#endif // GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#ifdef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
namespace impl {

template <typename DerivedT>
class DropWhileShapeInvariantInDeviceClusterPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantInDeviceClusterPassBase;

  DropWhileShapeInvariantInDeviceClusterPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantInDeviceClusterPassBase(const DropWhileShapeInvariantInDeviceClusterPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DropWhileShapeInvariantInDeviceClusterPassBase& operator=(const DropWhileShapeInvariantInDeviceClusterPassBase &) = delete;
  DropWhileShapeInvariantInDeviceClusterPassBase(DropWhileShapeInvariantInDeviceClusterPassBase &&) = delete;
  DropWhileShapeInvariantInDeviceClusterPassBase& operator=(DropWhileShapeInvariantInDeviceClusterPassBase &&) = delete;
  ~DropWhileShapeInvariantInDeviceClusterPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant-in-device-cluster");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant-in-device-cluster"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops inside device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantInDeviceClusterPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantInDeviceClusterPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantInDeviceClusterPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#endif // GEN_PASS_DEF_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#undef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#endif // GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#ifdef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTPASS
namespace impl {

template <typename DerivedT>
class DropWhileShapeInvariantPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantPassBase;

  DropWhileShapeInvariantPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantPassBase(const DropWhileShapeInvariantPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DropWhileShapeInvariantPassBase& operator=(const DropWhileShapeInvariantPassBase &) = delete;
  DropWhileShapeInvariantPassBase(DropWhileShapeInvariantPassBase &&) = delete;
  DropWhileShapeInvariantPassBase& operator=(DropWhileShapeInvariantPassBase &&) = delete;
  ~DropWhileShapeInvariantPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTPASS
#endif // GEN_PASS_DEF_DROPWHILESHAPEINVARIANTPASS

//===----------------------------------------------------------------------===//
// ExecutorCheckControlDependenciesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#undef GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#ifdef GEN_PASS_DEF_EXECUTORCHECKCONTROLDEPENDENCIESPASS
namespace impl {

template <typename DerivedT>
class ExecutorCheckControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorCheckControlDependenciesPassBase;

  ExecutorCheckControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorCheckControlDependenciesPassBase(const ExecutorCheckControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorCheckControlDependenciesPassBase& operator=(const ExecutorCheckControlDependenciesPassBase &) = delete;
  ExecutorCheckControlDependenciesPassBase(ExecutorCheckControlDependenciesPassBase &&) = delete;
  ExecutorCheckControlDependenciesPassBase& operator=(ExecutorCheckControlDependenciesPassBase &&) = delete;
  ~ExecutorCheckControlDependenciesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-check-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-check-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Checks control dependencies"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorCheckControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorCheckControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorCheckControlDependenciesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DEF_EXECUTORCHECKCONTROLDEPENDENCIESPASS

//===----------------------------------------------------------------------===//
// ExecutorConvertControlToDataOutputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
struct ExecutorConvertControlToDataOutputsPassOptions {
  bool composite_tpuexecute_side_effects_ = false;
};
#undef GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#endif // GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#ifdef GEN_PASS_DEF_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
namespace impl {

template <typename DerivedT>
class ExecutorConvertControlToDataOutputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorConvertControlToDataOutputsPassBase;

  ExecutorConvertControlToDataOutputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorConvertControlToDataOutputsPassBase(const ExecutorConvertControlToDataOutputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorConvertControlToDataOutputsPassBase& operator=(const ExecutorConvertControlToDataOutputsPassBase &) = delete;
  ExecutorConvertControlToDataOutputsPassBase(ExecutorConvertControlToDataOutputsPassBase &&) = delete;
  ExecutorConvertControlToDataOutputsPassBase& operator=(ExecutorConvertControlToDataOutputsPassBase &&) = delete;
  ~ExecutorConvertControlToDataOutputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-convert-control-to-data-outputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-convert-control-to-data-outputs"; }

  ::llvm::StringRef getDescription() const override { return "Chain control outputs of while loop body"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorConvertControlToDataOutputsPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorConvertControlToDataOutputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorConvertControlToDataOutputsPassBase<DerivedT>)

  ExecutorConvertControlToDataOutputsPassBase(const ExecutorConvertControlToDataOutputsPassOptions &options) : ExecutorConvertControlToDataOutputsPassBase() {
    composite_tpuexecute_side_effects_ = options.composite_tpuexecute_side_effects_;
  }
protected:
  ::mlir::Pass::Option<bool> composite_tpuexecute_side_effects_{*this, "composite-tpuexecute-side-effects", ::llvm::cl::desc("Enables certain TPUExecute ops to run in parallel if they only operate on resources that live on composite devices."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#endif // GEN_PASS_DEF_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS

//===----------------------------------------------------------------------===//
// ExecutorDialectToFunctionalPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#undef GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#endif // GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#ifdef GEN_PASS_DEF_EXECUTORDIALECTTOFUNCTIONALPASS
namespace impl {

template <typename DerivedT>
class ExecutorDialectToFunctionalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorDialectToFunctionalPassBase;

  ExecutorDialectToFunctionalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorDialectToFunctionalPassBase(const ExecutorDialectToFunctionalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExecutorDialectToFunctionalPassBase& operator=(const ExecutorDialectToFunctionalPassBase &) = delete;
  ExecutorDialectToFunctionalPassBase(ExecutorDialectToFunctionalPassBase &&) = delete;
  ExecutorDialectToFunctionalPassBase& operator=(ExecutorDialectToFunctionalPassBase &&) = delete;
  ~ExecutorDialectToFunctionalPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-to-functional-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-to-functional-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Lifts tf_executor.island inner ops from a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorDialectToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorDialectToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorDialectToFunctionalPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORDIALECTTOFUNCTIONALPASS
#endif // GEN_PASS_DEF_EXECUTORDIALECTTOFUNCTIONALPASS

//===----------------------------------------------------------------------===//
// ExecutorGraphPruningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
struct ExecutorGraphPruningPassOptions {
  ::llvm::ArrayRef<std::string> ops_to_preserve_;
};
#undef GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
#endif // GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
#ifdef GEN_PASS_DEF_EXECUTORGRAPHPRUNINGPASS
namespace impl {

template <typename DerivedT>
class ExecutorGraphPruningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorGraphPruningPassBase;

  ExecutorGraphPruningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorGraphPruningPassBase(const ExecutorGraphPruningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExecutorGraphPruningPassBase& operator=(const ExecutorGraphPruningPassBase &) = delete;
  ExecutorGraphPruningPassBase(ExecutorGraphPruningPassBase &&) = delete;
  ExecutorGraphPruningPassBase& operator=(ExecutorGraphPruningPassBase &&) = delete;
  ~ExecutorGraphPruningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-graph-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-graph-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Prunes unreachable ops in a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorGraphPruningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorGraphPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorGraphPruningPassBase<DerivedT>)

  ExecutorGraphPruningPassBase(const ExecutorGraphPruningPassOptions &options) : ExecutorGraphPruningPassBase() {
    ops_to_preserve_ = options.ops_to_preserve_;
  }
protected:
  ::mlir::Pass::ListOption<std::string> ops_to_preserve_{*this, "ops-to-preserve", ::llvm::cl::desc("Comma separated list of ops that should not be pruned regardless of reachability")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORGRAPHPRUNINGPASS
#endif // GEN_PASS_DEF_EXECUTORGRAPHPRUNINGPASS

//===----------------------------------------------------------------------===//
// ExecutorIslandCoarseningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#undef GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#ifdef GEN_PASS_DEF_EXECUTORISLANDCOARSENINGPASS
namespace impl {

template <typename DerivedT>
class ExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorIslandCoarseningPassBase;

  ExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorIslandCoarseningPassBase(const ExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExecutorIslandCoarseningPassBase& operator=(const ExecutorIslandCoarseningPassBase &) = delete;
  ExecutorIslandCoarseningPassBase(ExecutorIslandCoarseningPassBase &&) = delete;
  ExecutorIslandCoarseningPassBase& operator=(ExecutorIslandCoarseningPassBase &&) = delete;
  ~ExecutorIslandCoarseningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Walks tf_executor::GraphOp and merges individual tf_executor::IslandOps."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorIslandCoarseningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DEF_EXECUTORISLANDCOARSENINGPASS

//===----------------------------------------------------------------------===//
// ExecutorTPUV1IslandInliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#undef GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#endif // GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#ifdef GEN_PASS_DEF_EXECUTORTPUV1ISLANDINLININGPASS
namespace impl {

template <typename DerivedT>
class ExecutorTPUV1IslandInliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorTPUV1IslandInliningPassBase;

  ExecutorTPUV1IslandInliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorTPUV1IslandInliningPassBase(const ExecutorTPUV1IslandInliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorTPUV1IslandInliningPassBase& operator=(const ExecutorTPUV1IslandInliningPassBase &) = delete;
  ExecutorTPUV1IslandInliningPassBase(ExecutorTPUV1IslandInliningPassBase &&) = delete;
  ExecutorTPUV1IslandInliningPassBase& operator=(ExecutorTPUV1IslandInliningPassBase &&) = delete;
  ~ExecutorTPUV1IslandInliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-inlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-inlining"; }

  ::llvm::StringRef getDescription() const override { return "Inline calls to the nested TPU module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorTPUV1IslandInliningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorTPUV1IslandInliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorTPUV1IslandInliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORTPUV1ISLANDINLININGPASS
#endif // GEN_PASS_DEF_EXECUTORTPUV1ISLANDINLININGPASS

//===----------------------------------------------------------------------===//
// ExecutorUpdateControlDependenciesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#undef GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#ifdef GEN_PASS_DEF_EXECUTORUPDATECONTROLDEPENDENCIESPASS
namespace impl {

template <typename DerivedT>
class ExecutorUpdateControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorUpdateControlDependenciesPassBase;

  ExecutorUpdateControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorUpdateControlDependenciesPassBase(const ExecutorUpdateControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorUpdateControlDependenciesPassBase& operator=(const ExecutorUpdateControlDependenciesPassBase &) = delete;
  ExecutorUpdateControlDependenciesPassBase(ExecutorUpdateControlDependenciesPassBase &&) = delete;
  ExecutorUpdateControlDependenciesPassBase& operator=(ExecutorUpdateControlDependenciesPassBase &&) = delete;
  ~ExecutorUpdateControlDependenciesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-update-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-update-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Computes and applies all necessary control dependencies based on side effect analysis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorUpdateControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorUpdateControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorUpdateControlDependenciesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DEF_EXECUTORUPDATECONTROLDEPENDENCIESPASS

//===----------------------------------------------------------------------===//
// ExtractTPUCopyWithDynamicShapeOpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXTRACTTPUCOPYWITHDYNAMICSHAPEOPPASS
#undef GEN_PASS_DECL_EXTRACTTPUCOPYWITHDYNAMICSHAPEOPPASS
#endif // GEN_PASS_DECL_EXTRACTTPUCOPYWITHDYNAMICSHAPEOPPASS
#ifdef GEN_PASS_DEF_EXTRACTTPUCOPYWITHDYNAMICSHAPEOPPASS
namespace impl {

template <typename DerivedT>
class ExtractTPUCopyWithDynamicShapeOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExtractTPUCopyWithDynamicShapeOpPassBase;

  ExtractTPUCopyWithDynamicShapeOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExtractTPUCopyWithDynamicShapeOpPassBase(const ExtractTPUCopyWithDynamicShapeOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExtractTPUCopyWithDynamicShapeOpPassBase& operator=(const ExtractTPUCopyWithDynamicShapeOpPassBase &) = delete;
  ExtractTPUCopyWithDynamicShapeOpPassBase(ExtractTPUCopyWithDynamicShapeOpPassBase &&) = delete;
  ExtractTPUCopyWithDynamicShapeOpPassBase& operator=(ExtractTPUCopyWithDynamicShapeOpPassBase &&) = delete;
  ~ExtractTPUCopyWithDynamicShapeOpPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-extract-tpu-copy-with-dynamic-shape-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-extract-tpu-copy-with-dynamic-shape-op"; }

  ::llvm::StringRef getDescription() const override { return "Extract the TPUCopyWithDynamicShapeOp out of the host launch and place it on device launch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExtractTPUCopyWithDynamicShapeOpPass");
  }
  ::llvm::StringRef getName() const override { return "ExtractTPUCopyWithDynamicShapeOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExtractTPUCopyWithDynamicShapeOpPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXTRACTTPUCOPYWITHDYNAMICSHAPEOPPASS
#endif // GEN_PASS_DEF_EXTRACTTPUCOPYWITHDYNAMICSHAPEOPPASS

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToCFGPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#undef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#endif // GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#ifdef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOCFGPASS
namespace impl {

template <typename DerivedT>
class FunctionalControlFlowToCFGPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalControlFlowToCFGPassBase;

  FunctionalControlFlowToCFGPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToCFGPassBase(const FunctionalControlFlowToCFGPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FunctionalControlFlowToCFGPassBase& operator=(const FunctionalControlFlowToCFGPassBase &) = delete;
  FunctionalControlFlowToCFGPassBase(FunctionalControlFlowToCFGPassBase &&) = delete;
  FunctionalControlFlowToCFGPassBase& operator=(FunctionalControlFlowToCFGPassBase &&) = delete;
  ~FunctionalControlFlowToCFGPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-cfg");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-cfg"; }

  ::llvm::StringRef getDescription() const override { return "Transform functional control flow Ops to MLIR Control Form Graph (CFG) form"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToCFGPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToCFGPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToCFGPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOCFGPASS
#endif // GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOCFGPASS

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToRegionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
struct FunctionalControlFlowToRegionsPassOptions {
  bool allow_passthrough_args_ = false;
};
#undef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#endif // GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#ifdef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOREGIONSPASS
namespace impl {

template <typename DerivedT>
class FunctionalControlFlowToRegionsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FunctionalControlFlowToRegionsPassBase;

  FunctionalControlFlowToRegionsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToRegionsPassBase(const FunctionalControlFlowToRegionsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  FunctionalControlFlowToRegionsPassBase& operator=(const FunctionalControlFlowToRegionsPassBase &) = delete;
  FunctionalControlFlowToRegionsPassBase(FunctionalControlFlowToRegionsPassBase &&) = delete;
  FunctionalControlFlowToRegionsPassBase& operator=(FunctionalControlFlowToRegionsPassBase &&) = delete;
  ~FunctionalControlFlowToRegionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-regions");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-regions"; }

  ::llvm::StringRef getDescription() const override { return "Transforms functional control flow operations to their region-based counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToRegionsPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToRegionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToRegionsPassBase<DerivedT>)

  FunctionalControlFlowToRegionsPassBase(const FunctionalControlFlowToRegionsPassOptions &options) : FunctionalControlFlowToRegionsPassBase() {
    allow_passthrough_args_ = options.allow_passthrough_args_;
  }
protected:
  ::mlir::Pass::Option<bool> allow_passthrough_args_{*this, "allow-passthrough-args", ::llvm::cl::desc("Allows to switch on passthrough args for control flow logic. This allows the pass to create blocks that better match MLIR interfaces, but might break assumptions in existing passes."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#endif // GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOREGIONSPASS

//===----------------------------------------------------------------------===//
// FunctionalToExecutorDialectConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#undef GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#endif // GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#ifdef GEN_PASS_DEF_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
namespace impl {

template <typename DerivedT>
class FunctionalToExecutorDialectConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalToExecutorDialectConversionPassBase;

  FunctionalToExecutorDialectConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalToExecutorDialectConversionPassBase(const FunctionalToExecutorDialectConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FunctionalToExecutorDialectConversionPassBase& operator=(const FunctionalToExecutorDialectConversionPassBase &) = delete;
  FunctionalToExecutorDialectConversionPassBase(FunctionalToExecutorDialectConversionPassBase &&) = delete;
  FunctionalToExecutorDialectConversionPassBase& operator=(FunctionalToExecutorDialectConversionPassBase &&) = delete;
  ~FunctionalToExecutorDialectConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-to-executor-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-to-executor-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Transform from func op to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalToExecutorDialectConversionPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalToExecutorDialectConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalToExecutorDialectConversionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#endif // GEN_PASS_DEF_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS

//===----------------------------------------------------------------------===//
// FusedKernelMatcherPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#undef GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#endif // GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#ifdef GEN_PASS_DEF_FUSEDKERNELMATCHERPASS
namespace impl {

template <typename DerivedT>
class FusedKernelMatcherPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusedKernelMatcherPassBase;

  FusedKernelMatcherPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusedKernelMatcherPassBase(const FusedKernelMatcherPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FusedKernelMatcherPassBase& operator=(const FusedKernelMatcherPassBase &) = delete;
  FusedKernelMatcherPassBase(FusedKernelMatcherPassBase &&) = delete;
  FusedKernelMatcherPassBase& operator=(FusedKernelMatcherPassBase &&) = delete;
  ~FusedKernelMatcherPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-fused-kernel-matcher");
  }
  ::llvm::StringRef getArgument() const override { return "tf-fused-kernel-matcher"; }

  ::llvm::StringRef getDescription() const override { return "Matches computations corresponding to optimized fused kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusedKernelMatcherPass");
  }
  ::llvm::StringRef getName() const override { return "FusedKernelMatcherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusedKernelMatcherPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSEDKERNELMATCHERPASS
#endif // GEN_PASS_DEF_FUSEDKERNELMATCHERPASS

//===----------------------------------------------------------------------===//
// GroupByDialectPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GROUPBYDIALECTPASS
#undef GEN_PASS_DECL_GROUPBYDIALECTPASS
#endif // GEN_PASS_DECL_GROUPBYDIALECTPASS
#ifdef GEN_PASS_DEF_GROUPBYDIALECTPASS
namespace impl {

template <typename DerivedT>
class GroupByDialectPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = GroupByDialectPassBase;

  GroupByDialectPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GroupByDialectPassBase(const GroupByDialectPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  GroupByDialectPassBase& operator=(const GroupByDialectPassBase &) = delete;
  GroupByDialectPassBase(GroupByDialectPassBase &&) = delete;
  GroupByDialectPassBase& operator=(GroupByDialectPassBase &&) = delete;
  ~GroupByDialectPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-group-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-group-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Groups ops into functions that only contain one dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GroupByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "GroupByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GroupByDialectPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GROUPBYDIALECTPASS
#endif // GEN_PASS_DEF_GROUPBYDIALECTPASS

//===----------------------------------------------------------------------===//
// GuaranteeAllFuncsOneUsePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#undef GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#endif // GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#ifdef GEN_PASS_DEF_GUARANTEEALLFUNCSONEUSEPASS
namespace impl {

template <typename DerivedT>
class GuaranteeAllFuncsOneUsePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GuaranteeAllFuncsOneUsePassBase;

  GuaranteeAllFuncsOneUsePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GuaranteeAllFuncsOneUsePassBase(const GuaranteeAllFuncsOneUsePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  GuaranteeAllFuncsOneUsePassBase& operator=(const GuaranteeAllFuncsOneUsePassBase &) = delete;
  GuaranteeAllFuncsOneUsePassBase(GuaranteeAllFuncsOneUsePassBase &&) = delete;
  GuaranteeAllFuncsOneUsePassBase& operator=(GuaranteeAllFuncsOneUsePassBase &&) = delete;
  ~GuaranteeAllFuncsOneUsePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-guarantee-all-funcs-one-use");
  }
  ::llvm::StringRef getArgument() const override { return "tf-guarantee-all-funcs-one-use"; }

  ::llvm::StringRef getDescription() const override { return "Guarantee all FuncOp's have only a single use."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GuaranteeAllFuncsOneUsePass");
  }
  ::llvm::StringRef getName() const override { return "GuaranteeAllFuncsOneUsePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GuaranteeAllFuncsOneUsePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GUARANTEEALLFUNCSONEUSEPASS
#endif // GEN_PASS_DEF_GUARANTEEALLFUNCSONEUSEPASS

//===----------------------------------------------------------------------===//
// HoistLoopInvariantPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HOISTLOOPINVARIANTPASS
#undef GEN_PASS_DECL_HOISTLOOPINVARIANTPASS
#endif // GEN_PASS_DECL_HOISTLOOPINVARIANTPASS
#ifdef GEN_PASS_DEF_HOISTLOOPINVARIANTPASS
namespace impl {

template <typename DerivedT>
class HoistLoopInvariantPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = HoistLoopInvariantPassBase;

  HoistLoopInvariantPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HoistLoopInvariantPassBase(const HoistLoopInvariantPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  HoistLoopInvariantPassBase& operator=(const HoistLoopInvariantPassBase &) = delete;
  HoistLoopInvariantPassBase(HoistLoopInvariantPassBase &&) = delete;
  HoistLoopInvariantPassBase& operator=(HoistLoopInvariantPassBase &&) = delete;
  ~HoistLoopInvariantPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-hoist-loop-invariant");
  }
  ::llvm::StringRef getArgument() const override { return "tf-hoist-loop-invariant"; }

  ::llvm::StringRef getDescription() const override { return "Hoists loop invariant ops to the outside of the loop"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HoistLoopInvariantPass");
  }
  ::llvm::StringRef getName() const override { return "HoistLoopInvariantPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HoistLoopInvariantPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HOISTLOOPINVARIANTPASS
#endif // GEN_PASS_DEF_HOISTLOOPINVARIANTPASS

//===----------------------------------------------------------------------===//
// HoistReplicateInvariantResourceWritesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#undef GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#endif // GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#ifdef GEN_PASS_DEF_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
namespace impl {

template <typename DerivedT>
class HoistReplicateInvariantResourceWritesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = HoistReplicateInvariantResourceWritesPassBase;

  HoistReplicateInvariantResourceWritesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HoistReplicateInvariantResourceWritesPassBase(const HoistReplicateInvariantResourceWritesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  HoistReplicateInvariantResourceWritesPassBase& operator=(const HoistReplicateInvariantResourceWritesPassBase &) = delete;
  HoistReplicateInvariantResourceWritesPassBase(HoistReplicateInvariantResourceWritesPassBase &&) = delete;
  HoistReplicateInvariantResourceWritesPassBase& operator=(HoistReplicateInvariantResourceWritesPassBase &&) = delete;
  ~HoistReplicateInvariantResourceWritesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-hoist-replicate-invariant-resource-writes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-hoist-replicate-invariant-resource-writes"; }

  ::llvm::StringRef getDescription() const override { return "Hoists writes to replicate invariant resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HoistReplicateInvariantResourceWritesPass");
  }
  ::llvm::StringRef getName() const override { return "HoistReplicateInvariantResourceWritesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HoistReplicateInvariantResourceWritesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#endif // GEN_PASS_DEF_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS

//===----------------------------------------------------------------------===//
// InitTextFileToImportPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
struct InitTextFileToImportPassOptions {
  std::string saved_model_dir_;
};
#undef GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
#endif // GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
#ifdef GEN_PASS_DEF_INITTEXTFILETOIMPORTPASS
namespace impl {

template <typename DerivedT>
class InitTextFileToImportPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = InitTextFileToImportPassBase;

  InitTextFileToImportPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InitTextFileToImportPassBase(const InitTextFileToImportPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  InitTextFileToImportPassBase& operator=(const InitTextFileToImportPassBase &) = delete;
  InitTextFileToImportPassBase(InitTextFileToImportPassBase &&) = delete;
  InitTextFileToImportPassBase& operator=(InitTextFileToImportPassBase &&) = delete;
  ~InitTextFileToImportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-init-text-file-to-import");
  }
  ::llvm::StringRef getArgument() const override { return "tf-init-text-file-to-import"; }

  ::llvm::StringRef getDescription() const override { return "convert InitializeTableFromTextFileV2 ops to LookupTableImportV2Op to remove the dependency on asset files"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InitTextFileToImportPass");
  }
  ::llvm::StringRef getName() const override { return "InitTextFileToImportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InitTextFileToImportPassBase<DerivedT>)

  InitTextFileToImportPassBase(const InitTextFileToImportPassOptions &options) : InitTextFileToImportPassBase() {
    saved_model_dir_ = options.saved_model_dir_;
  }
protected:
  ::mlir::Pass::Option<std::string> saved_model_dir_{*this, "tf-saved-model-dir", ::llvm::cl::desc("Directory containing the model exported as a TensorFlow SavedModel. If your model is not based on the TensorFlow SavedModel, use an empty value.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_INITTEXTFILETOIMPORTPASS
#endif // GEN_PASS_DEF_INITTEXTFILETOIMPORTPASS

//===----------------------------------------------------------------------===//
// LaunchOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LAUNCHOUTLININGPASS
struct LaunchOutliningPassOptions {
  bool globally_unique_func_names_ = true;
};
#undef GEN_PASS_DECL_LAUNCHOUTLININGPASS
#endif // GEN_PASS_DECL_LAUNCHOUTLININGPASS
#ifdef GEN_PASS_DEF_LAUNCHOUTLININGPASS
namespace impl {

template <typename DerivedT>
class LaunchOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LaunchOutliningPassBase;

  LaunchOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LaunchOutliningPassBase(const LaunchOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LaunchOutliningPassBase& operator=(const LaunchOutliningPassBase &) = delete;
  LaunchOutliningPassBase(LaunchOutliningPassBase &&) = delete;
  LaunchOutliningPassBase& operator=(LaunchOutliningPassBase &&) = delete;
  ~LaunchOutliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-launch-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-launch-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.launch operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LaunchOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "LaunchOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LaunchOutliningPassBase<DerivedT>)

  LaunchOutliningPassBase(const LaunchOutliningPassOptions &options) : LaunchOutliningPassBase() {
    globally_unique_func_names_ = options.globally_unique_func_names_;
  }
protected:
  ::mlir::Pass::Option<bool> globally_unique_func_names_{*this, "globally-unique-func-names", ::llvm::cl::desc("If true, the pass adds extra identifiers to make function names globally unique within a process, not just within a module."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LAUNCHOUTLININGPASS
#endif // GEN_PASS_DEF_LAUNCHOUTLININGPASS

//===----------------------------------------------------------------------===//
// LayoutAssignmentPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
struct LayoutAssignmentPassOptions {
  std::string force_data_format_;
};
#undef GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
#endif // GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
#ifdef GEN_PASS_DEF_LAYOUTASSIGNMENTPASS
namespace impl {

template <typename DerivedT>
class LayoutAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LayoutAssignmentPassBase;

  LayoutAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LayoutAssignmentPassBase(const LayoutAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LayoutAssignmentPassBase& operator=(const LayoutAssignmentPassBase &) = delete;
  LayoutAssignmentPassBase(LayoutAssignmentPassBase &&) = delete;
  LayoutAssignmentPassBase& operator=(LayoutAssignmentPassBase &&) = delete;
  ~LayoutAssignmentPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-layout-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-layout-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Layout assignment pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LayoutAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "LayoutAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LayoutAssignmentPassBase<DerivedT>)

  LayoutAssignmentPassBase(const LayoutAssignmentPassOptions &options) : LayoutAssignmentPassBase() {
    force_data_format_ = options.force_data_format_;
  }
protected:
  ::mlir::Pass::Option<std::string> force_data_format_{*this, "force-data-format", ::llvm::cl::desc("Force data format for all layout sensitive ops.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LAYOUTASSIGNMENTPASS
#endif // GEN_PASS_DEF_LAYOUTASSIGNMENTPASS

//===----------------------------------------------------------------------===//
// LegalizeTFGToTFPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#undef GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#endif // GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#ifdef GEN_PASS_DEF_LEGALIZETFGTOTFPASS
namespace impl {

template <typename DerivedT>
class LegalizeTFGToTFPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFGToTFPassBase;

  LegalizeTFGToTFPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFGToTFPassBase(const LegalizeTFGToTFPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LegalizeTFGToTFPassBase& operator=(const LegalizeTFGToTFPassBase &) = delete;
  LegalizeTFGToTFPassBase(LegalizeTFGToTFPassBase &&) = delete;
  LegalizeTFGToTFPassBase& operator=(LegalizeTFGToTFPassBase &&) = delete;
  ~LegalizeTFGToTFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tfe-legalize-tfg");
  }
  ::llvm::StringRef getArgument() const override { return "tfe-legalize-tfg"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TFG to the TFE dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFGToTFPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFGToTFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFGToTFPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZETFGTOTFPASS
#endif // GEN_PASS_DEF_LEGALIZETFGTOTFPASS

//===----------------------------------------------------------------------===//
// LocalizeVarHandlesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#undef GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#endif // GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#ifdef GEN_PASS_DEF_LOCALIZEVARHANDLESPASS
namespace impl {

template <typename DerivedT>
class LocalizeVarHandlesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LocalizeVarHandlesPassBase;

  LocalizeVarHandlesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LocalizeVarHandlesPassBase(const LocalizeVarHandlesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LocalizeVarHandlesPassBase& operator=(const LocalizeVarHandlesPassBase &) = delete;
  LocalizeVarHandlesPassBase(LocalizeVarHandlesPassBase &&) = delete;
  LocalizeVarHandlesPassBase& operator=(LocalizeVarHandlesPassBase &&) = delete;
  ~LocalizeVarHandlesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-localize-var-handles");
  }
  ::llvm::StringRef getArgument() const override { return "tf-localize-var-handles"; }

  ::llvm::StringRef getDescription() const override { return "Creates VarHandleOps next to the operations that use them."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LocalizeVarHandlesPass");
  }
  ::llvm::StringRef getName() const override { return "LocalizeVarHandlesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LocalizeVarHandlesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOCALIZEVARHANDLESPASS
#endif // GEN_PASS_DEF_LOCALIZEVARHANDLESPASS

//===----------------------------------------------------------------------===//
// LowerQuantizedPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERQUANTIZEDPASS
#undef GEN_PASS_DECL_LOWERQUANTIZEDPASS
#endif // GEN_PASS_DECL_LOWERQUANTIZEDPASS
#ifdef GEN_PASS_DEF_LOWERQUANTIZEDPASS
namespace impl {

template <typename DerivedT>
class LowerQuantizedPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerQuantizedPassBase;

  LowerQuantizedPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerQuantizedPassBase(const LowerQuantizedPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerQuantizedPassBase& operator=(const LowerQuantizedPassBase &) = delete;
  LowerQuantizedPassBase(LowerQuantizedPassBase &&) = delete;
  LowerQuantizedPassBase& operator=(LowerQuantizedPassBase &&) = delete;
  ~LowerQuantizedPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-lower-quantized");
  }
  ::llvm::StringRef getArgument() const override { return "tf-lower-quantized"; }

  ::llvm::StringRef getDescription() const override { return "Lowers ops that require quantized input or output."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerQuantizedPass");
  }
  ::llvm::StringRef getName() const override { return "LowerQuantizedPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerQuantizedPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERQUANTIZEDPASS
#endif // GEN_PASS_DEF_LOWERQUANTIZEDPASS

//===----------------------------------------------------------------------===//
// MarkInputOutputAliasesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#undef GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#endif // GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#ifdef GEN_PASS_DEF_MARKINPUTOUTPUTALIASESPASS
namespace impl {

template <typename DerivedT>
class MarkInputOutputAliasesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkInputOutputAliasesPassBase;

  MarkInputOutputAliasesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkInputOutputAliasesPassBase(const MarkInputOutputAliasesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  MarkInputOutputAliasesPassBase& operator=(const MarkInputOutputAliasesPassBase &) = delete;
  MarkInputOutputAliasesPassBase(MarkInputOutputAliasesPassBase &&) = delete;
  MarkInputOutputAliasesPassBase& operator=(MarkInputOutputAliasesPassBase &&) = delete;
  ~MarkInputOutputAliasesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-mark-input-output-aliases");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-mark-input-output-aliases"; }

  ::llvm::StringRef getDescription() const override { return "Marks device cluster inputs-output pairs that read/write to the same variable as aliases"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkInputOutputAliasesPass");
  }
  ::llvm::StringRef getName() const override { return "MarkInputOutputAliasesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkInputOutputAliasesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MARKINPUTOUTPUTALIASESPASS
#endif // GEN_PASS_DEF_MARKINPUTOUTPUTALIASESPASS

//===----------------------------------------------------------------------===//
// MaterializePassthroughOp
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#undef GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#endif // GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#ifdef GEN_PASS_DEF_MATERIALIZEPASSTHROUGHOP
namespace impl {

template <typename DerivedT>
class MaterializePassthroughOpBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MaterializePassthroughOpBase;

  MaterializePassthroughOpBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MaterializePassthroughOpBase(const MaterializePassthroughOpBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  MaterializePassthroughOpBase& operator=(const MaterializePassthroughOpBase &) = delete;
  MaterializePassthroughOpBase(MaterializePassthroughOpBase &&) = delete;
  MaterializePassthroughOpBase& operator=(MaterializePassthroughOpBase &&) = delete;
  ~MaterializePassthroughOpBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-materialize-passthrough-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-materialize-passthrough-op"; }

  ::llvm::StringRef getDescription() const override { return "Materialize the MlirPassthroughOp by replacing it with the MLIR module attached as an attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MaterializePassthroughOp");
  }
  ::llvm::StringRef getName() const override { return "MaterializePassthroughOp"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MaterializePassthroughOpBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MATERIALIZEPASSTHROUGHOP
#endif // GEN_PASS_DEF_MATERIALIZEPASSTHROUGHOP

//===----------------------------------------------------------------------===//
// MergeControlFlowPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGECONTROLFLOWPASS
#undef GEN_PASS_DECL_MERGECONTROLFLOWPASS
#endif // GEN_PASS_DECL_MERGECONTROLFLOWPASS
#ifdef GEN_PASS_DEF_MERGECONTROLFLOWPASS
namespace impl {

template <typename DerivedT>
class MergeControlFlowPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MergeControlFlowPassBase;

  MergeControlFlowPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeControlFlowPassBase(const MergeControlFlowPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  MergeControlFlowPassBase& operator=(const MergeControlFlowPassBase &) = delete;
  MergeControlFlowPassBase(MergeControlFlowPassBase &&) = delete;
  MergeControlFlowPassBase& operator=(MergeControlFlowPassBase &&) = delete;
  ~MergeControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-merge-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "tf-merge-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Merges IfRegion ops together with a common predicate."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "MergeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeControlFlowPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MERGECONTROLFLOWPASS
#endif // GEN_PASS_DEF_MERGECONTROLFLOWPASS

//===----------------------------------------------------------------------===//
// MoveTpuCompileToFrontPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MOVETPUCOMPILETOFRONTPASS
#undef GEN_PASS_DECL_MOVETPUCOMPILETOFRONTPASS
#endif // GEN_PASS_DECL_MOVETPUCOMPILETOFRONTPASS
#ifdef GEN_PASS_DEF_MOVETPUCOMPILETOFRONTPASS
namespace impl {

template <typename DerivedT>
class MoveTpuCompileToFrontPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MoveTpuCompileToFrontPassBase;

  MoveTpuCompileToFrontPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MoveTpuCompileToFrontPassBase(const MoveTpuCompileToFrontPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  MoveTpuCompileToFrontPassBase& operator=(const MoveTpuCompileToFrontPassBase &) = delete;
  MoveTpuCompileToFrontPassBase(MoveTpuCompileToFrontPassBase &&) = delete;
  MoveTpuCompileToFrontPassBase& operator=(MoveTpuCompileToFrontPassBase &&) = delete;
  ~MoveTpuCompileToFrontPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-move-tpu-compile-to-front");
  }
  ::llvm::StringRef getArgument() const override { return "tf-move-tpu-compile-to-front"; }

  ::llvm::StringRef getDescription() const override { return "Moves compile ops to the front."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MoveTpuCompileToFrontPass");
  }
  ::llvm::StringRef getName() const override { return "MoveTpuCompileToFrontPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MoveTpuCompileToFrontPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MOVETPUCOMPILETOFRONTPASS
#endif // GEN_PASS_DEF_MOVETPUCOMPILETOFRONTPASS

//===----------------------------------------------------------------------===//
// MoveTransposesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MOVETRANSPOSESPASS
struct MoveTransposesPassOptions {
  bool fold_transpose_in_ops_ = true;
  enum MoveTransposeDirection direction_ = MoveTransposeDirection::kBegin;
};
#undef GEN_PASS_DECL_MOVETRANSPOSESPASS
#endif // GEN_PASS_DECL_MOVETRANSPOSESPASS
#ifdef GEN_PASS_DEF_MOVETRANSPOSESPASS
namespace impl {

template <typename DerivedT>
class MoveTransposesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MoveTransposesPassBase;

  MoveTransposesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MoveTransposesPassBase(const MoveTransposesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  MoveTransposesPassBase& operator=(const MoveTransposesPassBase &) = delete;
  MoveTransposesPassBase(MoveTransposesPassBase &&) = delete;
  MoveTransposesPassBase& operator=(MoveTransposesPassBase &&) = delete;
  ~MoveTransposesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-move-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-move-transposes"; }

  ::llvm::StringRef getDescription() const override { return "Move transposes pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MoveTransposesPass");
  }
  ::llvm::StringRef getName() const override { return "MoveTransposesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MoveTransposesPassBase<DerivedT>)

  MoveTransposesPassBase(const MoveTransposesPassOptions &options) : MoveTransposesPassBase() {
    fold_transpose_in_ops_ = options.fold_transpose_in_ops_;
    direction_ = options.direction_;
  }
protected:
  ::mlir::Pass::Option<bool> fold_transpose_in_ops_{*this, "fold-transpose-in-ops", ::llvm::cl::desc("Whether to fold transposes in ops which can support folding."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<enum MoveTransposeDirection> direction_{*this, "direction", ::llvm::cl::desc("Move transposes to the beginning or the end of the block where they are defined."), ::llvm::cl::init(MoveTransposeDirection::kBegin), llvm::cl::values(clEnumValN(MoveTransposeDirection::kBegin, "begin", "beginning of the block"),clEnumValN(MoveTransposeDirection::kEnd, "end", "end of the block"))};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MOVETRANSPOSESPASS
#endif // GEN_PASS_DEF_MOVETRANSPOSESPASS

//===----------------------------------------------------------------------===//
// NameAnonymousIteratorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#undef GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#endif // GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#ifdef GEN_PASS_DEF_NAMEANONYMOUSITERATORSPASS
namespace impl {

template <typename DerivedT>
class NameAnonymousIteratorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = NameAnonymousIteratorsPassBase;

  NameAnonymousIteratorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NameAnonymousIteratorsPassBase(const NameAnonymousIteratorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  NameAnonymousIteratorsPassBase& operator=(const NameAnonymousIteratorsPassBase &) = delete;
  NameAnonymousIteratorsPassBase(NameAnonymousIteratorsPassBase &&) = delete;
  NameAnonymousIteratorsPassBase& operator=(NameAnonymousIteratorsPassBase &&) = delete;
  ~NameAnonymousIteratorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-name-anonymous-iterators");
  }
  ::llvm::StringRef getArgument() const override { return "tf-name-anonymous-iterators"; }

  ::llvm::StringRef getDescription() const override { return "Converts anonymous iterators to named iterators"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NameAnonymousIteratorsPass");
  }
  ::llvm::StringRef getName() const override { return "NameAnonymousIteratorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NameAnonymousIteratorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_NAMEANONYMOUSITERATORSPASS
#endif // GEN_PASS_DEF_NAMEANONYMOUSITERATORSPASS

//===----------------------------------------------------------------------===//
// OrderByDialectPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ORDERBYDIALECTPASS
#undef GEN_PASS_DECL_ORDERBYDIALECTPASS
#endif // GEN_PASS_DECL_ORDERBYDIALECTPASS
#ifdef GEN_PASS_DEF_ORDERBYDIALECTPASS
namespace impl {

template <typename DerivedT>
class OrderByDialectPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OrderByDialectPassBase;

  OrderByDialectPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OrderByDialectPassBase(const OrderByDialectPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  OrderByDialectPassBase& operator=(const OrderByDialectPassBase &) = delete;
  OrderByDialectPassBase(OrderByDialectPassBase &&) = delete;
  OrderByDialectPassBase& operator=(OrderByDialectPassBase &&) = delete;
  ~OrderByDialectPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-order-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-order-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Reorders ops so ops of the same dialect are next to each other."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OrderByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "OrderByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OrderByDialectPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ORDERBYDIALECTPASS
#endif // GEN_PASS_DEF_ORDERBYDIALECTPASS

//===----------------------------------------------------------------------===//
// ParallelExecuteToIslandsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
struct ParallelExecuteToIslandsPassOptions {
  bool legacy_graph_export_ = true;
};
#undef GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
#endif // GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
#ifdef GEN_PASS_DEF_PARALLELEXECUTETOISLANDSPASS
namespace impl {

template <typename DerivedT>
class ParallelExecuteToIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelExecuteToIslandsPassBase;

  ParallelExecuteToIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelExecuteToIslandsPassBase(const ParallelExecuteToIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ParallelExecuteToIslandsPassBase& operator=(const ParallelExecuteToIslandsPassBase &) = delete;
  ParallelExecuteToIslandsPassBase(ParallelExecuteToIslandsPassBase &&) = delete;
  ParallelExecuteToIslandsPassBase& operator=(ParallelExecuteToIslandsPassBase &&) = delete;
  ~ParallelExecuteToIslandsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-parallel-execute-to-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-parallel-execute-to-islands"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device parallel_execute to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelExecuteToIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "ParallelExecuteToIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelExecuteToIslandsPassBase<DerivedT>)

  ParallelExecuteToIslandsPassBase(const ParallelExecuteToIslandsPassOptions &options) : ParallelExecuteToIslandsPassBase() {
    legacy_graph_export_ = options.legacy_graph_export_;
  }
protected:
  ::mlir::Pass::Option<bool> legacy_graph_export_{*this, "legacy-graph-export", ::llvm::cl::desc("Determines whether or not this pass should execute logic that is reserved for the legacy graph export pipeline to maintain expected invariants. In the case of this pass, that means manually propagating controls to lifted parallel execute regions to the graph fetch to ensure the ops execute."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PARALLELEXECUTETOISLANDSPASS
#endif // GEN_PASS_DEF_PARALLELEXECUTETOISLANDSPASS

//===----------------------------------------------------------------------===//
// PrepareTpuComputationForTfExportPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#undef GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#endif // GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#ifdef GEN_PASS_DEF_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
namespace impl {

template <typename DerivedT>
class PrepareTpuComputationForTfExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PrepareTpuComputationForTfExportPassBase;

  PrepareTpuComputationForTfExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrepareTpuComputationForTfExportPassBase(const PrepareTpuComputationForTfExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PrepareTpuComputationForTfExportPassBase& operator=(const PrepareTpuComputationForTfExportPassBase &) = delete;
  PrepareTpuComputationForTfExportPassBase(PrepareTpuComputationForTfExportPassBase &&) = delete;
  PrepareTpuComputationForTfExportPassBase& operator=(PrepareTpuComputationForTfExportPassBase &&) = delete;
  ~PrepareTpuComputationForTfExportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("prepare-tpu-computation-for-tf-export");
  }
  ::llvm::StringRef getArgument() const override { return "prepare-tpu-computation-for-tf-export"; }

  ::llvm::StringRef getDescription() const override { return "Prepare TPU computation to be legal for export to TensorFlow"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrepareTpuComputationForTfExportPass");
  }
  ::llvm::StringRef getName() const override { return "PrepareTpuComputationForTfExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrepareTpuComputationForTfExportPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#endif // GEN_PASS_DEF_PREPARETPUCOMPUTATIONFORTFEXPORTPASS

//===----------------------------------------------------------------------===//
// PrintPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PRINTPASS
#undef GEN_PASS_DECL_PRINTPASS
#endif // GEN_PASS_DECL_PRINTPASS
#ifdef GEN_PASS_DEF_PRINTPASS
namespace impl {

template <typename DerivedT>
class PrintPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PrintPassBase;

  PrintPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrintPassBase(const PrintPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PrintPassBase& operator=(const PrintPassBase &) = delete;
  PrintPassBase(PrintPassBase &&) = delete;
  PrintPassBase& operator=(PrintPassBase &&) = delete;
  ~PrintPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-print");
  }
  ::llvm::StringRef getArgument() const override { return "tf-print"; }

  ::llvm::StringRef getDescription() const override { return "Prints the current module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrintPass");
  }
  ::llvm::StringRef getName() const override { return "PrintPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrintPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PRINTPASS
#endif // GEN_PASS_DEF_PRINTPASS

//===----------------------------------------------------------------------===//
// PromoteResourcesToArgsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
struct PromoteResourcesToArgsPassOptions {
  ::llvm::ArrayRef<std::string> functions_;
};
#undef GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
#endif // GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
#ifdef GEN_PASS_DEF_PROMOTERESOURCESTOARGSPASS
namespace impl {

template <typename DerivedT>
class PromoteResourcesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteResourcesToArgsPassBase;

  PromoteResourcesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteResourcesToArgsPassBase(const PromoteResourcesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PromoteResourcesToArgsPassBase& operator=(const PromoteResourcesToArgsPassBase &) = delete;
  PromoteResourcesToArgsPassBase(PromoteResourcesToArgsPassBase &&) = delete;
  PromoteResourcesToArgsPassBase& operator=(PromoteResourcesToArgsPassBase &&) = delete;
  ~PromoteResourcesToArgsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-resources-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-resources-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote resources reads/writes to function inputs/outputs."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteResourcesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteResourcesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteResourcesToArgsPassBase<DerivedT>)

  PromoteResourcesToArgsPassBase(const PromoteResourcesToArgsPassOptions &options) : PromoteResourcesToArgsPassBase() {
    functions_ = options.functions_;
  }
protected:
  ::mlir::Pass::ListOption<std::string> functions_{*this, "functions", ::llvm::cl::desc("Comma separated list of functions whose resources read/writes should be promoted to function inputs/outputs.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROMOTERESOURCESTOARGSPASS
#endif // GEN_PASS_DEF_PROMOTERESOURCESTOARGSPASS

//===----------------------------------------------------------------------===//
// PromoteVarHandlesToArgsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#undef GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#endif // GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#ifdef GEN_PASS_DEF_PROMOTEVARHANDLESTOARGSPASS
namespace impl {

template <typename DerivedT>
class PromoteVarHandlesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteVarHandlesToArgsPassBase;

  PromoteVarHandlesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteVarHandlesToArgsPassBase(const PromoteVarHandlesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PromoteVarHandlesToArgsPassBase& operator=(const PromoteVarHandlesToArgsPassBase &) = delete;
  PromoteVarHandlesToArgsPassBase(PromoteVarHandlesToArgsPassBase &&) = delete;
  PromoteVarHandlesToArgsPassBase& operator=(PromoteVarHandlesToArgsPassBase &&) = delete;
  ~PromoteVarHandlesToArgsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-var-handles-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-var-handles-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote tf.VarHandleOps to function arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteVarHandlesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteVarHandlesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteVarHandlesToArgsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROMOTEVARHANDLESTOARGSPASS
#endif // GEN_PASS_DEF_PROMOTEVARHANDLESTOARGSPASS

//===----------------------------------------------------------------------===//
// RegionControlFlowToFunctionalPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#undef GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#endif // GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#ifdef GEN_PASS_DEF_REGIONCONTROLFLOWTOFUNCTIONALPASS
namespace impl {

template <typename DerivedT>
class RegionControlFlowToFunctionalPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RegionControlFlowToFunctionalPassBase;

  RegionControlFlowToFunctionalPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RegionControlFlowToFunctionalPassBase(const RegionControlFlowToFunctionalPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  RegionControlFlowToFunctionalPassBase& operator=(const RegionControlFlowToFunctionalPassBase &) = delete;
  RegionControlFlowToFunctionalPassBase(RegionControlFlowToFunctionalPassBase &&) = delete;
  RegionControlFlowToFunctionalPassBase& operator=(RegionControlFlowToFunctionalPassBase &&) = delete;
  ~RegionControlFlowToFunctionalPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-region-control-flow-to-functional");
  }
  ::llvm::StringRef getArgument() const override { return "tf-region-control-flow-to-functional"; }

  ::llvm::StringRef getDescription() const override { return "Transforms region-based control flow operations to their functional counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RegionControlFlowToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "RegionControlFlowToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RegionControlFlowToFunctionalPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REGIONCONTROLFLOWTOFUNCTIONALPASS
#endif // GEN_PASS_DEF_REGIONCONTROLFLOWTOFUNCTIONALPASS

//===----------------------------------------------------------------------===//
// RemoveUnusedArgumentsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#undef GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#endif // GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#ifdef GEN_PASS_DEF_REMOVEUNUSEDARGUMENTSPASS
namespace impl {

template <typename DerivedT>
class RemoveUnusedArgumentsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RemoveUnusedArgumentsPassBase;

  RemoveUnusedArgumentsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedArgumentsPassBase(const RemoveUnusedArgumentsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  RemoveUnusedArgumentsPassBase& operator=(const RemoveUnusedArgumentsPassBase &) = delete;
  RemoveUnusedArgumentsPassBase(RemoveUnusedArgumentsPassBase &&) = delete;
  RemoveUnusedArgumentsPassBase& operator=(RemoveUnusedArgumentsPassBase &&) = delete;
  ~RemoveUnusedArgumentsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-arguments");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-arguments"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused args from private functions & their callers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedArgumentsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedArgumentsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedArgumentsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REMOVEUNUSEDARGUMENTSPASS
#endif // GEN_PASS_DEF_REMOVEUNUSEDARGUMENTSPASS

//===----------------------------------------------------------------------===//
// RemoveUnusedWhileResultsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#undef GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#endif // GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#ifdef GEN_PASS_DEF_REMOVEUNUSEDWHILERESULTSPASS
namespace impl {

template <typename DerivedT>
class RemoveUnusedWhileResultsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveUnusedWhileResultsPassBase;

  RemoveUnusedWhileResultsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedWhileResultsPassBase(const RemoveUnusedWhileResultsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  RemoveUnusedWhileResultsPassBase& operator=(const RemoveUnusedWhileResultsPassBase &) = delete;
  RemoveUnusedWhileResultsPassBase(RemoveUnusedWhileResultsPassBase &&) = delete;
  RemoveUnusedWhileResultsPassBase& operator=(RemoveUnusedWhileResultsPassBase &&) = delete;
  ~RemoveUnusedWhileResultsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-while-results");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-while-results"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused results from tf.WhileRegion ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedWhileResultsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedWhileResultsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedWhileResultsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REMOVEUNUSEDWHILERESULTSPASS
#endif // GEN_PASS_DEF_REMOVEUNUSEDWHILERESULTSPASS

//===----------------------------------------------------------------------===//
// ReplicaIDToDeviceOrdinalPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#undef GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#endif // GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#ifdef GEN_PASS_DEF_REPLICAIDTODEVICEORDINALPASS
namespace impl {

template <typename DerivedT>
class ReplicaIDToDeviceOrdinalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicaIDToDeviceOrdinalPassBase;

  ReplicaIDToDeviceOrdinalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicaIDToDeviceOrdinalPassBase(const ReplicaIDToDeviceOrdinalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicaIDToDeviceOrdinalPassBase& operator=(const ReplicaIDToDeviceOrdinalPassBase &) = delete;
  ReplicaIDToDeviceOrdinalPassBase(ReplicaIDToDeviceOrdinalPassBase &&) = delete;
  ReplicaIDToDeviceOrdinalPassBase& operator=(ReplicaIDToDeviceOrdinalPassBase &&) = delete;
  ~ReplicaIDToDeviceOrdinalPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replica-id-to-device-ordinal");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replica-id-to-device-ordinal"; }

  ::llvm::StringRef getDescription() const override { return "Set device ordinal with replica id"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicaIDToDeviceOrdinalPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicaIDToDeviceOrdinalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicaIDToDeviceOrdinalPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REPLICAIDTODEVICEORDINALPASS
#endif // GEN_PASS_DEF_REPLICAIDTODEVICEORDINALPASS

//===----------------------------------------------------------------------===//
// ReplicateInvariantOpHoistingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#undef GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#endif // GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#ifdef GEN_PASS_DEF_REPLICATEINVARIANTOPHOISTINGPASS
namespace impl {

template <typename DerivedT>
class ReplicateInvariantOpHoistingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateInvariantOpHoistingPassBase;

  ReplicateInvariantOpHoistingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateInvariantOpHoistingPassBase(const ReplicateInvariantOpHoistingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicateInvariantOpHoistingPassBase& operator=(const ReplicateInvariantOpHoistingPassBase &) = delete;
  ReplicateInvariantOpHoistingPassBase(ReplicateInvariantOpHoistingPassBase &&) = delete;
  ReplicateInvariantOpHoistingPassBase& operator=(ReplicateInvariantOpHoistingPassBase &&) = delete;
  ~ReplicateInvariantOpHoistingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-invariant-op-hoisting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-invariant-op-hoisting"; }

  ::llvm::StringRef getDescription() const override { return "Hoists replicate invariant operations out of replicate"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateInvariantOpHoistingPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateInvariantOpHoistingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateInvariantOpHoistingPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REPLICATEINVARIANTOPHOISTINGPASS
#endif // GEN_PASS_DEF_REPLICATEINVARIANTOPHOISTINGPASS

//===----------------------------------------------------------------------===//
// ReplicateTensorListInitOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REPLICATETENSORLISTINITOPSPASS
#undef GEN_PASS_DECL_REPLICATETENSORLISTINITOPSPASS
#endif // GEN_PASS_DECL_REPLICATETENSORLISTINITOPSPASS
#ifdef GEN_PASS_DEF_REPLICATETENSORLISTINITOPSPASS
namespace impl {

template <typename DerivedT>
class ReplicateTensorListInitOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateTensorListInitOpsPassBase;

  ReplicateTensorListInitOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateTensorListInitOpsPassBase(const ReplicateTensorListInitOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicateTensorListInitOpsPassBase& operator=(const ReplicateTensorListInitOpsPassBase &) = delete;
  ReplicateTensorListInitOpsPassBase(ReplicateTensorListInitOpsPassBase &&) = delete;
  ReplicateTensorListInitOpsPassBase& operator=(ReplicateTensorListInitOpsPassBase &&) = delete;
  ~ReplicateTensorListInitOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-tensor-list-init-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-tensor-list-init-ops"; }

  ::llvm::StringRef getDescription() const override { return "Replicate TensorList init ops for correct shape assignments in shape inference"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateTensorListInitOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateTensorListInitOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateTensorListInitOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REPLICATETENSORLISTINITOPSPASS
#endif // GEN_PASS_DEF_REPLICATETENSORLISTINITOPSPASS

//===----------------------------------------------------------------------===//
// ReplicateToIslandPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REPLICATETOISLANDPASS
struct ReplicateToIslandPassOptions {
  bool legacy_graph_export_ = true;
};
#undef GEN_PASS_DECL_REPLICATETOISLANDPASS
#endif // GEN_PASS_DECL_REPLICATETOISLANDPASS
#ifdef GEN_PASS_DEF_REPLICATETOISLANDPASS
namespace impl {

template <typename DerivedT>
class ReplicateToIslandPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateToIslandPassBase;

  ReplicateToIslandPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateToIslandPassBase(const ReplicateToIslandPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicateToIslandPassBase& operator=(const ReplicateToIslandPassBase &) = delete;
  ReplicateToIslandPassBase(ReplicateToIslandPassBase &&) = delete;
  ReplicateToIslandPassBase& operator=(ReplicateToIslandPassBase &&) = delete;
  ~ReplicateToIslandPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-to-island");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-to-island"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device replicate to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateToIslandPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateToIslandPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateToIslandPassBase<DerivedT>)

  ReplicateToIslandPassBase(const ReplicateToIslandPassOptions &options) : ReplicateToIslandPassBase() {
    legacy_graph_export_ = options.legacy_graph_export_;
  }
protected:
  ::mlir::Pass::Option<bool> legacy_graph_export_{*this, "legacy-graph-export", ::llvm::cl::desc("Determines whether or not this pass should execute logic that is reserved for the legacy graph export pipeline to maintain expected invariants. In the case of this pass, that means manually propagating controls to lifted parallel execute regions to the graph fetch to ensure the ops execute, as well as determining whether or not the islands created by this pass should be split after the replicated ops have been lifted."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REPLICATETOISLANDPASS
#endif // GEN_PASS_DEF_REPLICATETOISLANDPASS

//===----------------------------------------------------------------------===//
// ResourceDeviceInferencePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#undef GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#endif // GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#ifdef GEN_PASS_DEF_RESOURCEDEVICEINFERENCEPASS
namespace impl {

template <typename DerivedT>
class ResourceDeviceInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ResourceDeviceInferencePassBase;

  ResourceDeviceInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ResourceDeviceInferencePassBase(const ResourceDeviceInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ResourceDeviceInferencePassBase& operator=(const ResourceDeviceInferencePassBase &) = delete;
  ResourceDeviceInferencePassBase(ResourceDeviceInferencePassBase &&) = delete;
  ResourceDeviceInferencePassBase& operator=(ResourceDeviceInferencePassBase &&) = delete;
  ~ResourceDeviceInferencePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-resource-device-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-resource-device-inference"; }

  ::llvm::StringRef getDescription() const override { return "Propagates the device attribute on resources from callers to callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResourceDeviceInferencePass");
  }
  ::llvm::StringRef getName() const override { return "ResourceDeviceInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResourceDeviceInferencePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_RESOURCEDEVICEINFERENCEPASS
#endif // GEN_PASS_DEF_RESOURCEDEVICEINFERENCEPASS

//===----------------------------------------------------------------------===//
// RewriteTPUEmbeddingOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#undef GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#endif // GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#ifdef GEN_PASS_DEF_REWRITETPUEMBEDDINGOPSPASS
namespace impl {

template <typename DerivedT>
class RewriteTPUEmbeddingOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteTPUEmbeddingOpsPassBase;

  RewriteTPUEmbeddingOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTPUEmbeddingOpsPassBase(const RewriteTPUEmbeddingOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  RewriteTPUEmbeddingOpsPassBase& operator=(const RewriteTPUEmbeddingOpsPassBase &) = delete;
  RewriteTPUEmbeddingOpsPassBase(RewriteTPUEmbeddingOpsPassBase &&) = delete;
  RewriteTPUEmbeddingOpsPassBase& operator=(RewriteTPUEmbeddingOpsPassBase &&) = delete;
  ~RewriteTPUEmbeddingOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-rewrite-tpu-embedding-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-rewrite-tpu-embedding-ops"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites TPU embedding send/recv ops by adding TPU embedding deduplication data"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTPUEmbeddingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteTPUEmbeddingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTPUEmbeddingOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITETPUEMBEDDINGOPSPASS
#endif // GEN_PASS_DEF_REWRITETPUEMBEDDINGOPSPASS

//===----------------------------------------------------------------------===//
// SimpleTFDeviceAssignmentPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
struct SimpleTFDeviceAssignmentPassOptions {
  std::string default_device_ = "cpu";
};
#undef GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
#ifdef GEN_PASS_DEF_SIMPLETFDEVICEASSIGNMENTPASS
namespace impl {

template <typename DerivedT>
class SimpleTFDeviceAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimpleTFDeviceAssignmentPassBase;

  SimpleTFDeviceAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimpleTFDeviceAssignmentPassBase(const SimpleTFDeviceAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  SimpleTFDeviceAssignmentPassBase& operator=(const SimpleTFDeviceAssignmentPassBase &) = delete;
  SimpleTFDeviceAssignmentPassBase(SimpleTFDeviceAssignmentPassBase &&) = delete;
  SimpleTFDeviceAssignmentPassBase& operator=(SimpleTFDeviceAssignmentPassBase &&) = delete;
  ~SimpleTFDeviceAssignmentPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-simple-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-simple-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Simple device assignment in TF dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimpleTFDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "SimpleTFDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimpleTFDeviceAssignmentPassBase<DerivedT>)

  SimpleTFDeviceAssignmentPassBase(const SimpleTFDeviceAssignmentPassOptions &options) : SimpleTFDeviceAssignmentPassBase() {
    default_device_ = options.default_device_;
  }
protected:
  ::mlir::Pass::Option<std::string> default_device_{*this, "default-device", ::llvm::cl::desc("The default device to assign."), ::llvm::cl::init("cpu")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLETFDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DEF_SIMPLETFDEVICEASSIGNMENTPASS

//===----------------------------------------------------------------------===//
// SplitIntoIslandPerOpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#undef GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#endif // GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#ifdef GEN_PASS_DEF_SPLITINTOISLANDPEROPPASS
namespace impl {

template <typename DerivedT>
class SplitIntoIslandPerOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SplitIntoIslandPerOpPassBase;

  SplitIntoIslandPerOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SplitIntoIslandPerOpPassBase(const SplitIntoIslandPerOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  SplitIntoIslandPerOpPassBase& operator=(const SplitIntoIslandPerOpPassBase &) = delete;
  SplitIntoIslandPerOpPassBase(SplitIntoIslandPerOpPassBase &&) = delete;
  SplitIntoIslandPerOpPassBase& operator=(SplitIntoIslandPerOpPassBase &&) = delete;
  ~SplitIntoIslandPerOpPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-split-into-island-per-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-split-into-island-per-op"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitIntoIslandPerOpPass");
  }
  ::llvm::StringRef getName() const override { return "SplitIntoIslandPerOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitIntoIslandPerOpPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPLITINTOISLANDPEROPPASS
#endif // GEN_PASS_DEF_SPLITINTOISLANDPEROPPASS

//===----------------------------------------------------------------------===//
// StackOpsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#undef GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_STACKOPSDECOMPOSITIONPASS
namespace impl {

template <typename DerivedT>
class StackOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StackOpsDecompositionPassBase;

  StackOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StackOpsDecompositionPassBase(const StackOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StackOpsDecompositionPassBase& operator=(const StackOpsDecompositionPassBase &) = delete;
  StackOpsDecompositionPassBase(StackOpsDecompositionPassBase &&) = delete;
  StackOpsDecompositionPassBase& operator=(StackOpsDecompositionPassBase &&) = delete;
  ~StackOpsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-stack-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-stack-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose stack operations into local variable operations. Needs static shapes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StackOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "StackOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StackOpsDecompositionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STACKOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_STACKOPSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// StripNoinlineAttributePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#undef GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#endif // GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#ifdef GEN_PASS_DEF_STRIPNOINLINEATTRIBUTEPASS
namespace impl {

template <typename DerivedT>
class StripNoinlineAttributePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StripNoinlineAttributePassBase;

  StripNoinlineAttributePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripNoinlineAttributePassBase(const StripNoinlineAttributePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StripNoinlineAttributePassBase& operator=(const StripNoinlineAttributePassBase &) = delete;
  StripNoinlineAttributePassBase(StripNoinlineAttributePassBase &&) = delete;
  StripNoinlineAttributePassBase& operator=(StripNoinlineAttributePassBase &&) = delete;
  ~StripNoinlineAttributePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-noinline-attribute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-noinline-attribute"; }

  ::llvm::StringRef getDescription() const override { return "Strip the tf._noinline attribute from top-level functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripNoinlineAttributePass");
  }
  ::llvm::StringRef getName() const override { return "StripNoinlineAttributePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripNoinlineAttributePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STRIPNOINLINEATTRIBUTEPASS
#endif // GEN_PASS_DEF_STRIPNOINLINEATTRIBUTEPASS

//===----------------------------------------------------------------------===//
// StripTfAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#undef GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#endif // GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#ifdef GEN_PASS_DEF_STRIPTFATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class StripTfAttributesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StripTfAttributesPassBase;

  StripTfAttributesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripTfAttributesPassBase(const StripTfAttributesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StripTfAttributesPassBase& operator=(const StripTfAttributesPassBase &) = delete;
  StripTfAttributesPassBase(StripTfAttributesPassBase &&) = delete;
  StripTfAttributesPassBase& operator=(StripTfAttributesPassBase &&) = delete;
  ~StripTfAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-tf-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-tf-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Removes TF specific attributes"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripTfAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "StripTfAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripTfAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STRIPTFATTRIBUTESPASS
#endif // GEN_PASS_DEF_STRIPTFATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// TFDataOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#undef GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_TFDATAOPTIMIZATIONPASS
namespace impl {

template <typename DerivedT>
class TFDataOptimizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDataOptimizationPassBase;

  TFDataOptimizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDataOptimizationPassBase(const TFDataOptimizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TFDataOptimizationPassBase& operator=(const TFDataOptimizationPassBase &) = delete;
  TFDataOptimizationPassBase(TFDataOptimizationPassBase &&) = delete;
  TFDataOptimizationPassBase& operator=(TFDataOptimizationPassBase &&) = delete;
  ~TFDataOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-data-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-data-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Performs tf.data optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDataOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "TFDataOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDataOptimizationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TFDATAOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_TFDATAOPTIMIZATIONPASS

//===----------------------------------------------------------------------===//
// TFDeviceAssignmentByFuncAttrPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#undef GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#endif // GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#ifdef GEN_PASS_DEF_TFDEVICEASSIGNMENTBYFUNCATTRPASS
namespace impl {

template <typename DerivedT>
class TFDeviceAssignmentByFuncAttrPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDeviceAssignmentByFuncAttrPassBase;

  TFDeviceAssignmentByFuncAttrPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDeviceAssignmentByFuncAttrPassBase(const TFDeviceAssignmentByFuncAttrPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TFDeviceAssignmentByFuncAttrPassBase& operator=(const TFDeviceAssignmentByFuncAttrPassBase &) = delete;
  TFDeviceAssignmentByFuncAttrPassBase(TFDeviceAssignmentByFuncAttrPassBase &&) = delete;
  TFDeviceAssignmentByFuncAttrPassBase& operator=(TFDeviceAssignmentByFuncAttrPassBase &&) = delete;
  ~TFDeviceAssignmentByFuncAttrPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-assignment-by-func-attr");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-assignment-by-func-attr"; }

  ::llvm::StringRef getDescription() const override { return "Device assignment in TF dialect using the device specified in the function attribute."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDeviceAssignmentByFuncAttrPass");
  }
  ::llvm::StringRef getName() const override { return "TFDeviceAssignmentByFuncAttrPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDeviceAssignmentByFuncAttrPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#endif // GEN_PASS_DEF_TFDEVICEASSIGNMENTBYFUNCATTRPASS

//===----------------------------------------------------------------------===//
// TPUAnnotateDynamicShapeInputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUANNOTATEDYNAMICSHAPEINPUTSPASS
#undef GEN_PASS_DECL_TPUANNOTATEDYNAMICSHAPEINPUTSPASS
#endif // GEN_PASS_DECL_TPUANNOTATEDYNAMICSHAPEINPUTSPASS
#ifdef GEN_PASS_DEF_TPUANNOTATEDYNAMICSHAPEINPUTSPASS
namespace impl {

template <typename DerivedT>
class TPUAnnotateDynamicShapeInputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUAnnotateDynamicShapeInputsPassBase;

  TPUAnnotateDynamicShapeInputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUAnnotateDynamicShapeInputsPassBase(const TPUAnnotateDynamicShapeInputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUAnnotateDynamicShapeInputsPassBase& operator=(const TPUAnnotateDynamicShapeInputsPassBase &) = delete;
  TPUAnnotateDynamicShapeInputsPassBase(TPUAnnotateDynamicShapeInputsPassBase &&) = delete;
  TPUAnnotateDynamicShapeInputsPassBase& operator=(TPUAnnotateDynamicShapeInputsPassBase &&) = delete;
  ~TPUAnnotateDynamicShapeInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-annotate-dynamic-shape-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-annotate-dynamic-shape-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Annotate the inputs returned by TPUCopyWithDynamicShapeOp with dynamic shape"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUAnnotateDynamicShapeInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUAnnotateDynamicShapeInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUAnnotateDynamicShapeInputsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUANNOTATEDYNAMICSHAPEINPUTSPASS
#endif // GEN_PASS_DEF_TPUANNOTATEDYNAMICSHAPEINPUTSPASS

//===----------------------------------------------------------------------===//
// TPUBridgeExecutorIslandOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#undef GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#endif // GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#ifdef GEN_PASS_DEF_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
namespace impl {

template <typename DerivedT>
class TPUBridgeExecutorIslandOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUBridgeExecutorIslandOutliningPassBase;

  TPUBridgeExecutorIslandOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUBridgeExecutorIslandOutliningPassBase(const TPUBridgeExecutorIslandOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUBridgeExecutorIslandOutliningPassBase& operator=(const TPUBridgeExecutorIslandOutliningPassBase &) = delete;
  TPUBridgeExecutorIslandOutliningPassBase(TPUBridgeExecutorIslandOutliningPassBase &&) = delete;
  TPUBridgeExecutorIslandOutliningPassBase& operator=(TPUBridgeExecutorIslandOutliningPassBase &&) = delete;
  ~TPUBridgeExecutorIslandOutliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outline TPU clusters from island into a nested module, so it can be processed like a V2 module, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUBridgeExecutorIslandOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUBridgeExecutorIslandOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUBridgeExecutorIslandOutliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#endif // GEN_PASS_DEF_TPUBRIDGEEXECUTORISLANDOUTLININGPASS

//===----------------------------------------------------------------------===//
// TPUCleanupClusterAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#undef GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#endif // GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#ifdef GEN_PASS_DEF_TPUCLEANUPCLUSTERATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class TPUCleanupClusterAttributesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUCleanupClusterAttributesPassBase;

  TPUCleanupClusterAttributesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUCleanupClusterAttributesPassBase(const TPUCleanupClusterAttributesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUCleanupClusterAttributesPassBase& operator=(const TPUCleanupClusterAttributesPassBase &) = delete;
  TPUCleanupClusterAttributesPassBase(TPUCleanupClusterAttributesPassBase &&) = delete;
  TPUCleanupClusterAttributesPassBase& operator=(TPUCleanupClusterAttributesPassBase &&) = delete;
  ~TPUCleanupClusterAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cleanup-cluster-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cleanup-cluster-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Eliminate _replication_info and other attributes from ops in a cluster"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUCleanupClusterAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "TPUCleanupClusterAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUCleanupClusterAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUCLEANUPCLUSTERATTRIBUTESPASS
#endif // GEN_PASS_DEF_TPUCLEANUPCLUSTERATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// TPUColocateCompositeResourceOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#undef GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#endif // GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#ifdef GEN_PASS_DEF_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
namespace impl {

template <typename DerivedT>
class TPUColocateCompositeResourceOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUColocateCompositeResourceOpsPassBase;

  TPUColocateCompositeResourceOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUColocateCompositeResourceOpsPassBase(const TPUColocateCompositeResourceOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUColocateCompositeResourceOpsPassBase& operator=(const TPUColocateCompositeResourceOpsPassBase &) = delete;
  TPUColocateCompositeResourceOpsPassBase(TPUColocateCompositeResourceOpsPassBase &&) = delete;
  TPUColocateCompositeResourceOpsPassBase& operator=(TPUColocateCompositeResourceOpsPassBase &&) = delete;
  ~TPUColocateCompositeResourceOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-colocate-composite-resource-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-colocate-composite-resource-ops"; }

  ::llvm::StringRef getDescription() const override { return "Colocate resource with composite device assignment to TPU device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUColocateCompositeResourceOpsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUColocateCompositeResourceOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUColocateCompositeResourceOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#endif // GEN_PASS_DEF_TPUCOLOCATECOMPOSITERESOURCEOPSPASS

//===----------------------------------------------------------------------===//
// TPUColocateSplitsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUCOLOCATESPLITSPASS
#undef GEN_PASS_DECL_TPUCOLOCATESPLITSPASS
#endif // GEN_PASS_DECL_TPUCOLOCATESPLITSPASS
#ifdef GEN_PASS_DEF_TPUCOLOCATESPLITSPASS
namespace impl {

template <typename DerivedT>
class TPUColocateSplitsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUColocateSplitsPassBase;

  TPUColocateSplitsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUColocateSplitsPassBase(const TPUColocateSplitsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUColocateSplitsPassBase& operator=(const TPUColocateSplitsPassBase &) = delete;
  TPUColocateSplitsPassBase(TPUColocateSplitsPassBase &&) = delete;
  TPUColocateSplitsPassBase& operator=(TPUColocateSplitsPassBase &&) = delete;
  ~TPUColocateSplitsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-colocate-splits");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-colocate-splits"; }

  ::llvm::StringRef getDescription() const override { return "Colocates each Split op with its predecessor"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUColocateSplitsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUColocateSplitsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUColocateSplitsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUCOLOCATESPLITSPASS
#endif // GEN_PASS_DEF_TPUCOLOCATESPLITSPASS

//===----------------------------------------------------------------------===//
// TPUDevicePropagationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#undef GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#endif // GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#ifdef GEN_PASS_DEF_TPUDEVICEPROPAGATIONPASS
namespace impl {

template <typename DerivedT>
class TPUDevicePropagationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUDevicePropagationPassBase;

  TPUDevicePropagationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDevicePropagationPassBase(const TPUDevicePropagationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUDevicePropagationPassBase& operator=(const TPUDevicePropagationPassBase &) = delete;
  TPUDevicePropagationPassBase(TPUDevicePropagationPassBase &&) = delete;
  TPUDevicePropagationPassBase& operator=(TPUDevicePropagationPassBase &&) = delete;
  ~TPUDevicePropagationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-device-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-device-propagation"; }

  ::llvm::StringRef getDescription() const override { return "Propagates TPU devices from ops to users"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDevicePropagationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDevicePropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDevicePropagationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUDEVICEPROPAGATIONPASS
#endif // GEN_PASS_DEF_TPUDEVICEPROPAGATIONPASS

//===----------------------------------------------------------------------===//
// TPUDynamicLayoutPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#undef GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#endif // GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#ifdef GEN_PASS_DEF_TPUDYNAMICLAYOUTPASS
namespace impl {

template <typename DerivedT>
class TPUDynamicLayoutPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUDynamicLayoutPassBase;

  TPUDynamicLayoutPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDynamicLayoutPassBase(const TPUDynamicLayoutPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUDynamicLayoutPassBase& operator=(const TPUDynamicLayoutPassBase &) = delete;
  TPUDynamicLayoutPassBase(TPUDynamicLayoutPassBase &&) = delete;
  TPUDynamicLayoutPassBase& operator=(TPUDynamicLayoutPassBase &&) = delete;
  ~TPUDynamicLayoutPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-dynamic-layout-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-dynamic-layout-pass"; }

  ::llvm::StringRef getDescription() const override { return "Inserts TPU layout ops to determine layout at run time."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDynamicLayoutPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDynamicLayoutPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDynamicLayoutPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUDYNAMICLAYOUTPASS
#endif // GEN_PASS_DEF_TPUDYNAMICLAYOUTPASS

//===----------------------------------------------------------------------===//
// TPUHostComputationExpansionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#undef GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#endif // GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#ifdef GEN_PASS_DEF_TPUHOSTCOMPUTATIONEXPANSIONPASS
namespace impl {

template <typename DerivedT>
class TPUHostComputationExpansionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUHostComputationExpansionPassBase;

  TPUHostComputationExpansionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUHostComputationExpansionPassBase(const TPUHostComputationExpansionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUHostComputationExpansionPassBase& operator=(const TPUHostComputationExpansionPassBase &) = delete;
  TPUHostComputationExpansionPassBase(TPUHostComputationExpansionPassBase &&) = delete;
  TPUHostComputationExpansionPassBase& operator=(TPUHostComputationExpansionPassBase &&) = delete;
  ~TPUHostComputationExpansionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-host-computation-expansion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-host-computation-expansion"; }

  ::llvm::StringRef getDescription() const override { return "Expands host computation before and after TPU computation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUHostComputationExpansionPass");
  }
  ::llvm::StringRef getName() const override { return "TPUHostComputationExpansionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUHostComputationExpansionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUHOSTCOMPUTATIONEXPANSIONPASS
#endif // GEN_PASS_DEF_TPUHOSTCOMPUTATIONEXPANSIONPASS

//===----------------------------------------------------------------------===//
// TPUIdentityPruningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#undef GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#endif // GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#ifdef GEN_PASS_DEF_TPUIDENTITYPRUNINGPASS
namespace impl {

template <typename DerivedT>
class TPUIdentityPruningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUIdentityPruningPassBase;

  TPUIdentityPruningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUIdentityPruningPassBase(const TPUIdentityPruningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUIdentityPruningPassBase& operator=(const TPUIdentityPruningPassBase &) = delete;
  TPUIdentityPruningPassBase(TPUIdentityPruningPassBase &&) = delete;
  TPUIdentityPruningPassBase& operator=(TPUIdentityPruningPassBase &&) = delete;
  ~TPUIdentityPruningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-identity-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-identity-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Removes Identity/IdentityN ops from the TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUIdentityPruningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUIdentityPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUIdentityPruningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUIDENTITYPRUNINGPASS
#endif // GEN_PASS_DEF_TPUIDENTITYPRUNINGPASS

//===----------------------------------------------------------------------===//
// TPUParallelExecuteSinkResourceWritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#undef GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#endif // GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#ifdef GEN_PASS_DEF_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
namespace impl {

template <typename DerivedT>
class TPUParallelExecuteSinkResourceWritePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUParallelExecuteSinkResourceWritePassBase;

  TPUParallelExecuteSinkResourceWritePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUParallelExecuteSinkResourceWritePassBase(const TPUParallelExecuteSinkResourceWritePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUParallelExecuteSinkResourceWritePassBase& operator=(const TPUParallelExecuteSinkResourceWritePassBase &) = delete;
  TPUParallelExecuteSinkResourceWritePassBase(TPUParallelExecuteSinkResourceWritePassBase &&) = delete;
  TPUParallelExecuteSinkResourceWritePassBase& operator=(TPUParallelExecuteSinkResourceWritePassBase &&) = delete;
  ~TPUParallelExecuteSinkResourceWritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-parallel-execute-sink-resource-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-parallel-execute-sink-resource-write"; }

  ::llvm::StringRef getDescription() const override { return "Moves tf.AssignVariableOp consumers of tf_device.parallel_execute into tf_device.parallel_execute regions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUParallelExecuteSinkResourceWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUParallelExecuteSinkResourceWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUParallelExecuteSinkResourceWritePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#endif // GEN_PASS_DEF_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS

//===----------------------------------------------------------------------===//
// TPUPartitionedOpConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUPARTITIONEDOPCONVERSIONPASS
#undef GEN_PASS_DECL_TPUPARTITIONEDOPCONVERSIONPASS
#endif // GEN_PASS_DECL_TPUPARTITIONEDOPCONVERSIONPASS
#ifdef GEN_PASS_DEF_TPUPARTITIONEDOPCONVERSIONPASS
namespace impl {

template <typename DerivedT>
class TPUPartitionedOpConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUPartitionedOpConversionPassBase;

  TPUPartitionedOpConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUPartitionedOpConversionPassBase(const TPUPartitionedOpConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUPartitionedOpConversionPassBase& operator=(const TPUPartitionedOpConversionPassBase &) = delete;
  TPUPartitionedOpConversionPassBase(TPUPartitionedOpConversionPassBase &&) = delete;
  TPUPartitionedOpConversionPassBase& operator=(TPUPartitionedOpConversionPassBase &&) = delete;
  ~TPUPartitionedOpConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-partitioned-op-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-partitioned-op-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Rewrite all TPU Partitioned ops into their V2 counterparts."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUPartitionedOpConversionPass");
  }
  ::llvm::StringRef getName() const override { return "TPUPartitionedOpConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUPartitionedOpConversionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUPARTITIONEDOPCONVERSIONPASS
#endif // GEN_PASS_DEF_TPUPARTITIONEDOPCONVERSIONPASS

//===----------------------------------------------------------------------===//
// TPUReorderReplicateAndPartitionedInputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#undef GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#endif // GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#ifdef GEN_PASS_DEF_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
namespace impl {

template <typename DerivedT>
class TPUReorderReplicateAndPartitionedInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUReorderReplicateAndPartitionedInputsPassBase;

  TPUReorderReplicateAndPartitionedInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUReorderReplicateAndPartitionedInputsPassBase(const TPUReorderReplicateAndPartitionedInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUReorderReplicateAndPartitionedInputsPassBase& operator=(const TPUReorderReplicateAndPartitionedInputsPassBase &) = delete;
  TPUReorderReplicateAndPartitionedInputsPassBase(TPUReorderReplicateAndPartitionedInputsPassBase &&) = delete;
  TPUReorderReplicateAndPartitionedInputsPassBase& operator=(TPUReorderReplicateAndPartitionedInputsPassBase &&) = delete;
  ~TPUReorderReplicateAndPartitionedInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-reorder-replicate-partitioned-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-reorder-replicate-partitioned-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Reorder replicated and partitioned input ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUReorderReplicateAndPartitionedInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUReorderReplicateAndPartitionedInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUReorderReplicateAndPartitionedInputsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#endif // GEN_PASS_DEF_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS

//===----------------------------------------------------------------------===//
// TPUResourceReadForWritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#undef GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#endif // GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#ifdef GEN_PASS_DEF_TPURESOURCEREADFORWRITEPASS
namespace impl {

template <typename DerivedT>
class TPUResourceReadForWritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUResourceReadForWritePassBase;

  TPUResourceReadForWritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadForWritePassBase(const TPUResourceReadForWritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUResourceReadForWritePassBase& operator=(const TPUResourceReadForWritePassBase &) = delete;
  TPUResourceReadForWritePassBase(TPUResourceReadForWritePassBase &&) = delete;
  TPUResourceReadForWritePassBase& operator=(TPUResourceReadForWritePassBase &&) = delete;
  ~TPUResourceReadForWritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-read-for-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-read-for-write"; }

  ::llvm::StringRef getDescription() const override { return "Inserts tf.ReadVariableOp inputs to a TPU cluster for resource writes with no reads"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadForWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadForWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadForWritePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPURESOURCEREADFORWRITEPASS
#endif // GEN_PASS_DEF_TPURESOURCEREADFORWRITEPASS

//===----------------------------------------------------------------------===//
// TPUResourceReadsWritesPartitioningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#undef GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#endif // GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#ifdef GEN_PASS_DEF_TPURESOURCEREADSWRITESPARTITIONINGPASS
namespace impl {

template <typename DerivedT>
class TPUResourceReadsWritesPartitioningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUResourceReadsWritesPartitioningPassBase;

  TPUResourceReadsWritesPartitioningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadsWritesPartitioningPassBase(const TPUResourceReadsWritesPartitioningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUResourceReadsWritesPartitioningPassBase& operator=(const TPUResourceReadsWritesPartitioningPassBase &) = delete;
  TPUResourceReadsWritesPartitioningPassBase(TPUResourceReadsWritesPartitioningPassBase &&) = delete;
  TPUResourceReadsWritesPartitioningPassBase& operator=(TPUResourceReadsWritesPartitioningPassBase &&) = delete;
  ~TPUResourceReadsWritesPartitioningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-partition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-partition"; }

  ::llvm::StringRef getDescription() const override { return "Partitions unpartitioned resource read/write to partitioned resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadsWritesPartitioningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadsWritesPartitioningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadsWritesPartitioningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPURESOURCEREADSWRITESPARTITIONINGPASS
#endif // GEN_PASS_DEF_TPURESOURCEREADSWRITESPARTITIONINGPASS

//===----------------------------------------------------------------------===//
// TPUSpaceToDepthPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUSPACETODEPTHPASS
#undef GEN_PASS_DECL_TPUSPACETODEPTHPASS
#endif // GEN_PASS_DECL_TPUSPACETODEPTHPASS
#ifdef GEN_PASS_DEF_TPUSPACETODEPTHPASS
namespace impl {

template <typename DerivedT>
class TPUSpaceToDepthPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUSpaceToDepthPassBase;

  TPUSpaceToDepthPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUSpaceToDepthPassBase(const TPUSpaceToDepthPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUSpaceToDepthPassBase& operator=(const TPUSpaceToDepthPassBase &) = delete;
  TPUSpaceToDepthPassBase(TPUSpaceToDepthPassBase &&) = delete;
  TPUSpaceToDepthPassBase& operator=(TPUSpaceToDepthPassBase &&) = delete;
  ~TPUSpaceToDepthPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-space-to-depth-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-space-to-depth-pass"; }

  ::llvm::StringRef getDescription() const override { return "Applies automatic space to depth transform for the first or frontier convolutions consume host inputs on TPU."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUSpaceToDepthPass");
  }
  ::llvm::StringRef getName() const override { return "TPUSpaceToDepthPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUSpaceToDepthPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUSPACETODEPTHPASS
#endif // GEN_PASS_DEF_TPUSPACETODEPTHPASS

//===----------------------------------------------------------------------===//
// TPUUpdateEmbeddingEnqueueOpInputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#undef GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#endif // GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#ifdef GEN_PASS_DEF_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
namespace impl {

template <typename DerivedT>
class TPUUpdateEmbeddingEnqueueOpInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUUpdateEmbeddingEnqueueOpInputsPassBase;

  TPUUpdateEmbeddingEnqueueOpInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUUpdateEmbeddingEnqueueOpInputsPassBase(const TPUUpdateEmbeddingEnqueueOpInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUUpdateEmbeddingEnqueueOpInputsPassBase& operator=(const TPUUpdateEmbeddingEnqueueOpInputsPassBase &) = delete;
  TPUUpdateEmbeddingEnqueueOpInputsPassBase(TPUUpdateEmbeddingEnqueueOpInputsPassBase &&) = delete;
  TPUUpdateEmbeddingEnqueueOpInputsPassBase& operator=(TPUUpdateEmbeddingEnqueueOpInputsPassBase &&) = delete;
  ~TPUUpdateEmbeddingEnqueueOpInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-update-embedding-enqueue-op-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-update-embedding-enqueue-op-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Updates inputs to TPU embedding enqueue ops depending on whether graph is in training mode or in evaluation mode."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUUpdateEmbeddingEnqueueOpInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUUpdateEmbeddingEnqueueOpInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUUpdateEmbeddingEnqueueOpInputsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#endif // GEN_PASS_DEF_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS

//===----------------------------------------------------------------------===//
// TPUValidateInputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUVALIDATEINPUTSPASS
#undef GEN_PASS_DECL_TPUVALIDATEINPUTSPASS
#endif // GEN_PASS_DECL_TPUVALIDATEINPUTSPASS
#ifdef GEN_PASS_DEF_TPUVALIDATEINPUTSPASS
namespace impl {

template <typename DerivedT>
class TPUValidateInputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUValidateInputsPassBase;

  TPUValidateInputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUValidateInputsPassBase(const TPUValidateInputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUValidateInputsPassBase& operator=(const TPUValidateInputsPassBase &) = delete;
  TPUValidateInputsPassBase(TPUValidateInputsPassBase &&) = delete;
  TPUValidateInputsPassBase& operator=(TPUValidateInputsPassBase &&) = delete;
  ~TPUValidateInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-validate-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-validate-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Validates inputs to the TPU TF/XLA bridge"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUValidateInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUValidateInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUValidateInputsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUVALIDATEINPUTSPASS
#endif // GEN_PASS_DEF_TPUVALIDATEINPUTSPASS

//===----------------------------------------------------------------------===//
// TensorArrayOpsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#undef GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_TENSORARRAYOPSDECOMPOSITIONPASS
namespace impl {

template <typename DerivedT>
class TensorArrayOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorArrayOpsDecompositionPassBase;

  TensorArrayOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorArrayOpsDecompositionPassBase(const TensorArrayOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TensorArrayOpsDecompositionPassBase& operator=(const TensorArrayOpsDecompositionPassBase &) = delete;
  TensorArrayOpsDecompositionPassBase(TensorArrayOpsDecompositionPassBase &&) = delete;
  TensorArrayOpsDecompositionPassBase& operator=(TensorArrayOpsDecompositionPassBase &&) = delete;
  ~TensorArrayOpsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-array-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-array-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose tensor array operations into local variable operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorArrayOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorArrayOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorArrayOpsDecompositionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORARRAYOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_TENSORARRAYOPSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// TensorDeviceCopyConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#undef GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#endif // GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#ifdef GEN_PASS_DEF_TENSORDEVICECOPYCONVERSIONPASS
namespace impl {

template <typename DerivedT>
class TensorDeviceCopyConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorDeviceCopyConversionPassBase;

  TensorDeviceCopyConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorDeviceCopyConversionPassBase(const TensorDeviceCopyConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TensorDeviceCopyConversionPassBase& operator=(const TensorDeviceCopyConversionPassBase &) = delete;
  TensorDeviceCopyConversionPassBase(TensorDeviceCopyConversionPassBase &&) = delete;
  TensorDeviceCopyConversionPassBase& operator=(TensorDeviceCopyConversionPassBase &&) = delete;
  ~TensorDeviceCopyConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-device-copy");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-device-copy"; }

  ::llvm::StringRef getDescription() const override { return "Fold the tf.Identity op and the tf.IdentityN op if the op has the same device as its operand"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorDeviceCopyConversionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorDeviceCopyConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorDeviceCopyConversionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORDEVICECOPYCONVERSIONPASS
#endif // GEN_PASS_DEF_TENSORDEVICECOPYCONVERSIONPASS

//===----------------------------------------------------------------------===//
// TensorFlowOptimizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#undef GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#endif // GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#ifdef GEN_PASS_DEF_TENSORFLOWOPTIMIZEPASS
namespace impl {

template <typename DerivedT>
class TensorFlowOptimizePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorFlowOptimizePassBase;

  TensorFlowOptimizePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowOptimizePassBase(const TensorFlowOptimizePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TensorFlowOptimizePassBase& operator=(const TensorFlowOptimizePassBase &) = delete;
  TensorFlowOptimizePassBase(TensorFlowOptimizePassBase &&) = delete;
  TensorFlowOptimizePassBase& operator=(TensorFlowOptimizePassBase &&) = delete;
  ~TensorFlowOptimizePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-optimize");
  }
  ::llvm::StringRef getArgument() const override { return "tf-optimize"; }

  ::llvm::StringRef getDescription() const override { return "Optimize TensorFlow module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowOptimizePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowOptimizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowOptimizePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORFLOWOPTIMIZEPASS
#endif // GEN_PASS_DEF_TENSORFLOWOPTIMIZEPASS

//===----------------------------------------------------------------------===//
// TensorFlowShapeInferencePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
struct TensorFlowShapeInferencePassOptions {
  int64_t max_iterations_ = 10;
  std::string input_arg_shapes_;
};
#undef GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
#endif // GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
#ifdef GEN_PASS_DEF_TENSORFLOWSHAPEINFERENCEPASS
namespace impl {

template <typename DerivedT>
class TensorFlowShapeInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorFlowShapeInferencePassBase;

  TensorFlowShapeInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowShapeInferencePassBase(const TensorFlowShapeInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TensorFlowShapeInferencePassBase& operator=(const TensorFlowShapeInferencePassBase &) = delete;
  TensorFlowShapeInferencePassBase(TensorFlowShapeInferencePassBase &&) = delete;
  TensorFlowShapeInferencePassBase& operator=(TensorFlowShapeInferencePassBase &&) = delete;
  ~TensorFlowShapeInferencePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-shape-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-shape-inference"; }

  ::llvm::StringRef getDescription() const override { return "Shape inference on TF dialect and ops implementing InferTypeOpInterface"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowShapeInferencePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowShapeInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowShapeInferencePassBase<DerivedT>)

  TensorFlowShapeInferencePassBase(const TensorFlowShapeInferencePassOptions &options) : TensorFlowShapeInferencePassBase() {
    max_iterations_ = options.max_iterations_;
    input_arg_shapes_ = options.input_arg_shapes_;
  }
protected:
  ::mlir::Pass::Option<int64_t> max_iterations_{*this, "max-iterations", ::llvm::cl::desc("Maximum shape inference iterations"), ::llvm::cl::init(10)};
  ::mlir::Pass::Option<std::string> input_arg_shapes_{*this, "input-arg-shapes", ::llvm::cl::desc("Input tensor shapes. Shapes for different tensors are separated by ':', and dimension sizes for the same tensor are separated by ','")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORFLOWSHAPEINFERENCEPASS
#endif // GEN_PASS_DEF_TENSORFLOWSHAPEINFERENCEPASS

//===----------------------------------------------------------------------===//
// TensorListOpsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#undef GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_TENSORLISTOPSDECOMPOSITIONPASS
namespace impl {

template <typename DerivedT>
class TensorListOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorListOpsDecompositionPassBase;

  TensorListOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorListOpsDecompositionPassBase(const TensorListOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TensorListOpsDecompositionPassBase& operator=(const TensorListOpsDecompositionPassBase &) = delete;
  TensorListOpsDecompositionPassBase(TensorListOpsDecompositionPassBase &&) = delete;
  TensorListOpsDecompositionPassBase& operator=(TensorListOpsDecompositionPassBase &&) = delete;
  ~TensorListOpsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-list-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-list-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes TensorList operations into generic operations on tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorListOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorListOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorListOpsDecompositionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORLISTOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_TENSORLISTOPSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// TensorflowGPUFusion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORFLOWGPUFUSION
#undef GEN_PASS_DECL_TENSORFLOWGPUFUSION
#endif // GEN_PASS_DECL_TENSORFLOWGPUFUSION
#ifdef GEN_PASS_DEF_TENSORFLOWGPUFUSION
namespace impl {

template <typename DerivedT>
class TensorflowGPUFusionBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorflowGPUFusionBase;

  TensorflowGPUFusionBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorflowGPUFusionBase(const TensorflowGPUFusionBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TensorflowGPUFusionBase& operator=(const TensorflowGPUFusionBase &) = delete;
  TensorflowGPUFusionBase(TensorflowGPUFusionBase &&) = delete;
  TensorflowGPUFusionBase& operator=(TensorflowGPUFusionBase &&) = delete;
  ~TensorflowGPUFusionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-gpu-op-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-gpu-op-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fusion optimization for GPU targets"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorflowGPUFusion");
  }
  ::llvm::StringRef getName() const override { return "TensorflowGPUFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorflowGPUFusionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORFLOWGPUFUSION
#endif // GEN_PASS_DEF_TENSORFLOWGPUFUSION

//===----------------------------------------------------------------------===//
// TpuV1BridgeExecutorIslandCoarseningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#undef GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#ifdef GEN_PASS_DEF_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
namespace impl {

template <typename DerivedT>
class TpuV1BridgeExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TpuV1BridgeExecutorIslandCoarseningPassBase;

  TpuV1BridgeExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TpuV1BridgeExecutorIslandCoarseningPassBase(const TpuV1BridgeExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TpuV1BridgeExecutorIslandCoarseningPassBase& operator=(const TpuV1BridgeExecutorIslandCoarseningPassBase &) = delete;
  TpuV1BridgeExecutorIslandCoarseningPassBase(TpuV1BridgeExecutorIslandCoarseningPassBase &&) = delete;
  TpuV1BridgeExecutorIslandCoarseningPassBase& operator=(TpuV1BridgeExecutorIslandCoarseningPassBase &&) = delete;
  ~TpuV1BridgeExecutorIslandCoarseningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Merges TPU clusters IslandOps, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TpuV1BridgeExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "TpuV1BridgeExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TpuV1BridgeExecutorIslandCoarseningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DEF_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS

//===----------------------------------------------------------------------===//
// TransformEinsumPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMEINSUMPASS
#undef GEN_PASS_DECL_TRANSFORMEINSUMPASS
#endif // GEN_PASS_DECL_TRANSFORMEINSUMPASS
#ifdef GEN_PASS_DEF_TRANSFORMEINSUMPASS
namespace impl {

template <typename DerivedT>
class TransformEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformEinsumPassBase;

  TransformEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformEinsumPassBase(const TransformEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TransformEinsumPassBase& operator=(const TransformEinsumPassBase &) = delete;
  TransformEinsumPassBase(TransformEinsumPassBase &&) = delete;
  TransformEinsumPassBase& operator=(TransformEinsumPassBase &&) = delete;
  ~TransformEinsumPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Transform Einsum to other TF Ops for the supported variants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "TransformEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformEinsumPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMEINSUMPASS
#endif // GEN_PASS_DEF_TRANSFORMEINSUMPASS

//===----------------------------------------------------------------------===//
// UnrollBatchMatMulPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#undef GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#endif // GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#ifdef GEN_PASS_DEF_UNROLLBATCHMATMULPASS
namespace impl {

template <typename DerivedT>
class UnrollBatchMatMulPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnrollBatchMatMulPassBase;

  UnrollBatchMatMulPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnrollBatchMatMulPassBase(const UnrollBatchMatMulPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  UnrollBatchMatMulPassBase& operator=(const UnrollBatchMatMulPassBase &) = delete;
  UnrollBatchMatMulPassBase(UnrollBatchMatMulPassBase &&) = delete;
  UnrollBatchMatMulPassBase& operator=(UnrollBatchMatMulPassBase &&) = delete;
  ~UnrollBatchMatMulPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-unroll-batch-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tf-unroll-batch-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Unroll TF BatchMatMul op into Reshape, Slice, MatMul, Pack ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnrollBatchMatMulPass");
  }
  ::llvm::StringRef getName() const override { return "UnrollBatchMatMulPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnrollBatchMatMulPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_UNROLLBATCHMATMULPASS
#endif // GEN_PASS_DEF_UNROLLBATCHMATMULPASS

//===----------------------------------------------------------------------===//
// VerifySuitableForExportPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#undef GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#endif // GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#ifdef GEN_PASS_DEF_VERIFYSUITABLEFOREXPORTPASS
namespace impl {

template <typename DerivedT>
class VerifySuitableForExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = VerifySuitableForExportPassBase;

  VerifySuitableForExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VerifySuitableForExportPassBase(const VerifySuitableForExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  VerifySuitableForExportPassBase& operator=(const VerifySuitableForExportPassBase &) = delete;
  VerifySuitableForExportPassBase(VerifySuitableForExportPassBase &&) = delete;
  VerifySuitableForExportPassBase& operator=(VerifySuitableForExportPassBase &&) = delete;
  ~VerifySuitableForExportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-verify-for-export");
  }
  ::llvm::StringRef getArgument() const override { return "tf-verify-for-export"; }

  ::llvm::StringRef getDescription() const override { return "Verify module is suitable for export back to TF Graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VerifySuitableForExportPass");
  }
  ::llvm::StringRef getName() const override { return "VerifySuitableForExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VerifySuitableForExportPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VERIFYSUITABLEFOREXPORTPASS
#endif // GEN_PASS_DEF_VERIFYSUITABLEFOREXPORTPASS

//===----------------------------------------------------------------------===//
// XlaCallModuleDeserializationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_XLACALLMODULEDESERIALIZATIONPASS
#undef GEN_PASS_DECL_XLACALLMODULEDESERIALIZATIONPASS
#endif // GEN_PASS_DECL_XLACALLMODULEDESERIALIZATIONPASS
#ifdef GEN_PASS_DEF_XLACALLMODULEDESERIALIZATIONPASS
namespace impl {

template <typename DerivedT>
class XlaCallModuleDeserializationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = XlaCallModuleDeserializationPassBase;

  XlaCallModuleDeserializationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  XlaCallModuleDeserializationPassBase(const XlaCallModuleDeserializationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  XlaCallModuleDeserializationPassBase& operator=(const XlaCallModuleDeserializationPassBase &) = delete;
  XlaCallModuleDeserializationPassBase(XlaCallModuleDeserializationPassBase &&) = delete;
  XlaCallModuleDeserializationPassBase& operator=(XlaCallModuleDeserializationPassBase &&) = delete;
  ~XlaCallModuleDeserializationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-xla-call-module-deserialization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-xla-call-module-deserialization"; }

  ::llvm::StringRef getDescription() const override { return "Deserializes StableHLO functions embedded in `tf.XlaCallModule` to top level module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XlaCallModuleDeserializationPass");
  }
  ::llvm::StringRef getName() const override { return "XlaCallModuleDeserializationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<chlo::ChloDialect>();
    registry.insert<mhlo::MhloDialect>();
    registry.insert<shape::ShapeDialect>();
    registry.insert<stablehlo::StablehloDialect>();
    registry.insert<vhlo::VhloDialect>();
    registry.insert<quant::QuantizationDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XlaCallModuleDeserializationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_XLACALLMODULEDESERIALIZATIONPASS
#endif // GEN_PASS_DEF_XLACALLMODULEDESERIALIZATIONPASS

//===----------------------------------------------------------------------===//
// XlaCallModuleSerializationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_XLACALLMODULESERIALIZATIONPASS
#undef GEN_PASS_DECL_XLACALLMODULESERIALIZATIONPASS
#endif // GEN_PASS_DECL_XLACALLMODULESERIALIZATIONPASS
#ifdef GEN_PASS_DEF_XLACALLMODULESERIALIZATIONPASS
namespace impl {

template <typename DerivedT>
class XlaCallModuleSerializationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = XlaCallModuleSerializationPassBase;

  XlaCallModuleSerializationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  XlaCallModuleSerializationPassBase(const XlaCallModuleSerializationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  XlaCallModuleSerializationPassBase& operator=(const XlaCallModuleSerializationPassBase &) = delete;
  XlaCallModuleSerializationPassBase(XlaCallModuleSerializationPassBase &&) = delete;
  XlaCallModuleSerializationPassBase& operator=(XlaCallModuleSerializationPassBase &&) = delete;
  ~XlaCallModuleSerializationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-xla-call-module-serialization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-xla-call-module-serialization"; }

  ::llvm::StringRef getDescription() const override { return "Serializes StableHLO functions from top-level module into `tf.XlaCallModule`'s `module` attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XlaCallModuleSerializationPass");
  }
  ::llvm::StringRef getName() const override { return "XlaCallModuleSerializationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<stablehlo::StablehloDialect>();
    registry.insert<vhlo::VhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XlaCallModuleSerializationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_XLACALLMODULESERIALIZATIONPASS
#endif // GEN_PASS_DEF_XLACALLMODULESERIALIZATIONPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BatchMatMulToEinsumPass Registration
//===----------------------------------------------------------------------===//

inline void registerBatchMatMulToEinsumPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBatchMatMulToEinsumPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBatchMatMulToEinsumPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBatchMatMulToEinsumPass();
  });
}

//===----------------------------------------------------------------------===//
// BreakUpIslandsPass Registration
//===----------------------------------------------------------------------===//

inline void registerBreakUpIslandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateBreakUpIslandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBreakUpIslandsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateBreakUpIslandsPass();
  });
}

//===----------------------------------------------------------------------===//
// BroadcastFoldPass Registration
//===----------------------------------------------------------------------===//

inline void registerBroadcastFoldPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBroadcastFoldPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBroadcastFoldPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBroadcastFoldPass();
  });
}

//===----------------------------------------------------------------------===//
// CanonicalizeCompileAndReplicateAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerCanonicalizeCompileAndReplicateAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateCanonicalizeCompileAndReplicateAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCanonicalizeCompileAndReplicateAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateCanonicalizeCompileAndReplicateAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterConstantSinkingPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterConstantSinkingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterConstantSinkingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterConstantSinkingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterConstantSinkingPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterFormationPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterFormationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterFormationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterFormationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterFormationPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterTFOpsByHostPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterTFOpsByHostPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateClusterTFOpsByHostPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterTFOpsByHostPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateClusterTFOpsByHostPass();
  });
}

//===----------------------------------------------------------------------===//
// ColocateTPUCopyWithDynamicShapePass Registration
//===----------------------------------------------------------------------===//

inline void registerColocateTPUCopyWithDynamicShapePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateColocateTPUCopyWithDynamicShapePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerColocateTPUCopyWithDynamicShapePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateColocateTPUCopyWithDynamicShapePass();
  });
}

//===----------------------------------------------------------------------===//
// ConstantOpDeviceAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerConstantOpDeviceAssignmentPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConstantOpDeviceAssignmentPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConstantOpDeviceAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConstantOpDeviceAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToTFCallPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLaunchFuncToTFCallPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateConvertLaunchFuncToTFCallPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLaunchFuncToTFCallPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateConvertLaunchFuncToTFCallPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertReadonlyReferenceVariablesToResourceVariablesPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertReadonlyReferenceVariablesToResourceVariablesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConvertReadonlyReferenceVariablesToResourceVariablesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertReadonlyReferenceVariablesToResourceVariablesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConvertReadonlyReferenceVariablesToResourceVariablesPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertTfControlFlowToScfPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertTfControlFlowToScfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::createConvertTfControlFlowToScfPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertTfControlFlowToScfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::createConvertTfControlFlowToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertToLegacyCompileAndReplicateAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertToLegacyCompileAndReplicateAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateConvertToLegacyCompileAndReplicateAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertToLegacyCompileAndReplicateAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateConvertToLegacyCompileAndReplicateAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// DecomposeOptionalsPass Registration
//===----------------------------------------------------------------------===//

inline void registerDecomposeOptionalsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDecomposeOptionalsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDecomposeOptionalsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDecomposeOptionalsPass();
  });
}

//===----------------------------------------------------------------------===//
// DecomposeReduceDatasetPass Registration
//===----------------------------------------------------------------------===//

inline void registerDecomposeReduceDatasetPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDecomposeReduceDatasetPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDecomposeReduceDatasetPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDecomposeReduceDatasetPass();
  });
}

//===----------------------------------------------------------------------===//
// DeviceIndexSelectorPass Registration
//===----------------------------------------------------------------------===//

inline void registerDeviceIndexSelectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDeviceIndexSelectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDeviceIndexSelectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDeviceIndexSelectorPass();
  });
}

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantInDeviceClusterPass Registration
//===----------------------------------------------------------------------===//

inline void registerDropWhileShapeInvariantInDeviceClusterPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantInDeviceClusterPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDropWhileShapeInvariantInDeviceClusterPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantInDeviceClusterPass();
  });
}

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantPass Registration
//===----------------------------------------------------------------------===//

inline void registerDropWhileShapeInvariantPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDropWhileShapeInvariantPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorCheckControlDependenciesPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorCheckControlDependenciesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorCheckControlDependenciesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorCheckControlDependenciesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorCheckControlDependenciesPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorConvertControlToDataOutputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorConvertControlToDataOutputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorConvertControlToDataOutputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorConvertControlToDataOutputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorConvertControlToDataOutputsPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorDialectToFunctionalPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorDialectToFunctionalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExecutorDialectToFunctionalConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorDialectToFunctionalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExecutorDialectToFunctionalConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorGraphPruningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorGraphPruningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorGraphPruningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorGraphPruningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorGraphPruningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorIslandCoarseningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorIslandCoarseningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorIslandCoarseningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorIslandCoarseningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorIslandCoarseningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorTPUV1IslandInliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorTPUV1IslandInliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandInliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorTPUV1IslandInliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandInliningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorUpdateControlDependenciesPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorUpdateControlDependenciesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorUpdateControlDependenciesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorUpdateControlDependenciesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorUpdateControlDependenciesPass();
  });
}

//===----------------------------------------------------------------------===//
// ExtractTPUCopyWithDynamicShapeOpPass Registration
//===----------------------------------------------------------------------===//

inline void registerExtractTPUCopyWithDynamicShapeOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateExtractTPUCopyWithDynamicShapeOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExtractTPUCopyWithDynamicShapeOpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateExtractTPUCopyWithDynamicShapeOpPass();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToCFGPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalControlFlowToCFGPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToCFG();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFunctionalControlFlowToCFGPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToCFG();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToRegionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalControlFlowToRegionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToRegions();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFunctionalControlFlowToRegionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToRegions();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalToExecutorDialectConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalToExecutorDialectConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFunctionalToExecutorDialectConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFunctionalToExecutorDialectConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFunctionalToExecutorDialectConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// FusedKernelMatcherPass Registration
//===----------------------------------------------------------------------===//

inline void registerFusedKernelMatcherPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateFusedKernelMatcherPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFusedKernelMatcherPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateFusedKernelMatcherPass();
  });
}

//===----------------------------------------------------------------------===//
// GroupByDialectPass Registration
//===----------------------------------------------------------------------===//

inline void registerGroupByDialectPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGroupByDialectPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGroupByDialectPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGroupByDialectPass();
  });
}

//===----------------------------------------------------------------------===//
// GuaranteeAllFuncsOneUsePass Registration
//===----------------------------------------------------------------------===//

inline void registerGuaranteeAllFuncsOneUsePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGuaranteeAllFuncsOneUsePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGuaranteeAllFuncsOneUsePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGuaranteeAllFuncsOneUsePass();
  });
}

//===----------------------------------------------------------------------===//
// HoistLoopInvariantPass Registration
//===----------------------------------------------------------------------===//

inline void registerHoistLoopInvariantPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateHoistLoopInvariantPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHoistLoopInvariantPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateHoistLoopInvariantPass();
  });
}

//===----------------------------------------------------------------------===//
// HoistReplicateInvariantResourceWritesPass Registration
//===----------------------------------------------------------------------===//

inline void registerHoistReplicateInvariantResourceWritesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateHoistReplicateInvariantResourceWritesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHoistReplicateInvariantResourceWritesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateHoistReplicateInvariantResourceWritesPass();
  });
}

//===----------------------------------------------------------------------===//
// InitTextFileToImportPass Registration
//===----------------------------------------------------------------------===//

inline void registerInitTextFileToImportPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateInitTextFileToImportPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerInitTextFileToImportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateInitTextFileToImportPass();
  });
}

//===----------------------------------------------------------------------===//
// LaunchOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerLaunchOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateLaunchOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLaunchOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateLaunchOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// LayoutAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerLayoutAssignmentPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLayoutAssignmentPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLayoutAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLayoutAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTFGToTFPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFGToTFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeTFGToTFEPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeTFGToTFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeTFGToTFEPass();
  });
}

//===----------------------------------------------------------------------===//
// LocalizeVarHandlesPass Registration
//===----------------------------------------------------------------------===//

inline void registerLocalizeVarHandlesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLocalizeVarHandlesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLocalizeVarHandlesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLocalizeVarHandlesPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerQuantizedPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerQuantizedPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLowerQuantizedPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerQuantizedPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLowerQuantizedPass();
  });
}

//===----------------------------------------------------------------------===//
// MarkInputOutputAliasesPass Registration
//===----------------------------------------------------------------------===//

inline void registerMarkInputOutputAliasesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkInputOutputAliasesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMarkInputOutputAliasesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkInputOutputAliasesPass();
  });
}

//===----------------------------------------------------------------------===//
// MaterializePassthroughOp Registration
//===----------------------------------------------------------------------===//

inline void registerMaterializePassthroughOp() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMaterializePassthroughOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMaterializePassthroughOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMaterializePassthroughOpPass();
  });
}

//===----------------------------------------------------------------------===//
// MergeControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerMergeControlFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMergeControlFlowPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergeControlFlowPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMergeControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// MoveTpuCompileToFrontPass Registration
//===----------------------------------------------------------------------===//

inline void registerMoveTpuCompileToFrontPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMoveTpuCompileToFrontPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMoveTpuCompileToFrontPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMoveTpuCompileToFrontPass();
  });
}

//===----------------------------------------------------------------------===//
// MoveTransposesPass Registration
//===----------------------------------------------------------------------===//

inline void registerMoveTransposesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMoveTransposesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMoveTransposesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMoveTransposesPass();
  });
}

//===----------------------------------------------------------------------===//
// NameAnonymousIteratorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerNameAnonymousIteratorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateNameAnonymousIteratorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNameAnonymousIteratorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateNameAnonymousIteratorsPass();
  });
}

//===----------------------------------------------------------------------===//
// OrderByDialectPass Registration
//===----------------------------------------------------------------------===//

inline void registerOrderByDialectPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateOrderByDialectPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOrderByDialectPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateOrderByDialectPass();
  });
}

//===----------------------------------------------------------------------===//
// ParallelExecuteToIslandsPass Registration
//===----------------------------------------------------------------------===//

inline void registerParallelExecuteToIslandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateParallelExecuteToIslandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerParallelExecuteToIslandsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateParallelExecuteToIslandsPass();
  });
}

//===----------------------------------------------------------------------===//
// PrepareTpuComputationForTfExportPass Registration
//===----------------------------------------------------------------------===//

inline void registerPrepareTpuComputationForTfExportPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePrepareTpuComputationForTfExportPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPrepareTpuComputationForTfExportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePrepareTpuComputationForTfExportPass();
  });
}

//===----------------------------------------------------------------------===//
// PrintPass Registration
//===----------------------------------------------------------------------===//

inline void registerPrintPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePrintPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPrintPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePrintPass();
  });
}

//===----------------------------------------------------------------------===//
// PromoteResourcesToArgsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPromoteResourcesToArgsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteResourcesToArgsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPromoteResourcesToArgsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteResourcesToArgsPass();
  });
}

//===----------------------------------------------------------------------===//
// PromoteVarHandlesToArgsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPromoteVarHandlesToArgsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteVarHandlesToArgsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPromoteVarHandlesToArgsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteVarHandlesToArgsPass();
  });
}

//===----------------------------------------------------------------------===//
// RegionControlFlowToFunctionalPass Registration
//===----------------------------------------------------------------------===//

inline void registerRegionControlFlowToFunctionalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFRegionControlFlowToFunctional();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRegionControlFlowToFunctionalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFRegionControlFlowToFunctional();
  });
}

//===----------------------------------------------------------------------===//
// RemoveUnusedArgumentsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRemoveUnusedArgumentsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedArgumentsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRemoveUnusedArgumentsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedArgumentsPass();
  });
}

//===----------------------------------------------------------------------===//
// RemoveUnusedWhileResultsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRemoveUnusedWhileResultsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedWhileResultsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRemoveUnusedWhileResultsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedWhileResultsPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicaIDToDeviceOrdinalPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicaIDToDeviceOrdinalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicaIDToDeviceOrdinalPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReplicaIDToDeviceOrdinalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicaIDToDeviceOrdinalPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicateInvariantOpHoistingPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicateInvariantOpHoistingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateInvariantOpHoistingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReplicateInvariantOpHoistingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateInvariantOpHoistingPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicateTensorListInitOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicateTensorListInitOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateReplicateTensorListInitOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReplicateTensorListInitOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateReplicateTensorListInitOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicateToIslandPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicateToIslandPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateToIslandPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReplicateToIslandPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateToIslandPass();
  });
}

//===----------------------------------------------------------------------===//
// ResourceDeviceInferencePass Registration
//===----------------------------------------------------------------------===//

inline void registerResourceDeviceInferencePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateResourceDeviceInferencePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerResourceDeviceInferencePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateResourceDeviceInferencePass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteTPUEmbeddingOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteTPUEmbeddingOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRewriteTPUEmbeddingOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteTPUEmbeddingOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRewriteTPUEmbeddingOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// SimpleTFDeviceAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerSimpleTFDeviceAssignmentPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateSimpleTFDeviceAssignmentPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimpleTFDeviceAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateSimpleTFDeviceAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// SplitIntoIslandPerOpPass Registration
//===----------------------------------------------------------------------===//

inline void registerSplitIntoIslandPerOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::TF::CreateSplitIntoIslandPerOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSplitIntoIslandPerOpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::TF::CreateSplitIntoIslandPerOpPass();
  });
}

//===----------------------------------------------------------------------===//
// StackOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerStackOpsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStackOpsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStackOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStackOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// StripNoinlineAttributePass Registration
//===----------------------------------------------------------------------===//

inline void registerStripNoinlineAttributePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripNoinlineAttributePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStripNoinlineAttributePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripNoinlineAttributePass();
  });
}

//===----------------------------------------------------------------------===//
// StripTfAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerStripTfAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripTfAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStripTfAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripTfAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// TFDataOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFDataOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDataOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTFDataOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDataOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// TFDeviceAssignmentByFuncAttrPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFDeviceAssignmentByFuncAttrPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDeviceAssignmentByFuncAttrPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTFDeviceAssignmentByFuncAttrPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDeviceAssignmentByFuncAttrPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUAnnotateDynamicShapeInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUAnnotateDynamicShapeInputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUAnnotateDynamicShapeInputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUAnnotateDynamicShapeInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUAnnotateDynamicShapeInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUBridgeExecutorIslandOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUBridgeExecutorIslandOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUBridgeExecutorIslandOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUCleanupClusterAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUCleanupClusterAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterCleanupAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUCleanupClusterAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterCleanupAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUColocateCompositeResourceOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUColocateCompositeResourceOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUColocateCompositeResourceOps();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUColocateCompositeResourceOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUColocateCompositeResourceOps();
  });
}

//===----------------------------------------------------------------------===//
// TPUColocateSplitsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUColocateSplitsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUColocateSplitsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUColocateSplitsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUColocateSplitsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUDevicePropagationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUDevicePropagationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDevicePropagationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUDevicePropagationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDevicePropagationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUDynamicLayoutPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUDynamicLayoutPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDynamicLayoutPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUDynamicLayoutPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDynamicLayoutPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUHostComputationExpansionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUHostComputationExpansionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUHostComputationExpansionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUHostComputationExpansionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUHostComputationExpansionPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUIdentityPruningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUIdentityPruningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUIdentityPruningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUIdentityPruningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUIdentityPruningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUParallelExecuteSinkResourceWritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUParallelExecuteSinkResourceWritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUParallelExecuteSinkResourceWritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUParallelExecuteSinkResourceWritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUParallelExecuteSinkResourceWritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUPartitionedOpConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUPartitionedOpConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUPartitionedOpConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUPartitionedOpConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUPartitionedOpConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUReorderReplicateAndPartitionedInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUReorderReplicateAndPartitionedInputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUReorderReplicateAndPartitionedInputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUReorderReplicateAndPartitionedInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUReorderReplicateAndPartitionedInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUResourceReadForWritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUResourceReadForWritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadForWritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUResourceReadForWritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadForWritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUResourceReadsWritesPartitioningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUResourceReadsWritesPartitioningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadsWritesPartitioningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUResourceReadsWritesPartitioningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadsWritesPartitioningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUSpaceToDepthPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUSpaceToDepthPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUSpaceToDepthPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUSpaceToDepthPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUSpaceToDepthPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUUpdateEmbeddingEnqueueOpInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUUpdateEmbeddingEnqueueOpInputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUUpdateEmbeddingEnqueueOpInputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUUpdateEmbeddingEnqueueOpInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUUpdateEmbeddingEnqueueOpInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUValidateInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUValidateInputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUValidateInputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUValidateInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUValidateInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorArrayOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorArrayOpsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorArrayOpsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorArrayOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorArrayOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorDeviceCopyConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorDeviceCopyConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorDeviceCopyConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorDeviceCopyConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorDeviceCopyConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlowOptimizePass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowOptimizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFOptimizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorFlowOptimizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFOptimizePass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlowShapeInferencePass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowShapeInferencePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFShapeInferencePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorFlowShapeInferencePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFShapeInferencePass();
  });
}

//===----------------------------------------------------------------------===//
// TensorListOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorListOpsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorListOpsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorListOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorListOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorflowGPUFusion Registration
//===----------------------------------------------------------------------===//

inline void registerTensorflowGPUFusion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGpuOpFusionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorflowGPUFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGpuOpFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// TpuV1BridgeExecutorIslandCoarseningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTpuV1BridgeExecutorIslandCoarseningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandCoarseningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTpuV1BridgeExecutorIslandCoarseningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandCoarseningPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformEinsumPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformEinsumPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTransformEinsumPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformEinsumPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTransformEinsumPass();
  });
}

//===----------------------------------------------------------------------===//
// UnrollBatchMatMulPass Registration
//===----------------------------------------------------------------------===//

inline void registerUnrollBatchMatMulPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateUnrollBatchMatMulPassPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUnrollBatchMatMulPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateUnrollBatchMatMulPassPass();
  });
}

//===----------------------------------------------------------------------===//
// VerifySuitableForExportPass Registration
//===----------------------------------------------------------------------===//

inline void registerVerifySuitableForExportPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateVerifySuitableForExportPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVerifySuitableForExportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateVerifySuitableForExportPass();
  });
}

//===----------------------------------------------------------------------===//
// XlaCallModuleDeserializationPass Registration
//===----------------------------------------------------------------------===//

inline void registerXlaCallModuleDeserializationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateXlaCallModuleDeserializationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerXlaCallModuleDeserializationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateXlaCallModuleDeserializationPass();
  });
}

//===----------------------------------------------------------------------===//
// XlaCallModuleSerializationPass Registration
//===----------------------------------------------------------------------===//

inline void registerXlaCallModuleSerializationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateXlaCallModuleSerializationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerXlaCallModuleSerializationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateXlaCallModuleSerializationPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlow Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowPasses() {
  registerBatchMatMulToEinsumPass();
  registerBreakUpIslandsPass();
  registerBroadcastFoldPass();
  registerCanonicalizeCompileAndReplicateAttributesPass();
  registerClusterConstantSinkingPass();
  registerClusterFormationPass();
  registerClusterOutliningPass();
  registerClusterTFOpsByHostPass();
  registerColocateTPUCopyWithDynamicShapePass();
  registerConstantOpDeviceAssignmentPass();
  registerConvertLaunchFuncToTFCallPass();
  registerConvertReadonlyReferenceVariablesToResourceVariablesPass();
  registerConvertTfControlFlowToScfPass();
  registerConvertToLegacyCompileAndReplicateAttributesPass();
  registerDecomposeOptionalsPass();
  registerDecomposeReduceDatasetPass();
  registerDeviceIndexSelectorPass();
  registerDropWhileShapeInvariantInDeviceClusterPass();
  registerDropWhileShapeInvariantPass();
  registerExecutorCheckControlDependenciesPass();
  registerExecutorConvertControlToDataOutputsPass();
  registerExecutorDialectToFunctionalPass();
  registerExecutorGraphPruningPass();
  registerExecutorIslandCoarseningPass();
  registerExecutorTPUV1IslandInliningPass();
  registerExecutorUpdateControlDependenciesPass();
  registerExtractTPUCopyWithDynamicShapeOpPass();
  registerFunctionalControlFlowToCFGPass();
  registerFunctionalControlFlowToRegionsPass();
  registerFunctionalToExecutorDialectConversionPass();
  registerFusedKernelMatcherPass();
  registerGroupByDialectPass();
  registerGuaranteeAllFuncsOneUsePass();
  registerHoistLoopInvariantPass();
  registerHoistReplicateInvariantResourceWritesPass();
  registerInitTextFileToImportPass();
  registerLaunchOutliningPass();
  registerLayoutAssignmentPass();
  registerLegalizeTFGToTFPass();
  registerLocalizeVarHandlesPass();
  registerLowerQuantizedPass();
  registerMarkInputOutputAliasesPass();
  registerMaterializePassthroughOp();
  registerMergeControlFlowPass();
  registerMoveTpuCompileToFrontPass();
  registerMoveTransposesPass();
  registerNameAnonymousIteratorsPass();
  registerOrderByDialectPass();
  registerParallelExecuteToIslandsPass();
  registerPrepareTpuComputationForTfExportPass();
  registerPrintPass();
  registerPromoteResourcesToArgsPass();
  registerPromoteVarHandlesToArgsPass();
  registerRegionControlFlowToFunctionalPass();
  registerRemoveUnusedArgumentsPass();
  registerRemoveUnusedWhileResultsPass();
  registerReplicaIDToDeviceOrdinalPass();
  registerReplicateInvariantOpHoistingPass();
  registerReplicateTensorListInitOpsPass();
  registerReplicateToIslandPass();
  registerResourceDeviceInferencePass();
  registerRewriteTPUEmbeddingOpsPass();
  registerSimpleTFDeviceAssignmentPass();
  registerSplitIntoIslandPerOpPass();
  registerStackOpsDecompositionPass();
  registerStripNoinlineAttributePass();
  registerStripTfAttributesPass();
  registerTFDataOptimizationPass();
  registerTFDeviceAssignmentByFuncAttrPass();
  registerTPUAnnotateDynamicShapeInputsPass();
  registerTPUBridgeExecutorIslandOutliningPass();
  registerTPUCleanupClusterAttributesPass();
  registerTPUColocateCompositeResourceOpsPass();
  registerTPUColocateSplitsPass();
  registerTPUDevicePropagationPass();
  registerTPUDynamicLayoutPass();
  registerTPUHostComputationExpansionPass();
  registerTPUIdentityPruningPass();
  registerTPUParallelExecuteSinkResourceWritePass();
  registerTPUPartitionedOpConversionPass();
  registerTPUReorderReplicateAndPartitionedInputsPass();
  registerTPUResourceReadForWritePass();
  registerTPUResourceReadsWritesPartitioningPass();
  registerTPUSpaceToDepthPass();
  registerTPUUpdateEmbeddingEnqueueOpInputsPass();
  registerTPUValidateInputsPass();
  registerTensorArrayOpsDecompositionPass();
  registerTensorDeviceCopyConversionPass();
  registerTensorFlowOptimizePass();
  registerTensorFlowShapeInferencePass();
  registerTensorListOpsDecompositionPass();
  registerTensorflowGPUFusion();
  registerTpuV1BridgeExecutorIslandCoarseningPass();
  registerTransformEinsumPass();
  registerUnrollBatchMatMulPass();
  registerVerifySuitableForExportPass();
  registerXlaCallModuleDeserializationPass();
  registerXlaCallModuleSerializationPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class BatchMatMulToEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BatchMatMulToEinsumPassBase;

  BatchMatMulToEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BatchMatMulToEinsumPassBase(const BatchMatMulToEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BatchMatMulToEinsumPassBase& operator=(const BatchMatMulToEinsumPassBase &) = delete;
  BatchMatMulToEinsumPassBase(BatchMatMulToEinsumPassBase &&) = delete;
  BatchMatMulToEinsumPassBase& operator=(BatchMatMulToEinsumPassBase &&) = delete;
  ~BatchMatMulToEinsumPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-batch-matmul-to-tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-batch-matmul-to-tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Replace TF BatchMatMul op by TF Einsum op."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BatchMatMulToEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "BatchMatMulToEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BatchMatMulToEinsumPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BreakUpIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BreakUpIslandsPassBase;

  BreakUpIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BreakUpIslandsPassBase(const BreakUpIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BreakUpIslandsPassBase& operator=(const BreakUpIslandsPassBase &) = delete;
  BreakUpIslandsPassBase(BreakUpIslandsPassBase &&) = delete;
  BreakUpIslandsPassBase& operator=(BreakUpIslandsPassBase &&) = delete;
  ~BreakUpIslandsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-break-up-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-break-up-islands"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BreakUpIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "BreakUpIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BreakUpIslandsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BroadcastFoldPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BroadcastFoldPassBase;

  BroadcastFoldPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastFoldPassBase(const BroadcastFoldPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BroadcastFoldPassBase& operator=(const BroadcastFoldPassBase &) = delete;
  BroadcastFoldPassBase(BroadcastFoldPassBase &&) = delete;
  BroadcastFoldPassBase& operator=(BroadcastFoldPassBase &&) = delete;
  ~BroadcastFoldPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-broadcast-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tf-broadcast-fold"; }

  ::llvm::StringRef getDescription() const override { return "Fold explicit broadcasts into the following operations if they support implicit broadcasting on their operand."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastFoldPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastFoldPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CanonicalizeCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CanonicalizeCompileAndReplicateAttributesPassBase;

  CanonicalizeCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CanonicalizeCompileAndReplicateAttributesPassBase(const CanonicalizeCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  CanonicalizeCompileAndReplicateAttributesPassBase& operator=(const CanonicalizeCompileAndReplicateAttributesPassBase &) = delete;
  CanonicalizeCompileAndReplicateAttributesPassBase(CanonicalizeCompileAndReplicateAttributesPassBase &&) = delete;
  CanonicalizeCompileAndReplicateAttributesPassBase& operator=(CanonicalizeCompileAndReplicateAttributesPassBase &&) = delete;
  ~CanonicalizeCompileAndReplicateAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-canonicalize-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-canonicalize-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize compilation and replication attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CanonicalizeCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "CanonicalizeCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CanonicalizeCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterConstantSinkingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterConstantSinkingPassBase;

  ClusterConstantSinkingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterConstantSinkingPassBase(const ClusterConstantSinkingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ClusterConstantSinkingPassBase& operator=(const ClusterConstantSinkingPassBase &) = delete;
  ClusterConstantSinkingPassBase(ClusterConstantSinkingPassBase &&) = delete;
  ClusterConstantSinkingPassBase& operator=(ClusterConstantSinkingPassBase &&) = delete;
  ~ClusterConstantSinkingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-constant-sinking");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-constant-sinking"; }

  ::llvm::StringRef getDescription() const override { return "Sinks constants implicitly captured in a tf_device.cluster region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterConstantSinkingPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterConstantSinkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterConstantSinkingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterFormationPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ClusterFormationPassBase;

  ClusterFormationPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterFormationPassBase(const ClusterFormationPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ClusterFormationPassBase& operator=(const ClusterFormationPassBase &) = delete;
  ClusterFormationPassBase(ClusterFormationPassBase &&) = delete;
  ClusterFormationPassBase& operator=(ClusterFormationPassBase &&) = delete;
  ~ClusterFormationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Form clusters from instructions assigned to same device"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterFormationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterOutliningPassBase;

  ClusterOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterOutliningPassBase(const ClusterOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ClusterOutliningPassBase& operator=(const ClusterOutliningPassBase &) = delete;
  ClusterOutliningPassBase(ClusterOutliningPassBase &&) = delete;
  ClusterOutliningPassBase& operator=(ClusterOutliningPassBase &&) = delete;
  ~ClusterOutliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.cluster operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterOutliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterTFOpsByHostPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterTFOpsByHostPassBase;

  ClusterTFOpsByHostPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterTFOpsByHostPassBase(const ClusterTFOpsByHostPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ClusterTFOpsByHostPassBase& operator=(const ClusterTFOpsByHostPassBase &) = delete;
  ClusterTFOpsByHostPassBase(ClusterTFOpsByHostPassBase &&) = delete;
  ClusterTFOpsByHostPassBase& operator=(ClusterTFOpsByHostPassBase &&) = delete;
  ~ClusterTFOpsByHostPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cluster-tf-ops-by-host");
  }
  ::llvm::StringRef getArgument() const override { return "cluster-tf-ops-by-host"; }

  ::llvm::StringRef getDescription() const override { return "Cluster the TensorFlow ops by host so that each function only contains ops placed on the same host"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterTFOpsByHostPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterTFOpsByHostPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterTFOpsByHostPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ColocateTPUCopyWithDynamicShapePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ColocateTPUCopyWithDynamicShapePassBase;

  ColocateTPUCopyWithDynamicShapePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ColocateTPUCopyWithDynamicShapePassBase(const ColocateTPUCopyWithDynamicShapePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ColocateTPUCopyWithDynamicShapePassBase& operator=(const ColocateTPUCopyWithDynamicShapePassBase &) = delete;
  ColocateTPUCopyWithDynamicShapePassBase(ColocateTPUCopyWithDynamicShapePassBase &&) = delete;
  ColocateTPUCopyWithDynamicShapePassBase& operator=(ColocateTPUCopyWithDynamicShapePassBase &&) = delete;
  ~ColocateTPUCopyWithDynamicShapePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-colocate-tpu-copy-with-dynamic-shape");
  }
  ::llvm::StringRef getArgument() const override { return "tf-colocate-tpu-copy-with-dynamic-shape"; }

  ::llvm::StringRef getDescription() const override { return "Adjusts the device annotation of TPUCopyWithDynamicShape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ColocateTPUCopyWithDynamicShapePass");
  }
  ::llvm::StringRef getName() const override { return "ColocateTPUCopyWithDynamicShapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ColocateTPUCopyWithDynamicShapePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConstantOpDeviceAssignmentPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConstantOpDeviceAssignmentPassBase;

  ConstantOpDeviceAssignmentPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConstantOpDeviceAssignmentPassBase(const ConstantOpDeviceAssignmentPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConstantOpDeviceAssignmentPassBase& operator=(const ConstantOpDeviceAssignmentPassBase &) = delete;
  ConstantOpDeviceAssignmentPassBase(ConstantOpDeviceAssignmentPassBase &&) = delete;
  ConstantOpDeviceAssignmentPassBase& operator=(ConstantOpDeviceAssignmentPassBase &&) = delete;
  ~ConstantOpDeviceAssignmentPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("constant-op-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "constant-op-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Assign device for tf.Const ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConstantOpDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "ConstantOpDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConstantOpDeviceAssignmentPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLaunchFuncToTFCallPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertLaunchFuncToTFCallPassBase;

  ConvertLaunchFuncToTFCallPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLaunchFuncToTFCallPassBase(const ConvertLaunchFuncToTFCallPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertLaunchFuncToTFCallPassBase& operator=(const ConvertLaunchFuncToTFCallPassBase &) = delete;
  ConvertLaunchFuncToTFCallPassBase(ConvertLaunchFuncToTFCallPassBase &&) = delete;
  ConvertLaunchFuncToTFCallPassBase& operator=(ConvertLaunchFuncToTFCallPassBase &&) = delete;
  ~ConvertLaunchFuncToTFCallPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-convert-launch-func-to-tf-call");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-convert-launch-func-to-tf-call"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites tf_device::LaunchFuncOp to TF::PartitionedCallOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLaunchFuncToTFCallPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLaunchFuncToTFCallPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLaunchFuncToTFCallPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertReadonlyReferenceVariablesToResourceVariablesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertReadonlyReferenceVariablesToResourceVariablesPassBase;

  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase(const ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase& operator=(const ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &) = delete;
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &&) = delete;
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase& operator=(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &&) = delete;
  ~ConvertReadonlyReferenceVariablesToResourceVariablesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-readonly-references-to-resources");
  }
  ::llvm::StringRef getArgument() const override { return "tf-readonly-references-to-resources"; }

  ::llvm::StringRef getDescription() const override { return "Convert readonly reference variables to resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertReadonlyReferenceVariablesToResourceVariablesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertReadonlyReferenceVariablesToResourceVariablesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertTfControlFlowToScfPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertTfControlFlowToScfPassBase;

  ConvertTfControlFlowToScfPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTfControlFlowToScfPassBase(const ConvertTfControlFlowToScfPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertTfControlFlowToScfPassBase& operator=(const ConvertTfControlFlowToScfPassBase &) = delete;
  ConvertTfControlFlowToScfPassBase(ConvertTfControlFlowToScfPassBase &&) = delete;
  ConvertTfControlFlowToScfPassBase& operator=(ConvertTfControlFlowToScfPassBase &&) = delete;
  ~ConvertTfControlFlowToScfPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tf-control-flow-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tf-control-flow-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Convert TensorFlow control flow to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTfControlFlowToScfPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTfControlFlowToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTfControlFlowToScfPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertToLegacyCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertToLegacyCompileAndReplicateAttributesPassBase;

  ConvertToLegacyCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToLegacyCompileAndReplicateAttributesPassBase(const ConvertToLegacyCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ConvertToLegacyCompileAndReplicateAttributesPassBase& operator=(const ConvertToLegacyCompileAndReplicateAttributesPassBase &) = delete;
  ConvertToLegacyCompileAndReplicateAttributesPassBase(ConvertToLegacyCompileAndReplicateAttributesPassBase &&) = delete;
  ConvertToLegacyCompileAndReplicateAttributesPassBase& operator=(ConvertToLegacyCompileAndReplicateAttributesPassBase &&) = delete;
  ~ConvertToLegacyCompileAndReplicateAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-convert-to-legacy-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-convert-to-legacy-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Convert unified compilation and replication attributes back to legacy attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToLegacyCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToLegacyCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToLegacyCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DecomposeOptionalsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = DecomposeOptionalsPassBase;

  DecomposeOptionalsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeOptionalsPassBase(const DecomposeOptionalsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  DecomposeOptionalsPassBase& operator=(const DecomposeOptionalsPassBase &) = delete;
  DecomposeOptionalsPassBase(DecomposeOptionalsPassBase &&) = delete;
  DecomposeOptionalsPassBase& operator=(DecomposeOptionalsPassBase &&) = delete;
  ~DecomposeOptionalsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-decompose-optionals");
  }
  ::llvm::StringRef getArgument() const override { return "tf-decompose-optionals"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes ops of the 'Optional' family"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeOptionalsPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeOptionalsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeOptionalsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DecomposeReduceDatasetPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DecomposeReduceDatasetPassBase;

  DecomposeReduceDatasetPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeReduceDatasetPassBase(const DecomposeReduceDatasetPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DecomposeReduceDatasetPassBase& operator=(const DecomposeReduceDatasetPassBase &) = delete;
  DecomposeReduceDatasetPassBase(DecomposeReduceDatasetPassBase &&) = delete;
  DecomposeReduceDatasetPassBase& operator=(DecomposeReduceDatasetPassBase &&) = delete;
  ~DecomposeReduceDatasetPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-decompose-reduce-dataset");
  }
  ::llvm::StringRef getArgument() const override { return "tf-decompose-reduce-dataset"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes ReduceDataset op into dataset operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeReduceDatasetPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeReduceDatasetPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeReduceDatasetPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DeviceIndexSelectorPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeviceIndexSelectorPassBase;

  DeviceIndexSelectorPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeviceIndexSelectorPassBase(const DeviceIndexSelectorPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DeviceIndexSelectorPassBase& operator=(const DeviceIndexSelectorPassBase &) = delete;
  DeviceIndexSelectorPassBase(DeviceIndexSelectorPassBase &&) = delete;
  DeviceIndexSelectorPassBase& operator=(DeviceIndexSelectorPassBase &&) = delete;
  ~DeviceIndexSelectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-index-selector");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-index-selector"; }

  ::llvm::StringRef getDescription() const override { return "Fold tf.DeviceIndex to constant."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeviceIndexSelectorPass");
  }
  ::llvm::StringRef getName() const override { return "DeviceIndexSelectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeviceIndexSelectorPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DropWhileShapeInvariantInDeviceClusterPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantInDeviceClusterPassBase;

  DropWhileShapeInvariantInDeviceClusterPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantInDeviceClusterPassBase(const DropWhileShapeInvariantInDeviceClusterPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DropWhileShapeInvariantInDeviceClusterPassBase& operator=(const DropWhileShapeInvariantInDeviceClusterPassBase &) = delete;
  DropWhileShapeInvariantInDeviceClusterPassBase(DropWhileShapeInvariantInDeviceClusterPassBase &&) = delete;
  DropWhileShapeInvariantInDeviceClusterPassBase& operator=(DropWhileShapeInvariantInDeviceClusterPassBase &&) = delete;
  ~DropWhileShapeInvariantInDeviceClusterPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant-in-device-cluster");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant-in-device-cluster"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops inside device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantInDeviceClusterPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantInDeviceClusterPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantInDeviceClusterPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DropWhileShapeInvariantPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantPassBase;

  DropWhileShapeInvariantPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantPassBase(const DropWhileShapeInvariantPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  DropWhileShapeInvariantPassBase& operator=(const DropWhileShapeInvariantPassBase &) = delete;
  DropWhileShapeInvariantPassBase(DropWhileShapeInvariantPassBase &&) = delete;
  DropWhileShapeInvariantPassBase& operator=(DropWhileShapeInvariantPassBase &&) = delete;
  ~DropWhileShapeInvariantPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorCheckControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorCheckControlDependenciesPassBase;

  ExecutorCheckControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorCheckControlDependenciesPassBase(const ExecutorCheckControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorCheckControlDependenciesPassBase& operator=(const ExecutorCheckControlDependenciesPassBase &) = delete;
  ExecutorCheckControlDependenciesPassBase(ExecutorCheckControlDependenciesPassBase &&) = delete;
  ExecutorCheckControlDependenciesPassBase& operator=(ExecutorCheckControlDependenciesPassBase &&) = delete;
  ~ExecutorCheckControlDependenciesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-check-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-check-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Checks control dependencies"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorCheckControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorCheckControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorCheckControlDependenciesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorConvertControlToDataOutputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorConvertControlToDataOutputsPassBase;

  ExecutorConvertControlToDataOutputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorConvertControlToDataOutputsPassBase(const ExecutorConvertControlToDataOutputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorConvertControlToDataOutputsPassBase& operator=(const ExecutorConvertControlToDataOutputsPassBase &) = delete;
  ExecutorConvertControlToDataOutputsPassBase(ExecutorConvertControlToDataOutputsPassBase &&) = delete;
  ExecutorConvertControlToDataOutputsPassBase& operator=(ExecutorConvertControlToDataOutputsPassBase &&) = delete;
  ~ExecutorConvertControlToDataOutputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-convert-control-to-data-outputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-convert-control-to-data-outputs"; }

  ::llvm::StringRef getDescription() const override { return "Chain control outputs of while loop body"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorConvertControlToDataOutputsPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorConvertControlToDataOutputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorConvertControlToDataOutputsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> composite_tpuexecute_side_effects_{*this, "composite-tpuexecute-side-effects", ::llvm::cl::desc("Enables certain TPUExecute ops to run in parallel if they only operate on resources that live on composite devices."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ExecutorDialectToFunctionalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorDialectToFunctionalPassBase;

  ExecutorDialectToFunctionalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorDialectToFunctionalPassBase(const ExecutorDialectToFunctionalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExecutorDialectToFunctionalPassBase& operator=(const ExecutorDialectToFunctionalPassBase &) = delete;
  ExecutorDialectToFunctionalPassBase(ExecutorDialectToFunctionalPassBase &&) = delete;
  ExecutorDialectToFunctionalPassBase& operator=(ExecutorDialectToFunctionalPassBase &&) = delete;
  ~ExecutorDialectToFunctionalPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-to-functional-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-to-functional-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Lifts tf_executor.island inner ops from a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorDialectToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorDialectToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorDialectToFunctionalPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorGraphPruningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorGraphPruningPassBase;

  ExecutorGraphPruningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorGraphPruningPassBase(const ExecutorGraphPruningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExecutorGraphPruningPassBase& operator=(const ExecutorGraphPruningPassBase &) = delete;
  ExecutorGraphPruningPassBase(ExecutorGraphPruningPassBase &&) = delete;
  ExecutorGraphPruningPassBase& operator=(ExecutorGraphPruningPassBase &&) = delete;
  ~ExecutorGraphPruningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-graph-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-graph-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Prunes unreachable ops in a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorGraphPruningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorGraphPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorGraphPruningPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> ops_to_preserve_{*this, "ops-to-preserve", ::llvm::cl::desc("Comma separated list of ops that should not be pruned regardless of reachability")};
};

template <typename DerivedT>
class ExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorIslandCoarseningPassBase;

  ExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorIslandCoarseningPassBase(const ExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExecutorIslandCoarseningPassBase& operator=(const ExecutorIslandCoarseningPassBase &) = delete;
  ExecutorIslandCoarseningPassBase(ExecutorIslandCoarseningPassBase &&) = delete;
  ExecutorIslandCoarseningPassBase& operator=(ExecutorIslandCoarseningPassBase &&) = delete;
  ~ExecutorIslandCoarseningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Walks tf_executor::GraphOp and merges individual tf_executor::IslandOps."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorIslandCoarseningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorTPUV1IslandInliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorTPUV1IslandInliningPassBase;

  ExecutorTPUV1IslandInliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorTPUV1IslandInliningPassBase(const ExecutorTPUV1IslandInliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorTPUV1IslandInliningPassBase& operator=(const ExecutorTPUV1IslandInliningPassBase &) = delete;
  ExecutorTPUV1IslandInliningPassBase(ExecutorTPUV1IslandInliningPassBase &&) = delete;
  ExecutorTPUV1IslandInliningPassBase& operator=(ExecutorTPUV1IslandInliningPassBase &&) = delete;
  ~ExecutorTPUV1IslandInliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-inlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-inlining"; }

  ::llvm::StringRef getDescription() const override { return "Inline calls to the nested TPU module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorTPUV1IslandInliningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorTPUV1IslandInliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorTPUV1IslandInliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorUpdateControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorUpdateControlDependenciesPassBase;

  ExecutorUpdateControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorUpdateControlDependenciesPassBase(const ExecutorUpdateControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ExecutorUpdateControlDependenciesPassBase& operator=(const ExecutorUpdateControlDependenciesPassBase &) = delete;
  ExecutorUpdateControlDependenciesPassBase(ExecutorUpdateControlDependenciesPassBase &&) = delete;
  ExecutorUpdateControlDependenciesPassBase& operator=(ExecutorUpdateControlDependenciesPassBase &&) = delete;
  ~ExecutorUpdateControlDependenciesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-update-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-update-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Computes and applies all necessary control dependencies based on side effect analysis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorUpdateControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorUpdateControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorUpdateControlDependenciesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExtractTPUCopyWithDynamicShapeOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExtractTPUCopyWithDynamicShapeOpPassBase;

  ExtractTPUCopyWithDynamicShapeOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExtractTPUCopyWithDynamicShapeOpPassBase(const ExtractTPUCopyWithDynamicShapeOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ExtractTPUCopyWithDynamicShapeOpPassBase& operator=(const ExtractTPUCopyWithDynamicShapeOpPassBase &) = delete;
  ExtractTPUCopyWithDynamicShapeOpPassBase(ExtractTPUCopyWithDynamicShapeOpPassBase &&) = delete;
  ExtractTPUCopyWithDynamicShapeOpPassBase& operator=(ExtractTPUCopyWithDynamicShapeOpPassBase &&) = delete;
  ~ExtractTPUCopyWithDynamicShapeOpPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-extract-tpu-copy-with-dynamic-shape-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-extract-tpu-copy-with-dynamic-shape-op"; }

  ::llvm::StringRef getDescription() const override { return "Extract the TPUCopyWithDynamicShapeOp out of the host launch and place it on device launch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExtractTPUCopyWithDynamicShapeOpPass");
  }
  ::llvm::StringRef getName() const override { return "ExtractTPUCopyWithDynamicShapeOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExtractTPUCopyWithDynamicShapeOpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FunctionalControlFlowToCFGPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalControlFlowToCFGPassBase;

  FunctionalControlFlowToCFGPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToCFGPassBase(const FunctionalControlFlowToCFGPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FunctionalControlFlowToCFGPassBase& operator=(const FunctionalControlFlowToCFGPassBase &) = delete;
  FunctionalControlFlowToCFGPassBase(FunctionalControlFlowToCFGPassBase &&) = delete;
  FunctionalControlFlowToCFGPassBase& operator=(FunctionalControlFlowToCFGPassBase &&) = delete;
  ~FunctionalControlFlowToCFGPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-cfg");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-cfg"; }

  ::llvm::StringRef getDescription() const override { return "Transform functional control flow Ops to MLIR Control Form Graph (CFG) form"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToCFGPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToCFGPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToCFGPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FunctionalControlFlowToRegionsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FunctionalControlFlowToRegionsPassBase;

  FunctionalControlFlowToRegionsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToRegionsPassBase(const FunctionalControlFlowToRegionsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  FunctionalControlFlowToRegionsPassBase& operator=(const FunctionalControlFlowToRegionsPassBase &) = delete;
  FunctionalControlFlowToRegionsPassBase(FunctionalControlFlowToRegionsPassBase &&) = delete;
  FunctionalControlFlowToRegionsPassBase& operator=(FunctionalControlFlowToRegionsPassBase &&) = delete;
  ~FunctionalControlFlowToRegionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-regions");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-regions"; }

  ::llvm::StringRef getDescription() const override { return "Transforms functional control flow operations to their region-based counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToRegionsPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToRegionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToRegionsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> allow_passthrough_args_{*this, "allow-passthrough-args", ::llvm::cl::desc("Allows to switch on passthrough args for control flow logic. This allows the pass to create blocks that better match MLIR interfaces, but might break assumptions in existing passes."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class FunctionalToExecutorDialectConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalToExecutorDialectConversionPassBase;

  FunctionalToExecutorDialectConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalToExecutorDialectConversionPassBase(const FunctionalToExecutorDialectConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FunctionalToExecutorDialectConversionPassBase& operator=(const FunctionalToExecutorDialectConversionPassBase &) = delete;
  FunctionalToExecutorDialectConversionPassBase(FunctionalToExecutorDialectConversionPassBase &&) = delete;
  FunctionalToExecutorDialectConversionPassBase& operator=(FunctionalToExecutorDialectConversionPassBase &&) = delete;
  ~FunctionalToExecutorDialectConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-to-executor-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-to-executor-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Transform from func op to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalToExecutorDialectConversionPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalToExecutorDialectConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalToExecutorDialectConversionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FusedKernelMatcherPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusedKernelMatcherPassBase;

  FusedKernelMatcherPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusedKernelMatcherPassBase(const FusedKernelMatcherPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FusedKernelMatcherPassBase& operator=(const FusedKernelMatcherPassBase &) = delete;
  FusedKernelMatcherPassBase(FusedKernelMatcherPassBase &&) = delete;
  FusedKernelMatcherPassBase& operator=(FusedKernelMatcherPassBase &&) = delete;
  ~FusedKernelMatcherPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-fused-kernel-matcher");
  }
  ::llvm::StringRef getArgument() const override { return "tf-fused-kernel-matcher"; }

  ::llvm::StringRef getDescription() const override { return "Matches computations corresponding to optimized fused kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusedKernelMatcherPass");
  }
  ::llvm::StringRef getName() const override { return "FusedKernelMatcherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusedKernelMatcherPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GroupByDialectPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = GroupByDialectPassBase;

  GroupByDialectPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GroupByDialectPassBase(const GroupByDialectPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  GroupByDialectPassBase& operator=(const GroupByDialectPassBase &) = delete;
  GroupByDialectPassBase(GroupByDialectPassBase &&) = delete;
  GroupByDialectPassBase& operator=(GroupByDialectPassBase &&) = delete;
  ~GroupByDialectPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-group-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-group-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Groups ops into functions that only contain one dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GroupByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "GroupByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GroupByDialectPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GuaranteeAllFuncsOneUsePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GuaranteeAllFuncsOneUsePassBase;

  GuaranteeAllFuncsOneUsePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GuaranteeAllFuncsOneUsePassBase(const GuaranteeAllFuncsOneUsePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  GuaranteeAllFuncsOneUsePassBase& operator=(const GuaranteeAllFuncsOneUsePassBase &) = delete;
  GuaranteeAllFuncsOneUsePassBase(GuaranteeAllFuncsOneUsePassBase &&) = delete;
  GuaranteeAllFuncsOneUsePassBase& operator=(GuaranteeAllFuncsOneUsePassBase &&) = delete;
  ~GuaranteeAllFuncsOneUsePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-guarantee-all-funcs-one-use");
  }
  ::llvm::StringRef getArgument() const override { return "tf-guarantee-all-funcs-one-use"; }

  ::llvm::StringRef getDescription() const override { return "Guarantee all FuncOp's have only a single use."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GuaranteeAllFuncsOneUsePass");
  }
  ::llvm::StringRef getName() const override { return "GuaranteeAllFuncsOneUsePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GuaranteeAllFuncsOneUsePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HoistLoopInvariantPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = HoistLoopInvariantPassBase;

  HoistLoopInvariantPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HoistLoopInvariantPassBase(const HoistLoopInvariantPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  HoistLoopInvariantPassBase& operator=(const HoistLoopInvariantPassBase &) = delete;
  HoistLoopInvariantPassBase(HoistLoopInvariantPassBase &&) = delete;
  HoistLoopInvariantPassBase& operator=(HoistLoopInvariantPassBase &&) = delete;
  ~HoistLoopInvariantPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-hoist-loop-invariant");
  }
  ::llvm::StringRef getArgument() const override { return "tf-hoist-loop-invariant"; }

  ::llvm::StringRef getDescription() const override { return "Hoists loop invariant ops to the outside of the loop"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HoistLoopInvariantPass");
  }
  ::llvm::StringRef getName() const override { return "HoistLoopInvariantPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HoistLoopInvariantPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HoistReplicateInvariantResourceWritesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = HoistReplicateInvariantResourceWritesPassBase;

  HoistReplicateInvariantResourceWritesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HoistReplicateInvariantResourceWritesPassBase(const HoistReplicateInvariantResourceWritesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  HoistReplicateInvariantResourceWritesPassBase& operator=(const HoistReplicateInvariantResourceWritesPassBase &) = delete;
  HoistReplicateInvariantResourceWritesPassBase(HoistReplicateInvariantResourceWritesPassBase &&) = delete;
  HoistReplicateInvariantResourceWritesPassBase& operator=(HoistReplicateInvariantResourceWritesPassBase &&) = delete;
  ~HoistReplicateInvariantResourceWritesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-hoist-replicate-invariant-resource-writes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-hoist-replicate-invariant-resource-writes"; }

  ::llvm::StringRef getDescription() const override { return "Hoists writes to replicate invariant resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HoistReplicateInvariantResourceWritesPass");
  }
  ::llvm::StringRef getName() const override { return "HoistReplicateInvariantResourceWritesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HoistReplicateInvariantResourceWritesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class InitTextFileToImportPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = InitTextFileToImportPassBase;

  InitTextFileToImportPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InitTextFileToImportPassBase(const InitTextFileToImportPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  InitTextFileToImportPassBase& operator=(const InitTextFileToImportPassBase &) = delete;
  InitTextFileToImportPassBase(InitTextFileToImportPassBase &&) = delete;
  InitTextFileToImportPassBase& operator=(InitTextFileToImportPassBase &&) = delete;
  ~InitTextFileToImportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-init-text-file-to-import");
  }
  ::llvm::StringRef getArgument() const override { return "tf-init-text-file-to-import"; }

  ::llvm::StringRef getDescription() const override { return "convert InitializeTableFromTextFileV2 ops to LookupTableImportV2Op to remove the dependency on asset files"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InitTextFileToImportPass");
  }
  ::llvm::StringRef getName() const override { return "InitTextFileToImportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InitTextFileToImportPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> saved_model_dir_{*this, "tf-saved-model-dir", ::llvm::cl::desc("Directory containing the model exported as a TensorFlow SavedModel. If your model is not based on the TensorFlow SavedModel, use an empty value.")};
};

template <typename DerivedT>
class LaunchOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LaunchOutliningPassBase;

  LaunchOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LaunchOutliningPassBase(const LaunchOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LaunchOutliningPassBase& operator=(const LaunchOutliningPassBase &) = delete;
  LaunchOutliningPassBase(LaunchOutliningPassBase &&) = delete;
  LaunchOutliningPassBase& operator=(LaunchOutliningPassBase &&) = delete;
  ~LaunchOutliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-launch-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-launch-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.launch operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LaunchOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "LaunchOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LaunchOutliningPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> globally_unique_func_names_{*this, "globally-unique-func-names", ::llvm::cl::desc("If true, the pass adds extra identifiers to make function names globally unique within a process, not just within a module."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class LayoutAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LayoutAssignmentPassBase;

  LayoutAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LayoutAssignmentPassBase(const LayoutAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LayoutAssignmentPassBase& operator=(const LayoutAssignmentPassBase &) = delete;
  LayoutAssignmentPassBase(LayoutAssignmentPassBase &&) = delete;
  LayoutAssignmentPassBase& operator=(LayoutAssignmentPassBase &&) = delete;
  ~LayoutAssignmentPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-layout-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-layout-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Layout assignment pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LayoutAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "LayoutAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LayoutAssignmentPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> force_data_format_{*this, "force-data-format", ::llvm::cl::desc("Force data format for all layout sensitive ops.")};
};

template <typename DerivedT>
class LegalizeTFGToTFPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFGToTFPassBase;

  LegalizeTFGToTFPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFGToTFPassBase(const LegalizeTFGToTFPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LegalizeTFGToTFPassBase& operator=(const LegalizeTFGToTFPassBase &) = delete;
  LegalizeTFGToTFPassBase(LegalizeTFGToTFPassBase &&) = delete;
  LegalizeTFGToTFPassBase& operator=(LegalizeTFGToTFPassBase &&) = delete;
  ~LegalizeTFGToTFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tfe-legalize-tfg");
  }
  ::llvm::StringRef getArgument() const override { return "tfe-legalize-tfg"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TFG to the TFE dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFGToTFPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFGToTFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFGToTFPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LocalizeVarHandlesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LocalizeVarHandlesPassBase;

  LocalizeVarHandlesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LocalizeVarHandlesPassBase(const LocalizeVarHandlesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LocalizeVarHandlesPassBase& operator=(const LocalizeVarHandlesPassBase &) = delete;
  LocalizeVarHandlesPassBase(LocalizeVarHandlesPassBase &&) = delete;
  LocalizeVarHandlesPassBase& operator=(LocalizeVarHandlesPassBase &&) = delete;
  ~LocalizeVarHandlesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-localize-var-handles");
  }
  ::llvm::StringRef getArgument() const override { return "tf-localize-var-handles"; }

  ::llvm::StringRef getDescription() const override { return "Creates VarHandleOps next to the operations that use them."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LocalizeVarHandlesPass");
  }
  ::llvm::StringRef getName() const override { return "LocalizeVarHandlesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LocalizeVarHandlesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerQuantizedPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerQuantizedPassBase;

  LowerQuantizedPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerQuantizedPassBase(const LowerQuantizedPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerQuantizedPassBase& operator=(const LowerQuantizedPassBase &) = delete;
  LowerQuantizedPassBase(LowerQuantizedPassBase &&) = delete;
  LowerQuantizedPassBase& operator=(LowerQuantizedPassBase &&) = delete;
  ~LowerQuantizedPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-lower-quantized");
  }
  ::llvm::StringRef getArgument() const override { return "tf-lower-quantized"; }

  ::llvm::StringRef getDescription() const override { return "Lowers ops that require quantized input or output."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerQuantizedPass");
  }
  ::llvm::StringRef getName() const override { return "LowerQuantizedPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerQuantizedPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MarkInputOutputAliasesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkInputOutputAliasesPassBase;

  MarkInputOutputAliasesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkInputOutputAliasesPassBase(const MarkInputOutputAliasesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  MarkInputOutputAliasesPassBase& operator=(const MarkInputOutputAliasesPassBase &) = delete;
  MarkInputOutputAliasesPassBase(MarkInputOutputAliasesPassBase &&) = delete;
  MarkInputOutputAliasesPassBase& operator=(MarkInputOutputAliasesPassBase &&) = delete;
  ~MarkInputOutputAliasesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-mark-input-output-aliases");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-mark-input-output-aliases"; }

  ::llvm::StringRef getDescription() const override { return "Marks device cluster inputs-output pairs that read/write to the same variable as aliases"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkInputOutputAliasesPass");
  }
  ::llvm::StringRef getName() const override { return "MarkInputOutputAliasesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkInputOutputAliasesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MaterializePassthroughOpBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MaterializePassthroughOpBase;

  MaterializePassthroughOpBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MaterializePassthroughOpBase(const MaterializePassthroughOpBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  MaterializePassthroughOpBase& operator=(const MaterializePassthroughOpBase &) = delete;
  MaterializePassthroughOpBase(MaterializePassthroughOpBase &&) = delete;
  MaterializePassthroughOpBase& operator=(MaterializePassthroughOpBase &&) = delete;
  ~MaterializePassthroughOpBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-materialize-passthrough-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-materialize-passthrough-op"; }

  ::llvm::StringRef getDescription() const override { return "Materialize the MlirPassthroughOp by replacing it with the MLIR module attached as an attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MaterializePassthroughOp");
  }
  ::llvm::StringRef getName() const override { return "MaterializePassthroughOp"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MaterializePassthroughOpBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergeControlFlowPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MergeControlFlowPassBase;

  MergeControlFlowPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeControlFlowPassBase(const MergeControlFlowPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  MergeControlFlowPassBase& operator=(const MergeControlFlowPassBase &) = delete;
  MergeControlFlowPassBase(MergeControlFlowPassBase &&) = delete;
  MergeControlFlowPassBase& operator=(MergeControlFlowPassBase &&) = delete;
  ~MergeControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-merge-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "tf-merge-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Merges IfRegion ops together with a common predicate."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "MergeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeControlFlowPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MoveTpuCompileToFrontPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MoveTpuCompileToFrontPassBase;

  MoveTpuCompileToFrontPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MoveTpuCompileToFrontPassBase(const MoveTpuCompileToFrontPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  MoveTpuCompileToFrontPassBase& operator=(const MoveTpuCompileToFrontPassBase &) = delete;
  MoveTpuCompileToFrontPassBase(MoveTpuCompileToFrontPassBase &&) = delete;
  MoveTpuCompileToFrontPassBase& operator=(MoveTpuCompileToFrontPassBase &&) = delete;
  ~MoveTpuCompileToFrontPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-move-tpu-compile-to-front");
  }
  ::llvm::StringRef getArgument() const override { return "tf-move-tpu-compile-to-front"; }

  ::llvm::StringRef getDescription() const override { return "Moves compile ops to the front."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MoveTpuCompileToFrontPass");
  }
  ::llvm::StringRef getName() const override { return "MoveTpuCompileToFrontPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MoveTpuCompileToFrontPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MoveTransposesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MoveTransposesPassBase;

  MoveTransposesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MoveTransposesPassBase(const MoveTransposesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  MoveTransposesPassBase& operator=(const MoveTransposesPassBase &) = delete;
  MoveTransposesPassBase(MoveTransposesPassBase &&) = delete;
  MoveTransposesPassBase& operator=(MoveTransposesPassBase &&) = delete;
  ~MoveTransposesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-move-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-move-transposes"; }

  ::llvm::StringRef getDescription() const override { return "Move transposes pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MoveTransposesPass");
  }
  ::llvm::StringRef getName() const override { return "MoveTransposesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MoveTransposesPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> fold_transpose_in_ops_{*this, "fold-transpose-in-ops", ::llvm::cl::desc("Whether to fold transposes in ops which can support folding."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<enum MoveTransposeDirection> direction_{*this, "direction", ::llvm::cl::desc("Move transposes to the beginning or the end of the block where they are defined."), ::llvm::cl::init(MoveTransposeDirection::kBegin), llvm::cl::values(clEnumValN(MoveTransposeDirection::kBegin, "begin", "beginning of the block"),clEnumValN(MoveTransposeDirection::kEnd, "end", "end of the block"))};
};

template <typename DerivedT>
class NameAnonymousIteratorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = NameAnonymousIteratorsPassBase;

  NameAnonymousIteratorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NameAnonymousIteratorsPassBase(const NameAnonymousIteratorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  NameAnonymousIteratorsPassBase& operator=(const NameAnonymousIteratorsPassBase &) = delete;
  NameAnonymousIteratorsPassBase(NameAnonymousIteratorsPassBase &&) = delete;
  NameAnonymousIteratorsPassBase& operator=(NameAnonymousIteratorsPassBase &&) = delete;
  ~NameAnonymousIteratorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-name-anonymous-iterators");
  }
  ::llvm::StringRef getArgument() const override { return "tf-name-anonymous-iterators"; }

  ::llvm::StringRef getDescription() const override { return "Converts anonymous iterators to named iterators"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NameAnonymousIteratorsPass");
  }
  ::llvm::StringRef getName() const override { return "NameAnonymousIteratorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NameAnonymousIteratorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OrderByDialectPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OrderByDialectPassBase;

  OrderByDialectPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OrderByDialectPassBase(const OrderByDialectPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  OrderByDialectPassBase& operator=(const OrderByDialectPassBase &) = delete;
  OrderByDialectPassBase(OrderByDialectPassBase &&) = delete;
  OrderByDialectPassBase& operator=(OrderByDialectPassBase &&) = delete;
  ~OrderByDialectPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-order-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-order-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Reorders ops so ops of the same dialect are next to each other."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OrderByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "OrderByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OrderByDialectPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ParallelExecuteToIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelExecuteToIslandsPassBase;

  ParallelExecuteToIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelExecuteToIslandsPassBase(const ParallelExecuteToIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ParallelExecuteToIslandsPassBase& operator=(const ParallelExecuteToIslandsPassBase &) = delete;
  ParallelExecuteToIslandsPassBase(ParallelExecuteToIslandsPassBase &&) = delete;
  ParallelExecuteToIslandsPassBase& operator=(ParallelExecuteToIslandsPassBase &&) = delete;
  ~ParallelExecuteToIslandsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-parallel-execute-to-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-parallel-execute-to-islands"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device parallel_execute to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelExecuteToIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "ParallelExecuteToIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelExecuteToIslandsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> legacy_graph_export_{*this, "legacy-graph-export", ::llvm::cl::desc("Determines whether or not this pass should execute logic that is reserved for the legacy graph export pipeline to maintain expected invariants. In the case of this pass, that means manually propagating controls to lifted parallel execute regions to the graph fetch to ensure the ops execute."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class PrepareTpuComputationForTfExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PrepareTpuComputationForTfExportPassBase;

  PrepareTpuComputationForTfExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrepareTpuComputationForTfExportPassBase(const PrepareTpuComputationForTfExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PrepareTpuComputationForTfExportPassBase& operator=(const PrepareTpuComputationForTfExportPassBase &) = delete;
  PrepareTpuComputationForTfExportPassBase(PrepareTpuComputationForTfExportPassBase &&) = delete;
  PrepareTpuComputationForTfExportPassBase& operator=(PrepareTpuComputationForTfExportPassBase &&) = delete;
  ~PrepareTpuComputationForTfExportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("prepare-tpu-computation-for-tf-export");
  }
  ::llvm::StringRef getArgument() const override { return "prepare-tpu-computation-for-tf-export"; }

  ::llvm::StringRef getDescription() const override { return "Prepare TPU computation to be legal for export to TensorFlow"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrepareTpuComputationForTfExportPass");
  }
  ::llvm::StringRef getName() const override { return "PrepareTpuComputationForTfExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrepareTpuComputationForTfExportPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PrintPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PrintPassBase;

  PrintPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrintPassBase(const PrintPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PrintPassBase& operator=(const PrintPassBase &) = delete;
  PrintPassBase(PrintPassBase &&) = delete;
  PrintPassBase& operator=(PrintPassBase &&) = delete;
  ~PrintPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-print");
  }
  ::llvm::StringRef getArgument() const override { return "tf-print"; }

  ::llvm::StringRef getDescription() const override { return "Prints the current module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrintPass");
  }
  ::llvm::StringRef getName() const override { return "PrintPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrintPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PromoteResourcesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteResourcesToArgsPassBase;

  PromoteResourcesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteResourcesToArgsPassBase(const PromoteResourcesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PromoteResourcesToArgsPassBase& operator=(const PromoteResourcesToArgsPassBase &) = delete;
  PromoteResourcesToArgsPassBase(PromoteResourcesToArgsPassBase &&) = delete;
  PromoteResourcesToArgsPassBase& operator=(PromoteResourcesToArgsPassBase &&) = delete;
  ~PromoteResourcesToArgsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-resources-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-resources-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote resources reads/writes to function inputs/outputs."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteResourcesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteResourcesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteResourcesToArgsPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> functions_{*this, "functions", ::llvm::cl::desc("Comma separated list of functions whose resources read/writes should be promoted to function inputs/outputs.")};
};

template <typename DerivedT>
class PromoteVarHandlesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteVarHandlesToArgsPassBase;

  PromoteVarHandlesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteVarHandlesToArgsPassBase(const PromoteVarHandlesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  PromoteVarHandlesToArgsPassBase& operator=(const PromoteVarHandlesToArgsPassBase &) = delete;
  PromoteVarHandlesToArgsPassBase(PromoteVarHandlesToArgsPassBase &&) = delete;
  PromoteVarHandlesToArgsPassBase& operator=(PromoteVarHandlesToArgsPassBase &&) = delete;
  ~PromoteVarHandlesToArgsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-var-handles-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-var-handles-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote tf.VarHandleOps to function arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteVarHandlesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteVarHandlesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteVarHandlesToArgsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RegionControlFlowToFunctionalPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RegionControlFlowToFunctionalPassBase;

  RegionControlFlowToFunctionalPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RegionControlFlowToFunctionalPassBase(const RegionControlFlowToFunctionalPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  RegionControlFlowToFunctionalPassBase& operator=(const RegionControlFlowToFunctionalPassBase &) = delete;
  RegionControlFlowToFunctionalPassBase(RegionControlFlowToFunctionalPassBase &&) = delete;
  RegionControlFlowToFunctionalPassBase& operator=(RegionControlFlowToFunctionalPassBase &&) = delete;
  ~RegionControlFlowToFunctionalPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-region-control-flow-to-functional");
  }
  ::llvm::StringRef getArgument() const override { return "tf-region-control-flow-to-functional"; }

  ::llvm::StringRef getDescription() const override { return "Transforms region-based control flow operations to their functional counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RegionControlFlowToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "RegionControlFlowToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RegionControlFlowToFunctionalPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RemoveUnusedArgumentsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RemoveUnusedArgumentsPassBase;

  RemoveUnusedArgumentsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedArgumentsPassBase(const RemoveUnusedArgumentsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  RemoveUnusedArgumentsPassBase& operator=(const RemoveUnusedArgumentsPassBase &) = delete;
  RemoveUnusedArgumentsPassBase(RemoveUnusedArgumentsPassBase &&) = delete;
  RemoveUnusedArgumentsPassBase& operator=(RemoveUnusedArgumentsPassBase &&) = delete;
  ~RemoveUnusedArgumentsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-arguments");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-arguments"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused args from private functions & their callers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedArgumentsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedArgumentsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedArgumentsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RemoveUnusedWhileResultsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveUnusedWhileResultsPassBase;

  RemoveUnusedWhileResultsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedWhileResultsPassBase(const RemoveUnusedWhileResultsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  RemoveUnusedWhileResultsPassBase& operator=(const RemoveUnusedWhileResultsPassBase &) = delete;
  RemoveUnusedWhileResultsPassBase(RemoveUnusedWhileResultsPassBase &&) = delete;
  RemoveUnusedWhileResultsPassBase& operator=(RemoveUnusedWhileResultsPassBase &&) = delete;
  ~RemoveUnusedWhileResultsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-while-results");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-while-results"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused results from tf.WhileRegion ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedWhileResultsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedWhileResultsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedWhileResultsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ReplicaIDToDeviceOrdinalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicaIDToDeviceOrdinalPassBase;

  ReplicaIDToDeviceOrdinalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicaIDToDeviceOrdinalPassBase(const ReplicaIDToDeviceOrdinalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicaIDToDeviceOrdinalPassBase& operator=(const ReplicaIDToDeviceOrdinalPassBase &) = delete;
  ReplicaIDToDeviceOrdinalPassBase(ReplicaIDToDeviceOrdinalPassBase &&) = delete;
  ReplicaIDToDeviceOrdinalPassBase& operator=(ReplicaIDToDeviceOrdinalPassBase &&) = delete;
  ~ReplicaIDToDeviceOrdinalPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replica-id-to-device-ordinal");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replica-id-to-device-ordinal"; }

  ::llvm::StringRef getDescription() const override { return "Set device ordinal with replica id"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicaIDToDeviceOrdinalPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicaIDToDeviceOrdinalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicaIDToDeviceOrdinalPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ReplicateInvariantOpHoistingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateInvariantOpHoistingPassBase;

  ReplicateInvariantOpHoistingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateInvariantOpHoistingPassBase(const ReplicateInvariantOpHoistingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicateInvariantOpHoistingPassBase& operator=(const ReplicateInvariantOpHoistingPassBase &) = delete;
  ReplicateInvariantOpHoistingPassBase(ReplicateInvariantOpHoistingPassBase &&) = delete;
  ReplicateInvariantOpHoistingPassBase& operator=(ReplicateInvariantOpHoistingPassBase &&) = delete;
  ~ReplicateInvariantOpHoistingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-invariant-op-hoisting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-invariant-op-hoisting"; }

  ::llvm::StringRef getDescription() const override { return "Hoists replicate invariant operations out of replicate"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateInvariantOpHoistingPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateInvariantOpHoistingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateInvariantOpHoistingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ReplicateTensorListInitOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateTensorListInitOpsPassBase;

  ReplicateTensorListInitOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateTensorListInitOpsPassBase(const ReplicateTensorListInitOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicateTensorListInitOpsPassBase& operator=(const ReplicateTensorListInitOpsPassBase &) = delete;
  ReplicateTensorListInitOpsPassBase(ReplicateTensorListInitOpsPassBase &&) = delete;
  ReplicateTensorListInitOpsPassBase& operator=(ReplicateTensorListInitOpsPassBase &&) = delete;
  ~ReplicateTensorListInitOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-tensor-list-init-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-tensor-list-init-ops"; }

  ::llvm::StringRef getDescription() const override { return "Replicate TensorList init ops for correct shape assignments in shape inference"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateTensorListInitOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateTensorListInitOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateTensorListInitOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ReplicateToIslandPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateToIslandPassBase;

  ReplicateToIslandPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateToIslandPassBase(const ReplicateToIslandPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ReplicateToIslandPassBase& operator=(const ReplicateToIslandPassBase &) = delete;
  ReplicateToIslandPassBase(ReplicateToIslandPassBase &&) = delete;
  ReplicateToIslandPassBase& operator=(ReplicateToIslandPassBase &&) = delete;
  ~ReplicateToIslandPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-to-island");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-to-island"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device replicate to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateToIslandPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateToIslandPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateToIslandPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> legacy_graph_export_{*this, "legacy-graph-export", ::llvm::cl::desc("Determines whether or not this pass should execute logic that is reserved for the legacy graph export pipeline to maintain expected invariants. In the case of this pass, that means manually propagating controls to lifted parallel execute regions to the graph fetch to ensure the ops execute, as well as determining whether or not the islands created by this pass should be split after the replicated ops have been lifted."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ResourceDeviceInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ResourceDeviceInferencePassBase;

  ResourceDeviceInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ResourceDeviceInferencePassBase(const ResourceDeviceInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ResourceDeviceInferencePassBase& operator=(const ResourceDeviceInferencePassBase &) = delete;
  ResourceDeviceInferencePassBase(ResourceDeviceInferencePassBase &&) = delete;
  ResourceDeviceInferencePassBase& operator=(ResourceDeviceInferencePassBase &&) = delete;
  ~ResourceDeviceInferencePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-resource-device-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-resource-device-inference"; }

  ::llvm::StringRef getDescription() const override { return "Propagates the device attribute on resources from callers to callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResourceDeviceInferencePass");
  }
  ::llvm::StringRef getName() const override { return "ResourceDeviceInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResourceDeviceInferencePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteTPUEmbeddingOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteTPUEmbeddingOpsPassBase;

  RewriteTPUEmbeddingOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTPUEmbeddingOpsPassBase(const RewriteTPUEmbeddingOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  RewriteTPUEmbeddingOpsPassBase& operator=(const RewriteTPUEmbeddingOpsPassBase &) = delete;
  RewriteTPUEmbeddingOpsPassBase(RewriteTPUEmbeddingOpsPassBase &&) = delete;
  RewriteTPUEmbeddingOpsPassBase& operator=(RewriteTPUEmbeddingOpsPassBase &&) = delete;
  ~RewriteTPUEmbeddingOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-rewrite-tpu-embedding-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-rewrite-tpu-embedding-ops"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites TPU embedding send/recv ops by adding TPU embedding deduplication data"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTPUEmbeddingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteTPUEmbeddingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTPUEmbeddingOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SimpleTFDeviceAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimpleTFDeviceAssignmentPassBase;

  SimpleTFDeviceAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimpleTFDeviceAssignmentPassBase(const SimpleTFDeviceAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  SimpleTFDeviceAssignmentPassBase& operator=(const SimpleTFDeviceAssignmentPassBase &) = delete;
  SimpleTFDeviceAssignmentPassBase(SimpleTFDeviceAssignmentPassBase &&) = delete;
  SimpleTFDeviceAssignmentPassBase& operator=(SimpleTFDeviceAssignmentPassBase &&) = delete;
  ~SimpleTFDeviceAssignmentPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-simple-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-simple-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Simple device assignment in TF dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimpleTFDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "SimpleTFDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimpleTFDeviceAssignmentPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> default_device_{*this, "default-device", ::llvm::cl::desc("The default device to assign."), ::llvm::cl::init("cpu")};
};

template <typename DerivedT>
class SplitIntoIslandPerOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SplitIntoIslandPerOpPassBase;

  SplitIntoIslandPerOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SplitIntoIslandPerOpPassBase(const SplitIntoIslandPerOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  SplitIntoIslandPerOpPassBase& operator=(const SplitIntoIslandPerOpPassBase &) = delete;
  SplitIntoIslandPerOpPassBase(SplitIntoIslandPerOpPassBase &&) = delete;
  SplitIntoIslandPerOpPassBase& operator=(SplitIntoIslandPerOpPassBase &&) = delete;
  ~SplitIntoIslandPerOpPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-split-into-island-per-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-split-into-island-per-op"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitIntoIslandPerOpPass");
  }
  ::llvm::StringRef getName() const override { return "SplitIntoIslandPerOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitIntoIslandPerOpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StackOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StackOpsDecompositionPassBase;

  StackOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StackOpsDecompositionPassBase(const StackOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StackOpsDecompositionPassBase& operator=(const StackOpsDecompositionPassBase &) = delete;
  StackOpsDecompositionPassBase(StackOpsDecompositionPassBase &&) = delete;
  StackOpsDecompositionPassBase& operator=(StackOpsDecompositionPassBase &&) = delete;
  ~StackOpsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-stack-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-stack-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose stack operations into local variable operations. Needs static shapes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StackOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "StackOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StackOpsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StripNoinlineAttributePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StripNoinlineAttributePassBase;

  StripNoinlineAttributePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripNoinlineAttributePassBase(const StripNoinlineAttributePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StripNoinlineAttributePassBase& operator=(const StripNoinlineAttributePassBase &) = delete;
  StripNoinlineAttributePassBase(StripNoinlineAttributePassBase &&) = delete;
  StripNoinlineAttributePassBase& operator=(StripNoinlineAttributePassBase &&) = delete;
  ~StripNoinlineAttributePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-noinline-attribute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-noinline-attribute"; }

  ::llvm::StringRef getDescription() const override { return "Strip the tf._noinline attribute from top-level functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripNoinlineAttributePass");
  }
  ::llvm::StringRef getName() const override { return "StripNoinlineAttributePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripNoinlineAttributePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StripTfAttributesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StripTfAttributesPassBase;

  StripTfAttributesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripTfAttributesPassBase(const StripTfAttributesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StripTfAttributesPassBase& operator=(const StripTfAttributesPassBase &) = delete;
  StripTfAttributesPassBase(StripTfAttributesPassBase &&) = delete;
  StripTfAttributesPassBase& operator=(StripTfAttributesPassBase &&) = delete;
  ~StripTfAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-tf-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-tf-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Removes TF specific attributes"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripTfAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "StripTfAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripTfAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TFDataOptimizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDataOptimizationPassBase;

  TFDataOptimizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDataOptimizationPassBase(const TFDataOptimizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TFDataOptimizationPassBase& operator=(const TFDataOptimizationPassBase &) = delete;
  TFDataOptimizationPassBase(TFDataOptimizationPassBase &&) = delete;
  TFDataOptimizationPassBase& operator=(TFDataOptimizationPassBase &&) = delete;
  ~TFDataOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-data-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-data-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Performs tf.data optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDataOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "TFDataOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDataOptimizationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TFDeviceAssignmentByFuncAttrPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDeviceAssignmentByFuncAttrPassBase;

  TFDeviceAssignmentByFuncAttrPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDeviceAssignmentByFuncAttrPassBase(const TFDeviceAssignmentByFuncAttrPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TFDeviceAssignmentByFuncAttrPassBase& operator=(const TFDeviceAssignmentByFuncAttrPassBase &) = delete;
  TFDeviceAssignmentByFuncAttrPassBase(TFDeviceAssignmentByFuncAttrPassBase &&) = delete;
  TFDeviceAssignmentByFuncAttrPassBase& operator=(TFDeviceAssignmentByFuncAttrPassBase &&) = delete;
  ~TFDeviceAssignmentByFuncAttrPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-assignment-by-func-attr");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-assignment-by-func-attr"; }

  ::llvm::StringRef getDescription() const override { return "Device assignment in TF dialect using the device specified in the function attribute."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDeviceAssignmentByFuncAttrPass");
  }
  ::llvm::StringRef getName() const override { return "TFDeviceAssignmentByFuncAttrPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDeviceAssignmentByFuncAttrPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUAnnotateDynamicShapeInputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUAnnotateDynamicShapeInputsPassBase;

  TPUAnnotateDynamicShapeInputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUAnnotateDynamicShapeInputsPassBase(const TPUAnnotateDynamicShapeInputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUAnnotateDynamicShapeInputsPassBase& operator=(const TPUAnnotateDynamicShapeInputsPassBase &) = delete;
  TPUAnnotateDynamicShapeInputsPassBase(TPUAnnotateDynamicShapeInputsPassBase &&) = delete;
  TPUAnnotateDynamicShapeInputsPassBase& operator=(TPUAnnotateDynamicShapeInputsPassBase &&) = delete;
  ~TPUAnnotateDynamicShapeInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-annotate-dynamic-shape-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-annotate-dynamic-shape-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Annotate the inputs returned by TPUCopyWithDynamicShapeOp with dynamic shape"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUAnnotateDynamicShapeInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUAnnotateDynamicShapeInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUAnnotateDynamicShapeInputsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUBridgeExecutorIslandOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUBridgeExecutorIslandOutliningPassBase;

  TPUBridgeExecutorIslandOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUBridgeExecutorIslandOutliningPassBase(const TPUBridgeExecutorIslandOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUBridgeExecutorIslandOutliningPassBase& operator=(const TPUBridgeExecutorIslandOutliningPassBase &) = delete;
  TPUBridgeExecutorIslandOutliningPassBase(TPUBridgeExecutorIslandOutliningPassBase &&) = delete;
  TPUBridgeExecutorIslandOutliningPassBase& operator=(TPUBridgeExecutorIslandOutliningPassBase &&) = delete;
  ~TPUBridgeExecutorIslandOutliningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outline TPU clusters from island into a nested module, so it can be processed like a V2 module, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUBridgeExecutorIslandOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUBridgeExecutorIslandOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUBridgeExecutorIslandOutliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUCleanupClusterAttributesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUCleanupClusterAttributesPassBase;

  TPUCleanupClusterAttributesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUCleanupClusterAttributesPassBase(const TPUCleanupClusterAttributesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUCleanupClusterAttributesPassBase& operator=(const TPUCleanupClusterAttributesPassBase &) = delete;
  TPUCleanupClusterAttributesPassBase(TPUCleanupClusterAttributesPassBase &&) = delete;
  TPUCleanupClusterAttributesPassBase& operator=(TPUCleanupClusterAttributesPassBase &&) = delete;
  ~TPUCleanupClusterAttributesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cleanup-cluster-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cleanup-cluster-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Eliminate _replication_info and other attributes from ops in a cluster"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUCleanupClusterAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "TPUCleanupClusterAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUCleanupClusterAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUColocateCompositeResourceOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUColocateCompositeResourceOpsPassBase;

  TPUColocateCompositeResourceOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUColocateCompositeResourceOpsPassBase(const TPUColocateCompositeResourceOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUColocateCompositeResourceOpsPassBase& operator=(const TPUColocateCompositeResourceOpsPassBase &) = delete;
  TPUColocateCompositeResourceOpsPassBase(TPUColocateCompositeResourceOpsPassBase &&) = delete;
  TPUColocateCompositeResourceOpsPassBase& operator=(TPUColocateCompositeResourceOpsPassBase &&) = delete;
  ~TPUColocateCompositeResourceOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-colocate-composite-resource-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-colocate-composite-resource-ops"; }

  ::llvm::StringRef getDescription() const override { return "Colocate resource with composite device assignment to TPU device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUColocateCompositeResourceOpsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUColocateCompositeResourceOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mhlo::MhloDialect>();
    registry.insert<tf_device::TensorFlowDeviceDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUColocateCompositeResourceOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUColocateSplitsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUColocateSplitsPassBase;

  TPUColocateSplitsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUColocateSplitsPassBase(const TPUColocateSplitsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUColocateSplitsPassBase& operator=(const TPUColocateSplitsPassBase &) = delete;
  TPUColocateSplitsPassBase(TPUColocateSplitsPassBase &&) = delete;
  TPUColocateSplitsPassBase& operator=(TPUColocateSplitsPassBase &&) = delete;
  ~TPUColocateSplitsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-colocate-splits");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-colocate-splits"; }

  ::llvm::StringRef getDescription() const override { return "Colocates each Split op with its predecessor"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUColocateSplitsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUColocateSplitsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUColocateSplitsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUDevicePropagationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUDevicePropagationPassBase;

  TPUDevicePropagationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDevicePropagationPassBase(const TPUDevicePropagationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUDevicePropagationPassBase& operator=(const TPUDevicePropagationPassBase &) = delete;
  TPUDevicePropagationPassBase(TPUDevicePropagationPassBase &&) = delete;
  TPUDevicePropagationPassBase& operator=(TPUDevicePropagationPassBase &&) = delete;
  ~TPUDevicePropagationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-device-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-device-propagation"; }

  ::llvm::StringRef getDescription() const override { return "Propagates TPU devices from ops to users"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDevicePropagationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDevicePropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDevicePropagationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUDynamicLayoutPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUDynamicLayoutPassBase;

  TPUDynamicLayoutPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDynamicLayoutPassBase(const TPUDynamicLayoutPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUDynamicLayoutPassBase& operator=(const TPUDynamicLayoutPassBase &) = delete;
  TPUDynamicLayoutPassBase(TPUDynamicLayoutPassBase &&) = delete;
  TPUDynamicLayoutPassBase& operator=(TPUDynamicLayoutPassBase &&) = delete;
  ~TPUDynamicLayoutPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-dynamic-layout-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-dynamic-layout-pass"; }

  ::llvm::StringRef getDescription() const override { return "Inserts TPU layout ops to determine layout at run time."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDynamicLayoutPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDynamicLayoutPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDynamicLayoutPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUHostComputationExpansionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUHostComputationExpansionPassBase;

  TPUHostComputationExpansionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUHostComputationExpansionPassBase(const TPUHostComputationExpansionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUHostComputationExpansionPassBase& operator=(const TPUHostComputationExpansionPassBase &) = delete;
  TPUHostComputationExpansionPassBase(TPUHostComputationExpansionPassBase &&) = delete;
  TPUHostComputationExpansionPassBase& operator=(TPUHostComputationExpansionPassBase &&) = delete;
  ~TPUHostComputationExpansionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-host-computation-expansion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-host-computation-expansion"; }

  ::llvm::StringRef getDescription() const override { return "Expands host computation before and after TPU computation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUHostComputationExpansionPass");
  }
  ::llvm::StringRef getName() const override { return "TPUHostComputationExpansionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUHostComputationExpansionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUIdentityPruningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUIdentityPruningPassBase;

  TPUIdentityPruningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUIdentityPruningPassBase(const TPUIdentityPruningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUIdentityPruningPassBase& operator=(const TPUIdentityPruningPassBase &) = delete;
  TPUIdentityPruningPassBase(TPUIdentityPruningPassBase &&) = delete;
  TPUIdentityPruningPassBase& operator=(TPUIdentityPruningPassBase &&) = delete;
  ~TPUIdentityPruningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-identity-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-identity-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Removes Identity/IdentityN ops from the TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUIdentityPruningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUIdentityPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUIdentityPruningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUParallelExecuteSinkResourceWritePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUParallelExecuteSinkResourceWritePassBase;

  TPUParallelExecuteSinkResourceWritePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUParallelExecuteSinkResourceWritePassBase(const TPUParallelExecuteSinkResourceWritePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUParallelExecuteSinkResourceWritePassBase& operator=(const TPUParallelExecuteSinkResourceWritePassBase &) = delete;
  TPUParallelExecuteSinkResourceWritePassBase(TPUParallelExecuteSinkResourceWritePassBase &&) = delete;
  TPUParallelExecuteSinkResourceWritePassBase& operator=(TPUParallelExecuteSinkResourceWritePassBase &&) = delete;
  ~TPUParallelExecuteSinkResourceWritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-parallel-execute-sink-resource-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-parallel-execute-sink-resource-write"; }

  ::llvm::StringRef getDescription() const override { return "Moves tf.AssignVariableOp consumers of tf_device.parallel_execute into tf_device.parallel_execute regions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUParallelExecuteSinkResourceWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUParallelExecuteSinkResourceWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUParallelExecuteSinkResourceWritePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUPartitionedOpConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUPartitionedOpConversionPassBase;

  TPUPartitionedOpConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUPartitionedOpConversionPassBase(const TPUPartitionedOpConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUPartitionedOpConversionPassBase& operator=(const TPUPartitionedOpConversionPassBase &) = delete;
  TPUPartitionedOpConversionPassBase(TPUPartitionedOpConversionPassBase &&) = delete;
  TPUPartitionedOpConversionPassBase& operator=(TPUPartitionedOpConversionPassBase &&) = delete;
  ~TPUPartitionedOpConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-partitioned-op-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-partitioned-op-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Rewrite all TPU Partitioned ops into their V2 counterparts."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUPartitionedOpConversionPass");
  }
  ::llvm::StringRef getName() const override { return "TPUPartitionedOpConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUPartitionedOpConversionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUReorderReplicateAndPartitionedInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUReorderReplicateAndPartitionedInputsPassBase;

  TPUReorderReplicateAndPartitionedInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUReorderReplicateAndPartitionedInputsPassBase(const TPUReorderReplicateAndPartitionedInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUReorderReplicateAndPartitionedInputsPassBase& operator=(const TPUReorderReplicateAndPartitionedInputsPassBase &) = delete;
  TPUReorderReplicateAndPartitionedInputsPassBase(TPUReorderReplicateAndPartitionedInputsPassBase &&) = delete;
  TPUReorderReplicateAndPartitionedInputsPassBase& operator=(TPUReorderReplicateAndPartitionedInputsPassBase &&) = delete;
  ~TPUReorderReplicateAndPartitionedInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-reorder-replicate-partitioned-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-reorder-replicate-partitioned-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Reorder replicated and partitioned input ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUReorderReplicateAndPartitionedInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUReorderReplicateAndPartitionedInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUReorderReplicateAndPartitionedInputsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUResourceReadForWritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUResourceReadForWritePassBase;

  TPUResourceReadForWritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadForWritePassBase(const TPUResourceReadForWritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUResourceReadForWritePassBase& operator=(const TPUResourceReadForWritePassBase &) = delete;
  TPUResourceReadForWritePassBase(TPUResourceReadForWritePassBase &&) = delete;
  TPUResourceReadForWritePassBase& operator=(TPUResourceReadForWritePassBase &&) = delete;
  ~TPUResourceReadForWritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-read-for-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-read-for-write"; }

  ::llvm::StringRef getDescription() const override { return "Inserts tf.ReadVariableOp inputs to a TPU cluster for resource writes with no reads"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadForWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadForWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadForWritePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUResourceReadsWritesPartitioningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUResourceReadsWritesPartitioningPassBase;

  TPUResourceReadsWritesPartitioningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadsWritesPartitioningPassBase(const TPUResourceReadsWritesPartitioningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUResourceReadsWritesPartitioningPassBase& operator=(const TPUResourceReadsWritesPartitioningPassBase &) = delete;
  TPUResourceReadsWritesPartitioningPassBase(TPUResourceReadsWritesPartitioningPassBase &&) = delete;
  TPUResourceReadsWritesPartitioningPassBase& operator=(TPUResourceReadsWritesPartitioningPassBase &&) = delete;
  ~TPUResourceReadsWritesPartitioningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-partition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-partition"; }

  ::llvm::StringRef getDescription() const override { return "Partitions unpartitioned resource read/write to partitioned resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadsWritesPartitioningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadsWritesPartitioningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadsWritesPartitioningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUSpaceToDepthPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUSpaceToDepthPassBase;

  TPUSpaceToDepthPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUSpaceToDepthPassBase(const TPUSpaceToDepthPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUSpaceToDepthPassBase& operator=(const TPUSpaceToDepthPassBase &) = delete;
  TPUSpaceToDepthPassBase(TPUSpaceToDepthPassBase &&) = delete;
  TPUSpaceToDepthPassBase& operator=(TPUSpaceToDepthPassBase &&) = delete;
  ~TPUSpaceToDepthPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-space-to-depth-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-space-to-depth-pass"; }

  ::llvm::StringRef getDescription() const override { return "Applies automatic space to depth transform for the first or frontier convolutions consume host inputs on TPU."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUSpaceToDepthPass");
  }
  ::llvm::StringRef getName() const override { return "TPUSpaceToDepthPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUSpaceToDepthPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUUpdateEmbeddingEnqueueOpInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUUpdateEmbeddingEnqueueOpInputsPassBase;

  TPUUpdateEmbeddingEnqueueOpInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUUpdateEmbeddingEnqueueOpInputsPassBase(const TPUUpdateEmbeddingEnqueueOpInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TPUUpdateEmbeddingEnqueueOpInputsPassBase& operator=(const TPUUpdateEmbeddingEnqueueOpInputsPassBase &) = delete;
  TPUUpdateEmbeddingEnqueueOpInputsPassBase(TPUUpdateEmbeddingEnqueueOpInputsPassBase &&) = delete;
  TPUUpdateEmbeddingEnqueueOpInputsPassBase& operator=(TPUUpdateEmbeddingEnqueueOpInputsPassBase &&) = delete;
  ~TPUUpdateEmbeddingEnqueueOpInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-update-embedding-enqueue-op-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-update-embedding-enqueue-op-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Updates inputs to TPU embedding enqueue ops depending on whether graph is in training mode or in evaluation mode."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUUpdateEmbeddingEnqueueOpInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUUpdateEmbeddingEnqueueOpInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUUpdateEmbeddingEnqueueOpInputsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUValidateInputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUValidateInputsPassBase;

  TPUValidateInputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUValidateInputsPassBase(const TPUValidateInputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TPUValidateInputsPassBase& operator=(const TPUValidateInputsPassBase &) = delete;
  TPUValidateInputsPassBase(TPUValidateInputsPassBase &&) = delete;
  TPUValidateInputsPassBase& operator=(TPUValidateInputsPassBase &&) = delete;
  ~TPUValidateInputsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-validate-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-validate-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Validates inputs to the TPU TF/XLA bridge"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUValidateInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUValidateInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUValidateInputsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorArrayOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorArrayOpsDecompositionPassBase;

  TensorArrayOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorArrayOpsDecompositionPassBase(const TensorArrayOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TensorArrayOpsDecompositionPassBase& operator=(const TensorArrayOpsDecompositionPassBase &) = delete;
  TensorArrayOpsDecompositionPassBase(TensorArrayOpsDecompositionPassBase &&) = delete;
  TensorArrayOpsDecompositionPassBase& operator=(TensorArrayOpsDecompositionPassBase &&) = delete;
  ~TensorArrayOpsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-array-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-array-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose tensor array operations into local variable operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorArrayOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorArrayOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorArrayOpsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorDeviceCopyConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorDeviceCopyConversionPassBase;

  TensorDeviceCopyConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorDeviceCopyConversionPassBase(const TensorDeviceCopyConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TensorDeviceCopyConversionPassBase& operator=(const TensorDeviceCopyConversionPassBase &) = delete;
  TensorDeviceCopyConversionPassBase(TensorDeviceCopyConversionPassBase &&) = delete;
  TensorDeviceCopyConversionPassBase& operator=(TensorDeviceCopyConversionPassBase &&) = delete;
  ~TensorDeviceCopyConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-device-copy");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-device-copy"; }

  ::llvm::StringRef getDescription() const override { return "Fold the tf.Identity op and the tf.IdentityN op if the op has the same device as its operand"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorDeviceCopyConversionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorDeviceCopyConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorDeviceCopyConversionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorFlowOptimizePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorFlowOptimizePassBase;

  TensorFlowOptimizePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowOptimizePassBase(const TensorFlowOptimizePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TensorFlowOptimizePassBase& operator=(const TensorFlowOptimizePassBase &) = delete;
  TensorFlowOptimizePassBase(TensorFlowOptimizePassBase &&) = delete;
  TensorFlowOptimizePassBase& operator=(TensorFlowOptimizePassBase &&) = delete;
  ~TensorFlowOptimizePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-optimize");
  }
  ::llvm::StringRef getArgument() const override { return "tf-optimize"; }

  ::llvm::StringRef getDescription() const override { return "Optimize TensorFlow module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowOptimizePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowOptimizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowOptimizePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorFlowShapeInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorFlowShapeInferencePassBase;

  TensorFlowShapeInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowShapeInferencePassBase(const TensorFlowShapeInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TensorFlowShapeInferencePassBase& operator=(const TensorFlowShapeInferencePassBase &) = delete;
  TensorFlowShapeInferencePassBase(TensorFlowShapeInferencePassBase &&) = delete;
  TensorFlowShapeInferencePassBase& operator=(TensorFlowShapeInferencePassBase &&) = delete;
  ~TensorFlowShapeInferencePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-shape-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-shape-inference"; }

  ::llvm::StringRef getDescription() const override { return "Shape inference on TF dialect and ops implementing InferTypeOpInterface"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowShapeInferencePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowShapeInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowShapeInferencePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> max_iterations_{*this, "max-iterations", ::llvm::cl::desc("Maximum shape inference iterations"), ::llvm::cl::init(10)};
  ::mlir::Pass::Option<std::string> input_arg_shapes_{*this, "input-arg-shapes", ::llvm::cl::desc("Input tensor shapes. Shapes for different tensors are separated by ':', and dimension sizes for the same tensor are separated by ','")};
};

template <typename DerivedT>
class TensorListOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorListOpsDecompositionPassBase;

  TensorListOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorListOpsDecompositionPassBase(const TensorListOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TensorListOpsDecompositionPassBase& operator=(const TensorListOpsDecompositionPassBase &) = delete;
  TensorListOpsDecompositionPassBase(TensorListOpsDecompositionPassBase &&) = delete;
  TensorListOpsDecompositionPassBase& operator=(TensorListOpsDecompositionPassBase &&) = delete;
  ~TensorListOpsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-list-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-list-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes TensorList operations into generic operations on tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorListOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorListOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorListOpsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorflowGPUFusionBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorflowGPUFusionBase;

  TensorflowGPUFusionBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorflowGPUFusionBase(const TensorflowGPUFusionBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TensorflowGPUFusionBase& operator=(const TensorflowGPUFusionBase &) = delete;
  TensorflowGPUFusionBase(TensorflowGPUFusionBase &&) = delete;
  TensorflowGPUFusionBase& operator=(TensorflowGPUFusionBase &&) = delete;
  ~TensorflowGPUFusionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-gpu-op-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-gpu-op-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fusion optimization for GPU targets"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorflowGPUFusion");
  }
  ::llvm::StringRef getName() const override { return "TensorflowGPUFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorflowGPUFusionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TpuV1BridgeExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TpuV1BridgeExecutorIslandCoarseningPassBase;

  TpuV1BridgeExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TpuV1BridgeExecutorIslandCoarseningPassBase(const TpuV1BridgeExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TpuV1BridgeExecutorIslandCoarseningPassBase& operator=(const TpuV1BridgeExecutorIslandCoarseningPassBase &) = delete;
  TpuV1BridgeExecutorIslandCoarseningPassBase(TpuV1BridgeExecutorIslandCoarseningPassBase &&) = delete;
  TpuV1BridgeExecutorIslandCoarseningPassBase& operator=(TpuV1BridgeExecutorIslandCoarseningPassBase &&) = delete;
  ~TpuV1BridgeExecutorIslandCoarseningPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Merges TPU clusters IslandOps, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TpuV1BridgeExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "TpuV1BridgeExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TpuV1BridgeExecutorIslandCoarseningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformEinsumPassBase;

  TransformEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformEinsumPassBase(const TransformEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  TransformEinsumPassBase& operator=(const TransformEinsumPassBase &) = delete;
  TransformEinsumPassBase(TransformEinsumPassBase &&) = delete;
  TransformEinsumPassBase& operator=(TransformEinsumPassBase &&) = delete;
  ~TransformEinsumPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Transform Einsum to other TF Ops for the supported variants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "TransformEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformEinsumPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class UnrollBatchMatMulPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnrollBatchMatMulPassBase;

  UnrollBatchMatMulPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnrollBatchMatMulPassBase(const UnrollBatchMatMulPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  UnrollBatchMatMulPassBase& operator=(const UnrollBatchMatMulPassBase &) = delete;
  UnrollBatchMatMulPassBase(UnrollBatchMatMulPassBase &&) = delete;
  UnrollBatchMatMulPassBase& operator=(UnrollBatchMatMulPassBase &&) = delete;
  ~UnrollBatchMatMulPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-unroll-batch-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tf-unroll-batch-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Unroll TF BatchMatMul op into Reshape, Slice, MatMul, Pack ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnrollBatchMatMulPass");
  }
  ::llvm::StringRef getName() const override { return "UnrollBatchMatMulPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnrollBatchMatMulPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VerifySuitableForExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = VerifySuitableForExportPassBase;

  VerifySuitableForExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VerifySuitableForExportPassBase(const VerifySuitableForExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  VerifySuitableForExportPassBase& operator=(const VerifySuitableForExportPassBase &) = delete;
  VerifySuitableForExportPassBase(VerifySuitableForExportPassBase &&) = delete;
  VerifySuitableForExportPassBase& operator=(VerifySuitableForExportPassBase &&) = delete;
  ~VerifySuitableForExportPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-verify-for-export");
  }
  ::llvm::StringRef getArgument() const override { return "tf-verify-for-export"; }

  ::llvm::StringRef getDescription() const override { return "Verify module is suitable for export back to TF Graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VerifySuitableForExportPass");
  }
  ::llvm::StringRef getName() const override { return "VerifySuitableForExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VerifySuitableForExportPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class XlaCallModuleDeserializationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = XlaCallModuleDeserializationPassBase;

  XlaCallModuleDeserializationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  XlaCallModuleDeserializationPassBase(const XlaCallModuleDeserializationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  XlaCallModuleDeserializationPassBase& operator=(const XlaCallModuleDeserializationPassBase &) = delete;
  XlaCallModuleDeserializationPassBase(XlaCallModuleDeserializationPassBase &&) = delete;
  XlaCallModuleDeserializationPassBase& operator=(XlaCallModuleDeserializationPassBase &&) = delete;
  ~XlaCallModuleDeserializationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-xla-call-module-deserialization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-xla-call-module-deserialization"; }

  ::llvm::StringRef getDescription() const override { return "Deserializes StableHLO functions embedded in `tf.XlaCallModule` to top level module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XlaCallModuleDeserializationPass");
  }
  ::llvm::StringRef getName() const override { return "XlaCallModuleDeserializationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<chlo::ChloDialect>();
    registry.insert<mhlo::MhloDialect>();
    registry.insert<shape::ShapeDialect>();
    registry.insert<stablehlo::StablehloDialect>();
    registry.insert<vhlo::VhloDialect>();
    registry.insert<quant::QuantizationDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XlaCallModuleDeserializationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class XlaCallModuleSerializationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = XlaCallModuleSerializationPassBase;

  XlaCallModuleSerializationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  XlaCallModuleSerializationPassBase(const XlaCallModuleSerializationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  XlaCallModuleSerializationPassBase& operator=(const XlaCallModuleSerializationPassBase &) = delete;
  XlaCallModuleSerializationPassBase(XlaCallModuleSerializationPassBase &&) = delete;
  XlaCallModuleSerializationPassBase& operator=(XlaCallModuleSerializationPassBase &&) = delete;
  ~XlaCallModuleSerializationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-xla-call-module-serialization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-xla-call-module-serialization"; }

  ::llvm::StringRef getDescription() const override { return "Serializes StableHLO functions from top-level module into `tf.XlaCallModule`'s `module` attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XlaCallModuleSerializationPass");
  }
  ::llvm::StringRef getName() const override { return "XlaCallModuleSerializationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<stablehlo::StablehloDialect>();
    registry.insert<vhlo::VhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XlaCallModuleSerializationPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
