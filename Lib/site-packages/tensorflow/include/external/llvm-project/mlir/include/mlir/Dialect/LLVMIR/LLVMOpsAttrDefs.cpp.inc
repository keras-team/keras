/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* AttrDef Definitions                                                        *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_ATTRDEF_LIST
#undef GET_ATTRDEF_LIST

::mlir::LLVM::CConvAttr,
::mlir::LLVM::ComdatAttr,
::mlir::LLVM::LinkageAttr,
::mlir::LLVM::FramePointerKindAttr,
::mlir::LLVM::LoopVectorizeAttr,
::mlir::LLVM::LoopInterleaveAttr,
::mlir::LLVM::LoopUnrollAttr,
::mlir::LLVM::LoopUnrollAndJamAttr,
::mlir::LLVM::LoopLICMAttr,
::mlir::LLVM::LoopDistributeAttr,
::mlir::LLVM::LoopPipelineAttr,
::mlir::LLVM::LoopPeeledAttr,
::mlir::LLVM::LoopUnswitchAttr,
::mlir::LLVM::LoopAnnotationAttr,
::mlir::LLVM::DIExpressionElemAttr,
::mlir::LLVM::DIExpressionAttr,
::mlir::LLVM::DINullTypeAttr,
::mlir::LLVM::DIBasicTypeAttr,
::mlir::LLVM::DICompileUnitAttr,
::mlir::LLVM::DICompositeTypeAttr,
::mlir::LLVM::DIDerivedTypeAttr,
::mlir::LLVM::DIFileAttr,
::mlir::LLVM::DIGlobalVariableExpressionAttr,
::mlir::LLVM::DIGlobalVariableAttr,
::mlir::LLVM::DILexicalBlockAttr,
::mlir::LLVM::DILexicalBlockFileAttr,
::mlir::LLVM::DILocalVariableAttr,
::mlir::LLVM::DISubprogramAttr,
::mlir::LLVM::DIModuleAttr,
::mlir::LLVM::DINamespaceAttr,
::mlir::LLVM::DIImportedEntityAttr,
::mlir::LLVM::DISubrangeAttr,
::mlir::LLVM::DISubroutineTypeAttr,
::mlir::LLVM::DILabelAttr,
::mlir::LLVM::DIStringTypeAttr,
::mlir::LLVM::MemoryEffectsAttr,
::mlir::LLVM::AliasScopeDomainAttr,
::mlir::LLVM::AliasScopeAttr,
::mlir::LLVM::AccessGroupAttr,
::mlir::LLVM::TBAARootAttr,
::mlir::LLVM::TBAAMemberAttr,
::mlir::LLVM::TBAATypeDescriptorAttr,
::mlir::LLVM::TBAATagAttr,
::mlir::LLVM::ConstantRangeAttr,
::mlir::LLVM::VScaleRangeAttr,
::mlir::LLVM::TargetFeaturesAttr,
::mlir::LLVM::UndefAttr,
::mlir::LLVM::PoisonAttr,
::mlir::LLVM::VecTypeHintAttr,
::mlir::LLVM::ZeroAttr,
::mlir::LLVM::TailCallKindAttr,
::mlir::LLVM::WorkgroupAttributionAttr,
::mlir::LLVM::IntegerOverflowFlagsAttr,
::mlir::LLVM::FastmathFlagsAttr

#endif  // GET_ATTRDEF_LIST

#ifdef GET_ATTRDEF_CLASSES
#undef GET_ATTRDEF_CLASSES

static ::mlir::OptionalParseResult generatedAttributeParser(::mlir::AsmParser &parser, ::llvm::StringRef *mnemonic, ::mlir::Type type, ::mlir::Attribute &value) {
  return ::mlir::AsmParser::KeywordSwitch<::mlir::OptionalParseResult>(parser)
    .Case(::mlir::LLVM::CConvAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::CConvAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::ComdatAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::ComdatAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LinkageAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LinkageAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::FramePointerKindAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::FramePointerKindAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopVectorizeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopVectorizeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopInterleaveAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopInterleaveAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopUnrollAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopUnrollAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopUnrollAndJamAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopUnrollAndJamAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopLICMAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopLICMAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopDistributeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopDistributeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopPipelineAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopPipelineAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopPeeledAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopPeeledAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopUnswitchAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopUnswitchAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::LoopAnnotationAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::LoopAnnotationAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIExpressionElemAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIExpressionElemAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIExpressionAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIExpressionAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DINullTypeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DINullTypeAttr::get(parser.getContext());
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIBasicTypeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIBasicTypeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DICompileUnitAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DICompileUnitAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DICompositeTypeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DICompositeTypeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIDerivedTypeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIDerivedTypeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIFileAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIFileAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIGlobalVariableExpressionAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIGlobalVariableExpressionAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIGlobalVariableAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIGlobalVariableAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DILexicalBlockAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DILexicalBlockAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DILexicalBlockFileAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DILexicalBlockFileAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DILocalVariableAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DILocalVariableAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DISubprogramAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DISubprogramAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIModuleAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIModuleAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DINamespaceAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DINamespaceAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIImportedEntityAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIImportedEntityAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DISubrangeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DISubrangeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DISubroutineTypeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DISubroutineTypeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DILabelAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DILabelAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::DIStringTypeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::DIStringTypeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::MemoryEffectsAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::MemoryEffectsAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::AliasScopeDomainAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::AliasScopeDomainAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::AliasScopeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::AliasScopeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::AccessGroupAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::AccessGroupAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::TBAARootAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::TBAARootAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::TBAAMemberAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::TBAAMemberAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::TBAATypeDescriptorAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::TBAATypeDescriptorAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::TBAATagAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::TBAATagAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::ConstantRangeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::ConstantRangeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::VScaleRangeAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::VScaleRangeAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::TargetFeaturesAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::TargetFeaturesAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::UndefAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::UndefAttr::get(parser.getContext());
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::PoisonAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::PoisonAttr::get(parser.getContext());
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::VecTypeHintAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::VecTypeHintAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::ZeroAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::ZeroAttr::get(parser.getContext());
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::TailCallKindAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::TailCallKindAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::WorkgroupAttributionAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::WorkgroupAttributionAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::IntegerOverflowFlagsAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::IntegerOverflowFlagsAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Case(::mlir::LLVM::FastmathFlagsAttr::getMnemonic(), [&](llvm::StringRef, llvm::SMLoc) {
      value = ::mlir::LLVM::FastmathFlagsAttr::parse(parser, type);
      return ::mlir::success(!!value);
    })
    .Default([&](llvm::StringRef keyword, llvm::SMLoc) {
      *mnemonic = keyword;
      return std::nullopt;
    });
}

static ::llvm::LogicalResult generatedAttributePrinter(::mlir::Attribute def, ::mlir::AsmPrinter &printer) {
  return ::llvm::TypeSwitch<::mlir::Attribute, ::llvm::LogicalResult>(def)    .Case<::mlir::LLVM::CConvAttr>([&](auto t) {
      printer << ::mlir::LLVM::CConvAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::ComdatAttr>([&](auto t) {
      printer << ::mlir::LLVM::ComdatAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LinkageAttr>([&](auto t) {
      printer << ::mlir::LLVM::LinkageAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::FramePointerKindAttr>([&](auto t) {
      printer << ::mlir::LLVM::FramePointerKindAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopVectorizeAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopVectorizeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopInterleaveAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopInterleaveAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopUnrollAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopUnrollAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopUnrollAndJamAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopUnrollAndJamAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopLICMAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopLICMAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopDistributeAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopDistributeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopPipelineAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopPipelineAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopPeeledAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopPeeledAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopUnswitchAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopUnswitchAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::LoopAnnotationAttr>([&](auto t) {
      printer << ::mlir::LLVM::LoopAnnotationAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIExpressionElemAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIExpressionElemAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIExpressionAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIExpressionAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DINullTypeAttr>([&](auto t) {
      printer << ::mlir::LLVM::DINullTypeAttr::getMnemonic();
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIBasicTypeAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIBasicTypeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DICompileUnitAttr>([&](auto t) {
      printer << ::mlir::LLVM::DICompileUnitAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DICompositeTypeAttr>([&](auto t) {
      printer << ::mlir::LLVM::DICompositeTypeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIDerivedTypeAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIDerivedTypeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIFileAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIFileAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIGlobalVariableExpressionAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIGlobalVariableExpressionAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIGlobalVariableAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIGlobalVariableAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DILexicalBlockAttr>([&](auto t) {
      printer << ::mlir::LLVM::DILexicalBlockAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DILexicalBlockFileAttr>([&](auto t) {
      printer << ::mlir::LLVM::DILexicalBlockFileAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DILocalVariableAttr>([&](auto t) {
      printer << ::mlir::LLVM::DILocalVariableAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DISubprogramAttr>([&](auto t) {
      printer << ::mlir::LLVM::DISubprogramAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIModuleAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIModuleAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DINamespaceAttr>([&](auto t) {
      printer << ::mlir::LLVM::DINamespaceAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIImportedEntityAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIImportedEntityAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DISubrangeAttr>([&](auto t) {
      printer << ::mlir::LLVM::DISubrangeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DISubroutineTypeAttr>([&](auto t) {
      printer << ::mlir::LLVM::DISubroutineTypeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DILabelAttr>([&](auto t) {
      printer << ::mlir::LLVM::DILabelAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::DIStringTypeAttr>([&](auto t) {
      printer << ::mlir::LLVM::DIStringTypeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::MemoryEffectsAttr>([&](auto t) {
      printer << ::mlir::LLVM::MemoryEffectsAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::AliasScopeDomainAttr>([&](auto t) {
      printer << ::mlir::LLVM::AliasScopeDomainAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::AliasScopeAttr>([&](auto t) {
      printer << ::mlir::LLVM::AliasScopeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::AccessGroupAttr>([&](auto t) {
      printer << ::mlir::LLVM::AccessGroupAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::TBAARootAttr>([&](auto t) {
      printer << ::mlir::LLVM::TBAARootAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::TBAAMemberAttr>([&](auto t) {
      printer << ::mlir::LLVM::TBAAMemberAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::TBAATypeDescriptorAttr>([&](auto t) {
      printer << ::mlir::LLVM::TBAATypeDescriptorAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::TBAATagAttr>([&](auto t) {
      printer << ::mlir::LLVM::TBAATagAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::ConstantRangeAttr>([&](auto t) {
      printer << ::mlir::LLVM::ConstantRangeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::VScaleRangeAttr>([&](auto t) {
      printer << ::mlir::LLVM::VScaleRangeAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::TargetFeaturesAttr>([&](auto t) {
      printer << ::mlir::LLVM::TargetFeaturesAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::UndefAttr>([&](auto t) {
      printer << ::mlir::LLVM::UndefAttr::getMnemonic();
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::PoisonAttr>([&](auto t) {
      printer << ::mlir::LLVM::PoisonAttr::getMnemonic();
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::VecTypeHintAttr>([&](auto t) {
      printer << ::mlir::LLVM::VecTypeHintAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::ZeroAttr>([&](auto t) {
      printer << ::mlir::LLVM::ZeroAttr::getMnemonic();
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::TailCallKindAttr>([&](auto t) {
      printer << ::mlir::LLVM::TailCallKindAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::WorkgroupAttributionAttr>([&](auto t) {
      printer << ::mlir::LLVM::WorkgroupAttributionAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::IntegerOverflowFlagsAttr>([&](auto t) {
      printer << ::mlir::LLVM::IntegerOverflowFlagsAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Case<::mlir::LLVM::FastmathFlagsAttr>([&](auto t) {
      printer << ::mlir::LLVM::FastmathFlagsAttr::getMnemonic();
t.print(printer);
      return ::mlir::success();
    })
    .Default([](auto) { return ::mlir::failure(); });
}

namespace mlir {
namespace LLVM {
namespace detail {
struct CConvAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<CConv>;
  CConvAttrStorage(CConv CallingConv) : CallingConv(std::move(CallingConv)) {}

  KeyTy getAsKey() const {
    return KeyTy(CallingConv);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (CallingConv == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static CConvAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto CallingConv = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<CConvAttrStorage>()) CConvAttrStorage(std::move(CallingConv));
  }

  CConv CallingConv;
};
} // namespace detail
CConvAttr CConvAttr::get(::mlir::MLIRContext *context, CConv CallingConv) {
  return Base::get(context, std::move(CallingConv));
}

::mlir::Attribute CConvAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<CConv> _result_CallingConv;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'CallingConv'
  _result_CallingConv = ::mlir::FieldParser<CConv>::parse(odsParser);
  if (::mlir::failed(_result_CallingConv)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse CConvAttr parameter 'CallingConv' which is to be a `CConv`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_CallingConv));
  return CConvAttr::get(odsParser.getContext(),
      CConv((*_result_CallingConv)));
}

void CConvAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter.printStrippedAttrOrType(getCallingConv());
  odsPrinter << ">";
}

CConv CConvAttr::getCallingConv() const {
  return getImpl()->CallingConv;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::CConvAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct ComdatAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<comdat::Comdat>;
  ComdatAttrStorage(comdat::Comdat comdat) : comdat(std::move(comdat)) {}

  KeyTy getAsKey() const {
    return KeyTy(comdat);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (comdat == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static ComdatAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto comdat = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<ComdatAttrStorage>()) ComdatAttrStorage(std::move(comdat));
  }

  comdat::Comdat comdat;
};
} // namespace detail
ComdatAttr ComdatAttr::get(::mlir::MLIRContext *context, comdat::Comdat comdat) {
  return Base::get(context, std::move(comdat));
}

::mlir::Attribute ComdatAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<comdat::Comdat> _result_comdat;

  // Parse variable 'comdat'
  _result_comdat = ::mlir::FieldParser<comdat::Comdat>::parse(odsParser);
  if (::mlir::failed(_result_comdat)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse ComdatAttr parameter 'comdat' which is to be a `comdat::Comdat`");
    return {};
  }
  assert(::mlir::succeeded(_result_comdat));
  return ComdatAttr::get(odsParser.getContext(),
      comdat::Comdat((*_result_comdat)));
}

void ComdatAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << ' ';
  odsPrinter.printStrippedAttrOrType(getComdat());
}

comdat::Comdat ComdatAttr::getComdat() const {
  return getImpl()->comdat;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ComdatAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LinkageAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<linkage::Linkage>;
  LinkageAttrStorage(linkage::Linkage linkage) : linkage(std::move(linkage)) {}

  KeyTy getAsKey() const {
    return KeyTy(linkage);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (linkage == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static LinkageAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto linkage = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<LinkageAttrStorage>()) LinkageAttrStorage(std::move(linkage));
  }

  linkage::Linkage linkage;
};
} // namespace detail
LinkageAttr LinkageAttr::get(::mlir::MLIRContext *context, linkage::Linkage linkage) {
  return Base::get(context, std::move(linkage));
}

::mlir::Attribute LinkageAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<linkage::Linkage> _result_linkage;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'linkage'
  _result_linkage = ::mlir::FieldParser<linkage::Linkage>::parse(odsParser);
  if (::mlir::failed(_result_linkage)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LinkageAttr parameter 'linkage' which is to be a `linkage::Linkage`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_linkage));
  return LinkageAttr::get(odsParser.getContext(),
      linkage::Linkage((*_result_linkage)));
}

void LinkageAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter.printStrippedAttrOrType(getLinkage());
  odsPrinter << ">";
}

linkage::Linkage LinkageAttr::getLinkage() const {
  return getImpl()->linkage;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LinkageAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct FramePointerKindAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<framePointerKind::FramePointerKind>;
  FramePointerKindAttrStorage(framePointerKind::FramePointerKind framePointerKind) : framePointerKind(std::move(framePointerKind)) {}

  KeyTy getAsKey() const {
    return KeyTy(framePointerKind);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (framePointerKind == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static FramePointerKindAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto framePointerKind = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<FramePointerKindAttrStorage>()) FramePointerKindAttrStorage(std::move(framePointerKind));
  }

  framePointerKind::FramePointerKind framePointerKind;
};
} // namespace detail
FramePointerKindAttr FramePointerKindAttr::get(::mlir::MLIRContext *context, framePointerKind::FramePointerKind framePointerKind) {
  return Base::get(context, std::move(framePointerKind));
}

::mlir::Attribute FramePointerKindAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<framePointerKind::FramePointerKind> _result_framePointerKind;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'framePointerKind'
  _result_framePointerKind = ::mlir::FieldParser<framePointerKind::FramePointerKind>::parse(odsParser);
  if (::mlir::failed(_result_framePointerKind)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse FramePointerKindAttr parameter 'framePointerKind' which is to be a `framePointerKind::FramePointerKind`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_framePointerKind));
  return FramePointerKindAttr::get(odsParser.getContext(),
      framePointerKind::FramePointerKind((*_result_framePointerKind)));
}

void FramePointerKindAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter.printStrippedAttrOrType(getFramePointerKind());
  odsPrinter << ">";
}

framePointerKind::FramePointerKind FramePointerKindAttr::getFramePointerKind() const {
  return getImpl()->framePointerKind;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FramePointerKindAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopVectorizeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr, BoolAttr, BoolAttr, IntegerAttr, LoopAnnotationAttr, LoopAnnotationAttr, LoopAnnotationAttr>;
  LoopVectorizeAttrStorage(BoolAttr disable, BoolAttr predicateEnable, BoolAttr scalableEnable, IntegerAttr width, LoopAnnotationAttr followupVectorized, LoopAnnotationAttr followupEpilogue, LoopAnnotationAttr followupAll) : disable(std::move(disable)), predicateEnable(std::move(predicateEnable)), scalableEnable(std::move(scalableEnable)), width(std::move(width)), followupVectorized(std::move(followupVectorized)), followupEpilogue(std::move(followupEpilogue)), followupAll(std::move(followupAll)) {}

  KeyTy getAsKey() const {
    return KeyTy(disable, predicateEnable, scalableEnable, width, followupVectorized, followupEpilogue, followupAll);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (disable == std::get<0>(tblgenKey)) && (predicateEnable == std::get<1>(tblgenKey)) && (scalableEnable == std::get<2>(tblgenKey)) && (width == std::get<3>(tblgenKey)) && (followupVectorized == std::get<4>(tblgenKey)) && (followupEpilogue == std::get<5>(tblgenKey)) && (followupAll == std::get<6>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey));
  }

  static LoopVectorizeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto disable = std::move(std::get<0>(tblgenKey));
    auto predicateEnable = std::move(std::get<1>(tblgenKey));
    auto scalableEnable = std::move(std::get<2>(tblgenKey));
    auto width = std::move(std::get<3>(tblgenKey));
    auto followupVectorized = std::move(std::get<4>(tblgenKey));
    auto followupEpilogue = std::move(std::get<5>(tblgenKey));
    auto followupAll = std::move(std::get<6>(tblgenKey));
    return new (allocator.allocate<LoopVectorizeAttrStorage>()) LoopVectorizeAttrStorage(std::move(disable), std::move(predicateEnable), std::move(scalableEnable), std::move(width), std::move(followupVectorized), std::move(followupEpilogue), std::move(followupAll));
  }

  BoolAttr disable;
  BoolAttr predicateEnable;
  BoolAttr scalableEnable;
  IntegerAttr width;
  LoopAnnotationAttr followupVectorized;
  LoopAnnotationAttr followupEpilogue;
  LoopAnnotationAttr followupAll;
};
} // namespace detail
LoopVectorizeAttr LoopVectorizeAttr::get(::mlir::MLIRContext *context, BoolAttr disable, BoolAttr predicateEnable, BoolAttr scalableEnable, IntegerAttr width, LoopAnnotationAttr followupVectorized, LoopAnnotationAttr followupEpilogue, LoopAnnotationAttr followupAll) {
  return Base::get(context, std::move(disable), std::move(predicateEnable), std::move(scalableEnable), std::move(width), std::move(followupVectorized), std::move(followupEpilogue), std::move(followupAll));
}

::mlir::Attribute LoopVectorizeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_disable;
  ::mlir::FailureOr<BoolAttr> _result_predicateEnable;
  ::mlir::FailureOr<BoolAttr> _result_scalableEnable;
  ::mlir::FailureOr<IntegerAttr> _result_width;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupVectorized;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupEpilogue;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupAll;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_disable = false;
  bool _seen_predicateEnable = false;
  bool _seen_scalableEnable = false;
  bool _seen_width = false;
  bool _seen_followupVectorized = false;
  bool _seen_followupEpilogue = false;
  bool _seen_followupAll = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_disable && _paramKey == "disable") {
        _seen_disable = true;

        // Parse variable 'disable'
        _result_disable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_disable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopVectorizeAttr parameter 'disable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_predicateEnable && _paramKey == "predicateEnable") {
        _seen_predicateEnable = true;

        // Parse variable 'predicateEnable'
        _result_predicateEnable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_predicateEnable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopVectorizeAttr parameter 'predicateEnable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_scalableEnable && _paramKey == "scalableEnable") {
        _seen_scalableEnable = true;

        // Parse variable 'scalableEnable'
        _result_scalableEnable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_scalableEnable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopVectorizeAttr parameter 'scalableEnable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_width && _paramKey == "width") {
        _seen_width = true;

        // Parse variable 'width'
        _result_width = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_width)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopVectorizeAttr parameter 'width' which is to be a `IntegerAttr`");
          return {};
        }
      } else if (!_seen_followupVectorized && _paramKey == "followupVectorized") {
        _seen_followupVectorized = true;

        // Parse variable 'followupVectorized'
        _result_followupVectorized = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupVectorized)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopVectorizeAttr parameter 'followupVectorized' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupEpilogue && _paramKey == "followupEpilogue") {
        _seen_followupEpilogue = true;

        // Parse variable 'followupEpilogue'
        _result_followupEpilogue = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupEpilogue)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopVectorizeAttr parameter 'followupEpilogue' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupAll && _paramKey == "followupAll") {
        _seen_followupAll = true;

        // Parse variable 'followupAll'
        _result_followupAll = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupAll)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopVectorizeAttr parameter 'followupAll' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopVectorizeAttr::get(odsParser.getContext(),
      BoolAttr((_result_disable.value_or(BoolAttr()))),
      BoolAttr((_result_predicateEnable.value_or(BoolAttr()))),
      BoolAttr((_result_scalableEnable.value_or(BoolAttr()))),
      IntegerAttr((_result_width.value_or(IntegerAttr()))),
      LoopAnnotationAttr((_result_followupVectorized.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupEpilogue.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupAll.value_or(LoopAnnotationAttr()))));
}

void LoopVectorizeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "disable = ";
      if (!(getDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getDisable());
      }
    }
    if (!(getPredicateEnable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "predicateEnable = ";
      if (!(getPredicateEnable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getPredicateEnable());
      }
    }
    if (!(getScalableEnable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "scalableEnable = ";
      if (!(getScalableEnable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getScalableEnable());
      }
    }
    if (!(getWidth() == IntegerAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "width = ";
      if (!(getWidth() == IntegerAttr())) {
        odsPrinter.printStrippedAttrOrType(getWidth());
      }
    }
    if (!(getFollowupVectorized() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupVectorized = ";
      if (!(getFollowupVectorized() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupVectorized());
      }
    }
    if (!(getFollowupEpilogue() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupEpilogue = ";
      if (!(getFollowupEpilogue() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupEpilogue());
      }
    }
    if (!(getFollowupAll() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupAll = ";
      if (!(getFollowupAll() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupAll());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopVectorizeAttr::getDisable() const {
  return getImpl()->disable;
}

BoolAttr LoopVectorizeAttr::getPredicateEnable() const {
  return getImpl()->predicateEnable;
}

BoolAttr LoopVectorizeAttr::getScalableEnable() const {
  return getImpl()->scalableEnable;
}

IntegerAttr LoopVectorizeAttr::getWidth() const {
  return getImpl()->width;
}

LoopAnnotationAttr LoopVectorizeAttr::getFollowupVectorized() const {
  return getImpl()->followupVectorized;
}

LoopAnnotationAttr LoopVectorizeAttr::getFollowupEpilogue() const {
  return getImpl()->followupEpilogue;
}

LoopAnnotationAttr LoopVectorizeAttr::getFollowupAll() const {
  return getImpl()->followupAll;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopVectorizeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopInterleaveAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<IntegerAttr>;
  LoopInterleaveAttrStorage(IntegerAttr count) : count(std::move(count)) {}

  KeyTy getAsKey() const {
    return KeyTy(count);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (count == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static LoopInterleaveAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto count = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<LoopInterleaveAttrStorage>()) LoopInterleaveAttrStorage(std::move(count));
  }

  IntegerAttr count;
};
} // namespace detail
LoopInterleaveAttr LoopInterleaveAttr::get(::mlir::MLIRContext *context, IntegerAttr count) {
  return Base::get(context, std::move(count));
}

::mlir::Attribute LoopInterleaveAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<IntegerAttr> _result_count;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_count = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_count && _paramKey == "count") {
        _seen_count = true;

        // Parse variable 'count'
        _result_count = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_count)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopInterleaveAttr parameter 'count' which is to be a `IntegerAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    for (unsigned odsStructIndex = 0; odsStructIndex < 1; ++odsStructIndex) {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
      if ((odsStructIndex != 1 - 1) && odsParser.parseComma())
        return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_count));
  return LoopInterleaveAttr::get(odsParser.getContext(),
      IntegerAttr((*_result_count)));
}

void LoopInterleaveAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "count = ";
    odsPrinter.printStrippedAttrOrType(getCount());
  }
  odsPrinter << ">";
}

IntegerAttr LoopInterleaveAttr::getCount() const {
  return getImpl()->count;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopInterleaveAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopUnrollAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr, IntegerAttr, BoolAttr, BoolAttr, LoopAnnotationAttr, LoopAnnotationAttr, LoopAnnotationAttr>;
  LoopUnrollAttrStorage(BoolAttr disable, IntegerAttr count, BoolAttr runtimeDisable, BoolAttr full, LoopAnnotationAttr followupUnrolled, LoopAnnotationAttr followupRemainder, LoopAnnotationAttr followupAll) : disable(std::move(disable)), count(std::move(count)), runtimeDisable(std::move(runtimeDisable)), full(std::move(full)), followupUnrolled(std::move(followupUnrolled)), followupRemainder(std::move(followupRemainder)), followupAll(std::move(followupAll)) {}

  KeyTy getAsKey() const {
    return KeyTy(disable, count, runtimeDisable, full, followupUnrolled, followupRemainder, followupAll);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (disable == std::get<0>(tblgenKey)) && (count == std::get<1>(tblgenKey)) && (runtimeDisable == std::get<2>(tblgenKey)) && (full == std::get<3>(tblgenKey)) && (followupUnrolled == std::get<4>(tblgenKey)) && (followupRemainder == std::get<5>(tblgenKey)) && (followupAll == std::get<6>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey));
  }

  static LoopUnrollAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto disable = std::move(std::get<0>(tblgenKey));
    auto count = std::move(std::get<1>(tblgenKey));
    auto runtimeDisable = std::move(std::get<2>(tblgenKey));
    auto full = std::move(std::get<3>(tblgenKey));
    auto followupUnrolled = std::move(std::get<4>(tblgenKey));
    auto followupRemainder = std::move(std::get<5>(tblgenKey));
    auto followupAll = std::move(std::get<6>(tblgenKey));
    return new (allocator.allocate<LoopUnrollAttrStorage>()) LoopUnrollAttrStorage(std::move(disable), std::move(count), std::move(runtimeDisable), std::move(full), std::move(followupUnrolled), std::move(followupRemainder), std::move(followupAll));
  }

  BoolAttr disable;
  IntegerAttr count;
  BoolAttr runtimeDisable;
  BoolAttr full;
  LoopAnnotationAttr followupUnrolled;
  LoopAnnotationAttr followupRemainder;
  LoopAnnotationAttr followupAll;
};
} // namespace detail
LoopUnrollAttr LoopUnrollAttr::get(::mlir::MLIRContext *context, BoolAttr disable, IntegerAttr count, BoolAttr runtimeDisable, BoolAttr full, LoopAnnotationAttr followupUnrolled, LoopAnnotationAttr followupRemainder, LoopAnnotationAttr followupAll) {
  return Base::get(context, std::move(disable), std::move(count), std::move(runtimeDisable), std::move(full), std::move(followupUnrolled), std::move(followupRemainder), std::move(followupAll));
}

::mlir::Attribute LoopUnrollAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_disable;
  ::mlir::FailureOr<IntegerAttr> _result_count;
  ::mlir::FailureOr<BoolAttr> _result_runtimeDisable;
  ::mlir::FailureOr<BoolAttr> _result_full;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupUnrolled;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupRemainder;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupAll;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_disable = false;
  bool _seen_count = false;
  bool _seen_runtimeDisable = false;
  bool _seen_full = false;
  bool _seen_followupUnrolled = false;
  bool _seen_followupRemainder = false;
  bool _seen_followupAll = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_disable && _paramKey == "disable") {
        _seen_disable = true;

        // Parse variable 'disable'
        _result_disable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_disable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAttr parameter 'disable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_count && _paramKey == "count") {
        _seen_count = true;

        // Parse variable 'count'
        _result_count = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_count)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAttr parameter 'count' which is to be a `IntegerAttr`");
          return {};
        }
      } else if (!_seen_runtimeDisable && _paramKey == "runtimeDisable") {
        _seen_runtimeDisable = true;

        // Parse variable 'runtimeDisable'
        _result_runtimeDisable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_runtimeDisable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAttr parameter 'runtimeDisable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_full && _paramKey == "full") {
        _seen_full = true;

        // Parse variable 'full'
        _result_full = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_full)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAttr parameter 'full' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_followupUnrolled && _paramKey == "followupUnrolled") {
        _seen_followupUnrolled = true;

        // Parse variable 'followupUnrolled'
        _result_followupUnrolled = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupUnrolled)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAttr parameter 'followupUnrolled' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupRemainder && _paramKey == "followupRemainder") {
        _seen_followupRemainder = true;

        // Parse variable 'followupRemainder'
        _result_followupRemainder = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupRemainder)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAttr parameter 'followupRemainder' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupAll && _paramKey == "followupAll") {
        _seen_followupAll = true;

        // Parse variable 'followupAll'
        _result_followupAll = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupAll)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAttr parameter 'followupAll' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopUnrollAttr::get(odsParser.getContext(),
      BoolAttr((_result_disable.value_or(BoolAttr()))),
      IntegerAttr((_result_count.value_or(IntegerAttr()))),
      BoolAttr((_result_runtimeDisable.value_or(BoolAttr()))),
      BoolAttr((_result_full.value_or(BoolAttr()))),
      LoopAnnotationAttr((_result_followupUnrolled.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupRemainder.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupAll.value_or(LoopAnnotationAttr()))));
}

void LoopUnrollAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "disable = ";
      if (!(getDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getDisable());
      }
    }
    if (!(getCount() == IntegerAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "count = ";
      if (!(getCount() == IntegerAttr())) {
        odsPrinter.printStrippedAttrOrType(getCount());
      }
    }
    if (!(getRuntimeDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "runtimeDisable = ";
      if (!(getRuntimeDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getRuntimeDisable());
      }
    }
    if (!(getFull() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "full = ";
      if (!(getFull() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getFull());
      }
    }
    if (!(getFollowupUnrolled() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupUnrolled = ";
      if (!(getFollowupUnrolled() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupUnrolled());
      }
    }
    if (!(getFollowupRemainder() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupRemainder = ";
      if (!(getFollowupRemainder() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupRemainder());
      }
    }
    if (!(getFollowupAll() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupAll = ";
      if (!(getFollowupAll() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupAll());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopUnrollAttr::getDisable() const {
  return getImpl()->disable;
}

IntegerAttr LoopUnrollAttr::getCount() const {
  return getImpl()->count;
}

BoolAttr LoopUnrollAttr::getRuntimeDisable() const {
  return getImpl()->runtimeDisable;
}

BoolAttr LoopUnrollAttr::getFull() const {
  return getImpl()->full;
}

LoopAnnotationAttr LoopUnrollAttr::getFollowupUnrolled() const {
  return getImpl()->followupUnrolled;
}

LoopAnnotationAttr LoopUnrollAttr::getFollowupRemainder() const {
  return getImpl()->followupRemainder;
}

LoopAnnotationAttr LoopUnrollAttr::getFollowupAll() const {
  return getImpl()->followupAll;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopUnrollAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopUnrollAndJamAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr, IntegerAttr, LoopAnnotationAttr, LoopAnnotationAttr, LoopAnnotationAttr, LoopAnnotationAttr, LoopAnnotationAttr>;
  LoopUnrollAndJamAttrStorage(BoolAttr disable, IntegerAttr count, LoopAnnotationAttr followupOuter, LoopAnnotationAttr followupInner, LoopAnnotationAttr followupRemainderOuter, LoopAnnotationAttr followupRemainderInner, LoopAnnotationAttr followupAll) : disable(std::move(disable)), count(std::move(count)), followupOuter(std::move(followupOuter)), followupInner(std::move(followupInner)), followupRemainderOuter(std::move(followupRemainderOuter)), followupRemainderInner(std::move(followupRemainderInner)), followupAll(std::move(followupAll)) {}

  KeyTy getAsKey() const {
    return KeyTy(disable, count, followupOuter, followupInner, followupRemainderOuter, followupRemainderInner, followupAll);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (disable == std::get<0>(tblgenKey)) && (count == std::get<1>(tblgenKey)) && (followupOuter == std::get<2>(tblgenKey)) && (followupInner == std::get<3>(tblgenKey)) && (followupRemainderOuter == std::get<4>(tblgenKey)) && (followupRemainderInner == std::get<5>(tblgenKey)) && (followupAll == std::get<6>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey));
  }

  static LoopUnrollAndJamAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto disable = std::move(std::get<0>(tblgenKey));
    auto count = std::move(std::get<1>(tblgenKey));
    auto followupOuter = std::move(std::get<2>(tblgenKey));
    auto followupInner = std::move(std::get<3>(tblgenKey));
    auto followupRemainderOuter = std::move(std::get<4>(tblgenKey));
    auto followupRemainderInner = std::move(std::get<5>(tblgenKey));
    auto followupAll = std::move(std::get<6>(tblgenKey));
    return new (allocator.allocate<LoopUnrollAndJamAttrStorage>()) LoopUnrollAndJamAttrStorage(std::move(disable), std::move(count), std::move(followupOuter), std::move(followupInner), std::move(followupRemainderOuter), std::move(followupRemainderInner), std::move(followupAll));
  }

  BoolAttr disable;
  IntegerAttr count;
  LoopAnnotationAttr followupOuter;
  LoopAnnotationAttr followupInner;
  LoopAnnotationAttr followupRemainderOuter;
  LoopAnnotationAttr followupRemainderInner;
  LoopAnnotationAttr followupAll;
};
} // namespace detail
LoopUnrollAndJamAttr LoopUnrollAndJamAttr::get(::mlir::MLIRContext *context, BoolAttr disable, IntegerAttr count, LoopAnnotationAttr followupOuter, LoopAnnotationAttr followupInner, LoopAnnotationAttr followupRemainderOuter, LoopAnnotationAttr followupRemainderInner, LoopAnnotationAttr followupAll) {
  return Base::get(context, std::move(disable), std::move(count), std::move(followupOuter), std::move(followupInner), std::move(followupRemainderOuter), std::move(followupRemainderInner), std::move(followupAll));
}

::mlir::Attribute LoopUnrollAndJamAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_disable;
  ::mlir::FailureOr<IntegerAttr> _result_count;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupOuter;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupInner;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupRemainderOuter;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupRemainderInner;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupAll;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_disable = false;
  bool _seen_count = false;
  bool _seen_followupOuter = false;
  bool _seen_followupInner = false;
  bool _seen_followupRemainderOuter = false;
  bool _seen_followupRemainderInner = false;
  bool _seen_followupAll = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_disable && _paramKey == "disable") {
        _seen_disable = true;

        // Parse variable 'disable'
        _result_disable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_disable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAndJamAttr parameter 'disable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_count && _paramKey == "count") {
        _seen_count = true;

        // Parse variable 'count'
        _result_count = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_count)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAndJamAttr parameter 'count' which is to be a `IntegerAttr`");
          return {};
        }
      } else if (!_seen_followupOuter && _paramKey == "followupOuter") {
        _seen_followupOuter = true;

        // Parse variable 'followupOuter'
        _result_followupOuter = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupOuter)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAndJamAttr parameter 'followupOuter' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupInner && _paramKey == "followupInner") {
        _seen_followupInner = true;

        // Parse variable 'followupInner'
        _result_followupInner = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupInner)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAndJamAttr parameter 'followupInner' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupRemainderOuter && _paramKey == "followupRemainderOuter") {
        _seen_followupRemainderOuter = true;

        // Parse variable 'followupRemainderOuter'
        _result_followupRemainderOuter = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupRemainderOuter)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAndJamAttr parameter 'followupRemainderOuter' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupRemainderInner && _paramKey == "followupRemainderInner") {
        _seen_followupRemainderInner = true;

        // Parse variable 'followupRemainderInner'
        _result_followupRemainderInner = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupRemainderInner)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAndJamAttr parameter 'followupRemainderInner' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupAll && _paramKey == "followupAll") {
        _seen_followupAll = true;

        // Parse variable 'followupAll'
        _result_followupAll = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupAll)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnrollAndJamAttr parameter 'followupAll' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopUnrollAndJamAttr::get(odsParser.getContext(),
      BoolAttr((_result_disable.value_or(BoolAttr()))),
      IntegerAttr((_result_count.value_or(IntegerAttr()))),
      LoopAnnotationAttr((_result_followupOuter.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupInner.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupRemainderOuter.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupRemainderInner.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupAll.value_or(LoopAnnotationAttr()))));
}

void LoopUnrollAndJamAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "disable = ";
      if (!(getDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getDisable());
      }
    }
    if (!(getCount() == IntegerAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "count = ";
      if (!(getCount() == IntegerAttr())) {
        odsPrinter.printStrippedAttrOrType(getCount());
      }
    }
    if (!(getFollowupOuter() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupOuter = ";
      if (!(getFollowupOuter() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupOuter());
      }
    }
    if (!(getFollowupInner() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupInner = ";
      if (!(getFollowupInner() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupInner());
      }
    }
    if (!(getFollowupRemainderOuter() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupRemainderOuter = ";
      if (!(getFollowupRemainderOuter() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupRemainderOuter());
      }
    }
    if (!(getFollowupRemainderInner() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupRemainderInner = ";
      if (!(getFollowupRemainderInner() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupRemainderInner());
      }
    }
    if (!(getFollowupAll() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupAll = ";
      if (!(getFollowupAll() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupAll());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopUnrollAndJamAttr::getDisable() const {
  return getImpl()->disable;
}

IntegerAttr LoopUnrollAndJamAttr::getCount() const {
  return getImpl()->count;
}

LoopAnnotationAttr LoopUnrollAndJamAttr::getFollowupOuter() const {
  return getImpl()->followupOuter;
}

LoopAnnotationAttr LoopUnrollAndJamAttr::getFollowupInner() const {
  return getImpl()->followupInner;
}

LoopAnnotationAttr LoopUnrollAndJamAttr::getFollowupRemainderOuter() const {
  return getImpl()->followupRemainderOuter;
}

LoopAnnotationAttr LoopUnrollAndJamAttr::getFollowupRemainderInner() const {
  return getImpl()->followupRemainderInner;
}

LoopAnnotationAttr LoopUnrollAndJamAttr::getFollowupAll() const {
  return getImpl()->followupAll;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopUnrollAndJamAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopLICMAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr, BoolAttr>;
  LoopLICMAttrStorage(BoolAttr disable, BoolAttr versioningDisable) : disable(std::move(disable)), versioningDisable(std::move(versioningDisable)) {}

  KeyTy getAsKey() const {
    return KeyTy(disable, versioningDisable);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (disable == std::get<0>(tblgenKey)) && (versioningDisable == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static LoopLICMAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto disable = std::move(std::get<0>(tblgenKey));
    auto versioningDisable = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<LoopLICMAttrStorage>()) LoopLICMAttrStorage(std::move(disable), std::move(versioningDisable));
  }

  BoolAttr disable;
  BoolAttr versioningDisable;
};
} // namespace detail
LoopLICMAttr LoopLICMAttr::get(::mlir::MLIRContext *context, BoolAttr disable, BoolAttr versioningDisable) {
  return Base::get(context, std::move(disable), std::move(versioningDisable));
}

::mlir::Attribute LoopLICMAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_disable;
  ::mlir::FailureOr<BoolAttr> _result_versioningDisable;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_disable = false;
  bool _seen_versioningDisable = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_disable && _paramKey == "disable") {
        _seen_disable = true;

        // Parse variable 'disable'
        _result_disable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_disable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopLICMAttr parameter 'disable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_versioningDisable && _paramKey == "versioningDisable") {
        _seen_versioningDisable = true;

        // Parse variable 'versioningDisable'
        _result_versioningDisable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_versioningDisable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopLICMAttr parameter 'versioningDisable' which is to be a `BoolAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopLICMAttr::get(odsParser.getContext(),
      BoolAttr((_result_disable.value_or(BoolAttr()))),
      BoolAttr((_result_versioningDisable.value_or(BoolAttr()))));
}

void LoopLICMAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "disable = ";
      if (!(getDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getDisable());
      }
    }
    if (!(getVersioningDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "versioningDisable = ";
      if (!(getVersioningDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getVersioningDisable());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopLICMAttr::getDisable() const {
  return getImpl()->disable;
}

BoolAttr LoopLICMAttr::getVersioningDisable() const {
  return getImpl()->versioningDisable;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopLICMAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopDistributeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr, LoopAnnotationAttr, LoopAnnotationAttr, LoopAnnotationAttr, LoopAnnotationAttr>;
  LoopDistributeAttrStorage(BoolAttr disable, LoopAnnotationAttr followupCoincident, LoopAnnotationAttr followupSequential, LoopAnnotationAttr followupFallback, LoopAnnotationAttr followupAll) : disable(std::move(disable)), followupCoincident(std::move(followupCoincident)), followupSequential(std::move(followupSequential)), followupFallback(std::move(followupFallback)), followupAll(std::move(followupAll)) {}

  KeyTy getAsKey() const {
    return KeyTy(disable, followupCoincident, followupSequential, followupFallback, followupAll);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (disable == std::get<0>(tblgenKey)) && (followupCoincident == std::get<1>(tblgenKey)) && (followupSequential == std::get<2>(tblgenKey)) && (followupFallback == std::get<3>(tblgenKey)) && (followupAll == std::get<4>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey));
  }

  static LoopDistributeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto disable = std::move(std::get<0>(tblgenKey));
    auto followupCoincident = std::move(std::get<1>(tblgenKey));
    auto followupSequential = std::move(std::get<2>(tblgenKey));
    auto followupFallback = std::move(std::get<3>(tblgenKey));
    auto followupAll = std::move(std::get<4>(tblgenKey));
    return new (allocator.allocate<LoopDistributeAttrStorage>()) LoopDistributeAttrStorage(std::move(disable), std::move(followupCoincident), std::move(followupSequential), std::move(followupFallback), std::move(followupAll));
  }

  BoolAttr disable;
  LoopAnnotationAttr followupCoincident;
  LoopAnnotationAttr followupSequential;
  LoopAnnotationAttr followupFallback;
  LoopAnnotationAttr followupAll;
};
} // namespace detail
LoopDistributeAttr LoopDistributeAttr::get(::mlir::MLIRContext *context, BoolAttr disable, LoopAnnotationAttr followupCoincident, LoopAnnotationAttr followupSequential, LoopAnnotationAttr followupFallback, LoopAnnotationAttr followupAll) {
  return Base::get(context, std::move(disable), std::move(followupCoincident), std::move(followupSequential), std::move(followupFallback), std::move(followupAll));
}

::mlir::Attribute LoopDistributeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_disable;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupCoincident;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupSequential;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupFallback;
  ::mlir::FailureOr<LoopAnnotationAttr> _result_followupAll;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_disable = false;
  bool _seen_followupCoincident = false;
  bool _seen_followupSequential = false;
  bool _seen_followupFallback = false;
  bool _seen_followupAll = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_disable && _paramKey == "disable") {
        _seen_disable = true;

        // Parse variable 'disable'
        _result_disable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_disable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopDistributeAttr parameter 'disable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_followupCoincident && _paramKey == "followupCoincident") {
        _seen_followupCoincident = true;

        // Parse variable 'followupCoincident'
        _result_followupCoincident = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupCoincident)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopDistributeAttr parameter 'followupCoincident' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupSequential && _paramKey == "followupSequential") {
        _seen_followupSequential = true;

        // Parse variable 'followupSequential'
        _result_followupSequential = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupSequential)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopDistributeAttr parameter 'followupSequential' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupFallback && _paramKey == "followupFallback") {
        _seen_followupFallback = true;

        // Parse variable 'followupFallback'
        _result_followupFallback = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupFallback)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopDistributeAttr parameter 'followupFallback' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else if (!_seen_followupAll && _paramKey == "followupAll") {
        _seen_followupAll = true;

        // Parse variable 'followupAll'
        _result_followupAll = ::mlir::FieldParser<LoopAnnotationAttr>::parse(odsParser);
        if (::mlir::failed(_result_followupAll)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopDistributeAttr parameter 'followupAll' which is to be a `LoopAnnotationAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopDistributeAttr::get(odsParser.getContext(),
      BoolAttr((_result_disable.value_or(BoolAttr()))),
      LoopAnnotationAttr((_result_followupCoincident.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupSequential.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupFallback.value_or(LoopAnnotationAttr()))),
      LoopAnnotationAttr((_result_followupAll.value_or(LoopAnnotationAttr()))));
}

void LoopDistributeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "disable = ";
      if (!(getDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getDisable());
      }
    }
    if (!(getFollowupCoincident() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupCoincident = ";
      if (!(getFollowupCoincident() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupCoincident());
      }
    }
    if (!(getFollowupSequential() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupSequential = ";
      if (!(getFollowupSequential() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupSequential());
      }
    }
    if (!(getFollowupFallback() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupFallback = ";
      if (!(getFollowupFallback() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupFallback());
      }
    }
    if (!(getFollowupAll() == LoopAnnotationAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "followupAll = ";
      if (!(getFollowupAll() == LoopAnnotationAttr())) {
        odsPrinter.printStrippedAttrOrType(getFollowupAll());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopDistributeAttr::getDisable() const {
  return getImpl()->disable;
}

LoopAnnotationAttr LoopDistributeAttr::getFollowupCoincident() const {
  return getImpl()->followupCoincident;
}

LoopAnnotationAttr LoopDistributeAttr::getFollowupSequential() const {
  return getImpl()->followupSequential;
}

LoopAnnotationAttr LoopDistributeAttr::getFollowupFallback() const {
  return getImpl()->followupFallback;
}

LoopAnnotationAttr LoopDistributeAttr::getFollowupAll() const {
  return getImpl()->followupAll;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopDistributeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopPipelineAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr, IntegerAttr>;
  LoopPipelineAttrStorage(BoolAttr disable, IntegerAttr initiationinterval) : disable(std::move(disable)), initiationinterval(std::move(initiationinterval)) {}

  KeyTy getAsKey() const {
    return KeyTy(disable, initiationinterval);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (disable == std::get<0>(tblgenKey)) && (initiationinterval == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static LoopPipelineAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto disable = std::move(std::get<0>(tblgenKey));
    auto initiationinterval = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<LoopPipelineAttrStorage>()) LoopPipelineAttrStorage(std::move(disable), std::move(initiationinterval));
  }

  BoolAttr disable;
  IntegerAttr initiationinterval;
};
} // namespace detail
LoopPipelineAttr LoopPipelineAttr::get(::mlir::MLIRContext *context, BoolAttr disable, IntegerAttr initiationinterval) {
  return Base::get(context, std::move(disable), std::move(initiationinterval));
}

::mlir::Attribute LoopPipelineAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_disable;
  ::mlir::FailureOr<IntegerAttr> _result_initiationinterval;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_disable = false;
  bool _seen_initiationinterval = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_disable && _paramKey == "disable") {
        _seen_disable = true;

        // Parse variable 'disable'
        _result_disable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_disable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopPipelineAttr parameter 'disable' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_initiationinterval && _paramKey == "initiationinterval") {
        _seen_initiationinterval = true;

        // Parse variable 'initiationinterval'
        _result_initiationinterval = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_initiationinterval)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopPipelineAttr parameter 'initiationinterval' which is to be a `IntegerAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopPipelineAttr::get(odsParser.getContext(),
      BoolAttr((_result_disable.value_or(BoolAttr()))),
      IntegerAttr((_result_initiationinterval.value_or(IntegerAttr()))));
}

void LoopPipelineAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "disable = ";
      if (!(getDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getDisable());
      }
    }
    if (!(getInitiationinterval() == IntegerAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "initiationinterval = ";
      if (!(getInitiationinterval() == IntegerAttr())) {
        odsPrinter.printStrippedAttrOrType(getInitiationinterval());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopPipelineAttr::getDisable() const {
  return getImpl()->disable;
}

IntegerAttr LoopPipelineAttr::getInitiationinterval() const {
  return getImpl()->initiationinterval;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopPipelineAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopPeeledAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<IntegerAttr>;
  LoopPeeledAttrStorage(IntegerAttr count) : count(std::move(count)) {}

  KeyTy getAsKey() const {
    return KeyTy(count);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (count == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static LoopPeeledAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto count = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<LoopPeeledAttrStorage>()) LoopPeeledAttrStorage(std::move(count));
  }

  IntegerAttr count;
};
} // namespace detail
LoopPeeledAttr LoopPeeledAttr::get(::mlir::MLIRContext *context, IntegerAttr count) {
  return Base::get(context, std::move(count));
}

::mlir::Attribute LoopPeeledAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<IntegerAttr> _result_count;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_count = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_count && _paramKey == "count") {
        _seen_count = true;

        // Parse variable 'count'
        _result_count = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_count)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopPeeledAttr parameter 'count' which is to be a `IntegerAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopPeeledAttr::get(odsParser.getContext(),
      IntegerAttr((_result_count.value_or(IntegerAttr()))));
}

void LoopPeeledAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getCount() == IntegerAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "count = ";
      if (!(getCount() == IntegerAttr())) {
        odsPrinter.printStrippedAttrOrType(getCount());
      }
    }
  }
  odsPrinter << ">";
}

IntegerAttr LoopPeeledAttr::getCount() const {
  return getImpl()->count;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopPeeledAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopUnswitchAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr>;
  LoopUnswitchAttrStorage(BoolAttr partialDisable) : partialDisable(std::move(partialDisable)) {}

  KeyTy getAsKey() const {
    return KeyTy(partialDisable);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (partialDisable == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static LoopUnswitchAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto partialDisable = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<LoopUnswitchAttrStorage>()) LoopUnswitchAttrStorage(std::move(partialDisable));
  }

  BoolAttr partialDisable;
};
} // namespace detail
LoopUnswitchAttr LoopUnswitchAttr::get(::mlir::MLIRContext *context, BoolAttr partialDisable) {
  return Base::get(context, std::move(partialDisable));
}

::mlir::Attribute LoopUnswitchAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_partialDisable;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_partialDisable = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_partialDisable && _paramKey == "partialDisable") {
        _seen_partialDisable = true;

        // Parse variable 'partialDisable'
        _result_partialDisable = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_partialDisable)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopUnswitchAttr parameter 'partialDisable' which is to be a `BoolAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopUnswitchAttr::get(odsParser.getContext(),
      BoolAttr((_result_partialDisable.value_or(BoolAttr()))));
}

void LoopUnswitchAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getPartialDisable() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "partialDisable = ";
      if (!(getPartialDisable() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getPartialDisable());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopUnswitchAttr::getPartialDisable() const {
  return getImpl()->partialDisable;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopUnswitchAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct LoopAnnotationAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<BoolAttr, LoopVectorizeAttr, LoopInterleaveAttr, LoopUnrollAttr, LoopUnrollAndJamAttr, LoopLICMAttr, LoopDistributeAttr, LoopPipelineAttr, LoopPeeledAttr, LoopUnswitchAttr, BoolAttr, BoolAttr, FusedLoc, FusedLoc, ::llvm::ArrayRef<AccessGroupAttr>>;
  LoopAnnotationAttrStorage(BoolAttr disableNonforced, LoopVectorizeAttr vectorize, LoopInterleaveAttr interleave, LoopUnrollAttr unroll, LoopUnrollAndJamAttr unrollAndJam, LoopLICMAttr licm, LoopDistributeAttr distribute, LoopPipelineAttr pipeline, LoopPeeledAttr peeled, LoopUnswitchAttr unswitch, BoolAttr mustProgress, BoolAttr isVectorized, FusedLoc startLoc, FusedLoc endLoc, ::llvm::ArrayRef<AccessGroupAttr> parallelAccesses) : disableNonforced(std::move(disableNonforced)), vectorize(std::move(vectorize)), interleave(std::move(interleave)), unroll(std::move(unroll)), unrollAndJam(std::move(unrollAndJam)), licm(std::move(licm)), distribute(std::move(distribute)), pipeline(std::move(pipeline)), peeled(std::move(peeled)), unswitch(std::move(unswitch)), mustProgress(std::move(mustProgress)), isVectorized(std::move(isVectorized)), startLoc(std::move(startLoc)), endLoc(std::move(endLoc)), parallelAccesses(std::move(parallelAccesses)) {}

  KeyTy getAsKey() const {
    return KeyTy(disableNonforced, vectorize, interleave, unroll, unrollAndJam, licm, distribute, pipeline, peeled, unswitch, mustProgress, isVectorized, startLoc, endLoc, parallelAccesses);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (disableNonforced == std::get<0>(tblgenKey)) && (vectorize == std::get<1>(tblgenKey)) && (interleave == std::get<2>(tblgenKey)) && (unroll == std::get<3>(tblgenKey)) && (unrollAndJam == std::get<4>(tblgenKey)) && (licm == std::get<5>(tblgenKey)) && (distribute == std::get<6>(tblgenKey)) && (pipeline == std::get<7>(tblgenKey)) && (peeled == std::get<8>(tblgenKey)) && (unswitch == std::get<9>(tblgenKey)) && (mustProgress == std::get<10>(tblgenKey)) && (isVectorized == std::get<11>(tblgenKey)) && (startLoc == std::get<12>(tblgenKey)) && (endLoc == std::get<13>(tblgenKey)) && (::llvm::ArrayRef<AccessGroupAttr>(parallelAccesses) == ::llvm::ArrayRef<AccessGroupAttr>(std::get<14>(tblgenKey)));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey), std::get<8>(tblgenKey), std::get<9>(tblgenKey), std::get<10>(tblgenKey), std::get<11>(tblgenKey), std::get<12>(tblgenKey), std::get<13>(tblgenKey), std::get<14>(tblgenKey));
  }

  static LoopAnnotationAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto disableNonforced = std::move(std::get<0>(tblgenKey));
    auto vectorize = std::move(std::get<1>(tblgenKey));
    auto interleave = std::move(std::get<2>(tblgenKey));
    auto unroll = std::move(std::get<3>(tblgenKey));
    auto unrollAndJam = std::move(std::get<4>(tblgenKey));
    auto licm = std::move(std::get<5>(tblgenKey));
    auto distribute = std::move(std::get<6>(tblgenKey));
    auto pipeline = std::move(std::get<7>(tblgenKey));
    auto peeled = std::move(std::get<8>(tblgenKey));
    auto unswitch = std::move(std::get<9>(tblgenKey));
    auto mustProgress = std::move(std::get<10>(tblgenKey));
    auto isVectorized = std::move(std::get<11>(tblgenKey));
    auto startLoc = std::move(std::get<12>(tblgenKey));
    auto endLoc = std::move(std::get<13>(tblgenKey));
    auto parallelAccesses = std::move(std::get<14>(tblgenKey));
    parallelAccesses = allocator.copyInto(parallelAccesses);
    return new (allocator.allocate<LoopAnnotationAttrStorage>()) LoopAnnotationAttrStorage(std::move(disableNonforced), std::move(vectorize), std::move(interleave), std::move(unroll), std::move(unrollAndJam), std::move(licm), std::move(distribute), std::move(pipeline), std::move(peeled), std::move(unswitch), std::move(mustProgress), std::move(isVectorized), std::move(startLoc), std::move(endLoc), std::move(parallelAccesses));
  }

  BoolAttr disableNonforced;
  LoopVectorizeAttr vectorize;
  LoopInterleaveAttr interleave;
  LoopUnrollAttr unroll;
  LoopUnrollAndJamAttr unrollAndJam;
  LoopLICMAttr licm;
  LoopDistributeAttr distribute;
  LoopPipelineAttr pipeline;
  LoopPeeledAttr peeled;
  LoopUnswitchAttr unswitch;
  BoolAttr mustProgress;
  BoolAttr isVectorized;
  FusedLoc startLoc;
  FusedLoc endLoc;
  ::llvm::ArrayRef<AccessGroupAttr> parallelAccesses;
};
} // namespace detail
LoopAnnotationAttr LoopAnnotationAttr::get(::mlir::MLIRContext *context, BoolAttr disableNonforced, LoopVectorizeAttr vectorize, LoopInterleaveAttr interleave, LoopUnrollAttr unroll, LoopUnrollAndJamAttr unrollAndJam, LoopLICMAttr licm, LoopDistributeAttr distribute, LoopPipelineAttr pipeline, LoopPeeledAttr peeled, LoopUnswitchAttr unswitch, BoolAttr mustProgress, BoolAttr isVectorized, FusedLoc startLoc, FusedLoc endLoc, ::llvm::ArrayRef<AccessGroupAttr> parallelAccesses) {
  return Base::get(context, std::move(disableNonforced), std::move(vectorize), std::move(interleave), std::move(unroll), std::move(unrollAndJam), std::move(licm), std::move(distribute), std::move(pipeline), std::move(peeled), std::move(unswitch), std::move(mustProgress), std::move(isVectorized), std::move(startLoc), std::move(endLoc), std::move(parallelAccesses));
}

::mlir::Attribute LoopAnnotationAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<BoolAttr> _result_disableNonforced;
  ::mlir::FailureOr<LoopVectorizeAttr> _result_vectorize;
  ::mlir::FailureOr<LoopInterleaveAttr> _result_interleave;
  ::mlir::FailureOr<LoopUnrollAttr> _result_unroll;
  ::mlir::FailureOr<LoopUnrollAndJamAttr> _result_unrollAndJam;
  ::mlir::FailureOr<LoopLICMAttr> _result_licm;
  ::mlir::FailureOr<LoopDistributeAttr> _result_distribute;
  ::mlir::FailureOr<LoopPipelineAttr> _result_pipeline;
  ::mlir::FailureOr<LoopPeeledAttr> _result_peeled;
  ::mlir::FailureOr<LoopUnswitchAttr> _result_unswitch;
  ::mlir::FailureOr<BoolAttr> _result_mustProgress;
  ::mlir::FailureOr<BoolAttr> _result_isVectorized;
  ::mlir::FailureOr<FusedLoc> _result_startLoc;
  ::mlir::FailureOr<FusedLoc> _result_endLoc;
  ::mlir::FailureOr<::llvm::SmallVector<AccessGroupAttr>> _result_parallelAccesses;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_disableNonforced = false;
  bool _seen_vectorize = false;
  bool _seen_interleave = false;
  bool _seen_unroll = false;
  bool _seen_unrollAndJam = false;
  bool _seen_licm = false;
  bool _seen_distribute = false;
  bool _seen_pipeline = false;
  bool _seen_peeled = false;
  bool _seen_unswitch = false;
  bool _seen_mustProgress = false;
  bool _seen_isVectorized = false;
  bool _seen_startLoc = false;
  bool _seen_endLoc = false;
  bool _seen_parallelAccesses = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_disableNonforced && _paramKey == "disableNonforced") {
        _seen_disableNonforced = true;

        // Parse variable 'disableNonforced'
        _result_disableNonforced = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_disableNonforced)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'disableNonforced' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_vectorize && _paramKey == "vectorize") {
        _seen_vectorize = true;

        // Parse variable 'vectorize'
        _result_vectorize = ::mlir::FieldParser<LoopVectorizeAttr>::parse(odsParser);
        if (::mlir::failed(_result_vectorize)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'vectorize' which is to be a `LoopVectorizeAttr`");
          return {};
        }
      } else if (!_seen_interleave && _paramKey == "interleave") {
        _seen_interleave = true;

        // Parse variable 'interleave'
        _result_interleave = ::mlir::FieldParser<LoopInterleaveAttr>::parse(odsParser);
        if (::mlir::failed(_result_interleave)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'interleave' which is to be a `LoopInterleaveAttr`");
          return {};
        }
      } else if (!_seen_unroll && _paramKey == "unroll") {
        _seen_unroll = true;

        // Parse variable 'unroll'
        _result_unroll = ::mlir::FieldParser<LoopUnrollAttr>::parse(odsParser);
        if (::mlir::failed(_result_unroll)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'unroll' which is to be a `LoopUnrollAttr`");
          return {};
        }
      } else if (!_seen_unrollAndJam && _paramKey == "unrollAndJam") {
        _seen_unrollAndJam = true;

        // Parse variable 'unrollAndJam'
        _result_unrollAndJam = ::mlir::FieldParser<LoopUnrollAndJamAttr>::parse(odsParser);
        if (::mlir::failed(_result_unrollAndJam)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'unrollAndJam' which is to be a `LoopUnrollAndJamAttr`");
          return {};
        }
      } else if (!_seen_licm && _paramKey == "licm") {
        _seen_licm = true;

        // Parse variable 'licm'
        _result_licm = ::mlir::FieldParser<LoopLICMAttr>::parse(odsParser);
        if (::mlir::failed(_result_licm)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'licm' which is to be a `LoopLICMAttr`");
          return {};
        }
      } else if (!_seen_distribute && _paramKey == "distribute") {
        _seen_distribute = true;

        // Parse variable 'distribute'
        _result_distribute = ::mlir::FieldParser<LoopDistributeAttr>::parse(odsParser);
        if (::mlir::failed(_result_distribute)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'distribute' which is to be a `LoopDistributeAttr`");
          return {};
        }
      } else if (!_seen_pipeline && _paramKey == "pipeline") {
        _seen_pipeline = true;

        // Parse variable 'pipeline'
        _result_pipeline = ::mlir::FieldParser<LoopPipelineAttr>::parse(odsParser);
        if (::mlir::failed(_result_pipeline)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'pipeline' which is to be a `LoopPipelineAttr`");
          return {};
        }
      } else if (!_seen_peeled && _paramKey == "peeled") {
        _seen_peeled = true;

        // Parse variable 'peeled'
        _result_peeled = ::mlir::FieldParser<LoopPeeledAttr>::parse(odsParser);
        if (::mlir::failed(_result_peeled)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'peeled' which is to be a `LoopPeeledAttr`");
          return {};
        }
      } else if (!_seen_unswitch && _paramKey == "unswitch") {
        _seen_unswitch = true;

        // Parse variable 'unswitch'
        _result_unswitch = ::mlir::FieldParser<LoopUnswitchAttr>::parse(odsParser);
        if (::mlir::failed(_result_unswitch)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'unswitch' which is to be a `LoopUnswitchAttr`");
          return {};
        }
      } else if (!_seen_mustProgress && _paramKey == "mustProgress") {
        _seen_mustProgress = true;

        // Parse variable 'mustProgress'
        _result_mustProgress = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_mustProgress)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'mustProgress' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_isVectorized && _paramKey == "isVectorized") {
        _seen_isVectorized = true;

        // Parse variable 'isVectorized'
        _result_isVectorized = ::mlir::FieldParser<BoolAttr>::parse(odsParser);
        if (::mlir::failed(_result_isVectorized)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'isVectorized' which is to be a `BoolAttr`");
          return {};
        }
      } else if (!_seen_startLoc && _paramKey == "startLoc") {
        _seen_startLoc = true;

        // Parse variable 'startLoc'
        _result_startLoc = ::mlir::FieldParser<FusedLoc>::parse(odsParser);
        if (::mlir::failed(_result_startLoc)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'startLoc' which is to be a `FusedLoc`");
          return {};
        }
      } else if (!_seen_endLoc && _paramKey == "endLoc") {
        _seen_endLoc = true;

        // Parse variable 'endLoc'
        _result_endLoc = ::mlir::FieldParser<FusedLoc>::parse(odsParser);
        if (::mlir::failed(_result_endLoc)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'endLoc' which is to be a `FusedLoc`");
          return {};
        }
      } else if (!_seen_parallelAccesses && _paramKey == "parallelAccesses") {
        _seen_parallelAccesses = true;

        // Parse variable 'parallelAccesses'
        _result_parallelAccesses = ::mlir::FieldParser<::llvm::SmallVector<AccessGroupAttr>>::parse(odsParser);
        if (::mlir::failed(_result_parallelAccesses)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LoopAnnotationAttr parameter 'parallelAccesses' which is to be a `::llvm::ArrayRef<AccessGroupAttr>`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return LoopAnnotationAttr::get(odsParser.getContext(),
      BoolAttr((_result_disableNonforced.value_or(BoolAttr()))),
      LoopVectorizeAttr((_result_vectorize.value_or(LoopVectorizeAttr()))),
      LoopInterleaveAttr((_result_interleave.value_or(LoopInterleaveAttr()))),
      LoopUnrollAttr((_result_unroll.value_or(LoopUnrollAttr()))),
      LoopUnrollAndJamAttr((_result_unrollAndJam.value_or(LoopUnrollAndJamAttr()))),
      LoopLICMAttr((_result_licm.value_or(LoopLICMAttr()))),
      LoopDistributeAttr((_result_distribute.value_or(LoopDistributeAttr()))),
      LoopPipelineAttr((_result_pipeline.value_or(LoopPipelineAttr()))),
      LoopPeeledAttr((_result_peeled.value_or(LoopPeeledAttr()))),
      LoopUnswitchAttr((_result_unswitch.value_or(LoopUnswitchAttr()))),
      BoolAttr((_result_mustProgress.value_or(BoolAttr()))),
      BoolAttr((_result_isVectorized.value_or(BoolAttr()))),
      FusedLoc((_result_startLoc.value_or(FusedLoc()))),
      FusedLoc((_result_endLoc.value_or(FusedLoc()))),
      ::llvm::ArrayRef<AccessGroupAttr>((_result_parallelAccesses.value_or(::llvm::SmallVector<AccessGroupAttr>()))));
}

void LoopAnnotationAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getDisableNonforced() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "disableNonforced = ";
      if (!(getDisableNonforced() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getDisableNonforced());
      }
    }
    if (!(getVectorize() == LoopVectorizeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "vectorize = ";
      if (!(getVectorize() == LoopVectorizeAttr())) {
        odsPrinter.printStrippedAttrOrType(getVectorize());
      }
    }
    if (!(getInterleave() == LoopInterleaveAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "interleave = ";
      if (!(getInterleave() == LoopInterleaveAttr())) {
        odsPrinter.printStrippedAttrOrType(getInterleave());
      }
    }
    if (!(getUnroll() == LoopUnrollAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "unroll = ";
      if (!(getUnroll() == LoopUnrollAttr())) {
        odsPrinter.printStrippedAttrOrType(getUnroll());
      }
    }
    if (!(getUnrollAndJam() == LoopUnrollAndJamAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "unrollAndJam = ";
      if (!(getUnrollAndJam() == LoopUnrollAndJamAttr())) {
        odsPrinter.printStrippedAttrOrType(getUnrollAndJam());
      }
    }
    if (!(getLicm() == LoopLICMAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "licm = ";
      if (!(getLicm() == LoopLICMAttr())) {
        odsPrinter.printStrippedAttrOrType(getLicm());
      }
    }
    if (!(getDistribute() == LoopDistributeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "distribute = ";
      if (!(getDistribute() == LoopDistributeAttr())) {
        odsPrinter.printStrippedAttrOrType(getDistribute());
      }
    }
    if (!(getPipeline() == LoopPipelineAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "pipeline = ";
      if (!(getPipeline() == LoopPipelineAttr())) {
        odsPrinter.printStrippedAttrOrType(getPipeline());
      }
    }
    if (!(getPeeled() == LoopPeeledAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "peeled = ";
      if (!(getPeeled() == LoopPeeledAttr())) {
        odsPrinter.printStrippedAttrOrType(getPeeled());
      }
    }
    if (!(getUnswitch() == LoopUnswitchAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "unswitch = ";
      if (!(getUnswitch() == LoopUnswitchAttr())) {
        odsPrinter.printStrippedAttrOrType(getUnswitch());
      }
    }
    if (!(getMustProgress() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "mustProgress = ";
      if (!(getMustProgress() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getMustProgress());
      }
    }
    if (!(getIsVectorized() == BoolAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "isVectorized = ";
      if (!(getIsVectorized() == BoolAttr())) {
        odsPrinter.printStrippedAttrOrType(getIsVectorized());
      }
    }
    if (!(getStartLoc() == FusedLoc())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "startLoc = ";
      if (!(getStartLoc() == FusedLoc())) {
        odsPrinter.printStrippedAttrOrType(getStartLoc());
      }
    }
    if (!(getEndLoc() == FusedLoc())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "endLoc = ";
      if (!(getEndLoc() == FusedLoc())) {
        odsPrinter.printStrippedAttrOrType(getEndLoc());
      }
    }
    if (!(::llvm::ArrayRef<AccessGroupAttr>(getParallelAccesses()) == ::llvm::ArrayRef<AccessGroupAttr>(::llvm::SmallVector<AccessGroupAttr>()))) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "parallelAccesses = ";
      if (!(::llvm::ArrayRef<AccessGroupAttr>(getParallelAccesses()) == ::llvm::ArrayRef<AccessGroupAttr>(::llvm::SmallVector<AccessGroupAttr>()))) {
        odsPrinter.printStrippedAttrOrType(getParallelAccesses());
      }
    }
  }
  odsPrinter << ">";
}

BoolAttr LoopAnnotationAttr::getDisableNonforced() const {
  return getImpl()->disableNonforced;
}

LoopVectorizeAttr LoopAnnotationAttr::getVectorize() const {
  return getImpl()->vectorize;
}

LoopInterleaveAttr LoopAnnotationAttr::getInterleave() const {
  return getImpl()->interleave;
}

LoopUnrollAttr LoopAnnotationAttr::getUnroll() const {
  return getImpl()->unroll;
}

LoopUnrollAndJamAttr LoopAnnotationAttr::getUnrollAndJam() const {
  return getImpl()->unrollAndJam;
}

LoopLICMAttr LoopAnnotationAttr::getLicm() const {
  return getImpl()->licm;
}

LoopDistributeAttr LoopAnnotationAttr::getDistribute() const {
  return getImpl()->distribute;
}

LoopPipelineAttr LoopAnnotationAttr::getPipeline() const {
  return getImpl()->pipeline;
}

LoopPeeledAttr LoopAnnotationAttr::getPeeled() const {
  return getImpl()->peeled;
}

LoopUnswitchAttr LoopAnnotationAttr::getUnswitch() const {
  return getImpl()->unswitch;
}

BoolAttr LoopAnnotationAttr::getMustProgress() const {
  return getImpl()->mustProgress;
}

BoolAttr LoopAnnotationAttr::getIsVectorized() const {
  return getImpl()->isVectorized;
}

FusedLoc LoopAnnotationAttr::getStartLoc() const {
  return getImpl()->startLoc;
}

FusedLoc LoopAnnotationAttr::getEndLoc() const {
  return getImpl()->endLoc;
}

::llvm::ArrayRef<AccessGroupAttr> LoopAnnotationAttr::getParallelAccesses() const {
  return getImpl()->parallelAccesses;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoopAnnotationAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIExpressionElemAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<unsigned, ::llvm::ArrayRef<uint64_t>>;
  DIExpressionElemAttrStorage(unsigned opcode, ::llvm::ArrayRef<uint64_t> arguments) : opcode(std::move(opcode)), arguments(std::move(arguments)) {}

  KeyTy getAsKey() const {
    return KeyTy(opcode, arguments);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (opcode == std::get<0>(tblgenKey)) && (::llvm::ArrayRef<uint64_t>(arguments) == ::llvm::ArrayRef<uint64_t>(std::get<1>(tblgenKey)));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static DIExpressionElemAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto opcode = std::move(std::get<0>(tblgenKey));
    auto arguments = std::move(std::get<1>(tblgenKey));
    arguments = allocator.copyInto(arguments);
    return new (allocator.allocate<DIExpressionElemAttrStorage>()) DIExpressionElemAttrStorage(std::move(opcode), std::move(arguments));
  }

  unsigned opcode;
  ::llvm::ArrayRef<uint64_t> arguments;
};
} // namespace detail
DIExpressionElemAttr DIExpressionElemAttr::get(::mlir::MLIRContext *context, unsigned opcode, ::llvm::ArrayRef<uint64_t> arguments) {
  return Base::get(context, std::move(opcode), std::move(arguments));
}

::mlir::Attribute DIExpressionElemAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<unsigned> _result_opcode;
  ::mlir::FailureOr<::llvm::SmallVector<uint64_t>> _result_arguments;

  // Parse variable 'opcode'
  _result_opcode =  [&]() -> FailureOr<unsigned> {
      SMLoc tagLoc = odsParser.getCurrentLocation();
      StringRef name;
      if (odsParser.parseKeyword(&name))
        return failure();

      unsigned tag = llvm::dwarf::getOperationEncoding(name);
      if (tag == 0)
        return odsParser.emitError(tagLoc)
          << "invalid debug info debug info operation encoding name: " << name;
      return tag;
    }() ;
  if (::mlir::failed(_result_opcode)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIExpressionElemAttr parameter 'opcode' which is to be a `unsigned`");
    return {};
  }
  // Parse literal '('
  if (odsParser.parseOptionalLParen()) {
  } else {
    {
      auto odsCustomLoc = odsParser.getCurrentLocation();
      (void)odsCustomLoc;
      auto odsCustomResult = parseExpressionArg(odsParser,
        *_result_opcode,
        ::mlir::detail::unwrapForCustomParse(_result_arguments));
      if (::mlir::failed(odsCustomResult)) return {};
    }
    // Parse literal ')'
    if (odsParser.parseRParen()) return {};
  }
  assert(::mlir::succeeded(_result_opcode));
  return DIExpressionElemAttr::get(odsParser.getContext(),
      unsigned((*_result_opcode)),
      ::llvm::ArrayRef<uint64_t>((_result_arguments.value_or(::llvm::SmallVector<uint64_t>()))));
}

void DIExpressionElemAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << llvm::dwarf::OperationEncodingString(getOpcode());
  if (!(::llvm::ArrayRef<uint64_t>(getArguments()) == ::llvm::ArrayRef<uint64_t>(::llvm::SmallVector<uint64_t>()))) {
    odsPrinter << "(";
    printExpressionArg(odsPrinter,
      getOpcode(),
      getArguments());
    odsPrinter << ")";
  } else {
  }
}

unsigned DIExpressionElemAttr::getOpcode() const {
  return getImpl()->opcode;
}

::llvm::ArrayRef<uint64_t> DIExpressionElemAttr::getArguments() const {
  return getImpl()->arguments;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIExpressionElemAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIExpressionAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<::llvm::ArrayRef<DIExpressionElemAttr>>;
  DIExpressionAttrStorage(::llvm::ArrayRef<DIExpressionElemAttr> operations) : operations(std::move(operations)) {}

  KeyTy getAsKey() const {
    return KeyTy(operations);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (::llvm::ArrayRef<DIExpressionElemAttr>(operations) == ::llvm::ArrayRef<DIExpressionElemAttr>(std::get<0>(tblgenKey)));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static DIExpressionAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto operations = std::move(std::get<0>(tblgenKey));
    operations = allocator.copyInto(operations);
    return new (allocator.allocate<DIExpressionAttrStorage>()) DIExpressionAttrStorage(std::move(operations));
  }

  ::llvm::ArrayRef<DIExpressionElemAttr> operations;
};
} // namespace detail
DIExpressionAttr DIExpressionAttr::get(::mlir::MLIRContext *context, ::llvm::ArrayRef<DIExpressionElemAttr> operations) {
  return Base::get(context, std::move(operations));
}

::mlir::Attribute DIExpressionAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<::llvm::SmallVector<DIExpressionElemAttr>> _result_operations;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse literal '['
  if (odsParser.parseOptionalLSquare()) {
  } else {

    // Parse variable 'operations'
    _result_operations = ::mlir::FieldParser<::llvm::SmallVector<DIExpressionElemAttr>>::parse(odsParser);
    if (::mlir::failed(_result_operations)) {
      odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIExpressionAttr parameter 'operations' which is to be a `::llvm::ArrayRef<DIExpressionElemAttr>`");
      return {};
    }
    // Parse literal ']'
    if (odsParser.parseRSquare()) return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return DIExpressionAttr::get(odsParser.getContext(),
      ::llvm::ArrayRef<DIExpressionElemAttr>((_result_operations.value_or(::llvm::SmallVector<DIExpressionElemAttr>()))));
}

void DIExpressionAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  if (!(::llvm::ArrayRef<DIExpressionElemAttr>(getOperations()) == ::llvm::ArrayRef<DIExpressionElemAttr>(::llvm::SmallVector<DIExpressionElemAttr>()))) {
    odsPrinter << "[";
    if (!(::llvm::ArrayRef<DIExpressionElemAttr>(getOperations()) == ::llvm::ArrayRef<DIExpressionElemAttr>(::llvm::SmallVector<DIExpressionElemAttr>()))) {
      odsPrinter.printStrippedAttrOrType(getOperations());
    }
    odsPrinter << "]";
  } else {
  }
  odsPrinter << ">";
}

::llvm::ArrayRef<DIExpressionElemAttr> DIExpressionAttr::getOperations() const {
  return getImpl()->operations;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIExpressionAttr)
namespace mlir {
namespace LLVM {
} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DINullTypeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIBasicTypeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<unsigned, StringAttr, uint64_t, unsigned>;
  DIBasicTypeAttrStorage(unsigned tag, StringAttr name, uint64_t sizeInBits, unsigned encoding) : tag(std::move(tag)), name(std::move(name)), sizeInBits(std::move(sizeInBits)), encoding(std::move(encoding)) {}

  KeyTy getAsKey() const {
    return KeyTy(tag, name, sizeInBits, encoding);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (tag == std::get<0>(tblgenKey)) && (name == std::get<1>(tblgenKey)) && (sizeInBits == std::get<2>(tblgenKey)) && (encoding == std::get<3>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey));
  }

  static DIBasicTypeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto tag = std::move(std::get<0>(tblgenKey));
    auto name = std::move(std::get<1>(tblgenKey));
    auto sizeInBits = std::move(std::get<2>(tblgenKey));
    auto encoding = std::move(std::get<3>(tblgenKey));
    return new (allocator.allocate<DIBasicTypeAttrStorage>()) DIBasicTypeAttrStorage(std::move(tag), std::move(name), std::move(sizeInBits), std::move(encoding));
  }

  unsigned tag;
  StringAttr name;
  uint64_t sizeInBits;
  unsigned encoding;
};
} // namespace detail
DIBasicTypeAttr DIBasicTypeAttr::get(::mlir::MLIRContext *context, unsigned tag, StringAttr name, uint64_t sizeInBits, unsigned encoding) {
  return Base::get(context, std::move(tag), std::move(name), std::move(sizeInBits), std::move(encoding));
}

DIBasicTypeAttr DIBasicTypeAttr::get(::mlir::MLIRContext *context, unsigned tag, const Twine &name, uint64_t sizeInBits, unsigned encoding) {
  return Base::get(context, tag, StringAttr::get(context, name), sizeInBits,
               encoding);
}

::mlir::Attribute DIBasicTypeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<unsigned> _result_tag;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<uint64_t> _result_sizeInBits;
  ::mlir::FailureOr<unsigned> _result_encoding;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_tag = false;
  bool _seen_name = false;
  bool _seen_sizeInBits = false;
  bool _seen_encoding = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_tag && _paramKey == "tag") {
        _seen_tag = true;

        // Parse variable 'tag'
        _result_tag =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getTag(name);
            if (tag == llvm::dwarf::DW_TAG_invalid)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info tag name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_tag)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIBasicTypeAttr parameter 'tag' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIBasicTypeAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_sizeInBits && _paramKey == "sizeInBits") {
        _seen_sizeInBits = true;

        // Parse variable 'sizeInBits'
        _result_sizeInBits = ::mlir::FieldParser<uint64_t>::parse(odsParser);
        if (::mlir::failed(_result_sizeInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIBasicTypeAttr parameter 'sizeInBits' which is to be a `uint64_t`");
          return {};
        }
      } else if (!_seen_encoding && _paramKey == "encoding") {
        _seen_encoding = true;

        // Parse variable 'encoding'
        _result_encoding =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getAttributeEncoding(name);
            if (tag == 0)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info encoding name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_encoding)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIBasicTypeAttr parameter 'encoding' which is to be a `unsigned`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_name) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "name";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_name));
  return DIBasicTypeAttr::get(odsParser.getContext(),
      unsigned((_result_tag.value_or(0))),
      StringAttr((*_result_name)),
      uint64_t((_result_sizeInBits.value_or(uint64_t()))),
      unsigned((_result_encoding.value_or(0))));
}

void DIBasicTypeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getTag() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "tag = ";
      if (!(getTag() == 0)) {
        odsPrinter << llvm::dwarf::TagString(getTag());
      }
    }
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "name = ";
    odsPrinter.printStrippedAttrOrType(getName());
    if (!(getSizeInBits() == uint64_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "sizeInBits = ";
      if (!(getSizeInBits() == uint64_t())) {
        odsPrinter.printStrippedAttrOrType(getSizeInBits());
      }
    }
    if (!(getEncoding() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "encoding = ";
      if (!(getEncoding() == 0)) {
        odsPrinter << llvm::dwarf::AttributeEncodingString(getEncoding());
      }
    }
  }
  odsPrinter << ">";
}

unsigned DIBasicTypeAttr::getTag() const {
  return getImpl()->tag;
}

StringAttr DIBasicTypeAttr::getName() const {
  return getImpl()->name;
}

uint64_t DIBasicTypeAttr::getSizeInBits() const {
  return getImpl()->sizeInBits;
}

unsigned DIBasicTypeAttr::getEncoding() const {
  return getImpl()->encoding;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIBasicTypeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DICompileUnitAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DistinctAttr, unsigned, DIFileAttr, StringAttr, bool, DIEmissionKind, DINameTableKind>;
  DICompileUnitAttrStorage(DistinctAttr id, unsigned sourceLanguage, DIFileAttr file, StringAttr producer, bool isOptimized, DIEmissionKind emissionKind, DINameTableKind nameTableKind) : id(std::move(id)), sourceLanguage(std::move(sourceLanguage)), file(std::move(file)), producer(std::move(producer)), isOptimized(std::move(isOptimized)), emissionKind(std::move(emissionKind)), nameTableKind(std::move(nameTableKind)) {}

  KeyTy getAsKey() const {
    return KeyTy(id, sourceLanguage, file, producer, isOptimized, emissionKind, nameTableKind);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (id == std::get<0>(tblgenKey)) && (sourceLanguage == std::get<1>(tblgenKey)) && (file == std::get<2>(tblgenKey)) && (producer == std::get<3>(tblgenKey)) && (isOptimized == std::get<4>(tblgenKey)) && (emissionKind == std::get<5>(tblgenKey)) && (nameTableKind == std::get<6>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey));
  }

  static DICompileUnitAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto id = std::move(std::get<0>(tblgenKey));
    auto sourceLanguage = std::move(std::get<1>(tblgenKey));
    auto file = std::move(std::get<2>(tblgenKey));
    auto producer = std::move(std::get<3>(tblgenKey));
    auto isOptimized = std::move(std::get<4>(tblgenKey));
    auto emissionKind = std::move(std::get<5>(tblgenKey));
    auto nameTableKind = std::move(std::get<6>(tblgenKey));
    return new (allocator.allocate<DICompileUnitAttrStorage>()) DICompileUnitAttrStorage(std::move(id), std::move(sourceLanguage), std::move(file), std::move(producer), std::move(isOptimized), std::move(emissionKind), std::move(nameTableKind));
  }

  DistinctAttr id;
  unsigned sourceLanguage;
  DIFileAttr file;
  StringAttr producer;
  bool isOptimized;
  DIEmissionKind emissionKind;
  DINameTableKind nameTableKind;
};
} // namespace detail
DICompileUnitAttr DICompileUnitAttr::get(::mlir::MLIRContext *context, DistinctAttr id, unsigned sourceLanguage, DIFileAttr file, StringAttr producer, bool isOptimized, DIEmissionKind emissionKind, DINameTableKind nameTableKind) {
  return Base::get(context, std::move(id), std::move(sourceLanguage), std::move(file), std::move(producer), std::move(isOptimized), std::move(emissionKind), std::move(nameTableKind));
}

DICompileUnitAttr DICompileUnitAttr::get(DistinctAttr id, unsigned sourceLanguage, DIFileAttr file, StringAttr producer, bool isOptimized, DIEmissionKind emissionKind, DINameTableKind nameTableKind) {
  return Base::get(id.getContext(), id, sourceLanguage, file, producer,
               isOptimized, emissionKind, nameTableKind);
}

::mlir::Attribute DICompileUnitAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DistinctAttr> _result_id;
  ::mlir::FailureOr<unsigned> _result_sourceLanguage;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<StringAttr> _result_producer;
  ::mlir::FailureOr<bool> _result_isOptimized;
  ::mlir::FailureOr<DIEmissionKind> _result_emissionKind;
  ::mlir::FailureOr<DINameTableKind> _result_nameTableKind;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_id = false;
  bool _seen_sourceLanguage = false;
  bool _seen_file = false;
  bool _seen_producer = false;
  bool _seen_isOptimized = false;
  bool _seen_emissionKind = false;
  bool _seen_nameTableKind = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_id && _paramKey == "id") {
        _seen_id = true;

        // Parse variable 'id'
        _result_id = ::mlir::FieldParser<DistinctAttr>::parse(odsParser);
        if (::mlir::failed(_result_id)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompileUnitAttr parameter 'id' which is to be a `DistinctAttr`");
          return {};
        }
      } else if (!_seen_sourceLanguage && _paramKey == "sourceLanguage") {
        _seen_sourceLanguage = true;

        // Parse variable 'sourceLanguage'
        _result_sourceLanguage =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getLanguage(name);
            if (tag == 0)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info language name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_sourceLanguage)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompileUnitAttr parameter 'sourceLanguage' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompileUnitAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_producer && _paramKey == "producer") {
        _seen_producer = true;

        // Parse variable 'producer'
        _result_producer = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_producer)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompileUnitAttr parameter 'producer' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_isOptimized && _paramKey == "isOptimized") {
        _seen_isOptimized = true;

        // Parse variable 'isOptimized'
        _result_isOptimized = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_isOptimized)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompileUnitAttr parameter 'isOptimized' which is to be a `bool`");
          return {};
        }
      } else if (!_seen_emissionKind && _paramKey == "emissionKind") {
        _seen_emissionKind = true;

        // Parse variable 'emissionKind'
        _result_emissionKind = ::mlir::FieldParser<DIEmissionKind>::parse(odsParser);
        if (::mlir::failed(_result_emissionKind)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompileUnitAttr parameter 'emissionKind' which is to be a `DIEmissionKind`");
          return {};
        }
      } else if (!_seen_nameTableKind && _paramKey == "nameTableKind") {
        _seen_nameTableKind = true;

        // Parse variable 'nameTableKind'
        _result_nameTableKind = ::mlir::FieldParser<DINameTableKind>::parse(odsParser);
        if (::mlir::failed(_result_nameTableKind)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompileUnitAttr parameter 'nameTableKind' which is to be a `DINameTableKind`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_id) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "id";
      return {};
    }
    if (!_seen_sourceLanguage) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "sourceLanguage";
      return {};
    }
    if (!_seen_file) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "file";
      return {};
    }
    if (!_seen_isOptimized) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "isOptimized";
      return {};
    }
    if (!_seen_emissionKind) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "emissionKind";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_id));
  assert(::mlir::succeeded(_result_sourceLanguage));
  assert(::mlir::succeeded(_result_file));
  assert(::mlir::succeeded(_result_isOptimized));
  assert(::mlir::succeeded(_result_emissionKind));
  return DICompileUnitAttr::get(odsParser.getContext(),
      DistinctAttr((*_result_id)),
      unsigned((*_result_sourceLanguage)),
      DIFileAttr((*_result_file)),
      StringAttr((_result_producer.value_or(StringAttr()))),
      bool((*_result_isOptimized)),
      DIEmissionKind((*_result_emissionKind)),
      DINameTableKind((_result_nameTableKind.value_or(DINameTableKind()))));
}

void DICompileUnitAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "id = ";
    odsPrinter.printStrippedAttrOrType(getId());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "sourceLanguage = ";
    odsPrinter << llvm::dwarf::LanguageString(getSourceLanguage());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "file = ";
    odsPrinter.printStrippedAttrOrType(getFile());
    if (!(getProducer() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "producer = ";
      if (!(getProducer() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getProducer());
      }
    }
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "isOptimized = ";
    odsPrinter.printStrippedAttrOrType(getIsOptimized());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "emissionKind = ";
    odsPrinter.printStrippedAttrOrType(getEmissionKind());
    if (!(getNameTableKind() == DINameTableKind())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "nameTableKind = ";
      if (!(getNameTableKind() == DINameTableKind())) {
        odsPrinter.printStrippedAttrOrType(getNameTableKind());
      }
    }
  }
  odsPrinter << ">";
}

DistinctAttr DICompileUnitAttr::getId() const {
  return getImpl()->id;
}

unsigned DICompileUnitAttr::getSourceLanguage() const {
  return getImpl()->sourceLanguage;
}

DIFileAttr DICompileUnitAttr::getFile() const {
  return getImpl()->file;
}

StringAttr DICompileUnitAttr::getProducer() const {
  return getImpl()->producer;
}

bool DICompileUnitAttr::getIsOptimized() const {
  return getImpl()->isOptimized;
}

DIEmissionKind DICompileUnitAttr::getEmissionKind() const {
  return getImpl()->emissionKind;
}

DINameTableKind DICompileUnitAttr::getNameTableKind() const {
  return getImpl()->nameTableKind;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DICompileUnitAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DICompositeTypeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DistinctAttr, bool, unsigned, StringAttr, DIFileAttr, uint32_t, DIScopeAttr, DITypeAttr, DIFlags, uint64_t, uint64_t, ::llvm::ArrayRef<DINodeAttr>, DIExpressionAttr, DIExpressionAttr, DIExpressionAttr, DIExpressionAttr>;
  DICompositeTypeAttrStorage(DistinctAttr recId, bool isRecSelf, unsigned tag, StringAttr name, DIFileAttr file, uint32_t line, DIScopeAttr scope, DITypeAttr baseType, DIFlags flags, uint64_t sizeInBits, uint64_t alignInBits, ::llvm::ArrayRef<DINodeAttr> elements, DIExpressionAttr dataLocation, DIExpressionAttr rank, DIExpressionAttr allocated, DIExpressionAttr associated) : recId(std::move(recId)), isRecSelf(std::move(isRecSelf)), tag(std::move(tag)), name(std::move(name)), file(std::move(file)), line(std::move(line)), scope(std::move(scope)), baseType(std::move(baseType)), flags(std::move(flags)), sizeInBits(std::move(sizeInBits)), alignInBits(std::move(alignInBits)), elements(std::move(elements)), dataLocation(std::move(dataLocation)), rank(std::move(rank)), allocated(std::move(allocated)), associated(std::move(associated)) {}

  KeyTy getAsKey() const {
    return KeyTy(recId, isRecSelf, tag, name, file, line, scope, baseType, flags, sizeInBits, alignInBits, elements, dataLocation, rank, allocated, associated);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (recId == std::get<0>(tblgenKey)) && (isRecSelf == std::get<1>(tblgenKey)) && (tag == std::get<2>(tblgenKey)) && (name == std::get<3>(tblgenKey)) && (file == std::get<4>(tblgenKey)) && (line == std::get<5>(tblgenKey)) && (scope == std::get<6>(tblgenKey)) && (baseType == std::get<7>(tblgenKey)) && (flags == std::get<8>(tblgenKey)) && (sizeInBits == std::get<9>(tblgenKey)) && (alignInBits == std::get<10>(tblgenKey)) && (::llvm::ArrayRef<DINodeAttr>(elements) == ::llvm::ArrayRef<DINodeAttr>(std::get<11>(tblgenKey))) && (dataLocation == std::get<12>(tblgenKey)) && (rank == std::get<13>(tblgenKey)) && (allocated == std::get<14>(tblgenKey)) && (associated == std::get<15>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey), std::get<8>(tblgenKey), std::get<9>(tblgenKey), std::get<10>(tblgenKey), std::get<11>(tblgenKey), std::get<12>(tblgenKey), std::get<13>(tblgenKey), std::get<14>(tblgenKey), std::get<15>(tblgenKey));
  }

  static DICompositeTypeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto recId = std::move(std::get<0>(tblgenKey));
    auto isRecSelf = std::move(std::get<1>(tblgenKey));
    auto tag = std::move(std::get<2>(tblgenKey));
    auto name = std::move(std::get<3>(tblgenKey));
    auto file = std::move(std::get<4>(tblgenKey));
    auto line = std::move(std::get<5>(tblgenKey));
    auto scope = std::move(std::get<6>(tblgenKey));
    auto baseType = std::move(std::get<7>(tblgenKey));
    auto flags = std::move(std::get<8>(tblgenKey));
    auto sizeInBits = std::move(std::get<9>(tblgenKey));
    auto alignInBits = std::move(std::get<10>(tblgenKey));
    auto elements = std::move(std::get<11>(tblgenKey));
    auto dataLocation = std::move(std::get<12>(tblgenKey));
    auto rank = std::move(std::get<13>(tblgenKey));
    auto allocated = std::move(std::get<14>(tblgenKey));
    auto associated = std::move(std::get<15>(tblgenKey));
    elements = allocator.copyInto(elements);
    return new (allocator.allocate<DICompositeTypeAttrStorage>()) DICompositeTypeAttrStorage(std::move(recId), std::move(isRecSelf), std::move(tag), std::move(name), std::move(file), std::move(line), std::move(scope), std::move(baseType), std::move(flags), std::move(sizeInBits), std::move(alignInBits), std::move(elements), std::move(dataLocation), std::move(rank), std::move(allocated), std::move(associated));
  }

  DistinctAttr recId;
  bool isRecSelf;
  unsigned tag;
  StringAttr name;
  DIFileAttr file;
  uint32_t line;
  DIScopeAttr scope;
  DITypeAttr baseType;
  DIFlags flags;
  uint64_t sizeInBits;
  uint64_t alignInBits;
  ::llvm::ArrayRef<DINodeAttr> elements;
  DIExpressionAttr dataLocation;
  DIExpressionAttr rank;
  DIExpressionAttr allocated;
  DIExpressionAttr associated;
};
} // namespace detail
DICompositeTypeAttr DICompositeTypeAttr::get(::mlir::MLIRContext *context, DistinctAttr recId, bool isRecSelf, unsigned tag, StringAttr name, DIFileAttr file, uint32_t line, DIScopeAttr scope, DITypeAttr baseType, DIFlags flags, uint64_t sizeInBits, uint64_t alignInBits, ::llvm::ArrayRef<DINodeAttr> elements, DIExpressionAttr dataLocation, DIExpressionAttr rank, DIExpressionAttr allocated, DIExpressionAttr associated) {
  return Base::get(context, std::move(recId), std::move(isRecSelf), std::move(tag), std::move(name), std::move(file), std::move(line), std::move(scope), std::move(baseType), std::move(flags), std::move(sizeInBits), std::move(alignInBits), std::move(elements), std::move(dataLocation), std::move(rank), std::move(allocated), std::move(associated));
}

DICompositeTypeAttr DICompositeTypeAttr::get(::mlir::MLIRContext *context, unsigned tag, StringAttr name, DIFileAttr file, uint32_t line, DIScopeAttr scope, DITypeAttr baseType, DIFlags flags, uint64_t sizeInBits, uint64_t alignInBits, ArrayRef<DINodeAttr> elements, DIExpressionAttr dataLocation, DIExpressionAttr rank, DIExpressionAttr allocated, DIExpressionAttr associated) {
  return Base::get(context, /*recId=*/nullptr, /*isRecSelf=*/nullptr,
               tag, name, file, line, scope, baseType, flags, sizeInBits,
               alignInBits, elements, dataLocation, rank, allocated,
               associated);
}

::mlir::Attribute DICompositeTypeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DistinctAttr> _result_recId;
  ::mlir::FailureOr<bool> _result_isRecSelf;
  ::mlir::FailureOr<unsigned> _result_tag;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<uint32_t> _result_line;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<DITypeAttr> _result_baseType;
  ::mlir::FailureOr<DIFlags> _result_flags;
  ::mlir::FailureOr<uint64_t> _result_sizeInBits;
  ::mlir::FailureOr<uint64_t> _result_alignInBits;
  ::mlir::FailureOr<::llvm::SmallVector<DINodeAttr>> _result_elements;
  ::mlir::FailureOr<DIExpressionAttr> _result_dataLocation;
  ::mlir::FailureOr<DIExpressionAttr> _result_rank;
  ::mlir::FailureOr<DIExpressionAttr> _result_allocated;
  ::mlir::FailureOr<DIExpressionAttr> _result_associated;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_recId = false;
  bool _seen_isRecSelf = false;
  bool _seen_tag = false;
  bool _seen_name = false;
  bool _seen_file = false;
  bool _seen_line = false;
  bool _seen_scope = false;
  bool _seen_baseType = false;
  bool _seen_flags = false;
  bool _seen_sizeInBits = false;
  bool _seen_alignInBits = false;
  bool _seen_elements = false;
  bool _seen_dataLocation = false;
  bool _seen_rank = false;
  bool _seen_allocated = false;
  bool _seen_associated = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_recId && _paramKey == "recId") {
        _seen_recId = true;

        // Parse variable 'recId'
        _result_recId = ::mlir::FieldParser<DistinctAttr>::parse(odsParser);
        if (::mlir::failed(_result_recId)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'recId' which is to be a `DistinctAttr`");
          return {};
        }
      } else if (!_seen_isRecSelf && _paramKey == "isRecSelf") {
        _seen_isRecSelf = true;

        // Parse variable 'isRecSelf'
        _result_isRecSelf = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_isRecSelf)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'isRecSelf' which is to be a `bool`");
          return {};
        }
      } else if (!_seen_tag && _paramKey == "tag") {
        _seen_tag = true;

        // Parse variable 'tag'
        _result_tag =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getTag(name);
            if (tag == llvm::dwarf::DW_TAG_invalid)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info tag name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_tag)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'tag' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<uint32_t>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'line' which is to be a `uint32_t`");
          return {};
        }
      } else if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_baseType && _paramKey == "baseType") {
        _seen_baseType = true;

        // Parse variable 'baseType'
        _result_baseType = ::mlir::FieldParser<DITypeAttr>::parse(odsParser);
        if (::mlir::failed(_result_baseType)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'baseType' which is to be a `DITypeAttr`");
          return {};
        }
      } else if (!_seen_flags && _paramKey == "flags") {
        _seen_flags = true;

        // Parse variable 'flags'
        _result_flags = ::mlir::FieldParser<DIFlags>::parse(odsParser);
        if (::mlir::failed(_result_flags)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'flags' which is to be a `DIFlags`");
          return {};
        }
      } else if (!_seen_sizeInBits && _paramKey == "sizeInBits") {
        _seen_sizeInBits = true;

        // Parse variable 'sizeInBits'
        _result_sizeInBits = ::mlir::FieldParser<uint64_t>::parse(odsParser);
        if (::mlir::failed(_result_sizeInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'sizeInBits' which is to be a `uint64_t`");
          return {};
        }
      } else if (!_seen_alignInBits && _paramKey == "alignInBits") {
        _seen_alignInBits = true;

        // Parse variable 'alignInBits'
        _result_alignInBits = ::mlir::FieldParser<uint64_t>::parse(odsParser);
        if (::mlir::failed(_result_alignInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'alignInBits' which is to be a `uint64_t`");
          return {};
        }
      } else if (!_seen_elements && _paramKey == "elements") {
        _seen_elements = true;

        // Parse variable 'elements'
        _result_elements = ::mlir::FieldParser<::llvm::SmallVector<DINodeAttr>>::parse(odsParser);
        if (::mlir::failed(_result_elements)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'elements' which is to be a `::llvm::ArrayRef<DINodeAttr>`");
          return {};
        }
      } else if (!_seen_dataLocation && _paramKey == "dataLocation") {
        _seen_dataLocation = true;

        // Parse variable 'dataLocation'
        _result_dataLocation = ::mlir::FieldParser<DIExpressionAttr>::parse(odsParser);
        if (::mlir::failed(_result_dataLocation)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'dataLocation' which is to be a `DIExpressionAttr`");
          return {};
        }
      } else if (!_seen_rank && _paramKey == "rank") {
        _seen_rank = true;

        // Parse variable 'rank'
        _result_rank = ::mlir::FieldParser<DIExpressionAttr>::parse(odsParser);
        if (::mlir::failed(_result_rank)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'rank' which is to be a `DIExpressionAttr`");
          return {};
        }
      } else if (!_seen_allocated && _paramKey == "allocated") {
        _seen_allocated = true;

        // Parse variable 'allocated'
        _result_allocated = ::mlir::FieldParser<DIExpressionAttr>::parse(odsParser);
        if (::mlir::failed(_result_allocated)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'allocated' which is to be a `DIExpressionAttr`");
          return {};
        }
      } else if (!_seen_associated && _paramKey == "associated") {
        _seen_associated = true;

        // Parse variable 'associated'
        _result_associated = ::mlir::FieldParser<DIExpressionAttr>::parse(odsParser);
        if (::mlir::failed(_result_associated)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DICompositeTypeAttr parameter 'associated' which is to be a `DIExpressionAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return DICompositeTypeAttr::get(odsParser.getContext(),
      DistinctAttr((_result_recId.value_or(DistinctAttr()))),
      bool((_result_isRecSelf.value_or(bool()))),
      unsigned((_result_tag.value_or(0))),
      StringAttr((_result_name.value_or(StringAttr()))),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      uint32_t((_result_line.value_or(uint32_t()))),
      DIScopeAttr((_result_scope.value_or(DIScopeAttr()))),
      DITypeAttr((_result_baseType.value_or(DITypeAttr()))),
      DIFlags((_result_flags.value_or(DIFlags()))),
      uint64_t((_result_sizeInBits.value_or(uint64_t()))),
      uint64_t((_result_alignInBits.value_or(uint64_t()))),
      ::llvm::ArrayRef<DINodeAttr>((_result_elements.value_or(::llvm::SmallVector<DINodeAttr>()))),
      DIExpressionAttr((_result_dataLocation.value_or(DIExpressionAttr()))),
      DIExpressionAttr((_result_rank.value_or(DIExpressionAttr()))),
      DIExpressionAttr((_result_allocated.value_or(DIExpressionAttr()))),
      DIExpressionAttr((_result_associated.value_or(DIExpressionAttr()))));
}

void DICompositeTypeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getRecId() == DistinctAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "recId = ";
      if (!(getRecId() == DistinctAttr())) {
        odsPrinter.printStrippedAttrOrType(getRecId());
      }
    }
    if (!(getIsRecSelf() == bool())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "isRecSelf = ";
      if (!(getIsRecSelf() == bool())) {
        odsPrinter.printStrippedAttrOrType(getIsRecSelf());
      }
    }
    if (!(getTag() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "tag = ";
      if (!(getTag() == 0)) {
        odsPrinter << llvm::dwarf::TagString(getTag());
      }
    }
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!(getLine() == uint32_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "line = ";
      if (!(getLine() == uint32_t())) {
        odsPrinter.printStrippedAttrOrType(getLine());
      }
    }
    if (!(getScope() == DIScopeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "scope = ";
      if (!(getScope() == DIScopeAttr())) {
        odsPrinter.printStrippedAttrOrType(getScope());
      }
    }
    if (!(getBaseType() == DITypeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "baseType = ";
      if (!(getBaseType() == DITypeAttr())) {
        odsPrinter.printStrippedAttrOrType(getBaseType());
      }
    }
    if (!(getFlags() == DIFlags())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "flags = ";
      if (!(getFlags() == DIFlags())) {
        odsPrinter.printStrippedAttrOrType(getFlags());
      }
    }
    if (!(getSizeInBits() == uint64_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "sizeInBits = ";
      if (!(getSizeInBits() == uint64_t())) {
        odsPrinter.printStrippedAttrOrType(getSizeInBits());
      }
    }
    if (!(getAlignInBits() == uint64_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "alignInBits = ";
      if (!(getAlignInBits() == uint64_t())) {
        odsPrinter.printStrippedAttrOrType(getAlignInBits());
      }
    }
    if (!(::llvm::ArrayRef<DINodeAttr>(getElements()) == ::llvm::ArrayRef<DINodeAttr>(::llvm::SmallVector<DINodeAttr>()))) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "elements = ";
      if (!(::llvm::ArrayRef<DINodeAttr>(getElements()) == ::llvm::ArrayRef<DINodeAttr>(::llvm::SmallVector<DINodeAttr>()))) {
        odsPrinter.printStrippedAttrOrType(getElements());
      }
    }
    if (!(getDataLocation() == DIExpressionAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "dataLocation = ";
      if (!(getDataLocation() == DIExpressionAttr())) {
        odsPrinter.printStrippedAttrOrType(getDataLocation());
      }
    }
    if (!(getRank() == DIExpressionAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "rank = ";
      if (!(getRank() == DIExpressionAttr())) {
        odsPrinter.printStrippedAttrOrType(getRank());
      }
    }
    if (!(getAllocated() == DIExpressionAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "allocated = ";
      if (!(getAllocated() == DIExpressionAttr())) {
        odsPrinter.printStrippedAttrOrType(getAllocated());
      }
    }
    if (!(getAssociated() == DIExpressionAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "associated = ";
      if (!(getAssociated() == DIExpressionAttr())) {
        odsPrinter.printStrippedAttrOrType(getAssociated());
      }
    }
  }
  odsPrinter << ">";
}

DistinctAttr DICompositeTypeAttr::getRecId() const {
  return getImpl()->recId;
}

bool DICompositeTypeAttr::getIsRecSelf() const {
  return getImpl()->isRecSelf;
}

unsigned DICompositeTypeAttr::getTag() const {
  return getImpl()->tag;
}

StringAttr DICompositeTypeAttr::getName() const {
  return getImpl()->name;
}

DIFileAttr DICompositeTypeAttr::getFile() const {
  return getImpl()->file;
}

uint32_t DICompositeTypeAttr::getLine() const {
  return getImpl()->line;
}

DIScopeAttr DICompositeTypeAttr::getScope() const {
  return getImpl()->scope;
}

DITypeAttr DICompositeTypeAttr::getBaseType() const {
  return getImpl()->baseType;
}

DIFlags DICompositeTypeAttr::getFlags() const {
  return getImpl()->flags;
}

uint64_t DICompositeTypeAttr::getSizeInBits() const {
  return getImpl()->sizeInBits;
}

uint64_t DICompositeTypeAttr::getAlignInBits() const {
  return getImpl()->alignInBits;
}

::llvm::ArrayRef<DINodeAttr> DICompositeTypeAttr::getElements() const {
  return getImpl()->elements;
}

DIExpressionAttr DICompositeTypeAttr::getDataLocation() const {
  return getImpl()->dataLocation;
}

DIExpressionAttr DICompositeTypeAttr::getRank() const {
  return getImpl()->rank;
}

DIExpressionAttr DICompositeTypeAttr::getAllocated() const {
  return getImpl()->allocated;
}

DIExpressionAttr DICompositeTypeAttr::getAssociated() const {
  return getImpl()->associated;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DICompositeTypeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIDerivedTypeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<unsigned, StringAttr, DITypeAttr, uint64_t, uint32_t, uint64_t, std::optional<unsigned>, DINodeAttr>;
  DIDerivedTypeAttrStorage(unsigned tag, StringAttr name, DITypeAttr baseType, uint64_t sizeInBits, uint32_t alignInBits, uint64_t offsetInBits, std::optional<unsigned> dwarfAddressSpace, DINodeAttr extraData) : tag(std::move(tag)), name(std::move(name)), baseType(std::move(baseType)), sizeInBits(std::move(sizeInBits)), alignInBits(std::move(alignInBits)), offsetInBits(std::move(offsetInBits)), dwarfAddressSpace(std::move(dwarfAddressSpace)), extraData(std::move(extraData)) {}

  KeyTy getAsKey() const {
    return KeyTy(tag, name, baseType, sizeInBits, alignInBits, offsetInBits, dwarfAddressSpace, extraData);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (tag == std::get<0>(tblgenKey)) && (name == std::get<1>(tblgenKey)) && (baseType == std::get<2>(tblgenKey)) && (sizeInBits == std::get<3>(tblgenKey)) && (alignInBits == std::get<4>(tblgenKey)) && (offsetInBits == std::get<5>(tblgenKey)) && (dwarfAddressSpace == std::get<6>(tblgenKey)) && (extraData == std::get<7>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey));
  }

  static DIDerivedTypeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto tag = std::move(std::get<0>(tblgenKey));
    auto name = std::move(std::get<1>(tblgenKey));
    auto baseType = std::move(std::get<2>(tblgenKey));
    auto sizeInBits = std::move(std::get<3>(tblgenKey));
    auto alignInBits = std::move(std::get<4>(tblgenKey));
    auto offsetInBits = std::move(std::get<5>(tblgenKey));
    auto dwarfAddressSpace = std::move(std::get<6>(tblgenKey));
    auto extraData = std::move(std::get<7>(tblgenKey));
    return new (allocator.allocate<DIDerivedTypeAttrStorage>()) DIDerivedTypeAttrStorage(std::move(tag), std::move(name), std::move(baseType), std::move(sizeInBits), std::move(alignInBits), std::move(offsetInBits), std::move(dwarfAddressSpace), std::move(extraData));
  }

  unsigned tag;
  StringAttr name;
  DITypeAttr baseType;
  uint64_t sizeInBits;
  uint32_t alignInBits;
  uint64_t offsetInBits;
  std::optional<unsigned> dwarfAddressSpace;
  DINodeAttr extraData;
};
} // namespace detail
DIDerivedTypeAttr DIDerivedTypeAttr::get(::mlir::MLIRContext *context, unsigned tag, StringAttr name, DITypeAttr baseType, uint64_t sizeInBits, uint32_t alignInBits, uint64_t offsetInBits, std::optional<unsigned> dwarfAddressSpace, DINodeAttr extraData) {
  return Base::get(context, std::move(tag), std::move(name), std::move(baseType), std::move(sizeInBits), std::move(alignInBits), std::move(offsetInBits), std::move(dwarfAddressSpace), std::move(extraData));
}

::mlir::Attribute DIDerivedTypeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<unsigned> _result_tag;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<DITypeAttr> _result_baseType;
  ::mlir::FailureOr<uint64_t> _result_sizeInBits;
  ::mlir::FailureOr<uint32_t> _result_alignInBits;
  ::mlir::FailureOr<uint64_t> _result_offsetInBits;
  ::mlir::FailureOr<std::optional<unsigned>> _result_dwarfAddressSpace;
  ::mlir::FailureOr<DINodeAttr> _result_extraData;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_tag = false;
  bool _seen_name = false;
  bool _seen_baseType = false;
  bool _seen_sizeInBits = false;
  bool _seen_alignInBits = false;
  bool _seen_offsetInBits = false;
  bool _seen_dwarfAddressSpace = false;
  bool _seen_extraData = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_tag && _paramKey == "tag") {
        _seen_tag = true;

        // Parse variable 'tag'
        _result_tag =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getTag(name);
            if (tag == llvm::dwarf::DW_TAG_invalid)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info tag name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_tag)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'tag' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_baseType && _paramKey == "baseType") {
        _seen_baseType = true;

        // Parse variable 'baseType'
        _result_baseType = ::mlir::FieldParser<DITypeAttr>::parse(odsParser);
        if (::mlir::failed(_result_baseType)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'baseType' which is to be a `DITypeAttr`");
          return {};
        }
      } else if (!_seen_sizeInBits && _paramKey == "sizeInBits") {
        _seen_sizeInBits = true;

        // Parse variable 'sizeInBits'
        _result_sizeInBits = ::mlir::FieldParser<uint64_t>::parse(odsParser);
        if (::mlir::failed(_result_sizeInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'sizeInBits' which is to be a `uint64_t`");
          return {};
        }
      } else if (!_seen_alignInBits && _paramKey == "alignInBits") {
        _seen_alignInBits = true;

        // Parse variable 'alignInBits'
        _result_alignInBits = ::mlir::FieldParser<uint32_t>::parse(odsParser);
        if (::mlir::failed(_result_alignInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'alignInBits' which is to be a `uint32_t`");
          return {};
        }
      } else if (!_seen_offsetInBits && _paramKey == "offsetInBits") {
        _seen_offsetInBits = true;

        // Parse variable 'offsetInBits'
        _result_offsetInBits = ::mlir::FieldParser<uint64_t>::parse(odsParser);
        if (::mlir::failed(_result_offsetInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'offsetInBits' which is to be a `uint64_t`");
          return {};
        }
      } else if (!_seen_dwarfAddressSpace && _paramKey == "dwarfAddressSpace") {
        _seen_dwarfAddressSpace = true;

        // Parse variable 'dwarfAddressSpace'
        _result_dwarfAddressSpace = ::mlir::FieldParser<std::optional<unsigned>>::parse(odsParser);
        if (::mlir::failed(_result_dwarfAddressSpace)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'dwarfAddressSpace' which is to be a `std::optional<unsigned>`");
          return {};
        }
      } else if (!_seen_extraData && _paramKey == "extraData") {
        _seen_extraData = true;

        // Parse variable 'extraData'
        _result_extraData = ::mlir::FieldParser<DINodeAttr>::parse(odsParser);
        if (::mlir::failed(_result_extraData)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIDerivedTypeAttr parameter 'extraData' which is to be a `DINodeAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return DIDerivedTypeAttr::get(odsParser.getContext(),
      unsigned((_result_tag.value_or(0))),
      StringAttr((_result_name.value_or(StringAttr()))),
      DITypeAttr((_result_baseType.value_or(DITypeAttr()))),
      uint64_t((_result_sizeInBits.value_or(uint64_t()))),
      uint32_t((_result_alignInBits.value_or(uint32_t()))),
      uint64_t((_result_offsetInBits.value_or(uint64_t()))),
      std::optional<unsigned>((_result_dwarfAddressSpace.value_or(std::optional<unsigned>()))),
      DINodeAttr((_result_extraData.value_or(DINodeAttr()))));
}

void DIDerivedTypeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getTag() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "tag = ";
      if (!(getTag() == 0)) {
        odsPrinter << llvm::dwarf::TagString(getTag());
      }
    }
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getBaseType() == DITypeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "baseType = ";
      if (!(getBaseType() == DITypeAttr())) {
        odsPrinter.printStrippedAttrOrType(getBaseType());
      }
    }
    if (!(getSizeInBits() == uint64_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "sizeInBits = ";
      if (!(getSizeInBits() == uint64_t())) {
        odsPrinter.printStrippedAttrOrType(getSizeInBits());
      }
    }
    if (!(getAlignInBits() == uint32_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "alignInBits = ";
      if (!(getAlignInBits() == uint32_t())) {
        odsPrinter.printStrippedAttrOrType(getAlignInBits());
      }
    }
    if (!(getOffsetInBits() == uint64_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "offsetInBits = ";
      if (!(getOffsetInBits() == uint64_t())) {
        odsPrinter.printStrippedAttrOrType(getOffsetInBits());
      }
    }
    if (!(getDwarfAddressSpace() == std::optional<unsigned>())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "dwarfAddressSpace = ";
      if (!(getDwarfAddressSpace() == std::optional<unsigned>())) {
        odsPrinter.printStrippedAttrOrType(getDwarfAddressSpace());
      }
    }
    if (!(getExtraData() == DINodeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "extraData = ";
      if (!(getExtraData() == DINodeAttr())) {
        odsPrinter.printStrippedAttrOrType(getExtraData());
      }
    }
  }
  odsPrinter << ">";
}

unsigned DIDerivedTypeAttr::getTag() const {
  return getImpl()->tag;
}

StringAttr DIDerivedTypeAttr::getName() const {
  return getImpl()->name;
}

DITypeAttr DIDerivedTypeAttr::getBaseType() const {
  return getImpl()->baseType;
}

uint64_t DIDerivedTypeAttr::getSizeInBits() const {
  return getImpl()->sizeInBits;
}

uint32_t DIDerivedTypeAttr::getAlignInBits() const {
  return getImpl()->alignInBits;
}

uint64_t DIDerivedTypeAttr::getOffsetInBits() const {
  return getImpl()->offsetInBits;
}

std::optional<unsigned> DIDerivedTypeAttr::getDwarfAddressSpace() const {
  return getImpl()->dwarfAddressSpace;
}

DINodeAttr DIDerivedTypeAttr::getExtraData() const {
  return getImpl()->extraData;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIDerivedTypeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIFileAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<StringAttr, StringAttr>;
  DIFileAttrStorage(StringAttr name, StringAttr directory) : name(std::move(name)), directory(std::move(directory)) {}

  KeyTy getAsKey() const {
    return KeyTy(name, directory);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (name == std::get<0>(tblgenKey)) && (directory == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static DIFileAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto name = std::move(std::get<0>(tblgenKey));
    auto directory = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<DIFileAttrStorage>()) DIFileAttrStorage(std::move(name), std::move(directory));
  }

  StringAttr name;
  StringAttr directory;
};
} // namespace detail
DIFileAttr DIFileAttr::get(::mlir::MLIRContext *context, StringAttr name, StringAttr directory) {
  return Base::get(context, std::move(name), std::move(directory));
}

DIFileAttr DIFileAttr::get(::mlir::MLIRContext *context, StringRef name, StringRef directory) {
  return Base::get(context, StringAttr::get(context, name),
               StringAttr::get(context, directory));
}

::mlir::Attribute DIFileAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<StringAttr> _result_directory;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'name'
  _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
  if (::mlir::failed(_result_name)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIFileAttr parameter 'name' which is to be a `StringAttr`");
    return {};
  }
  // Parse literal 'in'
  if (odsParser.parseKeyword("in")) return {};

  // Parse variable 'directory'
  _result_directory = ::mlir::FieldParser<StringAttr>::parse(odsParser);
  if (::mlir::failed(_result_directory)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIFileAttr parameter 'directory' which is to be a `StringAttr`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_name));
  assert(::mlir::succeeded(_result_directory));
  return DIFileAttr::get(odsParser.getContext(),
      StringAttr((*_result_name)),
      StringAttr((*_result_directory)));
}

void DIFileAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter.printStrippedAttrOrType(getName());
  odsPrinter << ' ' << "in";
  odsPrinter << ' ';
  odsPrinter.printStrippedAttrOrType(getDirectory());
  odsPrinter << ">";
}

StringAttr DIFileAttr::getName() const {
  return getImpl()->name;
}

StringAttr DIFileAttr::getDirectory() const {
  return getImpl()->directory;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIFileAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIGlobalVariableExpressionAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DIGlobalVariableAttr, DIExpressionAttr>;
  DIGlobalVariableExpressionAttrStorage(DIGlobalVariableAttr var, DIExpressionAttr expr) : var(std::move(var)), expr(std::move(expr)) {}

  KeyTy getAsKey() const {
    return KeyTy(var, expr);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (var == std::get<0>(tblgenKey)) && (expr == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static DIGlobalVariableExpressionAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto var = std::move(std::get<0>(tblgenKey));
    auto expr = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<DIGlobalVariableExpressionAttrStorage>()) DIGlobalVariableExpressionAttrStorage(std::move(var), std::move(expr));
  }

  DIGlobalVariableAttr var;
  DIExpressionAttr expr;
};
} // namespace detail
DIGlobalVariableExpressionAttr DIGlobalVariableExpressionAttr::get(::mlir::MLIRContext *context, DIGlobalVariableAttr var, DIExpressionAttr expr) {
  return Base::get(context, std::move(var), std::move(expr));
}

::mlir::Attribute DIGlobalVariableExpressionAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DIGlobalVariableAttr> _result_var;
  ::mlir::FailureOr<DIExpressionAttr> _result_expr;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_var = false;
  bool _seen_expr = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_var && _paramKey == "var") {
        _seen_var = true;

        // Parse variable 'var'
        _result_var = ::mlir::FieldParser<DIGlobalVariableAttr>::parse(odsParser);
        if (::mlir::failed(_result_var)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariableExpressionAttr parameter 'var' which is to be a `DIGlobalVariableAttr`");
          return {};
        }
      } else if (!_seen_expr && _paramKey == "expr") {
        _seen_expr = true;

        // Parse variable 'expr'
        _result_expr = ::mlir::FieldParser<DIExpressionAttr>::parse(odsParser);
        if (::mlir::failed(_result_expr)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariableExpressionAttr parameter 'expr' which is to be a `DIExpressionAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_var) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "var";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_var));
  return DIGlobalVariableExpressionAttr::get(odsParser.getContext(),
      DIGlobalVariableAttr((*_result_var)),
      DIExpressionAttr((_result_expr.value_or(DIExpressionAttr()))));
}

void DIGlobalVariableExpressionAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "var = ";
    odsPrinter.printStrippedAttrOrType(getVar());
    if (!(getExpr() == DIExpressionAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "expr = ";
      if (!(getExpr() == DIExpressionAttr())) {
        odsPrinter.printStrippedAttrOrType(getExpr());
      }
    }
  }
  odsPrinter << ">";
}

DIGlobalVariableAttr DIGlobalVariableExpressionAttr::getVar() const {
  return getImpl()->var;
}

DIExpressionAttr DIGlobalVariableExpressionAttr::getExpr() const {
  return getImpl()->expr;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIGlobalVariableExpressionAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIGlobalVariableAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DIScopeAttr, StringAttr, StringAttr, DIFileAttr, unsigned, DITypeAttr, bool, bool, unsigned>;
  DIGlobalVariableAttrStorage(DIScopeAttr scope, StringAttr name, StringAttr linkageName, DIFileAttr file, unsigned line, DITypeAttr type, bool isLocalToUnit, bool isDefined, unsigned alignInBits) : scope(std::move(scope)), name(std::move(name)), linkageName(std::move(linkageName)), file(std::move(file)), line(std::move(line)), type(std::move(type)), isLocalToUnit(std::move(isLocalToUnit)), isDefined(std::move(isDefined)), alignInBits(std::move(alignInBits)) {}

  KeyTy getAsKey() const {
    return KeyTy(scope, name, linkageName, file, line, type, isLocalToUnit, isDefined, alignInBits);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (scope == std::get<0>(tblgenKey)) && (name == std::get<1>(tblgenKey)) && (linkageName == std::get<2>(tblgenKey)) && (file == std::get<3>(tblgenKey)) && (line == std::get<4>(tblgenKey)) && (type == std::get<5>(tblgenKey)) && (isLocalToUnit == std::get<6>(tblgenKey)) && (isDefined == std::get<7>(tblgenKey)) && (alignInBits == std::get<8>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey), std::get<8>(tblgenKey));
  }

  static DIGlobalVariableAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto scope = std::move(std::get<0>(tblgenKey));
    auto name = std::move(std::get<1>(tblgenKey));
    auto linkageName = std::move(std::get<2>(tblgenKey));
    auto file = std::move(std::get<3>(tblgenKey));
    auto line = std::move(std::get<4>(tblgenKey));
    auto type = std::move(std::get<5>(tblgenKey));
    auto isLocalToUnit = std::move(std::get<6>(tblgenKey));
    auto isDefined = std::move(std::get<7>(tblgenKey));
    auto alignInBits = std::move(std::get<8>(tblgenKey));
    return new (allocator.allocate<DIGlobalVariableAttrStorage>()) DIGlobalVariableAttrStorage(std::move(scope), std::move(name), std::move(linkageName), std::move(file), std::move(line), std::move(type), std::move(isLocalToUnit), std::move(isDefined), std::move(alignInBits));
  }

  DIScopeAttr scope;
  StringAttr name;
  StringAttr linkageName;
  DIFileAttr file;
  unsigned line;
  DITypeAttr type;
  bool isLocalToUnit;
  bool isDefined;
  unsigned alignInBits;
};
} // namespace detail
DIGlobalVariableAttr DIGlobalVariableAttr::get(::mlir::MLIRContext *context, DIScopeAttr scope, StringAttr name, StringAttr linkageName, DIFileAttr file, unsigned line, DITypeAttr type, bool isLocalToUnit, bool isDefined, unsigned alignInBits) {
  return Base::get(context, std::move(scope), std::move(name), std::move(linkageName), std::move(file), std::move(line), std::move(type), std::move(isLocalToUnit), std::move(isDefined), std::move(alignInBits));
}

::mlir::Attribute DIGlobalVariableAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<StringAttr> _result_linkageName;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<unsigned> _result_line;
  ::mlir::FailureOr<DITypeAttr> _result_type;
  ::mlir::FailureOr<bool> _result_isLocalToUnit;
  ::mlir::FailureOr<bool> _result_isDefined;
  ::mlir::FailureOr<unsigned> _result_alignInBits;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_scope = false;
  bool _seen_name = false;
  bool _seen_linkageName = false;
  bool _seen_file = false;
  bool _seen_line = false;
  bool _seen_type = false;
  bool _seen_isLocalToUnit = false;
  bool _seen_isDefined = false;
  bool _seen_alignInBits = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_linkageName && _paramKey == "linkageName") {
        _seen_linkageName = true;

        // Parse variable 'linkageName'
        _result_linkageName = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_linkageName)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'linkageName' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'line' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_type && _paramKey == "type") {
        _seen_type = true;

        // Parse variable 'type'
        _result_type = ::mlir::FieldParser<DITypeAttr>::parse(odsParser);
        if (::mlir::failed(_result_type)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'type' which is to be a `DITypeAttr`");
          return {};
        }
      } else if (!_seen_isLocalToUnit && _paramKey == "isLocalToUnit") {
        _seen_isLocalToUnit = true;

        // Parse variable 'isLocalToUnit'
        _result_isLocalToUnit = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_isLocalToUnit)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'isLocalToUnit' which is to be a `bool`");
          return {};
        }
      } else if (!_seen_isDefined && _paramKey == "isDefined") {
        _seen_isDefined = true;

        // Parse variable 'isDefined'
        _result_isDefined = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_isDefined)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'isDefined' which is to be a `bool`");
          return {};
        }
      } else if (!_seen_alignInBits && _paramKey == "alignInBits") {
        _seen_alignInBits = true;

        // Parse variable 'alignInBits'
        _result_alignInBits = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_alignInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIGlobalVariable parameter 'alignInBits' which is to be a `unsigned`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_file) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "file";
      return {};
    }
    if (!_seen_line) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "line";
      return {};
    }
    if (!_seen_type) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "type";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_file));
  assert(::mlir::succeeded(_result_line));
  assert(::mlir::succeeded(_result_type));
  return DIGlobalVariableAttr::get(odsParser.getContext(),
      DIScopeAttr((_result_scope.value_or(DIScopeAttr()))),
      StringAttr((_result_name.value_or(StringAttr()))),
      StringAttr((_result_linkageName.value_or(StringAttr()))),
      DIFileAttr((*_result_file)),
      unsigned((*_result_line)),
      DITypeAttr((*_result_type)),
      bool((_result_isLocalToUnit.value_or(bool()))),
      bool((_result_isDefined.value_or(bool()))),
      unsigned((_result_alignInBits.value_or(unsigned()))));
}

void DIGlobalVariableAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getScope() == DIScopeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "scope = ";
      if (!(getScope() == DIScopeAttr())) {
        odsPrinter.printStrippedAttrOrType(getScope());
      }
    }
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getLinkageName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "linkageName = ";
      if (!(getLinkageName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getLinkageName());
      }
    }
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "file = ";
    odsPrinter.printStrippedAttrOrType(getFile());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "line = ";
    odsPrinter.printStrippedAttrOrType(getLine());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "type = ";
    odsPrinter.printStrippedAttrOrType(getType());
    if (!(getIsLocalToUnit() == bool())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "isLocalToUnit = ";
      if (!(getIsLocalToUnit() == bool())) {
        odsPrinter.printStrippedAttrOrType(getIsLocalToUnit());
      }
    }
    if (!(getIsDefined() == bool())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "isDefined = ";
      if (!(getIsDefined() == bool())) {
        odsPrinter.printStrippedAttrOrType(getIsDefined());
      }
    }
    if (!(getAlignInBits() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "alignInBits = ";
      if (!(getAlignInBits() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getAlignInBits());
      }
    }
  }
  odsPrinter << ">";
}

DIScopeAttr DIGlobalVariableAttr::getScope() const {
  return getImpl()->scope;
}

StringAttr DIGlobalVariableAttr::getName() const {
  return getImpl()->name;
}

StringAttr DIGlobalVariableAttr::getLinkageName() const {
  return getImpl()->linkageName;
}

DIFileAttr DIGlobalVariableAttr::getFile() const {
  return getImpl()->file;
}

unsigned DIGlobalVariableAttr::getLine() const {
  return getImpl()->line;
}

DITypeAttr DIGlobalVariableAttr::getType() const {
  return getImpl()->type;
}

bool DIGlobalVariableAttr::getIsLocalToUnit() const {
  return getImpl()->isLocalToUnit;
}

bool DIGlobalVariableAttr::getIsDefined() const {
  return getImpl()->isDefined;
}

unsigned DIGlobalVariableAttr::getAlignInBits() const {
  return getImpl()->alignInBits;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIGlobalVariableAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DILexicalBlockAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DIScopeAttr, DIFileAttr, unsigned, unsigned>;
  DILexicalBlockAttrStorage(DIScopeAttr scope, DIFileAttr file, unsigned line, unsigned column) : scope(std::move(scope)), file(std::move(file)), line(std::move(line)), column(std::move(column)) {}

  KeyTy getAsKey() const {
    return KeyTy(scope, file, line, column);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (scope == std::get<0>(tblgenKey)) && (file == std::get<1>(tblgenKey)) && (line == std::get<2>(tblgenKey)) && (column == std::get<3>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey));
  }

  static DILexicalBlockAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto scope = std::move(std::get<0>(tblgenKey));
    auto file = std::move(std::get<1>(tblgenKey));
    auto line = std::move(std::get<2>(tblgenKey));
    auto column = std::move(std::get<3>(tblgenKey));
    return new (allocator.allocate<DILexicalBlockAttrStorage>()) DILexicalBlockAttrStorage(std::move(scope), std::move(file), std::move(line), std::move(column));
  }

  DIScopeAttr scope;
  DIFileAttr file;
  unsigned line;
  unsigned column;
};
} // namespace detail
DILexicalBlockAttr DILexicalBlockAttr::get(::mlir::MLIRContext *context, DIScopeAttr scope, DIFileAttr file, unsigned line, unsigned column) {
  return Base::get(context, std::move(scope), std::move(file), std::move(line), std::move(column));
}

DILexicalBlockAttr DILexicalBlockAttr::get(DIScopeAttr scope, DIFileAttr file, unsigned line, unsigned column) {
  return Base::get(scope.getContext(), scope, file, line, column);
}

::mlir::Attribute DILexicalBlockAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<unsigned> _result_line;
  ::mlir::FailureOr<unsigned> _result_column;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_scope = false;
  bool _seen_file = false;
  bool _seen_line = false;
  bool _seen_column = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILexicalBlockAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILexicalBlockAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILexicalBlockAttr parameter 'line' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_column && _paramKey == "column") {
        _seen_column = true;

        // Parse variable 'column'
        _result_column = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_column)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILexicalBlockAttr parameter 'column' which is to be a `unsigned`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_scope) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "scope";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_scope));
  return DILexicalBlockAttr::get(odsParser.getContext(),
      DIScopeAttr((*_result_scope)),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      unsigned((_result_line.value_or(unsigned()))),
      unsigned((_result_column.value_or(unsigned()))));
}

void DILexicalBlockAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "scope = ";
    odsPrinter.printStrippedAttrOrType(getScope());
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!(getLine() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "line = ";
      if (!(getLine() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getLine());
      }
    }
    if (!(getColumn() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "column = ";
      if (!(getColumn() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getColumn());
      }
    }
  }
  odsPrinter << ">";
}

DIScopeAttr DILexicalBlockAttr::getScope() const {
  return getImpl()->scope;
}

DIFileAttr DILexicalBlockAttr::getFile() const {
  return getImpl()->file;
}

unsigned DILexicalBlockAttr::getLine() const {
  return getImpl()->line;
}

unsigned DILexicalBlockAttr::getColumn() const {
  return getImpl()->column;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DILexicalBlockAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DILexicalBlockFileAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DIScopeAttr, DIFileAttr, unsigned>;
  DILexicalBlockFileAttrStorage(DIScopeAttr scope, DIFileAttr file, unsigned discriminator) : scope(std::move(scope)), file(std::move(file)), discriminator(std::move(discriminator)) {}

  KeyTy getAsKey() const {
    return KeyTy(scope, file, discriminator);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (scope == std::get<0>(tblgenKey)) && (file == std::get<1>(tblgenKey)) && (discriminator == std::get<2>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey));
  }

  static DILexicalBlockFileAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto scope = std::move(std::get<0>(tblgenKey));
    auto file = std::move(std::get<1>(tblgenKey));
    auto discriminator = std::move(std::get<2>(tblgenKey));
    return new (allocator.allocate<DILexicalBlockFileAttrStorage>()) DILexicalBlockFileAttrStorage(std::move(scope), std::move(file), std::move(discriminator));
  }

  DIScopeAttr scope;
  DIFileAttr file;
  unsigned discriminator;
};
} // namespace detail
DILexicalBlockFileAttr DILexicalBlockFileAttr::get(::mlir::MLIRContext *context, DIScopeAttr scope, DIFileAttr file, unsigned discriminator) {
  return Base::get(context, std::move(scope), std::move(file), std::move(discriminator));
}

DILexicalBlockFileAttr DILexicalBlockFileAttr::get(DIScopeAttr scope, DIFileAttr file, unsigned discriminator) {
  return Base::get(scope.getContext(), scope, file, discriminator);
}

::mlir::Attribute DILexicalBlockFileAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<unsigned> _result_discriminator;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_scope = false;
  bool _seen_file = false;
  bool _seen_discriminator = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILexicalBlockFile parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILexicalBlockFile parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_discriminator && _paramKey == "discriminator") {
        _seen_discriminator = true;

        // Parse variable 'discriminator'
        _result_discriminator = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_discriminator)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILexicalBlockFile parameter 'discriminator' which is to be a `unsigned`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_scope) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "scope";
      return {};
    }
    if (!_seen_discriminator) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "discriminator";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_scope));
  assert(::mlir::succeeded(_result_discriminator));
  return DILexicalBlockFileAttr::get(odsParser.getContext(),
      DIScopeAttr((*_result_scope)),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      unsigned((*_result_discriminator)));
}

void DILexicalBlockFileAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "scope = ";
    odsPrinter.printStrippedAttrOrType(getScope());
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "discriminator = ";
    odsPrinter.printStrippedAttrOrType(getDiscriminator());
  }
  odsPrinter << ">";
}

DIScopeAttr DILexicalBlockFileAttr::getScope() const {
  return getImpl()->scope;
}

DIFileAttr DILexicalBlockFileAttr::getFile() const {
  return getImpl()->file;
}

unsigned DILexicalBlockFileAttr::getDiscriminator() const {
  return getImpl()->discriminator;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DILexicalBlockFileAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DILocalVariableAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DIScopeAttr, StringAttr, DIFileAttr, unsigned, unsigned, unsigned, DITypeAttr, DIFlags>;
  DILocalVariableAttrStorage(DIScopeAttr scope, StringAttr name, DIFileAttr file, unsigned line, unsigned arg, unsigned alignInBits, DITypeAttr type, DIFlags flags) : scope(std::move(scope)), name(std::move(name)), file(std::move(file)), line(std::move(line)), arg(std::move(arg)), alignInBits(std::move(alignInBits)), type(std::move(type)), flags(std::move(flags)) {}

  KeyTy getAsKey() const {
    return KeyTy(scope, name, file, line, arg, alignInBits, type, flags);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (scope == std::get<0>(tblgenKey)) && (name == std::get<1>(tblgenKey)) && (file == std::get<2>(tblgenKey)) && (line == std::get<3>(tblgenKey)) && (arg == std::get<4>(tblgenKey)) && (alignInBits == std::get<5>(tblgenKey)) && (type == std::get<6>(tblgenKey)) && (flags == std::get<7>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey));
  }

  static DILocalVariableAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto scope = std::move(std::get<0>(tblgenKey));
    auto name = std::move(std::get<1>(tblgenKey));
    auto file = std::move(std::get<2>(tblgenKey));
    auto line = std::move(std::get<3>(tblgenKey));
    auto arg = std::move(std::get<4>(tblgenKey));
    auto alignInBits = std::move(std::get<5>(tblgenKey));
    auto type = std::move(std::get<6>(tblgenKey));
    auto flags = std::move(std::get<7>(tblgenKey));
    return new (allocator.allocate<DILocalVariableAttrStorage>()) DILocalVariableAttrStorage(std::move(scope), std::move(name), std::move(file), std::move(line), std::move(arg), std::move(alignInBits), std::move(type), std::move(flags));
  }

  DIScopeAttr scope;
  StringAttr name;
  DIFileAttr file;
  unsigned line;
  unsigned arg;
  unsigned alignInBits;
  DITypeAttr type;
  DIFlags flags;
};
} // namespace detail
DILocalVariableAttr DILocalVariableAttr::get(::mlir::MLIRContext *context, DIScopeAttr scope, StringAttr name, DIFileAttr file, unsigned line, unsigned arg, unsigned alignInBits, DITypeAttr type, DIFlags flags) {
  return Base::get(context, std::move(scope), std::move(name), std::move(file), std::move(line), std::move(arg), std::move(alignInBits), std::move(type), std::move(flags));
}

DILocalVariableAttr DILocalVariableAttr::get(DIScopeAttr scope, StringRef name, DIFileAttr file, unsigned line, unsigned arg, unsigned alignInBits, DITypeAttr type, DIFlags flags) {
  MLIRContext *ctx = scope.getContext();
  return Base::get(ctx, scope, StringAttr::get(ctx, name), file, line,
               arg, alignInBits, type, flags);
}

::mlir::Attribute DILocalVariableAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<unsigned> _result_line;
  ::mlir::FailureOr<unsigned> _result_arg;
  ::mlir::FailureOr<unsigned> _result_alignInBits;
  ::mlir::FailureOr<DITypeAttr> _result_type;
  ::mlir::FailureOr<DIFlags> _result_flags;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_scope = false;
  bool _seen_name = false;
  bool _seen_file = false;
  bool _seen_line = false;
  bool _seen_arg = false;
  bool _seen_alignInBits = false;
  bool _seen_type = false;
  bool _seen_flags = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'line' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_arg && _paramKey == "arg") {
        _seen_arg = true;

        // Parse variable 'arg'
        _result_arg = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_arg)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'arg' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_alignInBits && _paramKey == "alignInBits") {
        _seen_alignInBits = true;

        // Parse variable 'alignInBits'
        _result_alignInBits = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_alignInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'alignInBits' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_type && _paramKey == "type") {
        _seen_type = true;

        // Parse variable 'type'
        _result_type = ::mlir::FieldParser<DITypeAttr>::parse(odsParser);
        if (::mlir::failed(_result_type)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'type' which is to be a `DITypeAttr`");
          return {};
        }
      } else if (!_seen_flags && _paramKey == "flags") {
        _seen_flags = true;

        // Parse variable 'flags'
        _result_flags = ::mlir::FieldParser<DIFlags>::parse(odsParser);
        if (::mlir::failed(_result_flags)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILocalVariableAttr parameter 'flags' which is to be a `DIFlags`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_scope) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "scope";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_scope));
  return DILocalVariableAttr::get(odsParser.getContext(),
      DIScopeAttr((*_result_scope)),
      StringAttr((_result_name.value_or(StringAttr()))),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      unsigned((_result_line.value_or(unsigned()))),
      unsigned((_result_arg.value_or(unsigned()))),
      unsigned((_result_alignInBits.value_or(unsigned()))),
      DITypeAttr((_result_type.value_or(DITypeAttr()))),
      DIFlags((_result_flags.value_or(DIFlags()))));
}

void DILocalVariableAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "scope = ";
    odsPrinter.printStrippedAttrOrType(getScope());
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!(getLine() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "line = ";
      if (!(getLine() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getLine());
      }
    }
    if (!(getArg() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "arg = ";
      if (!(getArg() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getArg());
      }
    }
    if (!(getAlignInBits() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "alignInBits = ";
      if (!(getAlignInBits() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getAlignInBits());
      }
    }
    if (!(getType() == DITypeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "type = ";
      if (!(getType() == DITypeAttr())) {
        odsPrinter.printStrippedAttrOrType(getType());
      }
    }
    if (!(getFlags() == DIFlags())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "flags = ";
      if (!(getFlags() == DIFlags())) {
        odsPrinter.printStrippedAttrOrType(getFlags());
      }
    }
  }
  odsPrinter << ">";
}

DIScopeAttr DILocalVariableAttr::getScope() const {
  return getImpl()->scope;
}

StringAttr DILocalVariableAttr::getName() const {
  return getImpl()->name;
}

DIFileAttr DILocalVariableAttr::getFile() const {
  return getImpl()->file;
}

unsigned DILocalVariableAttr::getLine() const {
  return getImpl()->line;
}

unsigned DILocalVariableAttr::getArg() const {
  return getImpl()->arg;
}

unsigned DILocalVariableAttr::getAlignInBits() const {
  return getImpl()->alignInBits;
}

DITypeAttr DILocalVariableAttr::getType() const {
  return getImpl()->type;
}

DIFlags DILocalVariableAttr::getFlags() const {
  return getImpl()->flags;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DILocalVariableAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DISubprogramAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DistinctAttr, bool, DistinctAttr, DICompileUnitAttr, DIScopeAttr, StringAttr, StringAttr, DIFileAttr, unsigned, unsigned, DISubprogramFlags, DISubroutineTypeAttr, ::llvm::ArrayRef<DINodeAttr>>;
  DISubprogramAttrStorage(DistinctAttr recId, bool isRecSelf, DistinctAttr id, DICompileUnitAttr compileUnit, DIScopeAttr scope, StringAttr name, StringAttr linkageName, DIFileAttr file, unsigned line, unsigned scopeLine, DISubprogramFlags subprogramFlags, DISubroutineTypeAttr type, ::llvm::ArrayRef<DINodeAttr> retainedNodes) : recId(std::move(recId)), isRecSelf(std::move(isRecSelf)), id(std::move(id)), compileUnit(std::move(compileUnit)), scope(std::move(scope)), name(std::move(name)), linkageName(std::move(linkageName)), file(std::move(file)), line(std::move(line)), scopeLine(std::move(scopeLine)), subprogramFlags(std::move(subprogramFlags)), type(std::move(type)), retainedNodes(std::move(retainedNodes)) {}

  KeyTy getAsKey() const {
    return KeyTy(recId, isRecSelf, id, compileUnit, scope, name, linkageName, file, line, scopeLine, subprogramFlags, type, retainedNodes);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (recId == std::get<0>(tblgenKey)) && (isRecSelf == std::get<1>(tblgenKey)) && (id == std::get<2>(tblgenKey)) && (compileUnit == std::get<3>(tblgenKey)) && (scope == std::get<4>(tblgenKey)) && (name == std::get<5>(tblgenKey)) && (linkageName == std::get<6>(tblgenKey)) && (file == std::get<7>(tblgenKey)) && (line == std::get<8>(tblgenKey)) && (scopeLine == std::get<9>(tblgenKey)) && (subprogramFlags == std::get<10>(tblgenKey)) && (type == std::get<11>(tblgenKey)) && (::llvm::ArrayRef<DINodeAttr>(retainedNodes) == ::llvm::ArrayRef<DINodeAttr>(std::get<12>(tblgenKey)));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey), std::get<8>(tblgenKey), std::get<9>(tblgenKey), std::get<10>(tblgenKey), std::get<11>(tblgenKey), std::get<12>(tblgenKey));
  }

  static DISubprogramAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto recId = std::move(std::get<0>(tblgenKey));
    auto isRecSelf = std::move(std::get<1>(tblgenKey));
    auto id = std::move(std::get<2>(tblgenKey));
    auto compileUnit = std::move(std::get<3>(tblgenKey));
    auto scope = std::move(std::get<4>(tblgenKey));
    auto name = std::move(std::get<5>(tblgenKey));
    auto linkageName = std::move(std::get<6>(tblgenKey));
    auto file = std::move(std::get<7>(tblgenKey));
    auto line = std::move(std::get<8>(tblgenKey));
    auto scopeLine = std::move(std::get<9>(tblgenKey));
    auto subprogramFlags = std::move(std::get<10>(tblgenKey));
    auto type = std::move(std::get<11>(tblgenKey));
    auto retainedNodes = std::move(std::get<12>(tblgenKey));
    retainedNodes = allocator.copyInto(retainedNodes);
    return new (allocator.allocate<DISubprogramAttrStorage>()) DISubprogramAttrStorage(std::move(recId), std::move(isRecSelf), std::move(id), std::move(compileUnit), std::move(scope), std::move(name), std::move(linkageName), std::move(file), std::move(line), std::move(scopeLine), std::move(subprogramFlags), std::move(type), std::move(retainedNodes));
  }

  DistinctAttr recId;
  bool isRecSelf;
  DistinctAttr id;
  DICompileUnitAttr compileUnit;
  DIScopeAttr scope;
  StringAttr name;
  StringAttr linkageName;
  DIFileAttr file;
  unsigned line;
  unsigned scopeLine;
  DISubprogramFlags subprogramFlags;
  DISubroutineTypeAttr type;
  ::llvm::ArrayRef<DINodeAttr> retainedNodes;
};
} // namespace detail
DISubprogramAttr DISubprogramAttr::get(::mlir::MLIRContext *context, DistinctAttr recId, bool isRecSelf, DistinctAttr id, DICompileUnitAttr compileUnit, DIScopeAttr scope, StringAttr name, StringAttr linkageName, DIFileAttr file, unsigned line, unsigned scopeLine, DISubprogramFlags subprogramFlags, DISubroutineTypeAttr type, ::llvm::ArrayRef<DINodeAttr> retainedNodes) {
  return Base::get(context, std::move(recId), std::move(isRecSelf), std::move(id), std::move(compileUnit), std::move(scope), std::move(name), std::move(linkageName), std::move(file), std::move(line), std::move(scopeLine), std::move(subprogramFlags), std::move(type), std::move(retainedNodes));
}

DISubprogramAttr DISubprogramAttr::get(::mlir::MLIRContext *context, DistinctAttr id, DICompileUnitAttr compileUnit, DIScopeAttr scope, StringAttr name, StringAttr linkageName, DIFileAttr file, unsigned line, unsigned scopeLine, DISubprogramFlags subprogramFlags, DISubroutineTypeAttr type, ArrayRef<DINodeAttr> retainedNodes) {
  return Base::get(context, /*recId=*/nullptr, /*isRecSelf=*/false, id, compileUnit,
               scope, name, linkageName, file, line, scopeLine,
               subprogramFlags, type, retainedNodes);
}

::mlir::Attribute DISubprogramAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DistinctAttr> _result_recId;
  ::mlir::FailureOr<bool> _result_isRecSelf;
  ::mlir::FailureOr<DistinctAttr> _result_id;
  ::mlir::FailureOr<DICompileUnitAttr> _result_compileUnit;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<StringAttr> _result_linkageName;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<unsigned> _result_line;
  ::mlir::FailureOr<unsigned> _result_scopeLine;
  ::mlir::FailureOr<DISubprogramFlags> _result_subprogramFlags;
  ::mlir::FailureOr<DISubroutineTypeAttr> _result_type;
  ::mlir::FailureOr<::llvm::SmallVector<DINodeAttr>> _result_retainedNodes;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_recId = false;
  bool _seen_isRecSelf = false;
  bool _seen_id = false;
  bool _seen_compileUnit = false;
  bool _seen_scope = false;
  bool _seen_name = false;
  bool _seen_linkageName = false;
  bool _seen_file = false;
  bool _seen_line = false;
  bool _seen_scopeLine = false;
  bool _seen_subprogramFlags = false;
  bool _seen_type = false;
  bool _seen_retainedNodes = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_recId && _paramKey == "recId") {
        _seen_recId = true;

        // Parse variable 'recId'
        _result_recId = ::mlir::FieldParser<DistinctAttr>::parse(odsParser);
        if (::mlir::failed(_result_recId)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'recId' which is to be a `DistinctAttr`");
          return {};
        }
      } else if (!_seen_isRecSelf && _paramKey == "isRecSelf") {
        _seen_isRecSelf = true;

        // Parse variable 'isRecSelf'
        _result_isRecSelf = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_isRecSelf)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'isRecSelf' which is to be a `bool`");
          return {};
        }
      } else if (!_seen_id && _paramKey == "id") {
        _seen_id = true;

        // Parse variable 'id'
        _result_id = ::mlir::FieldParser<DistinctAttr>::parse(odsParser);
        if (::mlir::failed(_result_id)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'id' which is to be a `DistinctAttr`");
          return {};
        }
      } else if (!_seen_compileUnit && _paramKey == "compileUnit") {
        _seen_compileUnit = true;

        // Parse variable 'compileUnit'
        _result_compileUnit = ::mlir::FieldParser<DICompileUnitAttr>::parse(odsParser);
        if (::mlir::failed(_result_compileUnit)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'compileUnit' which is to be a `DICompileUnitAttr`");
          return {};
        }
      } else if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_linkageName && _paramKey == "linkageName") {
        _seen_linkageName = true;

        // Parse variable 'linkageName'
        _result_linkageName = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_linkageName)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'linkageName' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'line' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_scopeLine && _paramKey == "scopeLine") {
        _seen_scopeLine = true;

        // Parse variable 'scopeLine'
        _result_scopeLine = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_scopeLine)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'scopeLine' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_subprogramFlags && _paramKey == "subprogramFlags") {
        _seen_subprogramFlags = true;

        // Parse variable 'subprogramFlags'
        _result_subprogramFlags = ::mlir::FieldParser<DISubprogramFlags>::parse(odsParser);
        if (::mlir::failed(_result_subprogramFlags)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'subprogramFlags' which is to be a `DISubprogramFlags`");
          return {};
        }
      } else if (!_seen_type && _paramKey == "type") {
        _seen_type = true;

        // Parse variable 'type'
        _result_type = ::mlir::FieldParser<DISubroutineTypeAttr>::parse(odsParser);
        if (::mlir::failed(_result_type)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'type' which is to be a `DISubroutineTypeAttr`");
          return {};
        }
      } else if (!_seen_retainedNodes && _paramKey == "retainedNodes") {
        _seen_retainedNodes = true;

        // Parse variable 'retainedNodes'
        _result_retainedNodes = ::mlir::FieldParser<::llvm::SmallVector<DINodeAttr>>::parse(odsParser);
        if (::mlir::failed(_result_retainedNodes)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubprogramAttr parameter 'retainedNodes' which is to be a `::llvm::ArrayRef<DINodeAttr>`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return DISubprogramAttr::get(odsParser.getContext(),
      DistinctAttr((_result_recId.value_or(DistinctAttr()))),
      bool((_result_isRecSelf.value_or(bool()))),
      DistinctAttr((_result_id.value_or(DistinctAttr()))),
      DICompileUnitAttr((_result_compileUnit.value_or(DICompileUnitAttr()))),
      DIScopeAttr((_result_scope.value_or(DIScopeAttr()))),
      StringAttr((_result_name.value_or(StringAttr()))),
      StringAttr((_result_linkageName.value_or(StringAttr()))),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      unsigned((_result_line.value_or(unsigned()))),
      unsigned((_result_scopeLine.value_or(unsigned()))),
      DISubprogramFlags((_result_subprogramFlags.value_or(DISubprogramFlags()))),
      DISubroutineTypeAttr((_result_type.value_or(DISubroutineTypeAttr()))),
      ::llvm::ArrayRef<DINodeAttr>((_result_retainedNodes.value_or(::llvm::SmallVector<DINodeAttr>()))));
}

void DISubprogramAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getRecId() == DistinctAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "recId = ";
      if (!(getRecId() == DistinctAttr())) {
        odsPrinter.printStrippedAttrOrType(getRecId());
      }
    }
    if (!(getIsRecSelf() == bool())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "isRecSelf = ";
      if (!(getIsRecSelf() == bool())) {
        odsPrinter.printStrippedAttrOrType(getIsRecSelf());
      }
    }
    if (!(getId() == DistinctAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "id = ";
      if (!(getId() == DistinctAttr())) {
        odsPrinter.printStrippedAttrOrType(getId());
      }
    }
    if (!(getCompileUnit() == DICompileUnitAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "compileUnit = ";
      if (!(getCompileUnit() == DICompileUnitAttr())) {
        odsPrinter.printStrippedAttrOrType(getCompileUnit());
      }
    }
    if (!(getScope() == DIScopeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "scope = ";
      if (!(getScope() == DIScopeAttr())) {
        odsPrinter.printStrippedAttrOrType(getScope());
      }
    }
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getLinkageName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "linkageName = ";
      if (!(getLinkageName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getLinkageName());
      }
    }
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!(getLine() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "line = ";
      if (!(getLine() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getLine());
      }
    }
    if (!(getScopeLine() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "scopeLine = ";
      if (!(getScopeLine() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getScopeLine());
      }
    }
    if (!(getSubprogramFlags() == DISubprogramFlags())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "subprogramFlags = ";
      if (!(getSubprogramFlags() == DISubprogramFlags())) {
        odsPrinter.printStrippedAttrOrType(getSubprogramFlags());
      }
    }
    if (!(getType() == DISubroutineTypeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "type = ";
      if (!(getType() == DISubroutineTypeAttr())) {
        odsPrinter.printStrippedAttrOrType(getType());
      }
    }
    if (!(::llvm::ArrayRef<DINodeAttr>(getRetainedNodes()) == ::llvm::ArrayRef<DINodeAttr>(::llvm::SmallVector<DINodeAttr>()))) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "retainedNodes = ";
      if (!(::llvm::ArrayRef<DINodeAttr>(getRetainedNodes()) == ::llvm::ArrayRef<DINodeAttr>(::llvm::SmallVector<DINodeAttr>()))) {
        odsPrinter.printStrippedAttrOrType(getRetainedNodes());
      }
    }
  }
  odsPrinter << ">";
}

DistinctAttr DISubprogramAttr::getRecId() const {
  return getImpl()->recId;
}

bool DISubprogramAttr::getIsRecSelf() const {
  return getImpl()->isRecSelf;
}

DistinctAttr DISubprogramAttr::getId() const {
  return getImpl()->id;
}

DICompileUnitAttr DISubprogramAttr::getCompileUnit() const {
  return getImpl()->compileUnit;
}

DIScopeAttr DISubprogramAttr::getScope() const {
  return getImpl()->scope;
}

StringAttr DISubprogramAttr::getName() const {
  return getImpl()->name;
}

StringAttr DISubprogramAttr::getLinkageName() const {
  return getImpl()->linkageName;
}

DIFileAttr DISubprogramAttr::getFile() const {
  return getImpl()->file;
}

unsigned DISubprogramAttr::getLine() const {
  return getImpl()->line;
}

unsigned DISubprogramAttr::getScopeLine() const {
  return getImpl()->scopeLine;
}

DISubprogramFlags DISubprogramAttr::getSubprogramFlags() const {
  return getImpl()->subprogramFlags;
}

DISubroutineTypeAttr DISubprogramAttr::getType() const {
  return getImpl()->type;
}

::llvm::ArrayRef<DINodeAttr> DISubprogramAttr::getRetainedNodes() const {
  return getImpl()->retainedNodes;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DISubprogramAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIModuleAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DIFileAttr, DIScopeAttr, StringAttr, StringAttr, StringAttr, StringAttr, unsigned, bool>;
  DIModuleAttrStorage(DIFileAttr file, DIScopeAttr scope, StringAttr name, StringAttr configMacros, StringAttr includePath, StringAttr apinotes, unsigned line, bool isDecl) : file(std::move(file)), scope(std::move(scope)), name(std::move(name)), configMacros(std::move(configMacros)), includePath(std::move(includePath)), apinotes(std::move(apinotes)), line(std::move(line)), isDecl(std::move(isDecl)) {}

  KeyTy getAsKey() const {
    return KeyTy(file, scope, name, configMacros, includePath, apinotes, line, isDecl);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (file == std::get<0>(tblgenKey)) && (scope == std::get<1>(tblgenKey)) && (name == std::get<2>(tblgenKey)) && (configMacros == std::get<3>(tblgenKey)) && (includePath == std::get<4>(tblgenKey)) && (apinotes == std::get<5>(tblgenKey)) && (line == std::get<6>(tblgenKey)) && (isDecl == std::get<7>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey));
  }

  static DIModuleAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto file = std::move(std::get<0>(tblgenKey));
    auto scope = std::move(std::get<1>(tblgenKey));
    auto name = std::move(std::get<2>(tblgenKey));
    auto configMacros = std::move(std::get<3>(tblgenKey));
    auto includePath = std::move(std::get<4>(tblgenKey));
    auto apinotes = std::move(std::get<5>(tblgenKey));
    auto line = std::move(std::get<6>(tblgenKey));
    auto isDecl = std::move(std::get<7>(tblgenKey));
    return new (allocator.allocate<DIModuleAttrStorage>()) DIModuleAttrStorage(std::move(file), std::move(scope), std::move(name), std::move(configMacros), std::move(includePath), std::move(apinotes), std::move(line), std::move(isDecl));
  }

  DIFileAttr file;
  DIScopeAttr scope;
  StringAttr name;
  StringAttr configMacros;
  StringAttr includePath;
  StringAttr apinotes;
  unsigned line;
  bool isDecl;
};
} // namespace detail
DIModuleAttr DIModuleAttr::get(::mlir::MLIRContext *context, DIFileAttr file, DIScopeAttr scope, StringAttr name, StringAttr configMacros, StringAttr includePath, StringAttr apinotes, unsigned line, bool isDecl) {
  return Base::get(context, std::move(file), std::move(scope), std::move(name), std::move(configMacros), std::move(includePath), std::move(apinotes), std::move(line), std::move(isDecl));
}

::mlir::Attribute DIModuleAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<StringAttr> _result_configMacros;
  ::mlir::FailureOr<StringAttr> _result_includePath;
  ::mlir::FailureOr<StringAttr> _result_apinotes;
  ::mlir::FailureOr<unsigned> _result_line;
  ::mlir::FailureOr<bool> _result_isDecl;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_file = false;
  bool _seen_scope = false;
  bool _seen_name = false;
  bool _seen_configMacros = false;
  bool _seen_includePath = false;
  bool _seen_apinotes = false;
  bool _seen_line = false;
  bool _seen_isDecl = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_configMacros && _paramKey == "configMacros") {
        _seen_configMacros = true;

        // Parse variable 'configMacros'
        _result_configMacros = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_configMacros)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'configMacros' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_includePath && _paramKey == "includePath") {
        _seen_includePath = true;

        // Parse variable 'includePath'
        _result_includePath = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_includePath)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'includePath' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_apinotes && _paramKey == "apinotes") {
        _seen_apinotes = true;

        // Parse variable 'apinotes'
        _result_apinotes = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_apinotes)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'apinotes' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'line' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_isDecl && _paramKey == "isDecl") {
        _seen_isDecl = true;

        // Parse variable 'isDecl'
        _result_isDecl = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_isDecl)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIModuleAttr parameter 'isDecl' which is to be a `bool`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return DIModuleAttr::get(odsParser.getContext(),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      DIScopeAttr((_result_scope.value_or(DIScopeAttr()))),
      StringAttr((_result_name.value_or(StringAttr()))),
      StringAttr((_result_configMacros.value_or(StringAttr()))),
      StringAttr((_result_includePath.value_or(StringAttr()))),
      StringAttr((_result_apinotes.value_or(StringAttr()))),
      unsigned((_result_line.value_or(unsigned()))),
      bool((_result_isDecl.value_or(bool()))));
}

void DIModuleAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!(getScope() == DIScopeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "scope = ";
      if (!(getScope() == DIScopeAttr())) {
        odsPrinter.printStrippedAttrOrType(getScope());
      }
    }
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getConfigMacros() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "configMacros = ";
      if (!(getConfigMacros() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getConfigMacros());
      }
    }
    if (!(getIncludePath() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "includePath = ";
      if (!(getIncludePath() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getIncludePath());
      }
    }
    if (!(getApinotes() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "apinotes = ";
      if (!(getApinotes() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getApinotes());
      }
    }
    if (!(getLine() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "line = ";
      if (!(getLine() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getLine());
      }
    }
    if (!(getIsDecl() == bool())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "isDecl = ";
      if (!(getIsDecl() == bool())) {
        odsPrinter.printStrippedAttrOrType(getIsDecl());
      }
    }
  }
  odsPrinter << ">";
}

DIFileAttr DIModuleAttr::getFile() const {
  return getImpl()->file;
}

DIScopeAttr DIModuleAttr::getScope() const {
  return getImpl()->scope;
}

StringAttr DIModuleAttr::getName() const {
  return getImpl()->name;
}

StringAttr DIModuleAttr::getConfigMacros() const {
  return getImpl()->configMacros;
}

StringAttr DIModuleAttr::getIncludePath() const {
  return getImpl()->includePath;
}

StringAttr DIModuleAttr::getApinotes() const {
  return getImpl()->apinotes;
}

unsigned DIModuleAttr::getLine() const {
  return getImpl()->line;
}

bool DIModuleAttr::getIsDecl() const {
  return getImpl()->isDecl;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIModuleAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DINamespaceAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<StringAttr, DIScopeAttr, bool>;
  DINamespaceAttrStorage(StringAttr name, DIScopeAttr scope, bool exportSymbols) : name(std::move(name)), scope(std::move(scope)), exportSymbols(std::move(exportSymbols)) {}

  KeyTy getAsKey() const {
    return KeyTy(name, scope, exportSymbols);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (name == std::get<0>(tblgenKey)) && (scope == std::get<1>(tblgenKey)) && (exportSymbols == std::get<2>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey));
  }

  static DINamespaceAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto name = std::move(std::get<0>(tblgenKey));
    auto scope = std::move(std::get<1>(tblgenKey));
    auto exportSymbols = std::move(std::get<2>(tblgenKey));
    return new (allocator.allocate<DINamespaceAttrStorage>()) DINamespaceAttrStorage(std::move(name), std::move(scope), std::move(exportSymbols));
  }

  StringAttr name;
  DIScopeAttr scope;
  bool exportSymbols;
};
} // namespace detail
DINamespaceAttr DINamespaceAttr::get(::mlir::MLIRContext *context, StringAttr name, DIScopeAttr scope, bool exportSymbols) {
  return Base::get(context, std::move(name), std::move(scope), std::move(exportSymbols));
}

::mlir::Attribute DINamespaceAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<bool> _result_exportSymbols;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_name = false;
  bool _seen_scope = false;
  bool _seen_exportSymbols = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DINamespaceAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DINamespaceAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_exportSymbols && _paramKey == "exportSymbols") {
        _seen_exportSymbols = true;

        // Parse variable 'exportSymbols'
        _result_exportSymbols = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_exportSymbols)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DINamespaceAttr parameter 'exportSymbols' which is to be a `bool`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_exportSymbols) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "exportSymbols";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_exportSymbols));
  return DINamespaceAttr::get(odsParser.getContext(),
      StringAttr((_result_name.value_or(StringAttr()))),
      DIScopeAttr((_result_scope.value_or(DIScopeAttr()))),
      bool((*_result_exportSymbols)));
}

void DINamespaceAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getScope() == DIScopeAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "scope = ";
      if (!(getScope() == DIScopeAttr())) {
        odsPrinter.printStrippedAttrOrType(getScope());
      }
    }
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "exportSymbols = ";
    odsPrinter.printStrippedAttrOrType(getExportSymbols());
  }
  odsPrinter << ">";
}

StringAttr DINamespaceAttr::getName() const {
  return getImpl()->name;
}

DIScopeAttr DINamespaceAttr::getScope() const {
  return getImpl()->scope;
}

bool DINamespaceAttr::getExportSymbols() const {
  return getImpl()->exportSymbols;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DINamespaceAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIImportedEntityAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<unsigned, DIScopeAttr, DINodeAttr, DIFileAttr, unsigned, StringAttr, ::llvm::ArrayRef<DINodeAttr>>;
  DIImportedEntityAttrStorage(unsigned tag, DIScopeAttr scope, DINodeAttr entity, DIFileAttr file, unsigned line, StringAttr name, ::llvm::ArrayRef<DINodeAttr> elements) : tag(std::move(tag)), scope(std::move(scope)), entity(std::move(entity)), file(std::move(file)), line(std::move(line)), name(std::move(name)), elements(std::move(elements)) {}

  KeyTy getAsKey() const {
    return KeyTy(tag, scope, entity, file, line, name, elements);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (tag == std::get<0>(tblgenKey)) && (scope == std::get<1>(tblgenKey)) && (entity == std::get<2>(tblgenKey)) && (file == std::get<3>(tblgenKey)) && (line == std::get<4>(tblgenKey)) && (name == std::get<5>(tblgenKey)) && (::llvm::ArrayRef<DINodeAttr>(elements) == ::llvm::ArrayRef<DINodeAttr>(std::get<6>(tblgenKey)));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey));
  }

  static DIImportedEntityAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto tag = std::move(std::get<0>(tblgenKey));
    auto scope = std::move(std::get<1>(tblgenKey));
    auto entity = std::move(std::get<2>(tblgenKey));
    auto file = std::move(std::get<3>(tblgenKey));
    auto line = std::move(std::get<4>(tblgenKey));
    auto name = std::move(std::get<5>(tblgenKey));
    auto elements = std::move(std::get<6>(tblgenKey));
    elements = allocator.copyInto(elements);
    return new (allocator.allocate<DIImportedEntityAttrStorage>()) DIImportedEntityAttrStorage(std::move(tag), std::move(scope), std::move(entity), std::move(file), std::move(line), std::move(name), std::move(elements));
  }

  unsigned tag;
  DIScopeAttr scope;
  DINodeAttr entity;
  DIFileAttr file;
  unsigned line;
  StringAttr name;
  ::llvm::ArrayRef<DINodeAttr> elements;
};
} // namespace detail
DIImportedEntityAttr DIImportedEntityAttr::get(::mlir::MLIRContext *context, unsigned tag, DIScopeAttr scope, DINodeAttr entity, DIFileAttr file, unsigned line, StringAttr name, ::llvm::ArrayRef<DINodeAttr> elements) {
  return Base::get(context, std::move(tag), std::move(scope), std::move(entity), std::move(file), std::move(line), std::move(name), std::move(elements));
}

::mlir::Attribute DIImportedEntityAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<unsigned> _result_tag;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<DINodeAttr> _result_entity;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<unsigned> _result_line;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<::llvm::SmallVector<DINodeAttr>> _result_elements;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_tag = false;
  bool _seen_scope = false;
  bool _seen_entity = false;
  bool _seen_file = false;
  bool _seen_line = false;
  bool _seen_name = false;
  bool _seen_elements = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_tag && _paramKey == "tag") {
        _seen_tag = true;

        // Parse variable 'tag'
        _result_tag =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getTag(name);
            if (tag == llvm::dwarf::DW_TAG_invalid)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info tag name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_tag)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIImportedEntityAttr parameter 'tag' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIImportedEntityAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_entity && _paramKey == "entity") {
        _seen_entity = true;

        // Parse variable 'entity'
        _result_entity = ::mlir::FieldParser<DINodeAttr>::parse(odsParser);
        if (::mlir::failed(_result_entity)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIImportedEntityAttr parameter 'entity' which is to be a `DINodeAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIImportedEntityAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIImportedEntityAttr parameter 'line' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIImportedEntityAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_elements && _paramKey == "elements") {
        _seen_elements = true;

        // Parse variable 'elements'
        _result_elements = ::mlir::FieldParser<::llvm::SmallVector<DINodeAttr>>::parse(odsParser);
        if (::mlir::failed(_result_elements)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIImportedEntityAttr parameter 'elements' which is to be a `::llvm::ArrayRef<DINodeAttr>`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_scope) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "scope";
      return {};
    }
    if (!_seen_entity) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "entity";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_scope));
  assert(::mlir::succeeded(_result_entity));
  return DIImportedEntityAttr::get(odsParser.getContext(),
      unsigned((_result_tag.value_or(0))),
      DIScopeAttr((*_result_scope)),
      DINodeAttr((*_result_entity)),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      unsigned((_result_line.value_or(unsigned()))),
      StringAttr((_result_name.value_or(StringAttr()))),
      ::llvm::ArrayRef<DINodeAttr>((_result_elements.value_or(::llvm::SmallVector<DINodeAttr>()))));
}

void DIImportedEntityAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getTag() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "tag = ";
      if (!(getTag() == 0)) {
        odsPrinter << llvm::dwarf::TagString(getTag());
      }
    }
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "scope = ";
    odsPrinter.printStrippedAttrOrType(getScope());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "entity = ";
    odsPrinter.printStrippedAttrOrType(getEntity());
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!(getLine() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "line = ";
      if (!(getLine() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getLine());
      }
    }
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(::llvm::ArrayRef<DINodeAttr>(getElements()) == ::llvm::ArrayRef<DINodeAttr>(::llvm::SmallVector<DINodeAttr>()))) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "elements = ";
      if (!(::llvm::ArrayRef<DINodeAttr>(getElements()) == ::llvm::ArrayRef<DINodeAttr>(::llvm::SmallVector<DINodeAttr>()))) {
        odsPrinter.printStrippedAttrOrType(getElements());
      }
    }
  }
  odsPrinter << ">";
}

unsigned DIImportedEntityAttr::getTag() const {
  return getImpl()->tag;
}

DIScopeAttr DIImportedEntityAttr::getScope() const {
  return getImpl()->scope;
}

DINodeAttr DIImportedEntityAttr::getEntity() const {
  return getImpl()->entity;
}

DIFileAttr DIImportedEntityAttr::getFile() const {
  return getImpl()->file;
}

unsigned DIImportedEntityAttr::getLine() const {
  return getImpl()->line;
}

StringAttr DIImportedEntityAttr::getName() const {
  return getImpl()->name;
}

::llvm::ArrayRef<DINodeAttr> DIImportedEntityAttr::getElements() const {
  return getImpl()->elements;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIImportedEntityAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DISubrangeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<::mlir::Attribute, ::mlir::Attribute, ::mlir::Attribute, ::mlir::Attribute>;
  DISubrangeAttrStorage(::mlir::Attribute count, ::mlir::Attribute lowerBound, ::mlir::Attribute upperBound, ::mlir::Attribute stride) : count(std::move(count)), lowerBound(std::move(lowerBound)), upperBound(std::move(upperBound)), stride(std::move(stride)) {}

  KeyTy getAsKey() const {
    return KeyTy(count, lowerBound, upperBound, stride);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (count == std::get<0>(tblgenKey)) && (lowerBound == std::get<1>(tblgenKey)) && (upperBound == std::get<2>(tblgenKey)) && (stride == std::get<3>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey));
  }

  static DISubrangeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto count = std::move(std::get<0>(tblgenKey));
    auto lowerBound = std::move(std::get<1>(tblgenKey));
    auto upperBound = std::move(std::get<2>(tblgenKey));
    auto stride = std::move(std::get<3>(tblgenKey));
    return new (allocator.allocate<DISubrangeAttrStorage>()) DISubrangeAttrStorage(std::move(count), std::move(lowerBound), std::move(upperBound), std::move(stride));
  }

  ::mlir::Attribute count;
  ::mlir::Attribute lowerBound;
  ::mlir::Attribute upperBound;
  ::mlir::Attribute stride;
};
} // namespace detail
DISubrangeAttr DISubrangeAttr::get(::mlir::MLIRContext *context, ::mlir::Attribute count, ::mlir::Attribute lowerBound, ::mlir::Attribute upperBound, ::mlir::Attribute stride) {
  return Base::get(context, std::move(count), std::move(lowerBound), std::move(upperBound), std::move(stride));
}

::mlir::Attribute DISubrangeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<::mlir::Attribute> _result_count;
  ::mlir::FailureOr<::mlir::Attribute> _result_lowerBound;
  ::mlir::FailureOr<::mlir::Attribute> _result_upperBound;
  ::mlir::FailureOr<::mlir::Attribute> _result_stride;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_count = false;
  bool _seen_lowerBound = false;
  bool _seen_upperBound = false;
  bool _seen_stride = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_count && _paramKey == "count") {
        _seen_count = true;

        // Parse variable 'count'
        _result_count = ::mlir::FieldParser<::mlir::Attribute>::parse(odsParser);
        if (::mlir::failed(_result_count)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubrangeAttr parameter 'count' which is to be a `::mlir::Attribute`");
          return {};
        }
      } else if (!_seen_lowerBound && _paramKey == "lowerBound") {
        _seen_lowerBound = true;

        // Parse variable 'lowerBound'
        _result_lowerBound = ::mlir::FieldParser<::mlir::Attribute>::parse(odsParser);
        if (::mlir::failed(_result_lowerBound)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubrangeAttr parameter 'lowerBound' which is to be a `::mlir::Attribute`");
          return {};
        }
      } else if (!_seen_upperBound && _paramKey == "upperBound") {
        _seen_upperBound = true;

        // Parse variable 'upperBound'
        _result_upperBound = ::mlir::FieldParser<::mlir::Attribute>::parse(odsParser);
        if (::mlir::failed(_result_upperBound)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubrangeAttr parameter 'upperBound' which is to be a `::mlir::Attribute`");
          return {};
        }
      } else if (!_seen_stride && _paramKey == "stride") {
        _seen_stride = true;

        // Parse variable 'stride'
        _result_stride = ::mlir::FieldParser<::mlir::Attribute>::parse(odsParser);
        if (::mlir::failed(_result_stride)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubrangeAttr parameter 'stride' which is to be a `::mlir::Attribute`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return DISubrangeAttr::get(odsParser.getContext(),
      ::mlir::Attribute((_result_count.value_or(::mlir::Attribute()))),
      ::mlir::Attribute((_result_lowerBound.value_or(::mlir::Attribute()))),
      ::mlir::Attribute((_result_upperBound.value_or(::mlir::Attribute()))),
      ::mlir::Attribute((_result_stride.value_or(::mlir::Attribute()))));
}

void DISubrangeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getCount() == ::mlir::Attribute())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "count = ";
      if (!(getCount() == ::mlir::Attribute())) {
        odsPrinter.printStrippedAttrOrType(getCount());
      }
    }
    if (!(getLowerBound() == ::mlir::Attribute())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "lowerBound = ";
      if (!(getLowerBound() == ::mlir::Attribute())) {
        odsPrinter.printStrippedAttrOrType(getLowerBound());
      }
    }
    if (!(getUpperBound() == ::mlir::Attribute())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "upperBound = ";
      if (!(getUpperBound() == ::mlir::Attribute())) {
        odsPrinter.printStrippedAttrOrType(getUpperBound());
      }
    }
    if (!(getStride() == ::mlir::Attribute())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "stride = ";
      if (!(getStride() == ::mlir::Attribute())) {
        odsPrinter.printStrippedAttrOrType(getStride());
      }
    }
  }
  odsPrinter << ">";
}

::mlir::Attribute DISubrangeAttr::getCount() const {
  return getImpl()->count;
}

::mlir::Attribute DISubrangeAttr::getLowerBound() const {
  return getImpl()->lowerBound;
}

::mlir::Attribute DISubrangeAttr::getUpperBound() const {
  return getImpl()->upperBound;
}

::mlir::Attribute DISubrangeAttr::getStride() const {
  return getImpl()->stride;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DISubrangeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DISubroutineTypeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<unsigned, ::llvm::ArrayRef<DITypeAttr>>;
  DISubroutineTypeAttrStorage(unsigned callingConvention, ::llvm::ArrayRef<DITypeAttr> types) : callingConvention(std::move(callingConvention)), types(std::move(types)) {}

  KeyTy getAsKey() const {
    return KeyTy(callingConvention, types);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (callingConvention == std::get<0>(tblgenKey)) && (::llvm::ArrayRef<DITypeAttr>(types) == ::llvm::ArrayRef<DITypeAttr>(std::get<1>(tblgenKey)));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static DISubroutineTypeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto callingConvention = std::move(std::get<0>(tblgenKey));
    auto types = std::move(std::get<1>(tblgenKey));
    types = allocator.copyInto(types);
    return new (allocator.allocate<DISubroutineTypeAttrStorage>()) DISubroutineTypeAttrStorage(std::move(callingConvention), std::move(types));
  }

  unsigned callingConvention;
  ::llvm::ArrayRef<DITypeAttr> types;
};
} // namespace detail
DISubroutineTypeAttr DISubroutineTypeAttr::get(::mlir::MLIRContext *context, unsigned callingConvention, ::llvm::ArrayRef<DITypeAttr> types) {
  return Base::get(context, std::move(callingConvention), std::move(types));
}

DISubroutineTypeAttr DISubroutineTypeAttr::get(::mlir::MLIRContext *context, ArrayRef<DITypeAttr> types) {
  return Base::get(context, /*callingConvention=*/0, types);
}

::mlir::Attribute DISubroutineTypeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<unsigned> _result_callingConvention;
  ::mlir::FailureOr<::llvm::SmallVector<DITypeAttr>> _result_types;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_callingConvention = false;
  bool _seen_types = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_callingConvention && _paramKey == "callingConvention") {
        _seen_callingConvention = true;

        // Parse variable 'callingConvention'
        _result_callingConvention =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getCallingConvention(name);
            if (tag == 0)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info calling convention name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_callingConvention)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubroutineTypeAttr parameter 'callingConvention' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_types && _paramKey == "types") {
        _seen_types = true;

        // Parse variable 'types'
        _result_types = ::mlir::FieldParser<::llvm::SmallVector<DITypeAttr>>::parse(odsParser);
        if (::mlir::failed(_result_types)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DISubroutineTypeAttr parameter 'types' which is to be a `::llvm::ArrayRef<DITypeAttr>`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    ::llvm::StringRef _paramKey;
    if (!odsParser.parseOptionalKeyword(&_paramKey)) {
      if (!_loop_body(_paramKey)) return {};
      while (!odsParser.parseOptionalComma()) {
        ::llvm::StringRef _paramKey;
        if (odsParser.parseKeyword(&_paramKey)) {
          odsParser.emitError(odsParser.getCurrentLocation(),
                             "expected a parameter name in struct");
          return {};
        }
        if (!_loop_body(_paramKey)) return {};
      }
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return DISubroutineTypeAttr::get(odsParser.getContext(),
      unsigned((_result_callingConvention.value_or(0))),
      ::llvm::ArrayRef<DITypeAttr>((_result_types.value_or(::llvm::SmallVector<DITypeAttr>()))));
}

void DISubroutineTypeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getCallingConvention() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "callingConvention = ";
      if (!(getCallingConvention() == 0)) {
        odsPrinter << llvm::dwarf::ConventionString(getCallingConvention());
      }
    }
    if (!(::llvm::ArrayRef<DITypeAttr>(getTypes()) == ::llvm::ArrayRef<DITypeAttr>(::llvm::SmallVector<DITypeAttr>()))) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "types = ";
      if (!(::llvm::ArrayRef<DITypeAttr>(getTypes()) == ::llvm::ArrayRef<DITypeAttr>(::llvm::SmallVector<DITypeAttr>()))) {
        odsPrinter.printStrippedAttrOrType(getTypes());
      }
    }
  }
  odsPrinter << ">";
}

unsigned DISubroutineTypeAttr::getCallingConvention() const {
  return getImpl()->callingConvention;
}

::llvm::ArrayRef<DITypeAttr> DISubroutineTypeAttr::getTypes() const {
  return getImpl()->types;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DISubroutineTypeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DILabelAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DIScopeAttr, StringAttr, DIFileAttr, unsigned>;
  DILabelAttrStorage(DIScopeAttr scope, StringAttr name, DIFileAttr file, unsigned line) : scope(std::move(scope)), name(std::move(name)), file(std::move(file)), line(std::move(line)) {}

  KeyTy getAsKey() const {
    return KeyTy(scope, name, file, line);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (scope == std::get<0>(tblgenKey)) && (name == std::get<1>(tblgenKey)) && (file == std::get<2>(tblgenKey)) && (line == std::get<3>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey));
  }

  static DILabelAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto scope = std::move(std::get<0>(tblgenKey));
    auto name = std::move(std::get<1>(tblgenKey));
    auto file = std::move(std::get<2>(tblgenKey));
    auto line = std::move(std::get<3>(tblgenKey));
    return new (allocator.allocate<DILabelAttrStorage>()) DILabelAttrStorage(std::move(scope), std::move(name), std::move(file), std::move(line));
  }

  DIScopeAttr scope;
  StringAttr name;
  DIFileAttr file;
  unsigned line;
};
} // namespace detail
DILabelAttr DILabelAttr::get(::mlir::MLIRContext *context, DIScopeAttr scope, StringAttr name, DIFileAttr file, unsigned line) {
  return Base::get(context, std::move(scope), std::move(name), std::move(file), std::move(line));
}

DILabelAttr DILabelAttr::get(DIScopeAttr scope, StringRef name, DIFileAttr file, unsigned line) {
  MLIRContext *ctx = scope.getContext();
  return Base::get(ctx, scope, StringAttr::get(ctx, name), file, line);
}

::mlir::Attribute DILabelAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DIScopeAttr> _result_scope;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<DIFileAttr> _result_file;
  ::mlir::FailureOr<unsigned> _result_line;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_scope = false;
  bool _seen_name = false;
  bool _seen_file = false;
  bool _seen_line = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_scope && _paramKey == "scope") {
        _seen_scope = true;

        // Parse variable 'scope'
        _result_scope = ::mlir::FieldParser<DIScopeAttr>::parse(odsParser);
        if (::mlir::failed(_result_scope)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILabelAttr parameter 'scope' which is to be a `DIScopeAttr`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILabelAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_file && _paramKey == "file") {
        _seen_file = true;

        // Parse variable 'file'
        _result_file = ::mlir::FieldParser<DIFileAttr>::parse(odsParser);
        if (::mlir::failed(_result_file)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILabelAttr parameter 'file' which is to be a `DIFileAttr`");
          return {};
        }
      } else if (!_seen_line && _paramKey == "line") {
        _seen_line = true;

        // Parse variable 'line'
        _result_line = ::mlir::FieldParser<unsigned>::parse(odsParser);
        if (::mlir::failed(_result_line)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DILabelAttr parameter 'line' which is to be a `unsigned`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_scope) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "scope";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_scope));
  return DILabelAttr::get(odsParser.getContext(),
      DIScopeAttr((*_result_scope)),
      StringAttr((_result_name.value_or(StringAttr()))),
      DIFileAttr((_result_file.value_or(DIFileAttr()))),
      unsigned((_result_line.value_or(unsigned()))));
}

void DILabelAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "scope = ";
    odsPrinter.printStrippedAttrOrType(getScope());
    if (!(getName() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "name = ";
      if (!(getName() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getName());
      }
    }
    if (!(getFile() == DIFileAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "file = ";
      if (!(getFile() == DIFileAttr())) {
        odsPrinter.printStrippedAttrOrType(getFile());
      }
    }
    if (!(getLine() == unsigned())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "line = ";
      if (!(getLine() == unsigned())) {
        odsPrinter.printStrippedAttrOrType(getLine());
      }
    }
  }
  odsPrinter << ">";
}

DIScopeAttr DILabelAttr::getScope() const {
  return getImpl()->scope;
}

StringAttr DILabelAttr::getName() const {
  return getImpl()->name;
}

DIFileAttr DILabelAttr::getFile() const {
  return getImpl()->file;
}

unsigned DILabelAttr::getLine() const {
  return getImpl()->line;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DILabelAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct DIStringTypeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<unsigned, StringAttr, uint64_t, uint32_t, DIVariableAttr, DIExpressionAttr, DIExpressionAttr, unsigned>;
  DIStringTypeAttrStorage(unsigned tag, StringAttr name, uint64_t sizeInBits, uint32_t alignInBits, DIVariableAttr stringLength, DIExpressionAttr stringLengthExp, DIExpressionAttr stringLocationExp, unsigned encoding) : tag(std::move(tag)), name(std::move(name)), sizeInBits(std::move(sizeInBits)), alignInBits(std::move(alignInBits)), stringLength(std::move(stringLength)), stringLengthExp(std::move(stringLengthExp)), stringLocationExp(std::move(stringLocationExp)), encoding(std::move(encoding)) {}

  KeyTy getAsKey() const {
    return KeyTy(tag, name, sizeInBits, alignInBits, stringLength, stringLengthExp, stringLocationExp, encoding);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (tag == std::get<0>(tblgenKey)) && (name == std::get<1>(tblgenKey)) && (sizeInBits == std::get<2>(tblgenKey)) && (alignInBits == std::get<3>(tblgenKey)) && (stringLength == std::get<4>(tblgenKey)) && (stringLengthExp == std::get<5>(tblgenKey)) && (stringLocationExp == std::get<6>(tblgenKey)) && (encoding == std::get<7>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey), std::get<4>(tblgenKey), std::get<5>(tblgenKey), std::get<6>(tblgenKey), std::get<7>(tblgenKey));
  }

  static DIStringTypeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto tag = std::move(std::get<0>(tblgenKey));
    auto name = std::move(std::get<1>(tblgenKey));
    auto sizeInBits = std::move(std::get<2>(tblgenKey));
    auto alignInBits = std::move(std::get<3>(tblgenKey));
    auto stringLength = std::move(std::get<4>(tblgenKey));
    auto stringLengthExp = std::move(std::get<5>(tblgenKey));
    auto stringLocationExp = std::move(std::get<6>(tblgenKey));
    auto encoding = std::move(std::get<7>(tblgenKey));
    return new (allocator.allocate<DIStringTypeAttrStorage>()) DIStringTypeAttrStorage(std::move(tag), std::move(name), std::move(sizeInBits), std::move(alignInBits), std::move(stringLength), std::move(stringLengthExp), std::move(stringLocationExp), std::move(encoding));
  }

  unsigned tag;
  StringAttr name;
  uint64_t sizeInBits;
  uint32_t alignInBits;
  DIVariableAttr stringLength;
  DIExpressionAttr stringLengthExp;
  DIExpressionAttr stringLocationExp;
  unsigned encoding;
};
} // namespace detail
DIStringTypeAttr DIStringTypeAttr::get(::mlir::MLIRContext *context, unsigned tag, StringAttr name, uint64_t sizeInBits, uint32_t alignInBits, DIVariableAttr stringLength, DIExpressionAttr stringLengthExp, DIExpressionAttr stringLocationExp, unsigned encoding) {
  return Base::get(context, std::move(tag), std::move(name), std::move(sizeInBits), std::move(alignInBits), std::move(stringLength), std::move(stringLengthExp), std::move(stringLocationExp), std::move(encoding));
}

::mlir::Attribute DIStringTypeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<unsigned> _result_tag;
  ::mlir::FailureOr<StringAttr> _result_name;
  ::mlir::FailureOr<uint64_t> _result_sizeInBits;
  ::mlir::FailureOr<uint32_t> _result_alignInBits;
  ::mlir::FailureOr<DIVariableAttr> _result_stringLength;
  ::mlir::FailureOr<DIExpressionAttr> _result_stringLengthExp;
  ::mlir::FailureOr<DIExpressionAttr> _result_stringLocationExp;
  ::mlir::FailureOr<unsigned> _result_encoding;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_tag = false;
  bool _seen_name = false;
  bool _seen_sizeInBits = false;
  bool _seen_alignInBits = false;
  bool _seen_stringLength = false;
  bool _seen_stringLengthExp = false;
  bool _seen_stringLocationExp = false;
  bool _seen_encoding = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_tag && _paramKey == "tag") {
        _seen_tag = true;

        // Parse variable 'tag'
        _result_tag =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getTag(name);
            if (tag == llvm::dwarf::DW_TAG_invalid)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info tag name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_tag)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'tag' which is to be a `unsigned`");
          return {};
        }
      } else if (!_seen_name && _paramKey == "name") {
        _seen_name = true;

        // Parse variable 'name'
        _result_name = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_name)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'name' which is to be a `StringAttr`");
          return {};
        }
      } else if (!_seen_sizeInBits && _paramKey == "sizeInBits") {
        _seen_sizeInBits = true;

        // Parse variable 'sizeInBits'
        _result_sizeInBits = ::mlir::FieldParser<uint64_t>::parse(odsParser);
        if (::mlir::failed(_result_sizeInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'sizeInBits' which is to be a `uint64_t`");
          return {};
        }
      } else if (!_seen_alignInBits && _paramKey == "alignInBits") {
        _seen_alignInBits = true;

        // Parse variable 'alignInBits'
        _result_alignInBits = ::mlir::FieldParser<uint32_t>::parse(odsParser);
        if (::mlir::failed(_result_alignInBits)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'alignInBits' which is to be a `uint32_t`");
          return {};
        }
      } else if (!_seen_stringLength && _paramKey == "stringLength") {
        _seen_stringLength = true;

        // Parse variable 'stringLength'
        _result_stringLength = ::mlir::FieldParser<DIVariableAttr>::parse(odsParser);
        if (::mlir::failed(_result_stringLength)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'stringLength' which is to be a `DIVariableAttr`");
          return {};
        }
      } else if (!_seen_stringLengthExp && _paramKey == "stringLengthExp") {
        _seen_stringLengthExp = true;

        // Parse variable 'stringLengthExp'
        _result_stringLengthExp = ::mlir::FieldParser<DIExpressionAttr>::parse(odsParser);
        if (::mlir::failed(_result_stringLengthExp)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'stringLengthExp' which is to be a `DIExpressionAttr`");
          return {};
        }
      } else if (!_seen_stringLocationExp && _paramKey == "stringLocationExp") {
        _seen_stringLocationExp = true;

        // Parse variable 'stringLocationExp'
        _result_stringLocationExp = ::mlir::FieldParser<DIExpressionAttr>::parse(odsParser);
        if (::mlir::failed(_result_stringLocationExp)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'stringLocationExp' which is to be a `DIExpressionAttr`");
          return {};
        }
      } else if (!_seen_encoding && _paramKey == "encoding") {
        _seen_encoding = true;

        // Parse variable 'encoding'
        _result_encoding =  [&]() -> FailureOr<unsigned> {
            SMLoc tagLoc = odsParser.getCurrentLocation();
            StringRef name;
            if (odsParser.parseKeyword(&name))
              return failure();

            unsigned tag = llvm::dwarf::getAttributeEncoding(name);
            if (tag == 0)
              return odsParser.emitError(tagLoc)
                << "invalid debug info debug info encoding name: " << name;
            return tag;
          }() ;
        if (::mlir::failed(_result_encoding)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_DIStringTypeAttr parameter 'encoding' which is to be a `unsigned`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_name) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "name";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_name));
  return DIStringTypeAttr::get(odsParser.getContext(),
      unsigned((_result_tag.value_or(0))),
      StringAttr((*_result_name)),
      uint64_t((_result_sizeInBits.value_or(uint64_t()))),
      uint32_t((_result_alignInBits.value_or(uint32_t()))),
      DIVariableAttr((_result_stringLength.value_or(DIVariableAttr()))),
      DIExpressionAttr((_result_stringLengthExp.value_or(DIExpressionAttr()))),
      DIExpressionAttr((_result_stringLocationExp.value_or(DIExpressionAttr()))),
      unsigned((_result_encoding.value_or(0))));
}

void DIStringTypeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!(getTag() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "tag = ";
      if (!(getTag() == 0)) {
        odsPrinter << llvm::dwarf::TagString(getTag());
      }
    }
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "name = ";
    odsPrinter.printStrippedAttrOrType(getName());
    if (!(getSizeInBits() == uint64_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "sizeInBits = ";
      if (!(getSizeInBits() == uint64_t())) {
        odsPrinter.printStrippedAttrOrType(getSizeInBits());
      }
    }
    if (!(getAlignInBits() == uint32_t())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "alignInBits = ";
      if (!(getAlignInBits() == uint32_t())) {
        odsPrinter.printStrippedAttrOrType(getAlignInBits());
      }
    }
    if (!(getStringLength() == DIVariableAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "stringLength = ";
      if (!(getStringLength() == DIVariableAttr())) {
        odsPrinter.printStrippedAttrOrType(getStringLength());
      }
    }
    if (!(getStringLengthExp() == DIExpressionAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "stringLengthExp = ";
      if (!(getStringLengthExp() == DIExpressionAttr())) {
        odsPrinter.printStrippedAttrOrType(getStringLengthExp());
      }
    }
    if (!(getStringLocationExp() == DIExpressionAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "stringLocationExp = ";
      if (!(getStringLocationExp() == DIExpressionAttr())) {
        odsPrinter.printStrippedAttrOrType(getStringLocationExp());
      }
    }
    if (!(getEncoding() == 0)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "encoding = ";
      if (!(getEncoding() == 0)) {
        odsPrinter << llvm::dwarf::AttributeEncodingString(getEncoding());
      }
    }
  }
  odsPrinter << ">";
}

unsigned DIStringTypeAttr::getTag() const {
  return getImpl()->tag;
}

StringAttr DIStringTypeAttr::getName() const {
  return getImpl()->name;
}

uint64_t DIStringTypeAttr::getSizeInBits() const {
  return getImpl()->sizeInBits;
}

uint32_t DIStringTypeAttr::getAlignInBits() const {
  return getImpl()->alignInBits;
}

DIVariableAttr DIStringTypeAttr::getStringLength() const {
  return getImpl()->stringLength;
}

DIExpressionAttr DIStringTypeAttr::getStringLengthExp() const {
  return getImpl()->stringLengthExp;
}

DIExpressionAttr DIStringTypeAttr::getStringLocationExp() const {
  return getImpl()->stringLocationExp;
}

unsigned DIStringTypeAttr::getEncoding() const {
  return getImpl()->encoding;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::DIStringTypeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct MemoryEffectsAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<ModRefInfo, ModRefInfo, ModRefInfo>;
  MemoryEffectsAttrStorage(ModRefInfo other, ModRefInfo argMem, ModRefInfo inaccessibleMem) : other(std::move(other)), argMem(std::move(argMem)), inaccessibleMem(std::move(inaccessibleMem)) {}

  KeyTy getAsKey() const {
    return KeyTy(other, argMem, inaccessibleMem);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (other == std::get<0>(tblgenKey)) && (argMem == std::get<1>(tblgenKey)) && (inaccessibleMem == std::get<2>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey));
  }

  static MemoryEffectsAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto other = std::move(std::get<0>(tblgenKey));
    auto argMem = std::move(std::get<1>(tblgenKey));
    auto inaccessibleMem = std::move(std::get<2>(tblgenKey));
    return new (allocator.allocate<MemoryEffectsAttrStorage>()) MemoryEffectsAttrStorage(std::move(other), std::move(argMem), std::move(inaccessibleMem));
  }

  ModRefInfo other;
  ModRefInfo argMem;
  ModRefInfo inaccessibleMem;
};
} // namespace detail
MemoryEffectsAttr MemoryEffectsAttr::get(::mlir::MLIRContext *context, ModRefInfo other, ModRefInfo argMem, ModRefInfo inaccessibleMem) {
  return Base::get(context, std::move(other), std::move(argMem), std::move(inaccessibleMem));
}

::mlir::Attribute MemoryEffectsAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<ModRefInfo> _result_other;
  ::mlir::FailureOr<ModRefInfo> _result_argMem;
  ::mlir::FailureOr<ModRefInfo> _result_inaccessibleMem;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_other = false;
  bool _seen_argMem = false;
  bool _seen_inaccessibleMem = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_other && _paramKey == "other") {
        _seen_other = true;

        // Parse variable 'other'
        _result_other = ::mlir::FieldParser<ModRefInfo>::parse(odsParser);
        if (::mlir::failed(_result_other)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_MemoryEffectsAttr parameter 'other' which is to be a `ModRefInfo`");
          return {};
        }
      } else if (!_seen_argMem && _paramKey == "argMem") {
        _seen_argMem = true;

        // Parse variable 'argMem'
        _result_argMem = ::mlir::FieldParser<ModRefInfo>::parse(odsParser);
        if (::mlir::failed(_result_argMem)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_MemoryEffectsAttr parameter 'argMem' which is to be a `ModRefInfo`");
          return {};
        }
      } else if (!_seen_inaccessibleMem && _paramKey == "inaccessibleMem") {
        _seen_inaccessibleMem = true;

        // Parse variable 'inaccessibleMem'
        _result_inaccessibleMem = ::mlir::FieldParser<ModRefInfo>::parse(odsParser);
        if (::mlir::failed(_result_inaccessibleMem)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_MemoryEffectsAttr parameter 'inaccessibleMem' which is to be a `ModRefInfo`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    for (unsigned odsStructIndex = 0; odsStructIndex < 3; ++odsStructIndex) {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
      if ((odsStructIndex != 3 - 1) && odsParser.parseComma())
        return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_other));
  assert(::mlir::succeeded(_result_argMem));
  assert(::mlir::succeeded(_result_inaccessibleMem));
  return MemoryEffectsAttr::get(odsParser.getContext(),
      ModRefInfo((*_result_other)),
      ModRefInfo((*_result_argMem)),
      ModRefInfo((*_result_inaccessibleMem)));
}

void MemoryEffectsAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "other = ";
    odsPrinter.printStrippedAttrOrType(getOther());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "argMem = ";
    odsPrinter.printStrippedAttrOrType(getArgMem());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "inaccessibleMem = ";
    odsPrinter.printStrippedAttrOrType(getInaccessibleMem());
  }
  odsPrinter << ">";
}

ModRefInfo MemoryEffectsAttr::getOther() const {
  return getImpl()->other;
}

ModRefInfo MemoryEffectsAttr::getArgMem() const {
  return getImpl()->argMem;
}

ModRefInfo MemoryEffectsAttr::getInaccessibleMem() const {
  return getImpl()->inaccessibleMem;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::MemoryEffectsAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct AliasScopeDomainAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DistinctAttr, StringAttr>;
  AliasScopeDomainAttrStorage(DistinctAttr id, StringAttr description) : id(std::move(id)), description(std::move(description)) {}

  KeyTy getAsKey() const {
    return KeyTy(id, description);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (id == std::get<0>(tblgenKey)) && (description == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static AliasScopeDomainAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto id = std::move(std::get<0>(tblgenKey));
    auto description = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<AliasScopeDomainAttrStorage>()) AliasScopeDomainAttrStorage(std::move(id), std::move(description));
  }

  DistinctAttr id;
  StringAttr description;
};
} // namespace detail
AliasScopeDomainAttr AliasScopeDomainAttr::get(::mlir::MLIRContext *context, DistinctAttr id, StringAttr description) {
  return Base::get(context, std::move(id), std::move(description));
}

AliasScopeDomainAttr AliasScopeDomainAttr::get(::mlir::MLIRContext *context, StringAttr description) {
  return Base::get(context, DistinctAttr::create(UnitAttr::get(context)), description);
}

::mlir::Attribute AliasScopeDomainAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DistinctAttr> _result_id;
  ::mlir::FailureOr<StringAttr> _result_description;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_id = false;
  bool _seen_description = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_id && _paramKey == "id") {
        _seen_id = true;

        // Parse variable 'id'
        _result_id = ::mlir::FieldParser<DistinctAttr>::parse(odsParser);
        if (::mlir::failed(_result_id)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_AliasScopeDomainAttr parameter 'id' which is to be a `DistinctAttr`");
          return {};
        }
      } else if (!_seen_description && _paramKey == "description") {
        _seen_description = true;

        // Parse variable 'description'
        _result_description = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_description)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_AliasScopeDomainAttr parameter 'description' which is to be a `StringAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_id) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "id";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_id));
  return AliasScopeDomainAttr::get(odsParser.getContext(),
      DistinctAttr((*_result_id)),
      StringAttr((_result_description.value_or(StringAttr()))));
}

void AliasScopeDomainAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "id = ";
    odsPrinter.printStrippedAttrOrType(getId());
    if (!(getDescription() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "description = ";
      if (!(getDescription() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getDescription());
      }
    }
  }
  odsPrinter << ">";
}

DistinctAttr AliasScopeDomainAttr::getId() const {
  return getImpl()->id;
}

StringAttr AliasScopeDomainAttr::getDescription() const {
  return getImpl()->description;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AliasScopeDomainAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct AliasScopeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DistinctAttr, AliasScopeDomainAttr, StringAttr>;
  AliasScopeAttrStorage(DistinctAttr id, AliasScopeDomainAttr domain, StringAttr description) : id(std::move(id)), domain(std::move(domain)), description(std::move(description)) {}

  KeyTy getAsKey() const {
    return KeyTy(id, domain, description);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (id == std::get<0>(tblgenKey)) && (domain == std::get<1>(tblgenKey)) && (description == std::get<2>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey));
  }

  static AliasScopeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto id = std::move(std::get<0>(tblgenKey));
    auto domain = std::move(std::get<1>(tblgenKey));
    auto description = std::move(std::get<2>(tblgenKey));
    return new (allocator.allocate<AliasScopeAttrStorage>()) AliasScopeAttrStorage(std::move(id), std::move(domain), std::move(description));
  }

  DistinctAttr id;
  AliasScopeDomainAttr domain;
  StringAttr description;
};
} // namespace detail
AliasScopeAttr AliasScopeAttr::get(::mlir::MLIRContext *context, DistinctAttr id, AliasScopeDomainAttr domain, StringAttr description) {
  return Base::get(context, std::move(id), std::move(domain), std::move(description));
}

AliasScopeAttr AliasScopeAttr::get(AliasScopeDomainAttr domain, StringAttr description) {
  MLIRContext *ctx = domain.getContext();
  return Base::get(ctx, DistinctAttr::create(UnitAttr::get(ctx)), domain, description);
}

::mlir::Attribute AliasScopeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DistinctAttr> _result_id;
  ::mlir::FailureOr<AliasScopeDomainAttr> _result_domain;
  ::mlir::FailureOr<StringAttr> _result_description;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_id = false;
  bool _seen_domain = false;
  bool _seen_description = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_id && _paramKey == "id") {
        _seen_id = true;

        // Parse variable 'id'
        _result_id = ::mlir::FieldParser<DistinctAttr>::parse(odsParser);
        if (::mlir::failed(_result_id)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_AliasScopeAttr parameter 'id' which is to be a `DistinctAttr`");
          return {};
        }
      } else if (!_seen_domain && _paramKey == "domain") {
        _seen_domain = true;

        // Parse variable 'domain'
        _result_domain = ::mlir::FieldParser<AliasScopeDomainAttr>::parse(odsParser);
        if (::mlir::failed(_result_domain)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_AliasScopeAttr parameter 'domain' which is to be a `AliasScopeDomainAttr`");
          return {};
        }
      } else if (!_seen_description && _paramKey == "description") {
        _seen_description = true;

        // Parse variable 'description'
        _result_description = ::mlir::FieldParser<StringAttr>::parse(odsParser);
        if (::mlir::failed(_result_description)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_AliasScopeAttr parameter 'description' which is to be a `StringAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_id) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "id";
      return {};
    }
    if (!_seen_domain) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "domain";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_id));
  assert(::mlir::succeeded(_result_domain));
  return AliasScopeAttr::get(odsParser.getContext(),
      DistinctAttr((*_result_id)),
      AliasScopeDomainAttr((*_result_domain)),
      StringAttr((_result_description.value_or(StringAttr()))));
}

void AliasScopeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "id = ";
    odsPrinter.printStrippedAttrOrType(getId());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "domain = ";
    odsPrinter.printStrippedAttrOrType(getDomain());
    if (!(getDescription() == StringAttr())) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "description = ";
      if (!(getDescription() == StringAttr())) {
        odsPrinter.printStrippedAttrOrType(getDescription());
      }
    }
  }
  odsPrinter << ">";
}

DistinctAttr AliasScopeAttr::getId() const {
  return getImpl()->id;
}

AliasScopeDomainAttr AliasScopeAttr::getDomain() const {
  return getImpl()->domain;
}

StringAttr AliasScopeAttr::getDescription() const {
  return getImpl()->description;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AliasScopeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct AccessGroupAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<DistinctAttr>;
  AccessGroupAttrStorage(DistinctAttr id) : id(std::move(id)) {}

  KeyTy getAsKey() const {
    return KeyTy(id);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (id == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static AccessGroupAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto id = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<AccessGroupAttrStorage>()) AccessGroupAttrStorage(std::move(id));
  }

  DistinctAttr id;
};
} // namespace detail
AccessGroupAttr AccessGroupAttr::get(::mlir::MLIRContext *context, DistinctAttr id) {
  return Base::get(context, std::move(id));
}

AccessGroupAttr AccessGroupAttr::get(::mlir::MLIRContext *context) {
  return Base::get(context, DistinctAttr::create(UnitAttr::get(context)));
}

::mlir::Attribute AccessGroupAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<DistinctAttr> _result_id;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_id = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_id && _paramKey == "id") {
        _seen_id = true;

        // Parse variable 'id'
        _result_id = ::mlir::FieldParser<DistinctAttr>::parse(odsParser);
        if (::mlir::failed(_result_id)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_AccessGroupAttr parameter 'id' which is to be a `DistinctAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    for (unsigned odsStructIndex = 0; odsStructIndex < 1; ++odsStructIndex) {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
      if ((odsStructIndex != 1 - 1) && odsParser.parseComma())
        return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_id));
  return AccessGroupAttr::get(odsParser.getContext(),
      DistinctAttr((*_result_id)));
}

void AccessGroupAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "id = ";
    odsPrinter.printStrippedAttrOrType(getId());
  }
  odsPrinter << ">";
}

DistinctAttr AccessGroupAttr::getId() const {
  return getImpl()->id;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AccessGroupAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct TBAARootAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<StringAttr>;
  TBAARootAttrStorage(StringAttr id) : id(std::move(id)) {}

  KeyTy getAsKey() const {
    return KeyTy(id);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (id == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static TBAARootAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto id = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<TBAARootAttrStorage>()) TBAARootAttrStorage(std::move(id));
  }

  StringAttr id;
};
} // namespace detail
TBAARootAttr TBAARootAttr::get(::mlir::MLIRContext *context, StringAttr id) {
  return Base::get(context, std::move(id));
}

::mlir::Attribute TBAARootAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<StringAttr> _result_id;
  // Parse literal '<'
  if (odsParser.parseOptionalLess()) {
  } else {
    // Parse parameter struct
    bool _seen_id = false;
    {
      const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
        // Parse literal '='
        if (odsParser.parseEqual()) return {};
        if (!_seen_id && _paramKey == "id") {
          _seen_id = true;

          // Parse variable 'id'
          _result_id = ::mlir::FieldParser<StringAttr>::parse(odsParser);
          if (::mlir::failed(_result_id)) {
            odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAARootAttr parameter 'id' which is to be a `StringAttr`");
            return {};
          }
        } else {
          odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
          return {};
        }
        return true;
      };
      ::llvm::StringRef _paramKey;
      if (!odsParser.parseOptionalKeyword(&_paramKey)) {
        if (!_loop_body(_paramKey)) return {};
        while (!odsParser.parseOptionalComma()) {
          ::llvm::StringRef _paramKey;
          if (odsParser.parseKeyword(&_paramKey)) {
            odsParser.emitError(odsParser.getCurrentLocation(),
                               "expected a parameter name in struct");
            return {};
          }
          if (!_loop_body(_paramKey)) return {};
        }
      }
    }
    // Parse literal '>'
    if (odsParser.parseGreater()) return {};
  }
  return TBAARootAttr::get(odsParser.getContext(),
      StringAttr((_result_id.value_or(StringAttr()))));
}

void TBAARootAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  if (!(getId() == StringAttr())) {
    odsPrinter << "<";
    {
      bool _firstPrinted = true;
      if (!(getId() == StringAttr())) {
        if (!_firstPrinted) odsPrinter << ", ";
        _firstPrinted = false;
        odsPrinter << "id = ";
        if (!(getId() == StringAttr())) {
          odsPrinter.printStrippedAttrOrType(getId());
        }
      }
    }
    odsPrinter << ">";
  } else {
  }
}

StringAttr TBAARootAttr::getId() const {
  return getImpl()->id;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::TBAARootAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct TBAAMemberAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<TBAANodeAttr, int64_t>;
  TBAAMemberAttrStorage(TBAANodeAttr typeDesc, int64_t offset) : typeDesc(std::move(typeDesc)), offset(std::move(offset)) {}

  KeyTy getAsKey() const {
    return KeyTy(typeDesc, offset);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (typeDesc == std::get<0>(tblgenKey)) && (offset == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static TBAAMemberAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto typeDesc = std::move(std::get<0>(tblgenKey));
    auto offset = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<TBAAMemberAttrStorage>()) TBAAMemberAttrStorage(std::move(typeDesc), std::move(offset));
  }

  TBAANodeAttr typeDesc;
  int64_t offset;
};
} // namespace detail
TBAAMemberAttr TBAAMemberAttr::get(::mlir::MLIRContext *context, TBAANodeAttr typeDesc, int64_t offset) {
  return Base::get(context, std::move(typeDesc), std::move(offset));
}

TBAAMemberAttr TBAAMemberAttr::get(TBAANodeAttr typeDesc, int64_t offset) {
  return Base::get(typeDesc.getContext(), typeDesc, offset);
}

::mlir::Attribute TBAAMemberAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<TBAANodeAttr> _result_typeDesc;
  ::mlir::FailureOr<int64_t> _result_offset;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter list

  // Parse variable 'typeDesc'
  _result_typeDesc = ::mlir::FieldParser<TBAANodeAttr>::parse(odsParser);
  if (::mlir::failed(_result_typeDesc)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAAMemberAttr parameter 'typeDesc' which is to be a `TBAANodeAttr`");
    return {};
  }
  // Parse literal ','
  if (odsParser.parseComma()) return {};

  // Parse variable 'offset'
  _result_offset = ::mlir::FieldParser<int64_t>::parse(odsParser);
  if (::mlir::failed(_result_offset)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAAMemberAttr parameter 'offset' which is to be a `int64_t`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_typeDesc));
  assert(::mlir::succeeded(_result_offset));
  return TBAAMemberAttr::get(odsParser.getContext(),
      TBAANodeAttr((*_result_typeDesc)),
      int64_t((*_result_offset)));
}

void TBAAMemberAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter.printStrippedAttrOrType(getTypeDesc());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter.printStrippedAttrOrType(getOffset());
  }
  odsPrinter << ">";
}

TBAANodeAttr TBAAMemberAttr::getTypeDesc() const {
  return getImpl()->typeDesc;
}

int64_t TBAAMemberAttr::getOffset() const {
  return getImpl()->offset;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::TBAAMemberAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct TBAATypeDescriptorAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<::llvm::StringRef, ::llvm::ArrayRef<TBAAMemberAttr>>;
  TBAATypeDescriptorAttrStorage(::llvm::StringRef id, ::llvm::ArrayRef<TBAAMemberAttr> members) : id(std::move(id)), members(std::move(members)) {}

  KeyTy getAsKey() const {
    return KeyTy(id, members);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (id == std::get<0>(tblgenKey)) && (members == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static TBAATypeDescriptorAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto id = std::move(std::get<0>(tblgenKey));
    auto members = std::move(std::get<1>(tblgenKey));
    id = allocator.copyInto(id);
    members = allocator.copyInto(members);
    return new (allocator.allocate<TBAATypeDescriptorAttrStorage>()) TBAATypeDescriptorAttrStorage(std::move(id), std::move(members));
  }

  ::llvm::StringRef id;
  ::llvm::ArrayRef<TBAAMemberAttr> members;
};
} // namespace detail
TBAATypeDescriptorAttr TBAATypeDescriptorAttr::get(::mlir::MLIRContext *context, ::llvm::StringRef id, ::llvm::ArrayRef<TBAAMemberAttr> members) {
  return Base::get(context, std::move(id), std::move(members));
}

::mlir::Attribute TBAATypeDescriptorAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<std::string> _result_id;
  ::mlir::FailureOr<::llvm::SmallVector<TBAAMemberAttr>> _result_members;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_id = false;
  bool _seen_members = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_id && _paramKey == "id") {
        _seen_id = true;

        // Parse variable 'id'
        _result_id = ::mlir::FieldParser<std::string>::parse(odsParser);
        if (::mlir::failed(_result_id)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAATypeDescriptorAttr parameter 'id' which is to be a `::llvm::StringRef`");
          return {};
        }
      } else if (!_seen_members && _paramKey == "members") {
        _seen_members = true;

        // Parse variable 'members'
        _result_members = 
            [&]() -> FailureOr<SmallVector<TBAAMemberAttr>> {
                using Result = SmallVector<TBAAMemberAttr>;
                if (odsParser.parseLBrace())
                    return failure();
                FailureOr<Result> result = FieldParser<Result>::parse(odsParser);
                if (failed(result))
                    return failure();
                if (odsParser.parseRBrace())
                    return failure();
                return result;
            }()
          ;
        if (::mlir::failed(_result_members)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAATypeDescriptorAttr parameter 'members' which is to be a `::llvm::ArrayRef<TBAAMemberAttr>`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    for (unsigned odsStructIndex = 0; odsStructIndex < 2; ++odsStructIndex) {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
      if ((odsStructIndex != 2 - 1) && odsParser.parseComma())
        return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_id));
  assert(::mlir::succeeded(_result_members));
  return TBAATypeDescriptorAttr::get(odsParser.getContext(),
      ::llvm::StringRef((*_result_id)),
      ::llvm::ArrayRef<TBAAMemberAttr>((*_result_members)));
}

void TBAATypeDescriptorAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "id = ";
    odsPrinter.printString(getId());;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "members = ";

        odsPrinter << '{';
        llvm::interleaveComma(getMembers(), odsPrinter, [&](TBAAMemberAttr attr) {
            odsPrinter.printStrippedAttrOrType(attr);
        });
        odsPrinter << '}';
      ;
  }
  odsPrinter << ">";
}

::llvm::StringRef TBAATypeDescriptorAttr::getId() const {
  return getImpl()->id;
}

::llvm::ArrayRef<TBAAMemberAttr> TBAATypeDescriptorAttr::getMembers() const {
  return getImpl()->members;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::TBAATypeDescriptorAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct TBAATagAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<TBAATypeDescriptorAttr, TBAATypeDescriptorAttr, int64_t, bool>;
  TBAATagAttrStorage(TBAATypeDescriptorAttr base_type, TBAATypeDescriptorAttr access_type, int64_t offset, bool constant) : base_type(std::move(base_type)), access_type(std::move(access_type)), offset(std::move(offset)), constant(std::move(constant)) {}

  KeyTy getAsKey() const {
    return KeyTy(base_type, access_type, offset, constant);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (base_type == std::get<0>(tblgenKey)) && (access_type == std::get<1>(tblgenKey)) && (offset == std::get<2>(tblgenKey)) && (constant == std::get<3>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey), std::get<2>(tblgenKey), std::get<3>(tblgenKey));
  }

  static TBAATagAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto base_type = std::move(std::get<0>(tblgenKey));
    auto access_type = std::move(std::get<1>(tblgenKey));
    auto offset = std::move(std::get<2>(tblgenKey));
    auto constant = std::move(std::get<3>(tblgenKey));
    return new (allocator.allocate<TBAATagAttrStorage>()) TBAATagAttrStorage(std::move(base_type), std::move(access_type), std::move(offset), std::move(constant));
  }

  TBAATypeDescriptorAttr base_type;
  TBAATypeDescriptorAttr access_type;
  int64_t offset;
  bool constant;
};
} // namespace detail
TBAATagAttr TBAATagAttr::get(::mlir::MLIRContext *context, TBAATypeDescriptorAttr base_type, TBAATypeDescriptorAttr access_type, int64_t offset, bool constant) {
  return Base::get(context, std::move(base_type), std::move(access_type), std::move(offset), std::move(constant));
}

TBAATagAttr TBAATagAttr::get(TBAATypeDescriptorAttr baseType, TBAATypeDescriptorAttr accessType, int64_t offset) {
  return Base::get(baseType.getContext(), baseType, accessType, offset,
                /*constant=*/false);
}

::mlir::Attribute TBAATagAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<TBAATypeDescriptorAttr> _result_base_type;
  ::mlir::FailureOr<TBAATypeDescriptorAttr> _result_access_type;
  ::mlir::FailureOr<int64_t> _result_offset;
  ::mlir::FailureOr<bool> _result_constant;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_base_type = false;
  bool _seen_access_type = false;
  bool _seen_offset = false;
  bool _seen_constant = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_base_type && _paramKey == "base_type") {
        _seen_base_type = true;

        // Parse variable 'base_type'
        _result_base_type = ::mlir::FieldParser<TBAATypeDescriptorAttr>::parse(odsParser);
        if (::mlir::failed(_result_base_type)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAATagAttr parameter 'base_type' which is to be a `TBAATypeDescriptorAttr`");
          return {};
        }
      } else if (!_seen_access_type && _paramKey == "access_type") {
        _seen_access_type = true;

        // Parse variable 'access_type'
        _result_access_type = ::mlir::FieldParser<TBAATypeDescriptorAttr>::parse(odsParser);
        if (::mlir::failed(_result_access_type)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAATagAttr parameter 'access_type' which is to be a `TBAATypeDescriptorAttr`");
          return {};
        }
      } else if (!_seen_offset && _paramKey == "offset") {
        _seen_offset = true;

        // Parse variable 'offset'
        _result_offset = ::mlir::FieldParser<int64_t>::parse(odsParser);
        if (::mlir::failed(_result_offset)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAATagAttr parameter 'offset' which is to be a `int64_t`");
          return {};
        }
      } else if (!_seen_constant && _paramKey == "constant") {
        _seen_constant = true;

        // Parse variable 'constant'
        _result_constant = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_constant)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TBAATagAttr parameter 'constant' which is to be a `bool`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_base_type) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "base_type";
      return {};
    }
    if (!_seen_access_type) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "access_type";
      return {};
    }
    if (!_seen_offset) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "offset";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_base_type));
  assert(::mlir::succeeded(_result_access_type));
  assert(::mlir::succeeded(_result_offset));
  return TBAATagAttr::get(odsParser.getContext(),
      TBAATypeDescriptorAttr((*_result_base_type)),
      TBAATypeDescriptorAttr((*_result_access_type)),
      int64_t((*_result_offset)),
      bool((_result_constant.value_or(false))));
}

void TBAATagAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "base_type = ";
    odsPrinter.printStrippedAttrOrType(getBaseType());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "access_type = ";
    odsPrinter.printStrippedAttrOrType(getAccessType());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "offset = ";
    odsPrinter.printStrippedAttrOrType(getOffset());
    if (!(getConstant() == false)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "constant = ";
      if (!(getConstant() == false)) {
        odsPrinter.printStrippedAttrOrType(getConstant());
      }
    }
  }
  odsPrinter << ">";
}

TBAATypeDescriptorAttr TBAATagAttr::getBaseType() const {
  return getImpl()->base_type;
}

TBAATypeDescriptorAttr TBAATagAttr::getAccessType() const {
  return getImpl()->access_type;
}

int64_t TBAATagAttr::getOffset() const {
  return getImpl()->offset;
}

bool TBAATagAttr::getConstant() const {
  return getImpl()->constant;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::TBAATagAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct ConstantRangeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<::llvm::APInt, ::llvm::APInt>;
  ConstantRangeAttrStorage(::llvm::APInt lower, ::llvm::APInt upper) : lower(std::move(lower)), upper(std::move(upper)) {}

  KeyTy getAsKey() const {
    return KeyTy(lower, upper);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (lower == std::get<0>(tblgenKey)) && (upper == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static ConstantRangeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto lower = std::move(std::get<0>(tblgenKey));
    auto upper = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<ConstantRangeAttrStorage>()) ConstantRangeAttrStorage(std::move(lower), std::move(upper));
  }

  ::llvm::APInt lower;
  ::llvm::APInt upper;
};
} // namespace detail
ConstantRangeAttr ConstantRangeAttr::get(::mlir::MLIRContext *context, ::llvm::APInt lower, ::llvm::APInt upper) {
  return Base::get(context, std::move(lower), std::move(upper));
}

ConstantRangeAttr ConstantRangeAttr::getChecked(::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, ::mlir::MLIRContext *context, ::llvm::APInt lower, ::llvm::APInt upper) {
  return Base::getChecked(emitError, context, lower, upper);
}

ConstantRangeAttr ConstantRangeAttr::get(::mlir::MLIRContext *context, uint32_t bitWidth, int64_t lower, int64_t upper) {
  return Base::get(context, ::llvm::APInt(bitWidth, lower), ::llvm::APInt(bitWidth, upper));
}

ConstantRangeAttr ConstantRangeAttr::getChecked(::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, ::mlir::MLIRContext *context, uint32_t bitWidth, int64_t lower, int64_t upper) {
  return Base::getChecked(emitError, context, ::llvm::APInt(bitWidth, lower), ::llvm::APInt(bitWidth, upper));
}

::llvm::LogicalResult ConstantRangeAttr::verifyInvariants(::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, ::llvm::APInt lower, ::llvm::APInt upper) {
  if (::mlir::failed(verify(emitError, lower, upper)))
    return ::mlir::failure();
  return ::mlir::success();
}

::llvm::APInt ConstantRangeAttr::getLower() const {
  return getImpl()->lower;
}

::llvm::APInt ConstantRangeAttr::getUpper() const {
  return getImpl()->upper;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ConstantRangeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct VScaleRangeAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<IntegerAttr, IntegerAttr>;
  VScaleRangeAttrStorage(IntegerAttr minRange, IntegerAttr maxRange) : minRange(std::move(minRange)), maxRange(std::move(maxRange)) {}

  KeyTy getAsKey() const {
    return KeyTy(minRange, maxRange);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (minRange == std::get<0>(tblgenKey)) && (maxRange == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static VScaleRangeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto minRange = std::move(std::get<0>(tblgenKey));
    auto maxRange = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<VScaleRangeAttrStorage>()) VScaleRangeAttrStorage(std::move(minRange), std::move(maxRange));
  }

  IntegerAttr minRange;
  IntegerAttr maxRange;
};
} // namespace detail
VScaleRangeAttr VScaleRangeAttr::get(::mlir::MLIRContext *context, IntegerAttr minRange, IntegerAttr maxRange) {
  return Base::get(context, std::move(minRange), std::move(maxRange));
}

::mlir::Attribute VScaleRangeAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<IntegerAttr> _result_minRange;
  ::mlir::FailureOr<IntegerAttr> _result_maxRange;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_minRange = false;
  bool _seen_maxRange = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_minRange && _paramKey == "minRange") {
        _seen_minRange = true;

        // Parse variable 'minRange'
        _result_minRange = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_minRange)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_VScaleRangeAttr parameter 'minRange' which is to be a `IntegerAttr`");
          return {};
        }
      } else if (!_seen_maxRange && _paramKey == "maxRange") {
        _seen_maxRange = true;

        // Parse variable 'maxRange'
        _result_maxRange = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
        if (::mlir::failed(_result_maxRange)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_VScaleRangeAttr parameter 'maxRange' which is to be a `IntegerAttr`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    for (unsigned odsStructIndex = 0; odsStructIndex < 2; ++odsStructIndex) {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
      if ((odsStructIndex != 2 - 1) && odsParser.parseComma())
        return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_minRange));
  assert(::mlir::succeeded(_result_maxRange));
  return VScaleRangeAttr::get(odsParser.getContext(),
      IntegerAttr((*_result_minRange)),
      IntegerAttr((*_result_maxRange)));
}

void VScaleRangeAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "minRange = ";
    odsPrinter.printStrippedAttrOrType(getMinRange());
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "maxRange = ";
    odsPrinter.printStrippedAttrOrType(getMaxRange());
  }
  odsPrinter << ">";
}

IntegerAttr VScaleRangeAttr::getMinRange() const {
  return getImpl()->minRange;
}

IntegerAttr VScaleRangeAttr::getMaxRange() const {
  return getImpl()->maxRange;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::VScaleRangeAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct TargetFeaturesAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<::llvm::ArrayRef<StringAttr>>;
  TargetFeaturesAttrStorage(::llvm::ArrayRef<StringAttr> features) : features(std::move(features)) {}

  KeyTy getAsKey() const {
    return KeyTy(features);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (::llvm::ArrayRef<StringAttr>(features) == ::llvm::ArrayRef<StringAttr>(std::get<0>(tblgenKey)));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static TargetFeaturesAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto features = std::move(std::get<0>(tblgenKey));
    features = allocator.copyInto(features);
    return new (allocator.allocate<TargetFeaturesAttrStorage>()) TargetFeaturesAttrStorage(std::move(features));
  }

  ::llvm::ArrayRef<StringAttr> features;
};
} // namespace detail
TargetFeaturesAttr TargetFeaturesAttr::get(::mlir::MLIRContext *context, ::llvm::ArrayRef<StringAttr> features) {
  return Base::get(context, std::move(features));
}

TargetFeaturesAttr TargetFeaturesAttr::getChecked(::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, ::mlir::MLIRContext *context, ::llvm::ArrayRef<StringAttr> features) {
  return Base::getChecked(emitError, context, features);
}

::llvm::LogicalResult TargetFeaturesAttr::verifyInvariants(::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, ::llvm::ArrayRef<StringAttr> features) {
  if (::mlir::failed(verify(emitError, features)))
    return ::mlir::failure();
  return ::mlir::success();
}

::mlir::Attribute TargetFeaturesAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<::llvm::SmallVector<StringAttr>> _result_features;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse literal '['
  if (odsParser.parseLSquare()) return {};
  // Parse literal ']'
  if (odsParser.parseOptionalRSquare()) {

    // Parse variable 'features'
    _result_features = ::mlir::FieldParser<::llvm::SmallVector<StringAttr>>::parse(odsParser);
    if (::mlir::failed(_result_features)) {
      odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_TargetFeaturesAttr parameter 'features' which is to be a `::llvm::ArrayRef<StringAttr>`");
      return {};
    }
    // Parse literal ']'
    if (odsParser.parseRSquare()) return {};
  } else {
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  return odsParser.getChecked<TargetFeaturesAttr>(odsLoc, odsParser.getContext(),
      ::llvm::ArrayRef<StringAttr>((_result_features.value_or(::llvm::SmallVector<StringAttr>()))));
}

void TargetFeaturesAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter << "[";
  if (!(!(::llvm::ArrayRef<StringAttr>(getFeatures()) == ::llvm::ArrayRef<StringAttr>(::llvm::SmallVector<StringAttr>())))) {
    odsPrinter << "]";
  } else {
    if (!(::llvm::ArrayRef<StringAttr>(getFeatures()) == ::llvm::ArrayRef<StringAttr>(::llvm::SmallVector<StringAttr>()))) {
      odsPrinter.printStrippedAttrOrType(getFeatures());
    }
    odsPrinter << "]";
  }
  odsPrinter << ">";
}

::llvm::ArrayRef<StringAttr> TargetFeaturesAttr::getFeatures() const {
  return getImpl()->features;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::TargetFeaturesAttr)
namespace mlir {
namespace LLVM {
} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::UndefAttr)
namespace mlir {
namespace LLVM {
} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::PoisonAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct VecTypeHintAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<TypeAttr, bool>;
  VecTypeHintAttrStorage(TypeAttr hint, bool is_signed) : hint(std::move(hint)), is_signed(std::move(is_signed)) {}

  KeyTy getAsKey() const {
    return KeyTy(hint, is_signed);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (hint == std::get<0>(tblgenKey)) && (is_signed == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static VecTypeHintAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto hint = std::move(std::get<0>(tblgenKey));
    auto is_signed = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<VecTypeHintAttrStorage>()) VecTypeHintAttrStorage(std::move(hint), std::move(is_signed));
  }

  TypeAttr hint;
  bool is_signed;
};
} // namespace detail
VecTypeHintAttr VecTypeHintAttr::get(::mlir::MLIRContext *context, TypeAttr hint, bool is_signed) {
  return Base::get(context, std::move(hint), std::move(is_signed));
}

::mlir::Attribute VecTypeHintAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<TypeAttr> _result_hint;
  ::mlir::FailureOr<bool> _result_is_signed;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};
  // Parse parameter struct
  bool _seen_hint = false;
  bool _seen_is_signed = false;
  {
    const auto _loop_body = [&](::llvm::StringRef _paramKey) -> bool {
      // Parse literal '='
      if (odsParser.parseEqual()) return {};
      if (!_seen_hint && _paramKey == "hint") {
        _seen_hint = true;

        // Parse variable 'hint'
        _result_hint = ::mlir::FieldParser<TypeAttr>::parse(odsParser);
        if (::mlir::failed(_result_hint)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_VecTypeHintAttr parameter 'hint' which is to be a `TypeAttr`");
          return {};
        }
      } else if (!_seen_is_signed && _paramKey == "is_signed") {
        _seen_is_signed = true;

        // Parse variable 'is_signed'
        _result_is_signed = ::mlir::FieldParser<bool>::parse(odsParser);
        if (::mlir::failed(_result_is_signed)) {
          odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_VecTypeHintAttr parameter 'is_signed' which is to be a `bool`");
          return {};
        }
      } else {
        odsParser.emitError(odsParser.getCurrentLocation(), "duplicate or unknown struct parameter name: ") << _paramKey;
        return {};
      }
      return true;
    };
    do {
      ::llvm::StringRef _paramKey;
      if (odsParser.parseKeyword(&_paramKey)) {
        odsParser.emitError(odsParser.getCurrentLocation(),
                           "expected a parameter name in struct");
        return {};
      }
      if (!_loop_body(_paramKey)) return {};
    } while(!odsParser.parseOptionalComma());
    if (!_seen_hint) {
      odsParser.emitError(odsParser.getCurrentLocation(), "struct is missing required parameter: ") << "hint";
      return {};
    }
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_hint));
  return VecTypeHintAttr::get(odsParser.getContext(),
      TypeAttr((*_result_hint)),
      bool((_result_is_signed.value_or(false))));
}

void VecTypeHintAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  {
    bool _firstPrinted = true;
    if (!_firstPrinted) odsPrinter << ", ";
    _firstPrinted = false;
    odsPrinter << "hint = ";
    odsPrinter.printStrippedAttrOrType(getHint());
    if (!(getIsSigned() == false)) {
      if (!_firstPrinted) odsPrinter << ", ";
      _firstPrinted = false;
      odsPrinter << "is_signed = ";
      if (!(getIsSigned() == false)) {
        odsPrinter.printStrippedAttrOrType(getIsSigned());
      }
    }
  }
  odsPrinter << ">";
}

TypeAttr VecTypeHintAttr::getHint() const {
  return getImpl()->hint;
}

bool VecTypeHintAttr::getIsSigned() const {
  return getImpl()->is_signed;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::VecTypeHintAttr)
namespace mlir {
namespace LLVM {
} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ZeroAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct TailCallKindAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<TailCallKind>;
  TailCallKindAttrStorage(TailCallKind tailCallKind) : tailCallKind(std::move(tailCallKind)) {}

  KeyTy getAsKey() const {
    return KeyTy(tailCallKind);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (tailCallKind == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static TailCallKindAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto tailCallKind = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<TailCallKindAttrStorage>()) TailCallKindAttrStorage(std::move(tailCallKind));
  }

  TailCallKind tailCallKind;
};
} // namespace detail
TailCallKindAttr TailCallKindAttr::get(::mlir::MLIRContext *context, TailCallKind tailCallKind) {
  return Base::get(context, std::move(tailCallKind));
}

::mlir::Attribute TailCallKindAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<TailCallKind> _result_tailCallKind;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'tailCallKind'
  _result_tailCallKind = ::mlir::FieldParser<TailCallKind>::parse(odsParser);
  if (::mlir::failed(_result_tailCallKind)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse TailCallKindAttr parameter 'tailCallKind' which is to be a `TailCallKind`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_tailCallKind));
  return TailCallKindAttr::get(odsParser.getContext(),
      TailCallKind((*_result_tailCallKind)));
}

void TailCallKindAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter.printStrippedAttrOrType(getTailCallKind());
  odsPrinter << ">";
}

TailCallKind TailCallKindAttr::getTailCallKind() const {
  return getImpl()->tailCallKind;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::TailCallKindAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct WorkgroupAttributionAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<IntegerAttr, TypeAttr>;
  WorkgroupAttributionAttrStorage(IntegerAttr num_elements, TypeAttr element_type) : num_elements(std::move(num_elements)), element_type(std::move(element_type)) {}

  KeyTy getAsKey() const {
    return KeyTy(num_elements, element_type);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (num_elements == std::get<0>(tblgenKey)) && (element_type == std::get<1>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey), std::get<1>(tblgenKey));
  }

  static WorkgroupAttributionAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto num_elements = std::move(std::get<0>(tblgenKey));
    auto element_type = std::move(std::get<1>(tblgenKey));
    return new (allocator.allocate<WorkgroupAttributionAttrStorage>()) WorkgroupAttributionAttrStorage(std::move(num_elements), std::move(element_type));
  }

  IntegerAttr num_elements;
  TypeAttr element_type;
};
} // namespace detail
WorkgroupAttributionAttr WorkgroupAttributionAttr::get(::mlir::MLIRContext *context, IntegerAttr num_elements, TypeAttr element_type) {
  return Base::get(context, std::move(num_elements), std::move(element_type));
}

::mlir::Attribute WorkgroupAttributionAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<IntegerAttr> _result_num_elements;
  ::mlir::FailureOr<TypeAttr> _result_element_type;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'num_elements'
  _result_num_elements = ::mlir::FieldParser<IntegerAttr>::parse(odsParser);
  if (::mlir::failed(_result_num_elements)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse WorkgroupAttributionAttr parameter 'num_elements' which is to be a `IntegerAttr`");
    return {};
  }
  // Parse literal ','
  if (odsParser.parseComma()) return {};

  // Parse variable 'element_type'
  _result_element_type = ::mlir::FieldParser<TypeAttr>::parse(odsParser);
  if (::mlir::failed(_result_element_type)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse WorkgroupAttributionAttr parameter 'element_type' which is to be a `TypeAttr`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_num_elements));
  assert(::mlir::succeeded(_result_element_type));
  return WorkgroupAttributionAttr::get(odsParser.getContext(),
      IntegerAttr((*_result_num_elements)),
      TypeAttr((*_result_element_type)));
}

void WorkgroupAttributionAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter.printStrippedAttrOrType(getNumElements());
  odsPrinter << ",";
  odsPrinter << ' ';
  odsPrinter.printStrippedAttrOrType(getElementType());
  odsPrinter << ">";
}

IntegerAttr WorkgroupAttributionAttr::getNumElements() const {
  return getImpl()->num_elements;
}

TypeAttr WorkgroupAttributionAttr::getElementType() const {
  return getImpl()->element_type;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::WorkgroupAttributionAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct IntegerOverflowFlagsAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<::mlir::LLVM::IntegerOverflowFlags>;
  IntegerOverflowFlagsAttrStorage(::mlir::LLVM::IntegerOverflowFlags value) : value(std::move(value)) {}

  KeyTy getAsKey() const {
    return KeyTy(value);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (value == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static IntegerOverflowFlagsAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto value = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<IntegerOverflowFlagsAttrStorage>()) IntegerOverflowFlagsAttrStorage(std::move(value));
  }

  ::mlir::LLVM::IntegerOverflowFlags value;
};
} // namespace detail
IntegerOverflowFlagsAttr IntegerOverflowFlagsAttr::get(::mlir::MLIRContext *context, ::mlir::LLVM::IntegerOverflowFlags value) {
  return Base::get(context, std::move(value));
}

::mlir::Attribute IntegerOverflowFlagsAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<::mlir::LLVM::IntegerOverflowFlags> _result_value;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'value'
  _result_value = [&]() -> ::mlir::FailureOr<::mlir::LLVM::IntegerOverflowFlags> {
      ::mlir::LLVM::IntegerOverflowFlags flags = {};
      auto loc = odsParser.getCurrentLocation();
      ::llvm::StringRef enumKeyword;
      do {
        if (::mlir::failed(odsParser.parseKeyword(&enumKeyword)))
          return ::mlir::failure();
        auto maybeEnum = ::mlir::LLVM::symbolizeIntegerOverflowFlags(enumKeyword);
        if (!maybeEnum) {
            return {(::llvm::LogicalResult)(odsParser.emitError(loc) << "expected " << "::mlir::LLVM::IntegerOverflowFlags" << " to be one of: " << "none" << ", " << "nsw" << ", " << "nuw")};
        }
        flags = flags | *maybeEnum;
      } while(::mlir::succeeded(odsParser.parseOptionalComma()));
      return flags;
    }();
  if (::mlir::failed(_result_value)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_IntegerOverflowFlagsAttr parameter 'value' which is to be a `::mlir::LLVM::IntegerOverflowFlags`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_value));
  return IntegerOverflowFlagsAttr::get(odsParser.getContext(),
      ::mlir::LLVM::IntegerOverflowFlags((*_result_value)));
}

void IntegerOverflowFlagsAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter << stringifyIntegerOverflowFlags(getValue());
  odsPrinter << ">";
}

::mlir::LLVM::IntegerOverflowFlags IntegerOverflowFlagsAttr::getValue() const {
  return getImpl()->value;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::IntegerOverflowFlagsAttr)
namespace mlir {
namespace LLVM {
namespace detail {
struct FastmathFlagsAttrStorage : public ::mlir::AttributeStorage {
  using KeyTy = std::tuple<::mlir::LLVM::FastmathFlags>;
  FastmathFlagsAttrStorage(::mlir::LLVM::FastmathFlags value) : value(std::move(value)) {}

  KeyTy getAsKey() const {
    return KeyTy(value);
  }

  bool operator==(const KeyTy &tblgenKey) const {
    return (value == std::get<0>(tblgenKey));
  }

  static ::llvm::hash_code hashKey(const KeyTy &tblgenKey) {
    return ::llvm::hash_combine(std::get<0>(tblgenKey));
  }

  static FastmathFlagsAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator, KeyTy &&tblgenKey) {
    auto value = std::move(std::get<0>(tblgenKey));
    return new (allocator.allocate<FastmathFlagsAttrStorage>()) FastmathFlagsAttrStorage(std::move(value));
  }

  ::mlir::LLVM::FastmathFlags value;
};
} // namespace detail
FastmathFlagsAttr FastmathFlagsAttr::get(::mlir::MLIRContext *context, ::mlir::LLVM::FastmathFlags value) {
  return Base::get(context, std::move(value));
}

::mlir::Attribute FastmathFlagsAttr::parse(::mlir::AsmParser &odsParser, ::mlir::Type odsType) {
  ::mlir::Builder odsBuilder(odsParser.getContext());
  ::llvm::SMLoc odsLoc = odsParser.getCurrentLocation();
  (void) odsLoc;
  ::mlir::FailureOr<::mlir::LLVM::FastmathFlags> _result_value;
  // Parse literal '<'
  if (odsParser.parseLess()) return {};

  // Parse variable 'value'
  _result_value = [&]() -> ::mlir::FailureOr<::mlir::LLVM::FastmathFlags> {
      ::mlir::LLVM::FastmathFlags flags = {};
      auto loc = odsParser.getCurrentLocation();
      ::llvm::StringRef enumKeyword;
      do {
        if (::mlir::failed(odsParser.parseKeyword(&enumKeyword)))
          return ::mlir::failure();
        auto maybeEnum = ::mlir::LLVM::symbolizeFastmathFlags(enumKeyword);
        if (!maybeEnum) {
            return {(::llvm::LogicalResult)(odsParser.emitError(loc) << "expected " << "::mlir::LLVM::FastmathFlags" << " to be one of: " << "none" << ", " << "nnan" << ", " << "ninf" << ", " << "nsz" << ", " << "arcp" << ", " << "contract" << ", " << "afn" << ", " << "reassoc" << ", " << "fast")};
        }
        flags = flags | *maybeEnum;
      } while(::mlir::succeeded(odsParser.parseOptionalComma()));
      return flags;
    }();
  if (::mlir::failed(_result_value)) {
    odsParser.emitError(odsParser.getCurrentLocation(), "failed to parse LLVM_FastmathFlagsAttr parameter 'value' which is to be a `::mlir::LLVM::FastmathFlags`");
    return {};
  }
  // Parse literal '>'
  if (odsParser.parseGreater()) return {};
  assert(::mlir::succeeded(_result_value));
  return FastmathFlagsAttr::get(odsParser.getContext(),
      ::mlir::LLVM::FastmathFlags((*_result_value)));
}

void FastmathFlagsAttr::print(::mlir::AsmPrinter &odsPrinter) const {
  ::mlir::Builder odsBuilder(getContext());
  odsPrinter << "<";
  odsPrinter << stringifyFastmathFlags(getValue());
  odsPrinter << ">";
}

::mlir::LLVM::FastmathFlags FastmathFlagsAttr::getValue() const {
  return getImpl()->value;
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FastmathFlagsAttr)
namespace mlir {
namespace LLVM {

/// Parse an attribute registered to this dialect.
::mlir::Attribute LLVMDialect::parseAttribute(::mlir::DialectAsmParser &parser,
                                      ::mlir::Type type) const {
  ::llvm::SMLoc typeLoc = parser.getCurrentLocation();
  ::llvm::StringRef attrTag;
  {
    ::mlir::Attribute attr;
    auto parseResult = generatedAttributeParser(parser, &attrTag, type, attr);
    if (parseResult.has_value())
      return attr;
  }
  
  parser.emitError(typeLoc) << "unknown attribute `"
      << attrTag << "` in dialect `" << getNamespace() << "`";
  return {};
}
/// Print an attribute registered to this dialect.
void LLVMDialect::printAttribute(::mlir::Attribute attr,
                         ::mlir::DialectAsmPrinter &printer) const {
  if (::mlir::succeeded(generatedAttributePrinter(attr, printer)))
    return;
  
}
} // namespace LLVM
} // namespace mlir

#endif  // GET_ATTRDEF_CLASSES

