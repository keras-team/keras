/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Declarations                                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: OpenMPOps.td                                                         *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

namespace mlir {
namespace omp {
class AtomicCaptureOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class AtomicReadOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class AtomicUpdateOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class AtomicWriteOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class BarrierOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class CancelOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class CancellationPointOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class CriticalDeclareOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class CriticalOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class DeclareReductionOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class DistributeOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class FlushOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class LoopNestOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class MapBoundsOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class MapInfoOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class MaskedOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class MasterOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class OrderedOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class OrderedRegionOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class ParallelOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class PrivateClauseOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class SectionOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class SectionsOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class SimdOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class SingleOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TargetDataOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TargetEnterDataOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TargetExitDataOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TargetOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TargetUpdateOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TaskOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TaskgroupOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TaskloopOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TaskwaitOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TaskyieldOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TeamsOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class TerminatorOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class ThreadprivateOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class WsloopOp;
} // namespace omp
} // namespace mlir
namespace mlir {
namespace omp {
class YieldOp;
} // namespace omp
} // namespace mlir
#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::AtomicCaptureOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicCaptureOpGenericAdaptorBase {
public:
  struct Properties {
    using hintTy = ::mlir::IntegerAttr;
    hintTy hint;

    auto getHint() {
      auto &propStorage = this->hint;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setHint(const ::mlir::IntegerAttr &propValue) {
      this->hint = propValue;
    }
    using memory_orderTy = ::mlir::omp::ClauseMemoryOrderKindAttr;
    memory_orderTy memory_order;

    auto getMemoryOrder() {
      auto &propStorage = this->memory_order;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(propStorage);
    }
    void setMemoryOrder(const ::mlir::omp::ClauseMemoryOrderKindAttr &propValue) {
      this->memory_order = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.hint == this->hint &&
        rhs.memory_order == this->memory_order &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AtomicCaptureOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.atomic.capture", odsAttrs.getContext());
  }

  AtomicCaptureOpGenericAdaptorBase(AtomicCaptureOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::IntegerAttr getHintAttr();
  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class AtomicCaptureOpGenericAdaptor : public detail::AtomicCaptureOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicCaptureOpGenericAdaptorBase;
public:
  AtomicCaptureOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicCaptureOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicCaptureOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AtomicCaptureOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AtomicCaptureOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AtomicCaptureOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicCaptureOp>>>
  AtomicCaptureOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicCaptureOpAdaptor : public AtomicCaptureOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicCaptureOpGenericAdaptor::AtomicCaptureOpGenericAdaptor;
  AtomicCaptureOpAdaptor(AtomicCaptureOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AtomicCaptureOp : public ::mlir::Op<AtomicCaptureOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::SingleBlockImplicitTerminator<TerminatorOp>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::accomp::AtomicCaptureOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicCaptureOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicCaptureOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("hint"), ::llvm::StringRef("memory_order")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getHintAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getHintAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getMemoryOrderAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getMemoryOrderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.atomic.capture");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::IntegerAttr getHintAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().hint);
  }

  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
  void setHintAttr(::mlir::IntegerAttr attr) {
    getProperties().hint = attr;
  }

  void setHint(::std::optional<uint64_t> attrValue);
  void setMemoryOrderAttr(::mlir::omp::ClauseMemoryOrderKindAttr attr) {
    getProperties().memory_order = attr;
  }

  void setMemoryOrder(::std::optional<::mlir::omp::ClauseMemoryOrderKind> attrValue);
  ::mlir::Attribute removeHintAttr() {
      auto &attr = getProperties().hint;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMemoryOrderAttr() {
      auto &attr = getProperties().memory_order;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  ::llvm::LogicalResult verifyRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Returns the `atomic.read` operation inside the region, if any.
  /// Otherwise, it returns nullptr.
  AtomicReadOp getAtomicReadOp();

  /// Returns the `atomic.write` operation inside the region, if any.
  /// Otherwise, it returns nullptr.
  AtomicWriteOp getAtomicWriteOp();

  /// Returns the `atomic.update` operation inside the region, if any.
  /// Otherwise, it returns nullptr.
  AtomicUpdateOp getAtomicUpdateOp();

};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::AtomicCaptureOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::AtomicReadOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicReadOpGenericAdaptorBase {
public:
  struct Properties {
    using element_typeTy = ::mlir::TypeAttr;
    element_typeTy element_type;

    auto getElementType() {
      auto &propStorage = this->element_type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setElementType(const ::mlir::TypeAttr &propValue) {
      this->element_type = propValue;
    }
    using hintTy = ::mlir::IntegerAttr;
    hintTy hint;

    auto getHint() {
      auto &propStorage = this->hint;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setHint(const ::mlir::IntegerAttr &propValue) {
      this->hint = propValue;
    }
    using memory_orderTy = ::mlir::omp::ClauseMemoryOrderKindAttr;
    memory_orderTy memory_order;

    auto getMemoryOrder() {
      auto &propStorage = this->memory_order;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(propStorage);
    }
    void setMemoryOrder(const ::mlir::omp::ClauseMemoryOrderKindAttr &propValue) {
      this->memory_order = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.element_type == this->element_type &&
        rhs.hint == this->hint &&
        rhs.memory_order == this->memory_order &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AtomicReadOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.atomic.read", odsAttrs.getContext());
  }

  AtomicReadOpGenericAdaptorBase(AtomicReadOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::TypeAttr getElementTypeAttr() {
    auto attr = ::llvm::cast<::mlir::TypeAttr>(getProperties().element_type);
    return attr;
  }

  ::mlir::Type getElementType();
  ::mlir::IntegerAttr getHintAttr();
  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
};
} // namespace detail
template <typename RangeT>
class AtomicReadOpGenericAdaptor : public detail::AtomicReadOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicReadOpGenericAdaptorBase;
public:
  AtomicReadOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicReadOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicReadOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AtomicReadOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AtomicReadOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AtomicReadOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicReadOp>>>
  AtomicReadOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  ValueT getV() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicReadOpAdaptor : public AtomicReadOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicReadOpGenericAdaptor::AtomicReadOpGenericAdaptor;
  AtomicReadOpAdaptor(AtomicReadOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AtomicReadOp : public ::mlir::Op<AtomicReadOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::accomp::AtomicReadOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicReadOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicReadOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_type"), ::llvm::StringRef("hint"), ::llvm::StringRef("memory_order")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getElementTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getElementTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getHintAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getHintAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getMemoryOrderAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getMemoryOrderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.atomic.read");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getX() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getV() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getXMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getVMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::TypeAttr getElementTypeAttr() {
    return ::llvm::cast<::mlir::TypeAttr>(getProperties().element_type);
  }

  ::mlir::Type getElementType();
  ::mlir::IntegerAttr getHintAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().hint);
  }

  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
  void setElementTypeAttr(::mlir::TypeAttr attr) {
    getProperties().element_type = attr;
  }

  void setElementType(::mlir::Type attrValue);
  void setHintAttr(::mlir::IntegerAttr attr) {
    getProperties().hint = attr;
  }

  void setHint(::std::optional<uint64_t> attrValue);
  void setMemoryOrderAttr(::mlir::omp::ClauseMemoryOrderKindAttr attr) {
    getProperties().memory_order = attr;
  }

  void setMemoryOrder(::std::optional<::mlir::omp::ClauseMemoryOrderKind> attrValue);
  ::mlir::Attribute removeHintAttr() {
      auto &attr = getProperties().hint;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMemoryOrderAttr() {
      auto &attr = getProperties().memory_order;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value v, ::mlir::TypeAttr element_type, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value v, ::mlir::TypeAttr element_type, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value v, ::mlir::Type element_type, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value v, ::mlir::Type element_type, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of variable operands.
  unsigned getNumVariableOperands() {
    assert(getX() && "expected 'x' operand");
    assert(getV() && "expected 'v' operand");
    return 2;
  }

  /// The i-th variable operand passed.
  Value getVariableOperand(unsigned i) {
    assert(i < 2 && "invalid index position for an operand");
    return i == 0 ? getX() : getV();
  }

};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::AtomicReadOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::AtomicUpdateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicUpdateOpGenericAdaptorBase {
public:
  struct Properties {
    using hintTy = ::mlir::IntegerAttr;
    hintTy hint;

    auto getHint() {
      auto &propStorage = this->hint;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setHint(const ::mlir::IntegerAttr &propValue) {
      this->hint = propValue;
    }
    using memory_orderTy = ::mlir::omp::ClauseMemoryOrderKindAttr;
    memory_orderTy memory_order;

    auto getMemoryOrder() {
      auto &propStorage = this->memory_order;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(propStorage);
    }
    void setMemoryOrder(const ::mlir::omp::ClauseMemoryOrderKindAttr &propValue) {
      this->memory_order = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.hint == this->hint &&
        rhs.memory_order == this->memory_order &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AtomicUpdateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.atomic.update", odsAttrs.getContext());
  }

  AtomicUpdateOpGenericAdaptorBase(AtomicUpdateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::IntegerAttr getHintAttr();
  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class AtomicUpdateOpGenericAdaptor : public detail::AtomicUpdateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicUpdateOpGenericAdaptorBase;
public:
  AtomicUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicUpdateOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AtomicUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AtomicUpdateOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AtomicUpdateOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicUpdateOp>>>
  AtomicUpdateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicUpdateOpAdaptor : public AtomicUpdateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicUpdateOpGenericAdaptor::AtomicUpdateOpGenericAdaptor;
  AtomicUpdateOpAdaptor(AtomicUpdateOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AtomicUpdateOp : public ::mlir::Op<AtomicUpdateOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::accomp::AtomicUpdateOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicUpdateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicUpdateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("hint"), ::llvm::StringRef("memory_order")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getHintAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getHintAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getMemoryOrderAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getMemoryOrderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.atomic.update");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getX() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getXMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::IntegerAttr getHintAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().hint);
  }

  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
  void setHintAttr(::mlir::IntegerAttr attr) {
    getProperties().hint = attr;
  }

  void setHint(::std::optional<uint64_t> attrValue);
  void setMemoryOrderAttr(::mlir::omp::ClauseMemoryOrderKindAttr attr) {
    getProperties().memory_order = attr;
  }

  void setMemoryOrder(::std::optional<::mlir::omp::ClauseMemoryOrderKind> attrValue);
  ::mlir::Attribute removeHintAttr() {
      auto &attr = getProperties().hint;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMemoryOrderAttr() {
      auto &attr = getProperties().memory_order;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  ::llvm::LogicalResult verifyRegions();
  static ::llvm::LogicalResult canonicalize(AtomicUpdateOp op, ::mlir::PatternRewriter &rewriter);
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of variable operands.
  unsigned getNumVariableOperands() {
    assert(getX() && "expected 'x' operand");
    return 1;
  }

  /// The i-th variable operand passed.
  Value getVariableOperand(unsigned i) {
    assert(i == 0 && "invalid index position for an operand");
    return getX();
  }

};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::AtomicUpdateOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::AtomicWriteOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicWriteOpGenericAdaptorBase {
public:
  struct Properties {
    using hintTy = ::mlir::IntegerAttr;
    hintTy hint;

    auto getHint() {
      auto &propStorage = this->hint;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setHint(const ::mlir::IntegerAttr &propValue) {
      this->hint = propValue;
    }
    using memory_orderTy = ::mlir::omp::ClauseMemoryOrderKindAttr;
    memory_orderTy memory_order;

    auto getMemoryOrder() {
      auto &propStorage = this->memory_order;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(propStorage);
    }
    void setMemoryOrder(const ::mlir::omp::ClauseMemoryOrderKindAttr &propValue) {
      this->memory_order = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.hint == this->hint &&
        rhs.memory_order == this->memory_order &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AtomicWriteOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.atomic.write", odsAttrs.getContext());
  }

  AtomicWriteOpGenericAdaptorBase(AtomicWriteOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::IntegerAttr getHintAttr();
  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
};
} // namespace detail
template <typename RangeT>
class AtomicWriteOpGenericAdaptor : public detail::AtomicWriteOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicWriteOpGenericAdaptorBase;
public:
  AtomicWriteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicWriteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicWriteOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AtomicWriteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AtomicWriteOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AtomicWriteOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicWriteOp>>>
  AtomicWriteOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  ValueT getExpr() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicWriteOpAdaptor : public AtomicWriteOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicWriteOpGenericAdaptor::AtomicWriteOpGenericAdaptor;
  AtomicWriteOpAdaptor(AtomicWriteOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AtomicWriteOp : public ::mlir::Op<AtomicWriteOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::accomp::AtomicWriteOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicWriteOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicWriteOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("hint"), ::llvm::StringRef("memory_order")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getHintAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getHintAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getMemoryOrderAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getMemoryOrderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.atomic.write");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getX() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getExpr() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getXMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getExprMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::IntegerAttr getHintAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().hint);
  }

  uint64_t getHint();
  ::mlir::omp::ClauseMemoryOrderKindAttr getMemoryOrderAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseMemoryOrderKindAttr>(getProperties().memory_order);
  }

  ::std::optional<::mlir::omp::ClauseMemoryOrderKind> getMemoryOrder();
  void setHintAttr(::mlir::IntegerAttr attr) {
    getProperties().hint = attr;
  }

  void setHint(::std::optional<uint64_t> attrValue);
  void setMemoryOrderAttr(::mlir::omp::ClauseMemoryOrderKindAttr attr) {
    getProperties().memory_order = attr;
  }

  void setMemoryOrder(::std::optional<::mlir::omp::ClauseMemoryOrderKind> attrValue);
  ::mlir::Attribute removeHintAttr() {
      auto &attr = getProperties().hint;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMemoryOrderAttr() {
      auto &attr = getProperties().memory_order;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value expr, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value expr, /*optional*/::mlir::IntegerAttr hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value expr, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value expr, /*optional*/uint64_t hint, /*optional*/::mlir::omp::ClauseMemoryOrderKindAttr memory_order);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of variable operands.
  unsigned getNumVariableOperands() {
    assert(getX() && "expected address operand");
    assert(getExpr() && "expected value operand");
    return 2;
  }

  /// The i-th variable operand passed.
  Value getVariableOperand(unsigned i) {
    assert(i < 2 && "invalid index position for an operand");
    return i == 0 ? getX() : getExpr();
  }

};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::AtomicWriteOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::BarrierOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BarrierOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BarrierOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.barrier", odsAttrs.getContext());
  }

  BarrierOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class BarrierOpGenericAdaptor : public detail::BarrierOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BarrierOpGenericAdaptorBase;
public:
  BarrierOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BarrierOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BarrierOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BarrierOp, typename = std::enable_if_t<std::is_same_v<LateInst, BarrierOp>>>
  BarrierOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BarrierOpAdaptor : public BarrierOpGenericAdaptor<::mlir::ValueRange> {
public:
  using BarrierOpGenericAdaptor::BarrierOpGenericAdaptor;
  BarrierOpAdaptor(BarrierOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class BarrierOp : public ::mlir::Op<BarrierOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BarrierOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = BarrierOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.barrier");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::BarrierOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::CancelOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CancelOpGenericAdaptorBase {
public:
  struct Properties {
    using cancel_directiveTy = ::mlir::omp::ClauseCancellationConstructTypeAttr;
    cancel_directiveTy cancel_directive;

    auto getCancelDirective() {
      auto &propStorage = this->cancel_directive;
      return ::llvm::cast<::mlir::omp::ClauseCancellationConstructTypeAttr>(propStorage);
    }
    void setCancelDirective(const ::mlir::omp::ClauseCancellationConstructTypeAttr &propValue) {
      this->cancel_directive = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.cancel_directive == this->cancel_directive &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CancelOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.cancel", odsAttrs.getContext());
  }

  CancelOpGenericAdaptorBase(CancelOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::omp::ClauseCancellationConstructTypeAttr getCancelDirectiveAttr() {
    auto attr = ::llvm::cast<::mlir::omp::ClauseCancellationConstructTypeAttr>(getProperties().cancel_directive);
    return attr;
  }

  ::mlir::omp::ClauseCancellationConstructType getCancelDirective();
};
} // namespace detail
template <typename RangeT>
class CancelOpGenericAdaptor : public detail::CancelOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CancelOpGenericAdaptorBase;
public:
  CancelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CancelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CancelOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CancelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CancelOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CancelOp, typename = std::enable_if_t<std::is_same_v<LateInst, CancelOp>>>
  CancelOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CancelOpAdaptor : public CancelOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CancelOpGenericAdaptor::CancelOpGenericAdaptor;
  CancelOpAdaptor(CancelOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CancelOp : public ::mlir::Op<CancelOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CancelOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CancelOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("cancel_directive")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCancelDirectiveAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCancelDirectiveAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.cancel");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::MutableOperandRange getIfExprMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::omp::ClauseCancellationConstructTypeAttr getCancelDirectiveAttr() {
    return ::llvm::cast<::mlir::omp::ClauseCancellationConstructTypeAttr>(getProperties().cancel_directive);
  }

  ::mlir::omp::ClauseCancellationConstructType getCancelDirective();
  void setCancelDirectiveAttr(::mlir::omp::ClauseCancellationConstructTypeAttr attr) {
    getProperties().cancel_directive = attr;
  }

  void setCancelDirective(::mlir::omp::ClauseCancellationConstructType attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const CancelOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::omp::ClauseCancellationConstructTypeAttr cancel_directive, /*optional*/::mlir::Value if_expr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::omp::ClauseCancellationConstructTypeAttr cancel_directive, /*optional*/::mlir::Value if_expr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::omp::ClauseCancellationConstructType cancel_directive, /*optional*/::mlir::Value if_expr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::omp::ClauseCancellationConstructType cancel_directive, /*optional*/::mlir::Value if_expr);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::CancelOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::CancellationPointOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CancellationPointOpGenericAdaptorBase {
public:
  struct Properties {
    using cancel_directiveTy = ::mlir::omp::ClauseCancellationConstructTypeAttr;
    cancel_directiveTy cancel_directive;

    auto getCancelDirective() {
      auto &propStorage = this->cancel_directive;
      return ::llvm::cast<::mlir::omp::ClauseCancellationConstructTypeAttr>(propStorage);
    }
    void setCancelDirective(const ::mlir::omp::ClauseCancellationConstructTypeAttr &propValue) {
      this->cancel_directive = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.cancel_directive == this->cancel_directive &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CancellationPointOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.cancellation_point", odsAttrs.getContext());
  }

  CancellationPointOpGenericAdaptorBase(CancellationPointOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::omp::ClauseCancellationConstructTypeAttr getCancelDirectiveAttr() {
    auto attr = ::llvm::cast<::mlir::omp::ClauseCancellationConstructTypeAttr>(getProperties().cancel_directive);
    return attr;
  }

  ::mlir::omp::ClauseCancellationConstructType getCancelDirective();
};
} // namespace detail
template <typename RangeT>
class CancellationPointOpGenericAdaptor : public detail::CancellationPointOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CancellationPointOpGenericAdaptorBase;
public:
  CancellationPointOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CancellationPointOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CancellationPointOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CancellationPointOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CancellationPointOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CancellationPointOp, typename = std::enable_if_t<std::is_same_v<LateInst, CancellationPointOp>>>
  CancellationPointOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CancellationPointOpAdaptor : public CancellationPointOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CancellationPointOpGenericAdaptor::CancellationPointOpGenericAdaptor;
  CancellationPointOpAdaptor(CancellationPointOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CancellationPointOp : public ::mlir::Op<CancellationPointOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CancellationPointOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CancellationPointOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("cancel_directive")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCancelDirectiveAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCancelDirectiveAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.cancellation_point");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::omp::ClauseCancellationConstructTypeAttr getCancelDirectiveAttr() {
    return ::llvm::cast<::mlir::omp::ClauseCancellationConstructTypeAttr>(getProperties().cancel_directive);
  }

  ::mlir::omp::ClauseCancellationConstructType getCancelDirective();
  void setCancelDirectiveAttr(::mlir::omp::ClauseCancellationConstructTypeAttr attr) {
    getProperties().cancel_directive = attr;
  }

  void setCancelDirective(::mlir::omp::ClauseCancellationConstructType attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const CancellationPointOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::omp::ClauseCancellationConstructTypeAttr cancel_directive);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::omp::ClauseCancellationConstructTypeAttr cancel_directive);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::omp::ClauseCancellationConstructType cancel_directive);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::omp::ClauseCancellationConstructType cancel_directive);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::CancellationPointOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::CriticalDeclareOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CriticalDeclareOpGenericAdaptorBase {
public:
  struct Properties {
    using hintTy = ::mlir::IntegerAttr;
    hintTy hint;

    auto getHint() {
      auto &propStorage = this->hint;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setHint(const ::mlir::IntegerAttr &propValue) {
      this->hint = propValue;
    }
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.hint == this->hint &&
        rhs.sym_name == this->sym_name &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CriticalDeclareOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.critical.declare", odsAttrs.getContext());
  }

  CriticalDeclareOpGenericAdaptorBase(CriticalDeclareOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::StringAttr getSymNameAttr() {
    auto attr = ::llvm::cast<::mlir::StringAttr>(getProperties().sym_name);
    return attr;
  }

  ::llvm::StringRef getSymName();
  ::mlir::IntegerAttr getHintAttr();
  uint64_t getHint();
};
} // namespace detail
template <typename RangeT>
class CriticalDeclareOpGenericAdaptor : public detail::CriticalDeclareOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CriticalDeclareOpGenericAdaptorBase;
public:
  CriticalDeclareOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CriticalDeclareOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CriticalDeclareOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CriticalDeclareOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CriticalDeclareOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CriticalDeclareOp, typename = std::enable_if_t<std::is_same_v<LateInst, CriticalDeclareOp>>>
  CriticalDeclareOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CriticalDeclareOpAdaptor : public CriticalDeclareOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CriticalDeclareOpGenericAdaptor::CriticalDeclareOpGenericAdaptor;
  CriticalDeclareOpAdaptor(CriticalDeclareOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CriticalDeclareOp : public ::mlir::Op<CriticalDeclareOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::SymbolOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CriticalDeclareOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CriticalDeclareOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("hint"), ::llvm::StringRef("sym_name")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getHintAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getHintAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.critical.declare");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr() {
    return ::llvm::cast<::mlir::StringAttr>(getProperties().sym_name);
  }

  ::llvm::StringRef getSymName();
  ::mlir::IntegerAttr getHintAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().hint);
  }

  uint64_t getHint();
  void setSymNameAttr(::mlir::StringAttr attr) {
    getProperties().sym_name = attr;
  }

  void setSymName(::llvm::StringRef attrValue);
  void setHintAttr(::mlir::IntegerAttr attr) {
    getProperties().hint = attr;
  }

  void setHint(::std::optional<uint64_t> attrValue);
  ::mlir::Attribute removeHintAttr() {
      auto &attr = getProperties().hint;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const CriticalDeclareOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, /*optional*/::mlir::IntegerAttr hint);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, /*optional*/::mlir::IntegerAttr hint);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, /*optional*/uint64_t hint = 0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, /*optional*/uint64_t hint = 0);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::CriticalDeclareOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::CriticalOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CriticalOpGenericAdaptorBase {
public:
  struct Properties {
    using nameTy = ::mlir::FlatSymbolRefAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::FlatSymbolRefAttr>(propStorage);
    }
    void setName(const ::mlir::FlatSymbolRefAttr &propValue) {
      this->name = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.name == this->name &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CriticalOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.critical", odsAttrs.getContext());
  }

  CriticalOpGenericAdaptorBase(CriticalOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::FlatSymbolRefAttr getNameAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::FlatSymbolRefAttr>(getProperties().name);
    return attr;
  }

  ::std::optional< ::llvm::StringRef > getName();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class CriticalOpGenericAdaptor : public detail::CriticalOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CriticalOpGenericAdaptorBase;
public:
  CriticalOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CriticalOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CriticalOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CriticalOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CriticalOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CriticalOp, typename = std::enable_if_t<std::is_same_v<LateInst, CriticalOp>>>
  CriticalOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CriticalOpAdaptor : public CriticalOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CriticalOpGenericAdaptor::CriticalOpGenericAdaptor;
  CriticalOpAdaptor(CriticalOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CriticalOp : public ::mlir::Op<CriticalOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::SymbolUserOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CriticalOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CriticalOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("name")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.critical");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::FlatSymbolRefAttr getNameAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::FlatSymbolRefAttr>(getProperties().name);
  }

  ::std::optional< ::llvm::StringRef > getName();
  void setNameAttr(::mlir::FlatSymbolRefAttr attr) {
    getProperties().name = attr;
  }

  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr() {
      auto &attr = getProperties().name;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::FlatSymbolRefAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::FlatSymbolRefAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verifySymbolUses(::mlir::SymbolTableCollection &symbolTable);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::CriticalOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::DeclareReductionOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DeclareReductionOpGenericAdaptorBase {
public:
  struct Properties {
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    using typeTy = ::mlir::TypeAttr;
    typeTy type;

    auto getType() {
      auto &propStorage = this->type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setType(const ::mlir::TypeAttr &propValue) {
      this->type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.sym_name == this->sym_name &&
        rhs.type == this->type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DeclareReductionOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.declare_reduction", odsAttrs.getContext());
  }

  DeclareReductionOpGenericAdaptorBase(DeclareReductionOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::StringAttr getSymNameAttr() {
    auto attr = ::llvm::cast<::mlir::StringAttr>(getProperties().sym_name);
    return attr;
  }

  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr() {
    auto attr = ::llvm::cast<::mlir::TypeAttr>(getProperties().type);
    return attr;
  }

  ::mlir::Type getType();
  ::mlir::Region &getAllocRegion() {
    return *odsRegions[0];
  }

  ::mlir::Region &getInitializerRegion() {
    return *odsRegions[1];
  }

  ::mlir::Region &getReductionRegion() {
    return *odsRegions[2];
  }

  ::mlir::Region &getAtomicReductionRegion() {
    return *odsRegions[3];
  }

  ::mlir::Region &getCleanupRegion() {
    return *odsRegions[4];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class DeclareReductionOpGenericAdaptor : public detail::DeclareReductionOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DeclareReductionOpGenericAdaptorBase;
public:
  DeclareReductionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DeclareReductionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DeclareReductionOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DeclareReductionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DeclareReductionOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DeclareReductionOp, typename = std::enable_if_t<std::is_same_v<LateInst, DeclareReductionOp>>>
  DeclareReductionOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DeclareReductionOpAdaptor : public DeclareReductionOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DeclareReductionOpGenericAdaptor::DeclareReductionOpGenericAdaptor;
  DeclareReductionOpAdaptor(DeclareReductionOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DeclareReductionOp : public ::mlir::Op<DeclareReductionOp, ::mlir::OpTrait::NRegions<5>::Impl, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::accomp::RecipeInterface::Trait, ::mlir::SymbolOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DeclareReductionOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DeclareReductionOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("sym_name"), ::llvm::StringRef("type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.declare_reduction");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getAllocRegion() {
    return (*this)->getRegion(0);
  }

  ::mlir::Region &getInitializerRegion() {
    return (*this)->getRegion(1);
  }

  ::mlir::Region &getReductionRegion() {
    return (*this)->getRegion(2);
  }

  ::mlir::Region &getAtomicReductionRegion() {
    return (*this)->getRegion(3);
  }

  ::mlir::Region &getCleanupRegion() {
    return (*this)->getRegion(4);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr() {
    return ::llvm::cast<::mlir::StringAttr>(getProperties().sym_name);
  }

  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr() {
    return ::llvm::cast<::mlir::TypeAttr>(getProperties().type);
  }

  ::mlir::Type getType();
  void setSymNameAttr(::mlir::StringAttr attr) {
    getProperties().sym_name = attr;
  }

  void setSymName(::llvm::StringRef attrValue);
  void setTypeAttr(::mlir::TypeAttr attr) {
    getProperties().type = attr;
  }

  void setType(::mlir::Type attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verifyRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  PointerLikeType getAccumulatorType() {
    if (getAtomicReductionRegion().empty())
      return {};

    return cast<PointerLikeType>(getAtomicReductionRegion().front().getArgument(0).getType());
  }

  Value getInitializerMoldArg() {
    return getInitializerRegion().front().getArgument(0);
  }

  Value getInitializerAllocArg() {
    if (getAllocRegion().empty() ||
        getInitializerRegion().front().getNumArguments() != 2)
      return {nullptr};
    return getInitializerRegion().front().getArgument(1);
  }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::DeclareReductionOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::DistributeOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DistributeOpGenericAdaptorBase {
public:
  struct Properties {
    using dist_schedule_staticTy = ::mlir::UnitAttr;
    dist_schedule_staticTy dist_schedule_static;

    auto getDistScheduleStatic() {
      auto &propStorage = this->dist_schedule_static;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setDistScheduleStatic(const ::mlir::UnitAttr &propValue) {
      this->dist_schedule_static = propValue;
    }
    using orderTy = ::mlir::omp::ClauseOrderKindAttr;
    orderTy order;

    auto getOrder() {
      auto &propStorage = this->order;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(propStorage);
    }
    void setOrder(const ::mlir::omp::ClauseOrderKindAttr &propValue) {
      this->order = propValue;
    }
    using order_modTy = ::mlir::omp::OrderModifierAttr;
    order_modTy order_mod;

    auto getOrderMod() {
      auto &propStorage = this->order_mod;
      return ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(propStorage);
    }
    void setOrderMod(const ::mlir::omp::OrderModifierAttr &propValue) {
      this->order_mod = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dist_schedule_static == this->dist_schedule_static &&
        rhs.order == this->order &&
        rhs.order_mod == this->order_mod &&
        rhs.private_syms == this->private_syms &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DistributeOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.distribute", odsAttrs.getContext());
  }

  DistributeOpGenericAdaptorBase(DistributeOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::UnitAttr getDistScheduleStaticAttr();
  bool getDistScheduleStatic();
  ::mlir::omp::ClauseOrderKindAttr getOrderAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(getProperties().order);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseOrderKind> getOrder();
  ::mlir::omp::OrderModifierAttr getOrderModAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(getProperties().order_mod);
    return attr;
  }

  ::std::optional<::mlir::omp::OrderModifier> getOrderMod();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class DistributeOpGenericAdaptor : public detail::DistributeOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DistributeOpGenericAdaptorBase;
public:
  DistributeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DistributeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DistributeOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DistributeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : DistributeOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DistributeOp, typename = std::enable_if_t<std::is_same_v<LateInst, DistributeOp>>>
  DistributeOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  ValueT getDistScheduleChunkSize() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getPrivateVars() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DistributeOpAdaptor : public DistributeOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DistributeOpGenericAdaptor::DistributeOpGenericAdaptor;
  DistributeOpAdaptor(DistributeOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DistributeOp : public ::mlir::Op<DistributeOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::ComposableOpInterface::Trait, ::mlir::omp::LoopWrapperInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DistributeOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DistributeOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dist_schedule_static"), ::llvm::StringRef("order"), ::llvm::StringRef("order_mod"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDistScheduleStaticAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDistScheduleStaticAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOrderAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getOrderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOrderModAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getOrderModAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.distribute");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::TypedValue<::mlir::Type> getDistScheduleChunkSize() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(3);
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getDistScheduleChunkSizeMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getDistScheduleStaticAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().dist_schedule_static);
  }

  bool getDistScheduleStatic();
  ::mlir::omp::ClauseOrderKindAttr getOrderAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(getProperties().order);
  }

  ::std::optional<::mlir::omp::ClauseOrderKind> getOrder();
  ::mlir::omp::OrderModifierAttr getOrderModAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(getProperties().order_mod);
  }

  ::std::optional<::mlir::omp::OrderModifier> getOrderMod();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  void setDistScheduleStaticAttr(::mlir::UnitAttr attr) {
    getProperties().dist_schedule_static = attr;
  }

  void setDistScheduleStatic(bool attrValue);
  void setOrderAttr(::mlir::omp::ClauseOrderKindAttr attr) {
    getProperties().order = attr;
  }

  void setOrder(::std::optional<::mlir::omp::ClauseOrderKind> attrValue);
  void setOrderModAttr(::mlir::omp::OrderModifierAttr attr) {
    getProperties().order_mod = attr;
  }

  void setOrderMod(::std::optional<::mlir::omp::OrderModifier> attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  ::mlir::Attribute removeDistScheduleStaticAttr() {
      auto &attr = getProperties().dist_schedule_static;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeOrderAttr() {
      auto &attr = getProperties().order;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeOrderModAttr() {
      auto &attr = getProperties().order_mod;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const DistributeOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::UnitAttr dist_schedule_static, /*optional*/::mlir::Value dist_schedule_chunk_size, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::UnitAttr dist_schedule_static, /*optional*/::mlir::Value dist_schedule_chunk_size, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/bool dist_schedule_static, /*optional*/::mlir::Value dist_schedule_chunk_size, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/bool dist_schedule_static, /*optional*/::mlir::Value dist_schedule_chunk_size, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }



};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::DistributeOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::FlushOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FlushOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  FlushOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.flush", odsAttrs.getContext());
  }

  FlushOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class FlushOpGenericAdaptor : public detail::FlushOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FlushOpGenericAdaptorBase;
public:
  FlushOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FlushOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FlushOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = FlushOp, typename = std::enable_if_t<std::is_same_v<LateInst, FlushOp>>>
  FlushOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getVarList() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FlushOpAdaptor : public FlushOpGenericAdaptor<::mlir::ValueRange> {
public:
  using FlushOpGenericAdaptor::FlushOpGenericAdaptor;
  FlushOpAdaptor(FlushOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class FlushOp : public ::mlir::Op<FlushOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FlushOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = FlushOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.flush");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getVarList() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getVarListMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange varList);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
  /// The number of variable operands.
  unsigned getNumVariableOperands() {
    return getOperation()->getNumOperands();
  }
  /// The i-th variable operand passed.
  Value getVariableOperand(unsigned i) {
    return getOperand(i);
  }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::FlushOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::LoopNestOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class LoopNestOpGenericAdaptorBase {
public:
  struct Properties {
    using loop_inclusiveTy = ::mlir::UnitAttr;
    loop_inclusiveTy loop_inclusive;

    auto getLoopInclusive() {
      auto &propStorage = this->loop_inclusive;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setLoopInclusive(const ::mlir::UnitAttr &propValue) {
      this->loop_inclusive = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.loop_inclusive == this->loop_inclusive &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  LoopNestOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.loop_nest", odsAttrs.getContext());
  }

  LoopNestOpGenericAdaptorBase(LoopNestOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::UnitAttr getLoopInclusiveAttr();
  bool getLoopInclusive();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class LoopNestOpGenericAdaptor : public detail::LoopNestOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::LoopNestOpGenericAdaptorBase;
public:
  LoopNestOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  LoopNestOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : LoopNestOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  LoopNestOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : LoopNestOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = LoopNestOp, typename = std::enable_if_t<std::is_same_v<LateInst, LoopNestOp>>>
  LoopNestOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getLoopLowerBounds() {
    return getODSOperands(0);
  }

  RangeT getLoopUpperBounds() {
    return getODSOperands(1);
  }

  RangeT getLoopSteps() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class LoopNestOpAdaptor : public LoopNestOpGenericAdaptor<::mlir::ValueRange> {
public:
  using LoopNestOpGenericAdaptor::LoopNestOpGenericAdaptor;
  LoopNestOpAdaptor(LoopNestOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class LoopNestOp : public ::mlir::Op<LoopNestOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = LoopNestOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = LoopNestOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("loop_inclusive")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLoopInclusiveAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLoopInclusiveAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.loop_nest");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getLoopLowerBounds() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getLoopUpperBounds() {
    return getODSOperands(1);
  }

  ::mlir::Operation::operand_range getLoopSteps() {
    return getODSOperands(2);
  }

  ::mlir::MutableOperandRange getLoopLowerBoundsMutable();
  ::mlir::MutableOperandRange getLoopUpperBoundsMutable();
  ::mlir::MutableOperandRange getLoopStepsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getLoopInclusiveAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().loop_inclusive);
  }

  bool getLoopInclusive();
  void setLoopInclusiveAttr(::mlir::UnitAttr attr) {
    getProperties().loop_inclusive = attr;
  }

  void setLoopInclusive(bool attrValue);
  ::mlir::Attribute removeLoopInclusiveAttr() {
      auto &attr = getProperties().loop_inclusive;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const LoopNestOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange loop_lower_bounds, ::mlir::ValueRange loop_upper_bounds, ::mlir::ValueRange loop_steps, /*optional*/::mlir::UnitAttr loop_inclusive);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange loop_lower_bounds, ::mlir::ValueRange loop_upper_bounds, ::mlir::ValueRange loop_steps, /*optional*/::mlir::UnitAttr loop_inclusive);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange loop_lower_bounds, ::mlir::ValueRange loop_upper_bounds, ::mlir::ValueRange loop_steps, /*optional*/bool loop_inclusive = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange loop_lower_bounds, ::mlir::ValueRange loop_upper_bounds, ::mlir::ValueRange loop_steps, /*optional*/bool loop_inclusive = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &p);
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Returns the induction variables of the loop nest.
  ArrayRef<BlockArgument> getIVs() { return getRegion().getArguments(); }

  /// Fills a list of wrapper operations around this loop nest. Wrappers
  /// in the resulting vector will be sorted from innermost to outermost.
  void gatherWrappers(SmallVectorImpl<LoopWrapperInterface> &wrappers);

  /// Returns the number of loops in the loop nest.
  unsigned getNumLoops() { return getLoopLowerBounds().size(); }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::LoopNestOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::MapBoundsOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MapBoundsOpGenericAdaptorBase {
public:
  struct Properties {
    using stride_in_bytesTy = ::mlir::BoolAttr;
    stride_in_bytesTy stride_in_bytes;

    auto getStrideInBytes() {
      auto &propStorage = this->stride_in_bytes;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStrideInBytes(const ::mlir::BoolAttr &propValue) {
      this->stride_in_bytes = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 5>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.stride_in_bytes == this->stride_in_bytes &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  MapBoundsOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.map.bounds", odsAttrs.getContext());
  }

  MapBoundsOpGenericAdaptorBase(MapBoundsOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::BoolAttr getStrideInBytesAttr();
  bool getStrideInBytes();
};
} // namespace detail
template <typename RangeT>
class MapBoundsOpGenericAdaptor : public detail::MapBoundsOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MapBoundsOpGenericAdaptorBase;
public:
  MapBoundsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MapBoundsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MapBoundsOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  MapBoundsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : MapBoundsOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = MapBoundsOp, typename = std::enable_if_t<std::is_same_v<LateInst, MapBoundsOp>>>
  MapBoundsOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLowerBound() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getUpperBound() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getExtent() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getStride() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getStartIdx() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MapBoundsOpAdaptor : public MapBoundsOpGenericAdaptor<::mlir::ValueRange> {
public:
  using MapBoundsOpGenericAdaptor::MapBoundsOpGenericAdaptor;
  MapBoundsOpAdaptor(MapBoundsOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MapBoundsOp : public ::mlir::Op<MapBoundsOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::omp::MapBoundsType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MapBoundsOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = MapBoundsOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("stride_in_bytes"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getStrideInBytesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getStrideInBytesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.map.bounds");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLowerBound() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::Type> getUpperBound() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::Type> getExtent() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStride() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStartIdx() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::MutableOperandRange getLowerBoundMutable();
  ::mlir::MutableOperandRange getUpperBoundMutable();
  ::mlir::MutableOperandRange getExtentMutable();
  ::mlir::MutableOperandRange getStrideMutable();
  ::mlir::MutableOperandRange getStartIdxMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::MapBoundsType> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::MapBoundsType>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::BoolAttr getStrideInBytesAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().stride_in_bytes);
  }

  bool getStrideInBytes();
  void setStrideInBytesAttr(::mlir::BoolAttr attr) {
    getProperties().stride_in_bytes = attr;
  }

  void setStrideInBytes(bool attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, /*optional*/::mlir::Value lower_bound, /*optional*/::mlir::Value upper_bound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, ::mlir::BoolAttr stride_in_bytes, /*optional*/::mlir::Value start_idx);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value lower_bound, /*optional*/::mlir::Value upper_bound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, ::mlir::BoolAttr stride_in_bytes, /*optional*/::mlir::Value start_idx);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, /*optional*/::mlir::Value lower_bound, /*optional*/::mlir::Value upper_bound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, bool stride_in_bytes, /*optional*/::mlir::Value start_idx);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value lower_bound, /*optional*/::mlir::Value upper_bound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, bool stride_in_bytes, /*optional*/::mlir::Value start_idx);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of variable operands.
  unsigned getNumVariableOperands() {
    return getNumOperands();
  }

  /// The i-th variable operand passed.
  Value getVariableOperand(unsigned i) {
    return getOperands()[i];
  }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::MapBoundsOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::MapInfoOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MapInfoOpGenericAdaptorBase {
public:
  struct Properties {
    using map_capture_typeTy = ::mlir::omp::VariableCaptureKindAttr;
    map_capture_typeTy map_capture_type;

    auto getMapCaptureType() {
      auto &propStorage = this->map_capture_type;
      return ::llvm::dyn_cast_or_null<::mlir::omp::VariableCaptureKindAttr>(propStorage);
    }
    void setMapCaptureType(const ::mlir::omp::VariableCaptureKindAttr &propValue) {
      this->map_capture_type = propValue;
    }
    using map_typeTy = ::mlir::IntegerAttr;
    map_typeTy map_type;

    auto getMapType() {
      auto &propStorage = this->map_type;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setMapType(const ::mlir::IntegerAttr &propValue) {
      this->map_type = propValue;
    }
    using members_indexTy = ::mlir::DenseIntElementsAttr;
    members_indexTy members_index;

    auto getMembersIndex() {
      auto &propStorage = this->members_index;
      return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setMembersIndex(const ::mlir::DenseIntElementsAttr &propValue) {
      this->members_index = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using partial_mapTy = ::mlir::BoolAttr;
    partial_mapTy partial_map;

    auto getPartialMap() {
      auto &propStorage = this->partial_map;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setPartialMap(const ::mlir::BoolAttr &propValue) {
      this->partial_map = propValue;
    }
    using var_typeTy = ::mlir::TypeAttr;
    var_typeTy var_type;

    auto getVarType() {
      auto &propStorage = this->var_type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setVarType(const ::mlir::TypeAttr &propValue) {
      this->var_type = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.map_capture_type == this->map_capture_type &&
        rhs.map_type == this->map_type &&
        rhs.members_index == this->members_index &&
        rhs.name == this->name &&
        rhs.partial_map == this->partial_map &&
        rhs.var_type == this->var_type &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  MapInfoOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.map.info", odsAttrs.getContext());
  }

  MapInfoOpGenericAdaptorBase(MapInfoOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::TypeAttr getVarTypeAttr() {
    auto attr = ::llvm::cast<::mlir::TypeAttr>(getProperties().var_type);
    return attr;
  }

  ::mlir::Type getVarType();
  ::mlir::DenseIntElementsAttr getMembersIndexAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().members_index);
    return attr;
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getMembersIndex();
  ::mlir::IntegerAttr getMapTypeAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().map_type);
    return attr;
  }

  ::std::optional<uint64_t> getMapType();
  ::mlir::omp::VariableCaptureKindAttr getMapCaptureTypeAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::VariableCaptureKindAttr>(getProperties().map_capture_type);
    return attr;
  }

  ::std::optional<::mlir::omp::VariableCaptureKind> getMapCaptureType();
  ::mlir::StringAttr getNameAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::StringAttr>(getProperties().name);
    return attr;
  }

  ::std::optional< ::llvm::StringRef > getName();
  ::mlir::BoolAttr getPartialMapAttr();
  bool getPartialMap();
};
} // namespace detail
template <typename RangeT>
class MapInfoOpGenericAdaptor : public detail::MapInfoOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MapInfoOpGenericAdaptorBase;
public:
  MapInfoOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MapInfoOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MapInfoOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  MapInfoOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : MapInfoOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = MapInfoOp, typename = std::enable_if_t<std::is_same_v<LateInst, MapInfoOp>>>
  MapInfoOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getMembers() {
    return getODSOperands(2);
  }

  RangeT getBounds() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MapInfoOpAdaptor : public MapInfoOpGenericAdaptor<::mlir::ValueRange> {
public:
  using MapInfoOpGenericAdaptor::MapInfoOpGenericAdaptor;
  MapInfoOpAdaptor(MapInfoOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MapInfoOp : public ::mlir::Op<MapInfoOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::omp::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MapInfoOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = MapInfoOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("map_capture_type"), ::llvm::StringRef("map_type"), ::llvm::StringRef("members_index"), ::llvm::StringRef("name"), ::llvm::StringRef("partial_map"), ::llvm::StringRef("var_type"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getMapCaptureTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getMapCaptureTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getMapTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getMapTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getMembersIndexAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getMembersIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getPartialMapAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getPartialMapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getVarTypeAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getVarTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.map.info");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getVarPtr() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ::mlir::TypedValue<::mlir::omp::PointerLikeType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getMembers() {
    return getODSOperands(2);
  }

  ::mlir::Operation::operand_range getBounds() {
    return getODSOperands(3);
  }

  ::mlir::OpOperand &getVarPtrMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getMembersMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getOmpPtr() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::TypeAttr getVarTypeAttr() {
    return ::llvm::cast<::mlir::TypeAttr>(getProperties().var_type);
  }

  ::mlir::Type getVarType();
  ::mlir::DenseIntElementsAttr getMembersIndexAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().members_index);
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getMembersIndex();
  ::mlir::IntegerAttr getMapTypeAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().map_type);
  }

  ::std::optional<uint64_t> getMapType();
  ::mlir::omp::VariableCaptureKindAttr getMapCaptureTypeAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::VariableCaptureKindAttr>(getProperties().map_capture_type);
  }

  ::std::optional<::mlir::omp::VariableCaptureKind> getMapCaptureType();
  ::mlir::StringAttr getNameAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(getProperties().name);
  }

  ::std::optional< ::llvm::StringRef > getName();
  ::mlir::BoolAttr getPartialMapAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().partial_map);
  }

  bool getPartialMap();
  void setVarTypeAttr(::mlir::TypeAttr attr) {
    getProperties().var_type = attr;
  }

  void setVarType(::mlir::Type attrValue);
  void setMembersIndexAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().members_index = attr;
  }

  void setMapTypeAttr(::mlir::IntegerAttr attr) {
    getProperties().map_type = attr;
  }

  void setMapType(::std::optional<uint64_t> attrValue);
  void setMapCaptureTypeAttr(::mlir::omp::VariableCaptureKindAttr attr) {
    getProperties().map_capture_type = attr;
  }

  void setMapCaptureType(::std::optional<::mlir::omp::VariableCaptureKind> attrValue);
  void setNameAttr(::mlir::StringAttr attr) {
    getProperties().name = attr;
  }

  void setName(::std::optional<::llvm::StringRef> attrValue);
  void setPartialMapAttr(::mlir::BoolAttr attr) {
    getProperties().partial_map = attr;
  }

  void setPartialMap(bool attrValue);
  ::mlir::Attribute removeMembersIndexAttr() {
      auto &attr = getProperties().members_index;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMapTypeAttr() {
      auto &attr = getProperties().map_type;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMapCaptureTypeAttr() {
      auto &attr = getProperties().map_capture_type;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNameAttr() {
      auto &attr = getProperties().name;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type omp_ptr, ::mlir::Value var_ptr, ::mlir::TypeAttr var_type, /*optional*/::mlir::Value var_ptr_ptr, ::mlir::ValueRange members, /*optional*/::mlir::DenseIntElementsAttr members_index, ::mlir::ValueRange bounds, /*optional*/::mlir::IntegerAttr map_type, /*optional*/::mlir::omp::VariableCaptureKindAttr map_capture_type, /*optional*/::mlir::StringAttr name, ::mlir::BoolAttr partial_map);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var_ptr, ::mlir::TypeAttr var_type, /*optional*/::mlir::Value var_ptr_ptr, ::mlir::ValueRange members, /*optional*/::mlir::DenseIntElementsAttr members_index, ::mlir::ValueRange bounds, /*optional*/::mlir::IntegerAttr map_type, /*optional*/::mlir::omp::VariableCaptureKindAttr map_capture_type, /*optional*/::mlir::StringAttr name, ::mlir::BoolAttr partial_map);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type omp_ptr, ::mlir::Value var_ptr, ::mlir::Type var_type, /*optional*/::mlir::Value var_ptr_ptr, ::mlir::ValueRange members, /*optional*/::mlir::DenseIntElementsAttr members_index, ::mlir::ValueRange bounds, /*optional*/::mlir::IntegerAttr map_type, /*optional*/::mlir::omp::VariableCaptureKindAttr map_capture_type, /*optional*/::mlir::StringAttr name, bool partial_map = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var_ptr, ::mlir::Type var_type, /*optional*/::mlir::Value var_ptr_ptr, ::mlir::ValueRange members, /*optional*/::mlir::DenseIntElementsAttr members_index, ::mlir::ValueRange bounds, /*optional*/::mlir::IntegerAttr map_type, /*optional*/::mlir::omp::VariableCaptureKindAttr map_capture_type, /*optional*/::mlir::StringAttr name, bool partial_map = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 6 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of variable operands.
  unsigned getNumVariableOperands() {
    return getNumOperands();
  }

  /// The i-th variable operand passed.
  Value getVariableOperand(unsigned i) {
    return getOperands()[i];
  }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::MapInfoOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::MaskedOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MaskedOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MaskedOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.masked", odsAttrs.getContext());
  }

  MaskedOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class MaskedOpGenericAdaptor : public detail::MaskedOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MaskedOpGenericAdaptorBase;
public:
  MaskedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MaskedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MaskedOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MaskedOp, typename = std::enable_if_t<std::is_same_v<LateInst, MaskedOp>>>
  MaskedOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getFilteredThreadId() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MaskedOpAdaptor : public MaskedOpGenericAdaptor<::mlir::ValueRange> {
public:
  using MaskedOpGenericAdaptor::MaskedOpGenericAdaptor;
  MaskedOpAdaptor(MaskedOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MaskedOp : public ::mlir::Op<MaskedOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MaskedOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = MaskedOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.masked");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getFilteredThreadId() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::MutableOperandRange getFilteredThreadIdMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const MaskedOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value filtered_thread_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value filtered_thread_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::MaskedOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::MasterOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MasterOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MasterOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.master", odsAttrs.getContext());
  }

  MasterOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class MasterOpGenericAdaptor : public detail::MasterOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MasterOpGenericAdaptorBase;
public:
  MasterOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MasterOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MasterOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MasterOp, typename = std::enable_if_t<std::is_same_v<LateInst, MasterOp>>>
  MasterOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MasterOpAdaptor : public MasterOpGenericAdaptor<::mlir::ValueRange> {
public:
  using MasterOpGenericAdaptor::MasterOpGenericAdaptor;
  MasterOpAdaptor(MasterOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MasterOp : public ::mlir::Op<MasterOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MasterOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = MasterOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.master");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::MasterOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::OrderedOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OrderedOpGenericAdaptorBase {
public:
  struct Properties {
    using doacross_depend_typeTy = ::mlir::omp::ClauseDependAttr;
    doacross_depend_typeTy doacross_depend_type;

    auto getDoacrossDependType() {
      auto &propStorage = this->doacross_depend_type;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseDependAttr>(propStorage);
    }
    void setDoacrossDependType(const ::mlir::omp::ClauseDependAttr &propValue) {
      this->doacross_depend_type = propValue;
    }
    using doacross_num_loopsTy = ::mlir::IntegerAttr;
    doacross_num_loopsTy doacross_num_loops;

    auto getDoacrossNumLoops() {
      auto &propStorage = this->doacross_num_loops;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setDoacrossNumLoops(const ::mlir::IntegerAttr &propValue) {
      this->doacross_num_loops = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.doacross_depend_type == this->doacross_depend_type &&
        rhs.doacross_num_loops == this->doacross_num_loops &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  OrderedOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.ordered", odsAttrs.getContext());
  }

  OrderedOpGenericAdaptorBase(OrderedOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::omp::ClauseDependAttr getDoacrossDependTypeAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseDependAttr>(getProperties().doacross_depend_type);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseDepend> getDoacrossDependType();
  ::mlir::IntegerAttr getDoacrossNumLoopsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().doacross_num_loops);
    return attr;
  }

  ::std::optional<uint64_t> getDoacrossNumLoops();
};
} // namespace detail
template <typename RangeT>
class OrderedOpGenericAdaptor : public detail::OrderedOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OrderedOpGenericAdaptorBase;
public:
  OrderedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OrderedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OrderedOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  OrderedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : OrderedOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = OrderedOp, typename = std::enable_if_t<std::is_same_v<LateInst, OrderedOp>>>
  OrderedOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDoacrossDependVars() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OrderedOpAdaptor : public OrderedOpGenericAdaptor<::mlir::ValueRange> {
public:
  using OrderedOpGenericAdaptor::OrderedOpGenericAdaptor;
  OrderedOpAdaptor(OrderedOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class OrderedOp : public ::mlir::Op<OrderedOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OrderedOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = OrderedOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("doacross_depend_type"), ::llvm::StringRef("doacross_num_loops")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDoacrossDependTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDoacrossDependTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getDoacrossNumLoopsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getDoacrossNumLoopsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.ordered");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getDoacrossDependVars() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getDoacrossDependVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::omp::ClauseDependAttr getDoacrossDependTypeAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseDependAttr>(getProperties().doacross_depend_type);
  }

  ::std::optional<::mlir::omp::ClauseDepend> getDoacrossDependType();
  ::mlir::IntegerAttr getDoacrossNumLoopsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().doacross_num_loops);
  }

  ::std::optional<uint64_t> getDoacrossNumLoops();
  void setDoacrossDependTypeAttr(::mlir::omp::ClauseDependAttr attr) {
    getProperties().doacross_depend_type = attr;
  }

  void setDoacrossDependType(::std::optional<::mlir::omp::ClauseDepend> attrValue);
  void setDoacrossNumLoopsAttr(::mlir::IntegerAttr attr) {
    getProperties().doacross_num_loops = attr;
  }

  void setDoacrossNumLoops(::std::optional<uint64_t> attrValue);
  ::mlir::Attribute removeDoacrossDependTypeAttr() {
      auto &attr = getProperties().doacross_depend_type;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeDoacrossNumLoopsAttr() {
      auto &attr = getProperties().doacross_num_loops;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const OrderedOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::omp::ClauseDependAttr doacross_depend_type, /*optional*/::mlir::IntegerAttr doacross_num_loops, ::mlir::ValueRange doacross_depend_vars);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::omp::ClauseDependAttr doacross_depend_type, /*optional*/::mlir::IntegerAttr doacross_num_loops, ::mlir::ValueRange doacross_depend_vars);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::OrderedOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::OrderedRegionOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OrderedRegionOpGenericAdaptorBase {
public:
  struct Properties {
    using par_level_simdTy = ::mlir::UnitAttr;
    par_level_simdTy par_level_simd;

    auto getParLevelSimd() {
      auto &propStorage = this->par_level_simd;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setParLevelSimd(const ::mlir::UnitAttr &propValue) {
      this->par_level_simd = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.par_level_simd == this->par_level_simd &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  OrderedRegionOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.ordered.region", odsAttrs.getContext());
  }

  OrderedRegionOpGenericAdaptorBase(OrderedRegionOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::UnitAttr getParLevelSimdAttr();
  bool getParLevelSimd();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class OrderedRegionOpGenericAdaptor : public detail::OrderedRegionOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OrderedRegionOpGenericAdaptorBase;
public:
  OrderedRegionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OrderedRegionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OrderedRegionOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  OrderedRegionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : OrderedRegionOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = OrderedRegionOp, typename = std::enable_if_t<std::is_same_v<LateInst, OrderedRegionOp>>>
  OrderedRegionOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OrderedRegionOpAdaptor : public OrderedRegionOpGenericAdaptor<::mlir::ValueRange> {
public:
  using OrderedRegionOpGenericAdaptor::OrderedRegionOpGenericAdaptor;
  OrderedRegionOpAdaptor(OrderedRegionOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class OrderedRegionOp : public ::mlir::Op<OrderedRegionOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OrderedRegionOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = OrderedRegionOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("par_level_simd")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getParLevelSimdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getParLevelSimdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.ordered.region");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getParLevelSimdAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().par_level_simd);
  }

  bool getParLevelSimd();
  void setParLevelSimdAttr(::mlir::UnitAttr attr) {
    getProperties().par_level_simd = attr;
  }

  void setParLevelSimd(bool attrValue);
  ::mlir::Attribute removeParLevelSimdAttr() {
      auto &attr = getProperties().par_level_simd;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const OrderedRegionOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::UnitAttr par_level_simd);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::UnitAttr par_level_simd);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/bool par_level_simd = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/bool par_level_simd = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::OrderedRegionOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::ParallelOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ParallelOpGenericAdaptorBase {
public:
  struct Properties {
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using proc_bind_kindTy = ::mlir::omp::ClauseProcBindKindAttr;
    proc_bind_kindTy proc_bind_kind;

    auto getProcBindKind() {
      auto &propStorage = this->proc_bind_kind;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseProcBindKindAttr>(propStorage);
    }
    void setProcBindKind(const ::mlir::omp::ClauseProcBindKindAttr &propValue) {
      this->proc_bind_kind = propValue;
    }
    using reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    reduction_byrefTy reduction_byref;

    auto getReductionByref() {
      auto &propStorage = this->reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->reduction_byref = propValue;
    }
    using reduction_symsTy = ::mlir::ArrayAttr;
    reduction_symsTy reduction_syms;

    auto getReductionSyms() {
      auto &propStorage = this->reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->reduction_syms = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 6>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.private_syms == this->private_syms &&
        rhs.proc_bind_kind == this->proc_bind_kind &&
        rhs.reduction_byref == this->reduction_byref &&
        rhs.reduction_syms == this->reduction_syms &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ParallelOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.parallel", odsAttrs.getContext());
  }

  ParallelOpGenericAdaptorBase(ParallelOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::omp::ClauseProcBindKindAttr getProcBindKindAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseProcBindKindAttr>(getProperties().proc_bind_kind);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseProcBindKind> getProcBindKind();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class ParallelOpGenericAdaptor : public detail::ParallelOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ParallelOpGenericAdaptorBase;
public:
  ParallelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ParallelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ParallelOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ParallelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : ParallelOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ParallelOp, typename = std::enable_if_t<std::is_same_v<LateInst, ParallelOp>>>
  ParallelOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getNumThreads() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getPrivateVars() {
    return getODSOperands(4);
  }

  RangeT getReductionVars() {
    return getODSOperands(5);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ParallelOpAdaptor : public ParallelOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ParallelOpGenericAdaptor::ParallelOpGenericAdaptor;
  ParallelOpAdaptor(ParallelOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ParallelOp : public ::mlir::Op<ParallelOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::AutomaticAllocationScope, ::mlir::omp::ComposableOpInterface::Trait, ::mlir::omp::OutlineableOpenMPOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParallelOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ParallelOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("private_syms"), ::llvm::StringRef("proc_bind_kind"), ::llvm::StringRef("reduction_byref"), ::llvm::StringRef("reduction_syms"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getProcBindKindAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getProcBindKindAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReductionByrefAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getReductionSymsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.parallel");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::Type> getNumThreads() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(4);
  }

  ::mlir::Operation::operand_range getReductionVars() {
    return getODSOperands(5);
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getNumThreadsMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  ::mlir::MutableOperandRange getReductionVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::omp::ClauseProcBindKindAttr getProcBindKindAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseProcBindKindAttr>(getProperties().proc_bind_kind);
  }

  ::std::optional<::mlir::omp::ClauseProcBindKind> getProcBindKind();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  void setProcBindKindAttr(::mlir::omp::ClauseProcBindKindAttr attr) {
    getProperties().proc_bind_kind = attr;
  }

  void setProcBindKind(::std::optional<::mlir::omp::ClauseProcBindKind> attrValue);
  void setReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().reduction_byref = attr;
  }

  void setReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().reduction_syms = attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeProcBindKindAttr() {
      auto &attr = getProperties().proc_bind_kind;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionByrefAttr() {
      auto &attr = getProperties().reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionSymsAttr() {
      auto &attr = getProperties().reduction_syms;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ArrayRef<NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const ParallelOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value if_expr, /*optional*/::mlir::Value num_threads, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::omp::ClauseProcBindKindAttr proc_bind_kind, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value if_expr, /*optional*/::mlir::Value num_threads, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::omp::ClauseProcBindKindAttr proc_bind_kind, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }






  /// Returns the number of reduction variables.
  unsigned getNumReductionVars() { return getReductionVars().size(); }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::ParallelOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::PrivateClauseOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PrivateClauseOpGenericAdaptorBase {
public:
  struct Properties {
    using data_sharing_typeTy = ::mlir::omp::DataSharingClauseTypeAttr;
    data_sharing_typeTy data_sharing_type;

    auto getDataSharingType() {
      auto &propStorage = this->data_sharing_type;
      return ::llvm::cast<::mlir::omp::DataSharingClauseTypeAttr>(propStorage);
    }
    void setDataSharingType(const ::mlir::omp::DataSharingClauseTypeAttr &propValue) {
      this->data_sharing_type = propValue;
    }
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    using typeTy = ::mlir::TypeAttr;
    typeTy type;

    auto getType() {
      auto &propStorage = this->type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setType(const ::mlir::TypeAttr &propValue) {
      this->type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.data_sharing_type == this->data_sharing_type &&
        rhs.sym_name == this->sym_name &&
        rhs.type == this->type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  PrivateClauseOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.private", odsAttrs.getContext());
  }

  PrivateClauseOpGenericAdaptorBase(PrivateClauseOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::StringAttr getSymNameAttr() {
    auto attr = ::llvm::cast<::mlir::StringAttr>(getProperties().sym_name);
    return attr;
  }

  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr() {
    auto attr = ::llvm::cast<::mlir::TypeAttr>(getProperties().type);
    return attr;
  }

  ::mlir::Type getType();
  ::mlir::omp::DataSharingClauseTypeAttr getDataSharingTypeAttr() {
    auto attr = ::llvm::cast<::mlir::omp::DataSharingClauseTypeAttr>(getProperties().data_sharing_type);
    return attr;
  }

  ::mlir::omp::DataSharingClauseType getDataSharingType();
  ::mlir::Region &getAllocRegion() {
    return *odsRegions[0];
  }

  ::mlir::Region &getCopyRegion() {
    return *odsRegions[1];
  }

  ::mlir::Region &getDeallocRegion() {
    return *odsRegions[2];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class PrivateClauseOpGenericAdaptor : public detail::PrivateClauseOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PrivateClauseOpGenericAdaptorBase;
public:
  PrivateClauseOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PrivateClauseOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PrivateClauseOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  PrivateClauseOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : PrivateClauseOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = PrivateClauseOp, typename = std::enable_if_t<std::is_same_v<LateInst, PrivateClauseOp>>>
  PrivateClauseOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PrivateClauseOpAdaptor : public PrivateClauseOpGenericAdaptor<::mlir::ValueRange> {
public:
  using PrivateClauseOpGenericAdaptor::PrivateClauseOpGenericAdaptor;
  PrivateClauseOpAdaptor(PrivateClauseOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class PrivateClauseOp : public ::mlir::Op<PrivateClauseOp, ::mlir::OpTrait::NRegions<3>::Impl, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::accomp::RecipeInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PrivateClauseOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = PrivateClauseOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("data_sharing_type"), ::llvm::StringRef("sym_name"), ::llvm::StringRef("type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataSharingTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataSharingTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getTypeAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.private");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getAllocRegion() {
    return (*this)->getRegion(0);
  }

  ::mlir::Region &getCopyRegion() {
    return (*this)->getRegion(1);
  }

  ::mlir::Region &getDeallocRegion() {
    return (*this)->getRegion(2);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr() {
    return ::llvm::cast<::mlir::StringAttr>(getProperties().sym_name);
  }

  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr() {
    return ::llvm::cast<::mlir::TypeAttr>(getProperties().type);
  }

  ::mlir::Type getType();
  ::mlir::omp::DataSharingClauseTypeAttr getDataSharingTypeAttr() {
    return ::llvm::cast<::mlir::omp::DataSharingClauseTypeAttr>(getProperties().data_sharing_type);
  }

  ::mlir::omp::DataSharingClauseType getDataSharingType();
  void setSymNameAttr(::mlir::StringAttr attr) {
    getProperties().sym_name = attr;
  }

  void setSymName(::llvm::StringRef attrValue);
  void setTypeAttr(::mlir::TypeAttr attr) {
    getProperties().type = attr;
  }

  void setType(::mlir::Type attrValue);
  void setDataSharingTypeAttr(::mlir::omp::DataSharingClauseTypeAttr attr) {
    getProperties().data_sharing_type = attr;
  }

  void setDataSharingType(::mlir::omp::DataSharingClauseType attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange result, StringAttr sym_name, TypeAttr type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type, ::mlir::omp::DataSharingClauseTypeAttr data_sharing_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type, ::mlir::omp::DataSharingClauseTypeAttr data_sharing_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type, ::mlir::omp::DataSharingClauseType data_sharing_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type, ::mlir::omp::DataSharingClauseType data_sharing_type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::PrivateClauseOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::SectionOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SectionOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SectionOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.section", odsAttrs.getContext());
  }

  SectionOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class SectionOpGenericAdaptor : public detail::SectionOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SectionOpGenericAdaptorBase;
public:
  SectionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SectionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SectionOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SectionOp, typename = std::enable_if_t<std::is_same_v<LateInst, SectionOp>>>
  SectionOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SectionOpAdaptor : public SectionOpGenericAdaptor<::mlir::ValueRange> {
public:
  using SectionOpGenericAdaptor::SectionOpGenericAdaptor;
  SectionOpAdaptor(SectionOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SectionOp : public ::mlir::Op<SectionOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::HasParent<SectionsOp>::Impl, ::mlir::OpTrait::OpInvariants> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SectionOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = SectionOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.section");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::SectionOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::SectionsOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SectionsOpGenericAdaptorBase {
public:
  struct Properties {
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    reduction_byrefTy reduction_byref;

    auto getReductionByref() {
      auto &propStorage = this->reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->reduction_byref = propValue;
    }
    using reduction_symsTy = ::mlir::ArrayAttr;
    reduction_symsTy reduction_syms;

    auto getReductionSyms() {
      auto &propStorage = this->reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->reduction_syms = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.nowait == this->nowait &&
        rhs.private_syms == this->private_syms &&
        rhs.reduction_byref == this->reduction_byref &&
        rhs.reduction_syms == this->reduction_syms &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SectionsOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.sections", odsAttrs.getContext());
  }

  SectionsOpGenericAdaptorBase(SectionsOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class SectionsOpGenericAdaptor : public detail::SectionsOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SectionsOpGenericAdaptorBase;
public:
  SectionsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SectionsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SectionsOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SectionsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : SectionsOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SectionsOp, typename = std::enable_if_t<std::is_same_v<LateInst, SectionsOp>>>
  SectionsOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  RangeT getPrivateVars() {
    return getODSOperands(2);
  }

  RangeT getReductionVars() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SectionsOpAdaptor : public SectionsOpGenericAdaptor<::mlir::ValueRange> {
public:
  using SectionsOpGenericAdaptor::SectionsOpGenericAdaptor;
  SectionsOpAdaptor(SectionsOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SectionsOp : public ::mlir::Op<SectionsOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SectionsOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = SectionsOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("nowait"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("reduction_byref"), ::llvm::StringRef("reduction_syms"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReductionByrefAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getReductionSymsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.sections");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(2);
  }

  ::mlir::Operation::operand_range getReductionVars() {
    return getODSOperands(3);
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  ::mlir::MutableOperandRange getReductionVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  void setReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().reduction_byref = attr;
  }

  void setReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().reduction_syms = attr;
  }

  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionByrefAttr() {
      auto &attr = getProperties().reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionSymsAttr() {
      auto &attr = getProperties().reduction_syms;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const SectionsOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::UnitAttr nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::UnitAttr nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/bool nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/bool nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  ::llvm::LogicalResult verifyRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }




  /// Returns the number of reduction variables.
  unsigned getNumReductionVars() { return getReductionVars().size(); }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::SectionsOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::SimdOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SimdOpGenericAdaptorBase {
public:
  struct Properties {
    using alignmentsTy = ::mlir::ArrayAttr;
    alignmentsTy alignments;

    auto getAlignments() {
      auto &propStorage = this->alignments;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAlignments(const ::mlir::ArrayAttr &propValue) {
      this->alignments = propValue;
    }
    using orderTy = ::mlir::omp::ClauseOrderKindAttr;
    orderTy order;

    auto getOrder() {
      auto &propStorage = this->order;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(propStorage);
    }
    void setOrder(const ::mlir::omp::ClauseOrderKindAttr &propValue) {
      this->order = propValue;
    }
    using order_modTy = ::mlir::omp::OrderModifierAttr;
    order_modTy order_mod;

    auto getOrderMod() {
      auto &propStorage = this->order_mod;
      return ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(propStorage);
    }
    void setOrderMod(const ::mlir::omp::OrderModifierAttr &propValue) {
      this->order_mod = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    reduction_byrefTy reduction_byref;

    auto getReductionByref() {
      auto &propStorage = this->reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->reduction_byref = propValue;
    }
    using reduction_symsTy = ::mlir::ArrayAttr;
    reduction_symsTy reduction_syms;

    auto getReductionSyms() {
      auto &propStorage = this->reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->reduction_syms = propValue;
    }
    using safelenTy = ::mlir::IntegerAttr;
    safelenTy safelen;

    auto getSafelen() {
      auto &propStorage = this->safelen;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setSafelen(const ::mlir::IntegerAttr &propValue) {
      this->safelen = propValue;
    }
    using simdlenTy = ::mlir::IntegerAttr;
    simdlenTy simdlen;

    auto getSimdlen() {
      auto &propStorage = this->simdlen;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setSimdlen(const ::mlir::IntegerAttr &propValue) {
      this->simdlen = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 7>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.alignments == this->alignments &&
        rhs.order == this->order &&
        rhs.order_mod == this->order_mod &&
        rhs.private_syms == this->private_syms &&
        rhs.reduction_byref == this->reduction_byref &&
        rhs.reduction_syms == this->reduction_syms &&
        rhs.safelen == this->safelen &&
        rhs.simdlen == this->simdlen &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SimdOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.simd", odsAttrs.getContext());
  }

  SimdOpGenericAdaptorBase(SimdOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getAlignmentsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().alignments);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getAlignments();
  ::mlir::omp::ClauseOrderKindAttr getOrderAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(getProperties().order);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseOrderKind> getOrder();
  ::mlir::omp::OrderModifierAttr getOrderModAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(getProperties().order_mod);
    return attr;
  }

  ::std::optional<::mlir::omp::OrderModifier> getOrderMod();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::IntegerAttr getSafelenAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().safelen);
    return attr;
  }

  ::std::optional<uint64_t> getSafelen();
  ::mlir::IntegerAttr getSimdlenAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().simdlen);
    return attr;
  }

  ::std::optional<uint64_t> getSimdlen();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class SimdOpGenericAdaptor : public detail::SimdOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SimdOpGenericAdaptorBase;
public:
  SimdOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SimdOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SimdOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SimdOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : SimdOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SimdOp, typename = std::enable_if_t<std::is_same_v<LateInst, SimdOp>>>
  SimdOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAlignedVars() {
    return getODSOperands(0);
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getLinearVars() {
    return getODSOperands(2);
  }

  RangeT getLinearStepVars() {
    return getODSOperands(3);
  }

  RangeT getNontemporalVars() {
    return getODSOperands(4);
  }

  RangeT getPrivateVars() {
    return getODSOperands(5);
  }

  RangeT getReductionVars() {
    return getODSOperands(6);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SimdOpAdaptor : public SimdOpGenericAdaptor<::mlir::ValueRange> {
public:
  using SimdOpGenericAdaptor::SimdOpGenericAdaptor;
  SimdOpAdaptor(SimdOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SimdOp : public ::mlir::Op<SimdOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::ComposableOpInterface::Trait, ::mlir::omp::LoopWrapperInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SimdOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = SimdOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("alignments"), ::llvm::StringRef("order"), ::llvm::StringRef("order_mod"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("reduction_byref"), ::llvm::StringRef("reduction_syms"), ::llvm::StringRef("safelen"), ::llvm::StringRef("simdlen"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAlignmentsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAlignmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOrderAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getOrderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOrderModAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getOrderModAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getReductionByrefAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getReductionSymsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getSafelenAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getSafelenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getSimdlenAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getSimdlenAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.simd");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAlignedVars() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getLinearVars() {
    return getODSOperands(2);
  }

  ::mlir::Operation::operand_range getLinearStepVars() {
    return getODSOperands(3);
  }

  ::mlir::Operation::operand_range getNontemporalVars() {
    return getODSOperands(4);
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(5);
  }

  ::mlir::Operation::operand_range getReductionVars() {
    return getODSOperands(6);
  }

  ::mlir::MutableOperandRange getAlignedVarsMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getLinearVarsMutable();
  ::mlir::MutableOperandRange getLinearStepVarsMutable();
  ::mlir::MutableOperandRange getNontemporalVarsMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  ::mlir::MutableOperandRange getReductionVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getAlignmentsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().alignments);
  }

  ::std::optional< ::mlir::ArrayAttr > getAlignments();
  ::mlir::omp::ClauseOrderKindAttr getOrderAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(getProperties().order);
  }

  ::std::optional<::mlir::omp::ClauseOrderKind> getOrder();
  ::mlir::omp::OrderModifierAttr getOrderModAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(getProperties().order_mod);
  }

  ::std::optional<::mlir::omp::OrderModifier> getOrderMod();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::IntegerAttr getSafelenAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().safelen);
  }

  ::std::optional<uint64_t> getSafelen();
  ::mlir::IntegerAttr getSimdlenAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().simdlen);
  }

  ::std::optional<uint64_t> getSimdlen();
  void setAlignmentsAttr(::mlir::ArrayAttr attr) {
    getProperties().alignments = attr;
  }

  void setOrderAttr(::mlir::omp::ClauseOrderKindAttr attr) {
    getProperties().order = attr;
  }

  void setOrder(::std::optional<::mlir::omp::ClauseOrderKind> attrValue);
  void setOrderModAttr(::mlir::omp::OrderModifierAttr attr) {
    getProperties().order_mod = attr;
  }

  void setOrderMod(::std::optional<::mlir::omp::OrderModifier> attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  void setReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().reduction_byref = attr;
  }

  void setReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().reduction_syms = attr;
  }

  void setSafelenAttr(::mlir::IntegerAttr attr) {
    getProperties().safelen = attr;
  }

  void setSafelen(::std::optional<uint64_t> attrValue);
  void setSimdlenAttr(::mlir::IntegerAttr attr) {
    getProperties().simdlen = attr;
  }

  void setSimdlen(::std::optional<uint64_t> attrValue);
  ::mlir::Attribute removeAlignmentsAttr() {
      auto &attr = getProperties().alignments;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeOrderAttr() {
      auto &attr = getProperties().order;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeOrderModAttr() {
      auto &attr = getProperties().order_mod;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionByrefAttr() {
      auto &attr = getProperties().reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionSymsAttr() {
      auto &attr = getProperties().reduction_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeSafelenAttr() {
      auto &attr = getProperties().safelen;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeSimdlenAttr() {
      auto &attr = getProperties().simdlen;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const SimdOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange aligned_vars, /*optional*/::mlir::ArrayAttr alignments, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange linear_vars, ::mlir::ValueRange linear_step_vars, ::mlir::ValueRange nontemporal_vars, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::IntegerAttr safelen, /*optional*/::mlir::IntegerAttr simdlen);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange aligned_vars, /*optional*/::mlir::ArrayAttr alignments, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange linear_vars, ::mlir::ValueRange linear_step_vars, ::mlir::ValueRange nontemporal_vars, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::IntegerAttr safelen, /*optional*/::mlir::IntegerAttr simdlen);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 8 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Returns the number of reduction variables.
  unsigned getNumReductionVars() { return getReductionVars().size(); }


};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::SimdOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::SingleOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SingleOpGenericAdaptorBase {
public:
  struct Properties {
    using copyprivate_symsTy = ::mlir::ArrayAttr;
    copyprivate_symsTy copyprivate_syms;

    auto getCopyprivateSyms() {
      auto &propStorage = this->copyprivate_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setCopyprivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->copyprivate_syms = propValue;
    }
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.copyprivate_syms == this->copyprivate_syms &&
        rhs.nowait == this->nowait &&
        rhs.private_syms == this->private_syms &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SingleOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.single", odsAttrs.getContext());
  }

  SingleOpGenericAdaptorBase(SingleOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getCopyprivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().copyprivate_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getCopyprivateSyms();
  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class SingleOpGenericAdaptor : public detail::SingleOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SingleOpGenericAdaptorBase;
public:
  SingleOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SingleOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SingleOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SingleOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : SingleOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SingleOp, typename = std::enable_if_t<std::is_same_v<LateInst, SingleOp>>>
  SingleOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  RangeT getCopyprivateVars() {
    return getODSOperands(2);
  }

  RangeT getPrivateVars() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SingleOpAdaptor : public SingleOpGenericAdaptor<::mlir::ValueRange> {
public:
  using SingleOpGenericAdaptor::SingleOpGenericAdaptor;
  SingleOpAdaptor(SingleOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SingleOp : public ::mlir::Op<SingleOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SingleOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = SingleOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("copyprivate_syms"), ::llvm::StringRef("nowait"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCopyprivateSymsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCopyprivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.single");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::Operation::operand_range getCopyprivateVars() {
    return getODSOperands(2);
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(3);
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getCopyprivateVarsMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getCopyprivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().copyprivate_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getCopyprivateSyms();
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  void setCopyprivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().copyprivate_syms = attr;
  }

  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  ::mlir::Attribute removeCopyprivateSymsAttr() {
      auto &attr = getProperties().copyprivate_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const SingleOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange copyprivate_vars, /*optional*/::mlir::ArrayAttr copyprivate_syms, /*optional*/::mlir::UnitAttr nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange copyprivate_vars, /*optional*/::mlir::ArrayAttr copyprivate_syms, /*optional*/::mlir::UnitAttr nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange copyprivate_vars, /*optional*/::mlir::ArrayAttr copyprivate_syms, /*optional*/bool nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange copyprivate_vars, /*optional*/::mlir::ArrayAttr copyprivate_syms, /*optional*/bool nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }



};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::SingleOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TargetDataOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TargetDataOpGenericAdaptorBase {
public:
  struct Properties {
    using operandSegmentSizesTy = std::array<int32_t, 5>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TargetDataOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.target_data", odsAttrs.getContext());
  }

  TargetDataOpGenericAdaptorBase(TargetDataOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class TargetDataOpGenericAdaptor : public detail::TargetDataOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TargetDataOpGenericAdaptorBase;
public:
  TargetDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TargetDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TargetDataOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TargetDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TargetDataOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TargetDataOp, typename = std::enable_if_t<std::is_same_v<LateInst, TargetDataOp>>>
  TargetDataOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getDevice() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getMapVars() {
    return getODSOperands(2);
  }

  RangeT getUseDeviceAddrVars() {
    return getODSOperands(3);
  }

  RangeT getUseDevicePtrVars() {
    return getODSOperands(4);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TargetDataOpAdaptor : public TargetDataOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TargetDataOpGenericAdaptor::TargetDataOpGenericAdaptor;
  TargetDataOpAdaptor(TargetDataOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TargetDataOp : public ::mlir::Op<TargetDataOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::MapClauseOwningOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TargetDataOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TargetDataOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.target_data");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::IntegerType> getDevice() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getMapVars() {
    return getODSOperands(2);
  }

  ::mlir::Operation::operand_range getUseDeviceAddrVars() {
    return getODSOperands(3);
  }

  ::mlir::Operation::operand_range getUseDevicePtrVars() {
    return getODSOperands(4);
  }

  ::mlir::MutableOperandRange getDeviceMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getMapVarsMutable();
  ::mlir::MutableOperandRange getUseDeviceAddrVarsMutable();
  ::mlir::MutableOperandRange getUseDevicePtrVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TargetDataOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, ::mlir::ValueRange use_device_addr_vars, ::mlir::ValueRange use_device_ptr_vars);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, ::mlir::ValueRange use_device_addr_vars, ::mlir::ValueRange use_device_ptr_vars);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    return {};
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TargetDataOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TargetEnterDataOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TargetEnterDataOpGenericAdaptorBase {
public:
  struct Properties {
    using depend_kindsTy = ::mlir::ArrayAttr;
    depend_kindsTy depend_kinds;

    auto getDependKinds() {
      auto &propStorage = this->depend_kinds;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDependKinds(const ::mlir::ArrayAttr &propValue) {
      this->depend_kinds = propValue;
    }
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.depend_kinds == this->depend_kinds &&
        rhs.nowait == this->nowait &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TargetEnterDataOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.target_enter_data", odsAttrs.getContext());
  }

  TargetEnterDataOpGenericAdaptorBase(TargetEnterDataOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getDependKindsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
};
} // namespace detail
template <typename RangeT>
class TargetEnterDataOpGenericAdaptor : public detail::TargetEnterDataOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TargetEnterDataOpGenericAdaptorBase;
public:
  TargetEnterDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TargetEnterDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TargetEnterDataOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TargetEnterDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TargetEnterDataOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TargetEnterDataOp, typename = std::enable_if_t<std::is_same_v<LateInst, TargetEnterDataOp>>>
  TargetEnterDataOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDependVars() {
    return getODSOperands(0);
  }

  ValueT getDevice() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getMapVars() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TargetEnterDataOpAdaptor : public TargetEnterDataOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TargetEnterDataOpGenericAdaptor::TargetEnterDataOpGenericAdaptor;
  TargetEnterDataOpAdaptor(TargetEnterDataOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TargetEnterDataOp : public ::mlir::Op<TargetEnterDataOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::MapClauseOwningOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TargetEnterDataOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TargetEnterDataOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("depend_kinds"), ::llvm::StringRef("nowait"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDependKindsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDependKindsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.target_enter_data");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getDependVars() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getDevice() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getMapVars() {
    return getODSOperands(3);
  }

  ::mlir::MutableOperandRange getDependVarsMutable();
  ::mlir::MutableOperandRange getDeviceMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getMapVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDependKindsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  void setDependKindsAttr(::mlir::ArrayAttr attr) {
    getProperties().depend_kinds = attr;
  }

  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  ::mlir::Attribute removeDependKindsAttr() {
      auto &attr = getProperties().depend_kinds;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TargetEnterExitUpdateDataOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TargetEnterDataOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TargetExitDataOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TargetExitDataOpGenericAdaptorBase {
public:
  struct Properties {
    using depend_kindsTy = ::mlir::ArrayAttr;
    depend_kindsTy depend_kinds;

    auto getDependKinds() {
      auto &propStorage = this->depend_kinds;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDependKinds(const ::mlir::ArrayAttr &propValue) {
      this->depend_kinds = propValue;
    }
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.depend_kinds == this->depend_kinds &&
        rhs.nowait == this->nowait &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TargetExitDataOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.target_exit_data", odsAttrs.getContext());
  }

  TargetExitDataOpGenericAdaptorBase(TargetExitDataOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getDependKindsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
};
} // namespace detail
template <typename RangeT>
class TargetExitDataOpGenericAdaptor : public detail::TargetExitDataOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TargetExitDataOpGenericAdaptorBase;
public:
  TargetExitDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TargetExitDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TargetExitDataOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TargetExitDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TargetExitDataOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TargetExitDataOp, typename = std::enable_if_t<std::is_same_v<LateInst, TargetExitDataOp>>>
  TargetExitDataOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDependVars() {
    return getODSOperands(0);
  }

  ValueT getDevice() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getMapVars() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TargetExitDataOpAdaptor : public TargetExitDataOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TargetExitDataOpGenericAdaptor::TargetExitDataOpGenericAdaptor;
  TargetExitDataOpAdaptor(TargetExitDataOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TargetExitDataOp : public ::mlir::Op<TargetExitDataOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::MapClauseOwningOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TargetExitDataOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TargetExitDataOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("depend_kinds"), ::llvm::StringRef("nowait"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDependKindsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDependKindsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.target_exit_data");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getDependVars() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getDevice() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getMapVars() {
    return getODSOperands(3);
  }

  ::mlir::MutableOperandRange getDependVarsMutable();
  ::mlir::MutableOperandRange getDeviceMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getMapVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDependKindsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  void setDependKindsAttr(::mlir::ArrayAttr attr) {
    getProperties().depend_kinds = attr;
  }

  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  ::mlir::Attribute removeDependKindsAttr() {
      auto &attr = getProperties().depend_kinds;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TargetEnterExitUpdateDataOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TargetExitDataOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TargetOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TargetOpGenericAdaptorBase {
public:
  struct Properties {
    using depend_kindsTy = ::mlir::ArrayAttr;
    depend_kindsTy depend_kinds;

    auto getDependKinds() {
      auto &propStorage = this->depend_kinds;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDependKinds(const ::mlir::ArrayAttr &propValue) {
      this->depend_kinds = propValue;
    }
    using in_reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    in_reduction_byrefTy in_reduction_byref;

    auto getInReductionByref() {
      auto &propStorage = this->in_reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setInReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->in_reduction_byref = propValue;
    }
    using in_reduction_symsTy = ::mlir::ArrayAttr;
    in_reduction_symsTy in_reduction_syms;

    auto getInReductionSyms() {
      auto &propStorage = this->in_reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setInReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->in_reduction_syms = propValue;
    }
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 11>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.depend_kinds == this->depend_kinds &&
        rhs.in_reduction_byref == this->in_reduction_byref &&
        rhs.in_reduction_syms == this->in_reduction_syms &&
        rhs.nowait == this->nowait &&
        rhs.private_syms == this->private_syms &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TargetOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.target", odsAttrs.getContext());
  }

  TargetOpGenericAdaptorBase(TargetOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getDependKindsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::DenseBoolArrayAttr getInReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().in_reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getInReductionByref();
  ::mlir::ArrayAttr getInReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().in_reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getInReductionSyms();
  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class TargetOpGenericAdaptor : public detail::TargetOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TargetOpGenericAdaptorBase;
public:
  TargetOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TargetOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TargetOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TargetOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TargetOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TargetOp, typename = std::enable_if_t<std::is_same_v<LateInst, TargetOp>>>
  TargetOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  RangeT getDependVars() {
    return getODSOperands(2);
  }

  ValueT getDevice() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getHasDeviceAddrVars() {
    return getODSOperands(4);
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(5);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getInReductionVars() {
    return getODSOperands(6);
  }

  RangeT getIsDevicePtrVars() {
    return getODSOperands(7);
  }

  RangeT getMapVars() {
    return getODSOperands(8);
  }

  RangeT getPrivateVars() {
    return getODSOperands(9);
  }

  ValueT getThreadLimit() {
    auto operands = getODSOperands(10);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TargetOpAdaptor : public TargetOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TargetOpGenericAdaptor::TargetOpGenericAdaptor;
  TargetOpAdaptor(TargetOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TargetOp : public ::mlir::Op<TargetOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::omp::OutlineableOpenMPOpInterface::Trait, ::mlir::omp::ReductionClauseInterface::Trait, ::mlir::omp::MapClauseOwningOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TargetOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TargetOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("depend_kinds"), ::llvm::StringRef("in_reduction_byref"), ::llvm::StringRef("in_reduction_syms"), ::llvm::StringRef("nowait"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDependKindsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDependKindsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getInReductionByrefAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getInReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInReductionSymsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.target");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::Operation::operand_range getDependVars() {
    return getODSOperands(2);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getDevice() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getHasDeviceAddrVars() {
    return getODSOperands(4);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(5);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getInReductionVars() {
    return getODSOperands(6);
  }

  ::mlir::Operation::operand_range getIsDevicePtrVars() {
    return getODSOperands(7);
  }

  ::mlir::Operation::operand_range getMapVars() {
    return getODSOperands(8);
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(9);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getThreadLimit() {
    auto operands = getODSOperands(10);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getDependVarsMutable();
  ::mlir::MutableOperandRange getDeviceMutable();
  ::mlir::MutableOperandRange getHasDeviceAddrVarsMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getInReductionVarsMutable();
  ::mlir::MutableOperandRange getIsDevicePtrVarsMutable();
  ::mlir::MutableOperandRange getMapVarsMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  ::mlir::MutableOperandRange getThreadLimitMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDependKindsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::DenseBoolArrayAttr getInReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().in_reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getInReductionByref();
  ::mlir::ArrayAttr getInReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().in_reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getInReductionSyms();
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  void setDependKindsAttr(::mlir::ArrayAttr attr) {
    getProperties().depend_kinds = attr;
  }

  void setInReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().in_reduction_byref = attr;
  }

  void setInReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setInReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().in_reduction_syms = attr;
  }

  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  ::mlir::Attribute removeDependKindsAttr() {
      auto &attr = getProperties().depend_kinds;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeInReductionByrefAttr() {
      auto &attr = getProperties().in_reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeInReductionSymsAttr() {
      auto &attr = getProperties().in_reduction_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TargetOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, ::mlir::ValueRange has_device_addr_vars, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, ::mlir::ValueRange is_device_ptr_vars, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::Value thread_limit);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, ::mlir::ValueRange has_device_addr_vars, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, ::mlir::ValueRange is_device_ptr_vars, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::Value thread_limit);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, ::mlir::ValueRange has_device_addr_vars, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, ::mlir::ValueRange is_device_ptr_vars, ::mlir::ValueRange map_vars, /*optional*/bool nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::Value thread_limit);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, ::mlir::ValueRange has_device_addr_vars, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, ::mlir::ValueRange is_device_ptr_vars, ::mlir::ValueRange map_vars, /*optional*/bool nowait, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::Value thread_limit);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }






  /// Returns the reduction variables.
  SmallVector<Value> getReductionVars() {
    return SmallVector<Value>(getInReductionVars().begin(),
                              getInReductionVars().end());
  }





};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TargetOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TargetUpdateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TargetUpdateOpGenericAdaptorBase {
public:
  struct Properties {
    using depend_kindsTy = ::mlir::ArrayAttr;
    depend_kindsTy depend_kinds;

    auto getDependKinds() {
      auto &propStorage = this->depend_kinds;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDependKinds(const ::mlir::ArrayAttr &propValue) {
      this->depend_kinds = propValue;
    }
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.depend_kinds == this->depend_kinds &&
        rhs.nowait == this->nowait &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TargetUpdateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.target_update", odsAttrs.getContext());
  }

  TargetUpdateOpGenericAdaptorBase(TargetUpdateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getDependKindsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
};
} // namespace detail
template <typename RangeT>
class TargetUpdateOpGenericAdaptor : public detail::TargetUpdateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TargetUpdateOpGenericAdaptorBase;
public:
  TargetUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TargetUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TargetUpdateOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TargetUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TargetUpdateOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TargetUpdateOp, typename = std::enable_if_t<std::is_same_v<LateInst, TargetUpdateOp>>>
  TargetUpdateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDependVars() {
    return getODSOperands(0);
  }

  ValueT getDevice() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getMapVars() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TargetUpdateOpAdaptor : public TargetUpdateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TargetUpdateOpGenericAdaptor::TargetUpdateOpGenericAdaptor;
  TargetUpdateOpAdaptor(TargetUpdateOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TargetUpdateOp : public ::mlir::Op<TargetUpdateOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::MapClauseOwningOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TargetUpdateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TargetUpdateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("depend_kinds"), ::llvm::StringRef("nowait"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDependKindsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDependKindsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.target_update");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getDependVars() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getDevice() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getMapVars() {
    return getODSOperands(3);
  }

  ::mlir::MutableOperandRange getDependVarsMutable();
  ::mlir::MutableOperandRange getDeviceMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getMapVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDependKindsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  void setDependKindsAttr(::mlir::ArrayAttr attr) {
    getProperties().depend_kinds = attr;
  }

  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  ::mlir::Attribute removeDependKindsAttr() {
      auto &attr = getProperties().depend_kinds;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TargetEnterExitUpdateDataOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value device, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange map_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TargetUpdateOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TaskOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TaskOpGenericAdaptorBase {
public:
  struct Properties {
    using depend_kindsTy = ::mlir::ArrayAttr;
    depend_kindsTy depend_kinds;

    auto getDependKinds() {
      auto &propStorage = this->depend_kinds;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDependKinds(const ::mlir::ArrayAttr &propValue) {
      this->depend_kinds = propValue;
    }
    using in_reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    in_reduction_byrefTy in_reduction_byref;

    auto getInReductionByref() {
      auto &propStorage = this->in_reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setInReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->in_reduction_byref = propValue;
    }
    using in_reduction_symsTy = ::mlir::ArrayAttr;
    in_reduction_symsTy in_reduction_syms;

    auto getInReductionSyms() {
      auto &propStorage = this->in_reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setInReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->in_reduction_syms = propValue;
    }
    using mergeableTy = ::mlir::UnitAttr;
    mergeableTy mergeable;

    auto getMergeable() {
      auto &propStorage = this->mergeable;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setMergeable(const ::mlir::UnitAttr &propValue) {
      this->mergeable = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using untiedTy = ::mlir::UnitAttr;
    untiedTy untied;

    auto getUntied() {
      auto &propStorage = this->untied;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setUntied(const ::mlir::UnitAttr &propValue) {
      this->untied = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 8>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.depend_kinds == this->depend_kinds &&
        rhs.in_reduction_byref == this->in_reduction_byref &&
        rhs.in_reduction_syms == this->in_reduction_syms &&
        rhs.mergeable == this->mergeable &&
        rhs.private_syms == this->private_syms &&
        rhs.untied == this->untied &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TaskOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.task", odsAttrs.getContext());
  }

  TaskOpGenericAdaptorBase(TaskOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getDependKindsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::DenseBoolArrayAttr getInReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().in_reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getInReductionByref();
  ::mlir::ArrayAttr getInReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().in_reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getInReductionSyms();
  ::mlir::UnitAttr getMergeableAttr();
  bool getMergeable();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::UnitAttr getUntiedAttr();
  bool getUntied();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class TaskOpGenericAdaptor : public detail::TaskOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TaskOpGenericAdaptorBase;
public:
  TaskOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TaskOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TaskOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TaskOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TaskOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TaskOp, typename = std::enable_if_t<std::is_same_v<LateInst, TaskOp>>>
  TaskOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  RangeT getDependVars() {
    return getODSOperands(2);
  }

  ValueT getFinal() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getInReductionVars() {
    return getODSOperands(5);
  }

  ValueT getPriority() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getPrivateVars() {
    return getODSOperands(7);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TaskOpAdaptor : public TaskOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TaskOpGenericAdaptor::TaskOpGenericAdaptor;
  TaskOpAdaptor(TaskOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TaskOp : public ::mlir::Op<TaskOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::AutomaticAllocationScope, ::mlir::omp::OutlineableOpenMPOpInterface::Trait, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TaskOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TaskOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("depend_kinds"), ::llvm::StringRef("in_reduction_byref"), ::llvm::StringRef("in_reduction_syms"), ::llvm::StringRef("mergeable"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("untied"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDependKindsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDependKindsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getInReductionByrefAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getInReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInReductionSymsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getMergeableAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getMergeableAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getUntiedAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getUntiedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.task");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::Operation::operand_range getDependVars() {
    return getODSOperands(2);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getFinal() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getInReductionVars() {
    return getODSOperands(5);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getPriority() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(7);
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getDependVarsMutable();
  ::mlir::MutableOperandRange getFinalMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getInReductionVarsMutable();
  ::mlir::MutableOperandRange getPriorityMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDependKindsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::DenseBoolArrayAttr getInReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().in_reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getInReductionByref();
  ::mlir::ArrayAttr getInReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().in_reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getInReductionSyms();
  ::mlir::UnitAttr getMergeableAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().mergeable);
  }

  bool getMergeable();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::UnitAttr getUntiedAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().untied);
  }

  bool getUntied();
  void setDependKindsAttr(::mlir::ArrayAttr attr) {
    getProperties().depend_kinds = attr;
  }

  void setInReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().in_reduction_byref = attr;
  }

  void setInReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setInReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().in_reduction_syms = attr;
  }

  void setMergeableAttr(::mlir::UnitAttr attr) {
    getProperties().mergeable = attr;
  }

  void setMergeable(bool attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  void setUntiedAttr(::mlir::UnitAttr attr) {
    getProperties().untied = attr;
  }

  void setUntied(bool attrValue);
  ::mlir::Attribute removeDependKindsAttr() {
      auto &attr = getProperties().depend_kinds;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeInReductionByrefAttr() {
      auto &attr = getProperties().in_reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeInReductionSymsAttr() {
      auto &attr = getProperties().in_reduction_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMergeableAttr() {
      auto &attr = getProperties().mergeable;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeUntiedAttr() {
      auto &attr = getProperties().untied;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TaskOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/::mlir::UnitAttr mergeable, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::UnitAttr untied);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/::mlir::UnitAttr mergeable, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/::mlir::UnitAttr untied);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/bool mergeable, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/bool untied = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/bool mergeable, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, /*optional*/bool untied = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 6 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }





  /// Returns the reduction variables.
  SmallVector<Value> getReductionVars() {
    return SmallVector<Value>(getInReductionVars().begin(),
                              getInReductionVars().end());
  }




};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TaskOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TaskgroupOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TaskgroupOpGenericAdaptorBase {
public:
  struct Properties {
    using task_reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    task_reduction_byrefTy task_reduction_byref;

    auto getTaskReductionByref() {
      auto &propStorage = this->task_reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setTaskReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->task_reduction_byref = propValue;
    }
    using task_reduction_symsTy = ::mlir::ArrayAttr;
    task_reduction_symsTy task_reduction_syms;

    auto getTaskReductionSyms() {
      auto &propStorage = this->task_reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setTaskReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->task_reduction_syms = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.task_reduction_byref == this->task_reduction_byref &&
        rhs.task_reduction_syms == this->task_reduction_syms &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TaskgroupOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.taskgroup", odsAttrs.getContext());
  }

  TaskgroupOpGenericAdaptorBase(TaskgroupOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::DenseBoolArrayAttr getTaskReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().task_reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getTaskReductionByref();
  ::mlir::ArrayAttr getTaskReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().task_reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getTaskReductionSyms();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class TaskgroupOpGenericAdaptor : public detail::TaskgroupOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TaskgroupOpGenericAdaptorBase;
public:
  TaskgroupOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TaskgroupOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TaskgroupOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TaskgroupOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TaskgroupOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TaskgroupOp, typename = std::enable_if_t<std::is_same_v<LateInst, TaskgroupOp>>>
  TaskgroupOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  RangeT getTaskReductionVars() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TaskgroupOpAdaptor : public TaskgroupOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TaskgroupOpGenericAdaptor::TaskgroupOpGenericAdaptor;
  TaskgroupOpAdaptor(TaskgroupOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TaskgroupOp : public ::mlir::Op<TaskgroupOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::AutomaticAllocationScope, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TaskgroupOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TaskgroupOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("task_reduction_byref"), ::llvm::StringRef("task_reduction_syms"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getTaskReductionByrefAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getTaskReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getTaskReductionSymsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getTaskReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.taskgroup");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::Operation::operand_range getTaskReductionVars() {
    return getODSOperands(2);
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getTaskReductionVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::DenseBoolArrayAttr getTaskReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().task_reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getTaskReductionByref();
  ::mlir::ArrayAttr getTaskReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().task_reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getTaskReductionSyms();
  void setTaskReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().task_reduction_byref = attr;
  }

  void setTaskReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setTaskReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().task_reduction_syms = attr;
  }

  ::mlir::Attribute removeTaskReductionByrefAttr() {
      auto &attr = getProperties().task_reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeTaskReductionSymsAttr() {
      auto &attr = getProperties().task_reduction_syms;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TaskgroupOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange task_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr task_reduction_byref, /*optional*/::mlir::ArrayAttr task_reduction_syms);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange task_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr task_reduction_byref, /*optional*/::mlir::ArrayAttr task_reduction_syms);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }


  /// Returns the reduction variables.
  SmallVector<Value> getReductionVars() {
    return SmallVector<Value>(getTaskReductionVars().begin(),
                              getTaskReductionVars().end());
  }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TaskgroupOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TaskloopOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TaskloopOpGenericAdaptorBase {
public:
  struct Properties {
    using in_reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    in_reduction_byrefTy in_reduction_byref;

    auto getInReductionByref() {
      auto &propStorage = this->in_reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setInReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->in_reduction_byref = propValue;
    }
    using in_reduction_symsTy = ::mlir::ArrayAttr;
    in_reduction_symsTy in_reduction_syms;

    auto getInReductionSyms() {
      auto &propStorage = this->in_reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setInReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->in_reduction_syms = propValue;
    }
    using mergeableTy = ::mlir::UnitAttr;
    mergeableTy mergeable;

    auto getMergeable() {
      auto &propStorage = this->mergeable;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setMergeable(const ::mlir::UnitAttr &propValue) {
      this->mergeable = propValue;
    }
    using nogroupTy = ::mlir::UnitAttr;
    nogroupTy nogroup;

    auto getNogroup() {
      auto &propStorage = this->nogroup;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNogroup(const ::mlir::UnitAttr &propValue) {
      this->nogroup = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    reduction_byrefTy reduction_byref;

    auto getReductionByref() {
      auto &propStorage = this->reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->reduction_byref = propValue;
    }
    using reduction_symsTy = ::mlir::ArrayAttr;
    reduction_symsTy reduction_syms;

    auto getReductionSyms() {
      auto &propStorage = this->reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->reduction_syms = propValue;
    }
    using untiedTy = ::mlir::UnitAttr;
    untiedTy untied;

    auto getUntied() {
      auto &propStorage = this->untied;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setUntied(const ::mlir::UnitAttr &propValue) {
      this->untied = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 10>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.in_reduction_byref == this->in_reduction_byref &&
        rhs.in_reduction_syms == this->in_reduction_syms &&
        rhs.mergeable == this->mergeable &&
        rhs.nogroup == this->nogroup &&
        rhs.private_syms == this->private_syms &&
        rhs.reduction_byref == this->reduction_byref &&
        rhs.reduction_syms == this->reduction_syms &&
        rhs.untied == this->untied &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TaskloopOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.taskloop", odsAttrs.getContext());
  }

  TaskloopOpGenericAdaptorBase(TaskloopOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::DenseBoolArrayAttr getInReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().in_reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getInReductionByref();
  ::mlir::ArrayAttr getInReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().in_reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getInReductionSyms();
  ::mlir::UnitAttr getMergeableAttr();
  bool getMergeable();
  ::mlir::UnitAttr getNogroupAttr();
  bool getNogroup();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::UnitAttr getUntiedAttr();
  bool getUntied();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class TaskloopOpGenericAdaptor : public detail::TaskloopOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TaskloopOpGenericAdaptorBase;
public:
  TaskloopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TaskloopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TaskloopOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TaskloopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TaskloopOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TaskloopOp, typename = std::enable_if_t<std::is_same_v<LateInst, TaskloopOp>>>
  TaskloopOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  ValueT getFinal() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getGrainsize() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getInReductionVars() {
    return getODSOperands(5);
  }

  ValueT getNumTasks() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getPriority() {
    auto operands = getODSOperands(7);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getPrivateVars() {
    return getODSOperands(8);
  }

  RangeT getReductionVars() {
    return getODSOperands(9);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TaskloopOpAdaptor : public TaskloopOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TaskloopOpGenericAdaptor::TaskloopOpGenericAdaptor;
  TaskloopOpAdaptor(TaskloopOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TaskloopOp : public ::mlir::Op<TaskloopOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::AutomaticAllocationScope, ::mlir::omp::ComposableOpInterface::Trait, ::mlir::omp::LoopWrapperInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TaskloopOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TaskloopOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("in_reduction_byref"), ::llvm::StringRef("in_reduction_syms"), ::llvm::StringRef("mergeable"), ::llvm::StringRef("nogroup"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("reduction_byref"), ::llvm::StringRef("reduction_syms"), ::llvm::StringRef("untied"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getInReductionByrefAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getInReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getInReductionSymsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getInReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getMergeableAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getMergeableAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getNogroupAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getNogroupAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getReductionByrefAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getReductionSymsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getUntiedAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getUntiedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.taskloop");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getFinal() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::Type> getGrainsize() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getInReductionVars() {
    return getODSOperands(5);
  }

  ::mlir::TypedValue<::mlir::Type> getNumTasks() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getPriority() {
    auto operands = getODSOperands(7);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(8);
  }

  ::mlir::Operation::operand_range getReductionVars() {
    return getODSOperands(9);
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getFinalMutable();
  ::mlir::MutableOperandRange getGrainsizeMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getInReductionVarsMutable();
  ::mlir::MutableOperandRange getNumTasksMutable();
  ::mlir::MutableOperandRange getPriorityMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  ::mlir::MutableOperandRange getReductionVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::DenseBoolArrayAttr getInReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().in_reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getInReductionByref();
  ::mlir::ArrayAttr getInReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().in_reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getInReductionSyms();
  ::mlir::UnitAttr getMergeableAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().mergeable);
  }

  bool getMergeable();
  ::mlir::UnitAttr getNogroupAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nogroup);
  }

  bool getNogroup();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::UnitAttr getUntiedAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().untied);
  }

  bool getUntied();
  void setInReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().in_reduction_byref = attr;
  }

  void setInReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setInReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().in_reduction_syms = attr;
  }

  void setMergeableAttr(::mlir::UnitAttr attr) {
    getProperties().mergeable = attr;
  }

  void setMergeable(bool attrValue);
  void setNogroupAttr(::mlir::UnitAttr attr) {
    getProperties().nogroup = attr;
  }

  void setNogroup(bool attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  void setReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().reduction_byref = attr;
  }

  void setReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().reduction_syms = attr;
  }

  void setUntiedAttr(::mlir::UnitAttr attr) {
    getProperties().untied = attr;
  }

  void setUntied(bool attrValue);
  ::mlir::Attribute removeInReductionByrefAttr() {
      auto &attr = getProperties().in_reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeInReductionSymsAttr() {
      auto &attr = getProperties().in_reduction_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeMergeableAttr() {
      auto &attr = getProperties().mergeable;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNogroupAttr() {
      auto &attr = getProperties().nogroup;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionByrefAttr() {
      auto &attr = getProperties().reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionSymsAttr() {
      auto &attr = getProperties().reduction_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeUntiedAttr() {
      auto &attr = getProperties().untied;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TaskloopOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value grainsize, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/::mlir::UnitAttr mergeable, /*optional*/::mlir::UnitAttr nogroup, /*optional*/::mlir::Value num_tasks, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::UnitAttr untied);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value grainsize, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/::mlir::UnitAttr mergeable, /*optional*/::mlir::UnitAttr nogroup, /*optional*/::mlir::Value num_tasks, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::UnitAttr untied);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value grainsize, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/bool mergeable, /*optional*/bool nogroup, /*optional*/::mlir::Value num_tasks, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/bool untied = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value final, /*optional*/::mlir::Value grainsize, /*optional*/::mlir::Value if_expr, ::mlir::ValueRange in_reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr in_reduction_byref, /*optional*/::mlir::ArrayAttr in_reduction_syms, /*optional*/bool mergeable, /*optional*/bool nogroup, /*optional*/::mlir::Value num_tasks, /*optional*/::mlir::Value priority, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/bool untied = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 8 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Returns the reduction variables
  SmallVector<Value> getAllReductionVars();

  void getEffects(SmallVectorImpl<MemoryEffects::EffectInstance> &effects);

  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }









};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TaskloopOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TaskwaitOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TaskwaitOpGenericAdaptorBase {
public:
  struct Properties {
    using depend_kindsTy = ::mlir::ArrayAttr;
    depend_kindsTy depend_kinds;

    auto getDependKinds() {
      auto &propStorage = this->depend_kinds;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDependKinds(const ::mlir::ArrayAttr &propValue) {
      this->depend_kinds = propValue;
    }
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.depend_kinds == this->depend_kinds &&
        rhs.nowait == this->nowait &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TaskwaitOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.taskwait", odsAttrs.getContext());
  }

  TaskwaitOpGenericAdaptorBase(TaskwaitOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getDependKindsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
};
} // namespace detail
template <typename RangeT>
class TaskwaitOpGenericAdaptor : public detail::TaskwaitOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TaskwaitOpGenericAdaptorBase;
public:
  TaskwaitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TaskwaitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TaskwaitOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TaskwaitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : TaskwaitOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TaskwaitOp, typename = std::enable_if_t<std::is_same_v<LateInst, TaskwaitOp>>>
  TaskwaitOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDependVars() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TaskwaitOpAdaptor : public TaskwaitOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TaskwaitOpGenericAdaptor::TaskwaitOpGenericAdaptor;
  TaskwaitOpAdaptor(TaskwaitOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TaskwaitOp : public ::mlir::Op<TaskwaitOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TaskwaitOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TaskwaitOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("depend_kinds"), ::llvm::StringRef("nowait")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDependKindsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDependKindsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.taskwait");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getDependVars() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getDependVarsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDependKindsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().depend_kinds);
  }

  ::std::optional< ::mlir::ArrayAttr > getDependKinds();
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  void setDependKindsAttr(::mlir::ArrayAttr attr) {
    getProperties().depend_kinds = attr;
  }

  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  ::mlir::Attribute removeDependKindsAttr() {
      auto &attr = getProperties().depend_kinds;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TaskwaitOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/::mlir::UnitAttr nowait);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr depend_kinds, ::mlir::ValueRange depend_vars, /*optional*/bool nowait = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TaskwaitOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TaskyieldOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TaskyieldOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TaskyieldOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.taskyield", odsAttrs.getContext());
  }

  TaskyieldOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class TaskyieldOpGenericAdaptor : public detail::TaskyieldOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TaskyieldOpGenericAdaptorBase;
public:
  TaskyieldOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TaskyieldOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TaskyieldOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TaskyieldOp, typename = std::enable_if_t<std::is_same_v<LateInst, TaskyieldOp>>>
  TaskyieldOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TaskyieldOpAdaptor : public TaskyieldOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TaskyieldOpGenericAdaptor::TaskyieldOpGenericAdaptor;
  TaskyieldOpAdaptor(TaskyieldOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TaskyieldOp : public ::mlir::Op<TaskyieldOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TaskyieldOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TaskyieldOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.taskyield");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TaskyieldOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TeamsOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TeamsOpGenericAdaptorBase {
public:
  struct Properties {
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    reduction_byrefTy reduction_byref;

    auto getReductionByref() {
      auto &propStorage = this->reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->reduction_byref = propValue;
    }
    using reduction_symsTy = ::mlir::ArrayAttr;
    reduction_symsTy reduction_syms;

    auto getReductionSyms() {
      auto &propStorage = this->reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->reduction_syms = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 8>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.private_syms == this->private_syms &&
        rhs.reduction_byref == this->reduction_byref &&
        rhs.reduction_syms == this->reduction_syms &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TeamsOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.teams", odsAttrs.getContext());
  }

  TeamsOpGenericAdaptorBase(TeamsOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class TeamsOpGenericAdaptor : public detail::TeamsOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TeamsOpGenericAdaptorBase;
public:
  TeamsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TeamsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TeamsOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TeamsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : TeamsOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TeamsOp, typename = std::enable_if_t<std::is_same_v<LateInst, TeamsOp>>>
  TeamsOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  ValueT getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getNumTeamsLower() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getNumTeamsUpper() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getPrivateVars() {
    return getODSOperands(5);
  }

  RangeT getReductionVars() {
    return getODSOperands(6);
  }

  ValueT getThreadLimit() {
    auto operands = getODSOperands(7);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TeamsOpAdaptor : public TeamsOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TeamsOpGenericAdaptor::TeamsOpGenericAdaptor;
  TeamsOpAdaptor(TeamsOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TeamsOp : public ::mlir::Op<TeamsOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TeamsOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TeamsOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("private_syms"), ::llvm::StringRef("reduction_byref"), ::llvm::StringRef("reduction_syms"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReductionByrefAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReductionSymsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.teams");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getIfExpr() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getNumTeamsLower() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::TypedValue<::mlir::IntegerType> getNumTeamsUpper() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(5);
  }

  ::mlir::Operation::operand_range getReductionVars() {
    return getODSOperands(6);
  }

  ::mlir::TypedValue<::mlir::IntegerType> getThreadLimit() {
    auto operands = getODSOperands(7);
    return operands.empty() ? ::mlir::TypedValue<::mlir::IntegerType>{} : ::llvm::cast<::mlir::TypedValue<::mlir::IntegerType>>(*operands.begin());
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getIfExprMutable();
  ::mlir::MutableOperandRange getNumTeamsLowerMutable();
  ::mlir::MutableOperandRange getNumTeamsUpperMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  ::mlir::MutableOperandRange getReductionVarsMutable();
  ::mlir::MutableOperandRange getThreadLimitMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  void setReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().reduction_byref = attr;
  }

  void setReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().reduction_syms = attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionByrefAttr() {
      auto &attr = getProperties().reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionSymsAttr() {
      auto &attr = getProperties().reduction_syms;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const TeamsOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value if_expr, /*optional*/::mlir::Value num_teams_lower, /*optional*/::mlir::Value num_teams_upper, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::Value thread_limit);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, /*optional*/::mlir::Value if_expr, /*optional*/::mlir::Value num_teams_lower, /*optional*/::mlir::Value num_teams_upper, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::Value thread_limit);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }





  /// Returns the number of reduction variables.
  unsigned getNumReductionVars() { return getReductionVars().size(); }

};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TeamsOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::TerminatorOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TerminatorOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TerminatorOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.terminator", odsAttrs.getContext());
  }

  TerminatorOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class TerminatorOpGenericAdaptor : public detail::TerminatorOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TerminatorOpGenericAdaptorBase;
public:
  TerminatorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TerminatorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TerminatorOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TerminatorOp, typename = std::enable_if_t<std::is_same_v<LateInst, TerminatorOp>>>
  TerminatorOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TerminatorOpAdaptor : public TerminatorOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TerminatorOpGenericAdaptor::TerminatorOpGenericAdaptor;
  TerminatorOpAdaptor(TerminatorOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TerminatorOp : public ::mlir::Op<TerminatorOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::OpTrait::IsTerminator, ::mlir::ConditionallySpeculatable::Trait, ::mlir::OpTrait::AlwaysSpeculatableImplTrait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TerminatorOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TerminatorOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.terminator");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::TerminatorOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::ThreadprivateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ThreadprivateOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ThreadprivateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.threadprivate", odsAttrs.getContext());
  }

  ThreadprivateOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ThreadprivateOpGenericAdaptor : public detail::ThreadprivateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ThreadprivateOpGenericAdaptorBase;
public:
  ThreadprivateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ThreadprivateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ThreadprivateOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ThreadprivateOp, typename = std::enable_if_t<std::is_same_v<LateInst, ThreadprivateOp>>>
  ThreadprivateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getSymAddr() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ThreadprivateOpAdaptor : public ThreadprivateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ThreadprivateOpGenericAdaptor::ThreadprivateOpGenericAdaptor;
  ThreadprivateOpAdaptor(ThreadprivateOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ThreadprivateOp : public ::mlir::Op<ThreadprivateOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::omp::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ThreadprivateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ThreadprivateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.threadprivate");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getSymAddr() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getSymAddrMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::omp::PointerLikeType> getTlsAddr() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::omp::PointerLikeType>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tls_addr, ::mlir::Value sym_addr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sym_addr);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
  /// The number of variable operands.
  unsigned getNumVariableOperands() {
    assert(getSymAddr() && "expected one variable operand");
    return 1;
  }

  /// The i-th variable operand passed.
  Value getVariableOperand(unsigned i) {
    assert(i == 0 && "invalid index position for an operand");
    return getSymAddr();
  }
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::ThreadprivateOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::WsloopOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class WsloopOpGenericAdaptorBase {
public:
  struct Properties {
    using nowaitTy = ::mlir::UnitAttr;
    nowaitTy nowait;

    auto getNowait() {
      auto &propStorage = this->nowait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNowait(const ::mlir::UnitAttr &propValue) {
      this->nowait = propValue;
    }
    using orderTy = ::mlir::omp::ClauseOrderKindAttr;
    orderTy order;

    auto getOrder() {
      auto &propStorage = this->order;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(propStorage);
    }
    void setOrder(const ::mlir::omp::ClauseOrderKindAttr &propValue) {
      this->order = propValue;
    }
    using order_modTy = ::mlir::omp::OrderModifierAttr;
    order_modTy order_mod;

    auto getOrderMod() {
      auto &propStorage = this->order_mod;
      return ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(propStorage);
    }
    void setOrderMod(const ::mlir::omp::OrderModifierAttr &propValue) {
      this->order_mod = propValue;
    }
    using orderedTy = ::mlir::IntegerAttr;
    orderedTy ordered;

    auto getOrdered() {
      auto &propStorage = this->ordered;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setOrdered(const ::mlir::IntegerAttr &propValue) {
      this->ordered = propValue;
    }
    using private_symsTy = ::mlir::ArrayAttr;
    private_symsTy private_syms;

    auto getPrivateSyms() {
      auto &propStorage = this->private_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivateSyms(const ::mlir::ArrayAttr &propValue) {
      this->private_syms = propValue;
    }
    using reduction_byrefTy = ::mlir::DenseBoolArrayAttr;
    reduction_byrefTy reduction_byref;

    auto getReductionByref() {
      auto &propStorage = this->reduction_byref;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setReductionByref(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->reduction_byref = propValue;
    }
    using reduction_symsTy = ::mlir::ArrayAttr;
    reduction_symsTy reduction_syms;

    auto getReductionSyms() {
      auto &propStorage = this->reduction_syms;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionSyms(const ::mlir::ArrayAttr &propValue) {
      this->reduction_syms = propValue;
    }
    using schedule_kindTy = ::mlir::omp::ClauseScheduleKindAttr;
    schedule_kindTy schedule_kind;

    auto getScheduleKind() {
      auto &propStorage = this->schedule_kind;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseScheduleKindAttr>(propStorage);
    }
    void setScheduleKind(const ::mlir::omp::ClauseScheduleKindAttr &propValue) {
      this->schedule_kind = propValue;
    }
    using schedule_modTy = ::mlir::omp::ScheduleModifierAttr;
    schedule_modTy schedule_mod;

    auto getScheduleMod() {
      auto &propStorage = this->schedule_mod;
      return ::llvm::dyn_cast_or_null<::mlir::omp::ScheduleModifierAttr>(propStorage);
    }
    void setScheduleMod(const ::mlir::omp::ScheduleModifierAttr &propValue) {
      this->schedule_mod = propValue;
    }
    using schedule_simdTy = ::mlir::UnitAttr;
    schedule_simdTy schedule_simd;

    auto getScheduleSimd() {
      auto &propStorage = this->schedule_simd;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setScheduleSimd(const ::mlir::UnitAttr &propValue) {
      this->schedule_simd = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 7>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() const {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(::llvm::ArrayRef<int32_t> propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.nowait == this->nowait &&
        rhs.order == this->order &&
        rhs.order_mod == this->order_mod &&
        rhs.ordered == this->ordered &&
        rhs.private_syms == this->private_syms &&
        rhs.reduction_byref == this->reduction_byref &&
        rhs.reduction_syms == this->reduction_syms &&
        rhs.schedule_kind == this->schedule_kind &&
        rhs.schedule_mod == this->schedule_mod &&
        rhs.schedule_simd == this->schedule_simd &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  WsloopOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.wsloop", odsAttrs.getContext());
  }

  WsloopOpGenericAdaptorBase(WsloopOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::UnitAttr getNowaitAttr();
  bool getNowait();
  ::mlir::omp::ClauseOrderKindAttr getOrderAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(getProperties().order);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseOrderKind> getOrder();
  ::mlir::omp::OrderModifierAttr getOrderModAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(getProperties().order_mod);
    return attr;
  }

  ::std::optional<::mlir::omp::OrderModifier> getOrderMod();
  ::mlir::IntegerAttr getOrderedAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().ordered);
    return attr;
  }

  ::std::optional<uint64_t> getOrdered();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
    return attr;
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::omp::ClauseScheduleKindAttr getScheduleKindAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ClauseScheduleKindAttr>(getProperties().schedule_kind);
    return attr;
  }

  ::std::optional<::mlir::omp::ClauseScheduleKind> getScheduleKind();
  ::mlir::omp::ScheduleModifierAttr getScheduleModAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::omp::ScheduleModifierAttr>(getProperties().schedule_mod);
    return attr;
  }

  ::std::optional<::mlir::omp::ScheduleModifier> getScheduleMod();
  ::mlir::UnitAttr getScheduleSimdAttr();
  bool getScheduleSimd();
  ::mlir::Region &getRegion() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class WsloopOpGenericAdaptor : public detail::WsloopOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::WsloopOpGenericAdaptorBase;
public:
  WsloopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  WsloopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : WsloopOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  WsloopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs) : WsloopOpGenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = WsloopOp, typename = std::enable_if_t<std::is_same_v<LateInst, WsloopOp>>>
  WsloopOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAllocateVars() {
    return getODSOperands(0);
  }

  RangeT getAllocatorVars() {
    return getODSOperands(1);
  }

  RangeT getLinearVars() {
    return getODSOperands(2);
  }

  RangeT getLinearStepVars() {
    return getODSOperands(3);
  }

  RangeT getPrivateVars() {
    return getODSOperands(4);
  }

  RangeT getReductionVars() {
    return getODSOperands(5);
  }

  ValueT getScheduleChunk() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class WsloopOpAdaptor : public WsloopOpGenericAdaptor<::mlir::ValueRange> {
public:
  using WsloopOpGenericAdaptor::WsloopOpGenericAdaptor;
  WsloopOpAdaptor(WsloopOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class WsloopOp : public ::mlir::Op<WsloopOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::omp::ComposableOpInterface::Trait, ::mlir::omp::LoopWrapperInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::omp::ReductionClauseInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WsloopOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = WsloopOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("nowait"), ::llvm::StringRef("order"), ::llvm::StringRef("order_mod"), ::llvm::StringRef("ordered"), ::llvm::StringRef("private_syms"), ::llvm::StringRef("reduction_byref"), ::llvm::StringRef("reduction_syms"), ::llvm::StringRef("schedule_kind"), ::llvm::StringRef("schedule_mod"), ::llvm::StringRef("schedule_simd"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getNowaitAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getNowaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOrderAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getOrderAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOrderModAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getOrderModAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOrderedAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getOrderedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getPrivateSymsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getPrivateSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getReductionByrefAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getReductionByrefAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getReductionSymsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getReductionSymsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getScheduleKindAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getScheduleKindAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getScheduleModAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getScheduleModAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getScheduleSimdAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getScheduleSimdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.wsloop");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getAllocateVars() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getAllocatorVars() {
    return getODSOperands(1);
  }

  ::mlir::Operation::operand_range getLinearVars() {
    return getODSOperands(2);
  }

  ::mlir::Operation::operand_range getLinearStepVars() {
    return getODSOperands(3);
  }

  ::mlir::Operation::operand_range getPrivateVars() {
    return getODSOperands(4);
  }

  ::mlir::Operation::operand_range getReductionVars() {
    return getODSOperands(5);
  }

  ::mlir::TypedValue<::mlir::Type> getScheduleChunk() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ::mlir::TypedValue<::mlir::Type>{} : ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*operands.begin());
  }

  ::mlir::MutableOperandRange getAllocateVarsMutable();
  ::mlir::MutableOperandRange getAllocatorVarsMutable();
  ::mlir::MutableOperandRange getLinearVarsMutable();
  ::mlir::MutableOperandRange getLinearStepVarsMutable();
  ::mlir::MutableOperandRange getPrivateVarsMutable();
  ::mlir::MutableOperandRange getReductionVarsMutable();
  ::mlir::MutableOperandRange getScheduleChunkMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getRegion() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getNowaitAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nowait);
  }

  bool getNowait();
  ::mlir::omp::ClauseOrderKindAttr getOrderAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseOrderKindAttr>(getProperties().order);
  }

  ::std::optional<::mlir::omp::ClauseOrderKind> getOrder();
  ::mlir::omp::OrderModifierAttr getOrderModAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::OrderModifierAttr>(getProperties().order_mod);
  }

  ::std::optional<::mlir::omp::OrderModifier> getOrderMod();
  ::mlir::IntegerAttr getOrderedAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().ordered);
  }

  ::std::optional<uint64_t> getOrdered();
  ::mlir::ArrayAttr getPrivateSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().private_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrivateSyms();
  ::mlir::DenseBoolArrayAttr getReductionByrefAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(getProperties().reduction_byref);
  }

  ::std::optional<::llvm::ArrayRef<bool>> getReductionByref();
  ::mlir::ArrayAttr getReductionSymsAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().reduction_syms);
  }

  ::std::optional< ::mlir::ArrayAttr > getReductionSyms();
  ::mlir::omp::ClauseScheduleKindAttr getScheduleKindAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ClauseScheduleKindAttr>(getProperties().schedule_kind);
  }

  ::std::optional<::mlir::omp::ClauseScheduleKind> getScheduleKind();
  ::mlir::omp::ScheduleModifierAttr getScheduleModAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::omp::ScheduleModifierAttr>(getProperties().schedule_mod);
  }

  ::std::optional<::mlir::omp::ScheduleModifier> getScheduleMod();
  ::mlir::UnitAttr getScheduleSimdAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().schedule_simd);
  }

  bool getScheduleSimd();
  void setNowaitAttr(::mlir::UnitAttr attr) {
    getProperties().nowait = attr;
  }

  void setNowait(bool attrValue);
  void setOrderAttr(::mlir::omp::ClauseOrderKindAttr attr) {
    getProperties().order = attr;
  }

  void setOrder(::std::optional<::mlir::omp::ClauseOrderKind> attrValue);
  void setOrderModAttr(::mlir::omp::OrderModifierAttr attr) {
    getProperties().order_mod = attr;
  }

  void setOrderMod(::std::optional<::mlir::omp::OrderModifier> attrValue);
  void setOrderedAttr(::mlir::IntegerAttr attr) {
    getProperties().ordered = attr;
  }

  void setOrdered(::std::optional<uint64_t> attrValue);
  void setPrivateSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().private_syms = attr;
  }

  void setReductionByrefAttr(::mlir::DenseBoolArrayAttr attr) {
    getProperties().reduction_byref = attr;
  }

  void setReductionByref(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setReductionSymsAttr(::mlir::ArrayAttr attr) {
    getProperties().reduction_syms = attr;
  }

  void setScheduleKindAttr(::mlir::omp::ClauseScheduleKindAttr attr) {
    getProperties().schedule_kind = attr;
  }

  void setScheduleKind(::std::optional<::mlir::omp::ClauseScheduleKind> attrValue);
  void setScheduleModAttr(::mlir::omp::ScheduleModifierAttr attr) {
    getProperties().schedule_mod = attr;
  }

  void setScheduleMod(::std::optional<::mlir::omp::ScheduleModifier> attrValue);
  void setScheduleSimdAttr(::mlir::UnitAttr attr) {
    getProperties().schedule_simd = attr;
  }

  void setScheduleSimd(bool attrValue);
  ::mlir::Attribute removeNowaitAttr() {
      auto &attr = getProperties().nowait;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeOrderAttr() {
      auto &attr = getProperties().order;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeOrderModAttr() {
      auto &attr = getProperties().order_mod;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeOrderedAttr() {
      auto &attr = getProperties().ordered;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrivateSymsAttr() {
      auto &attr = getProperties().private_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionByrefAttr() {
      auto &attr = getProperties().reduction_byref;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeReductionSymsAttr() {
      auto &attr = getProperties().reduction_syms;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeScheduleKindAttr() {
      auto &attr = getProperties().schedule_kind;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeScheduleModAttr() {
      auto &attr = getProperties().schedule_mod;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeScheduleSimdAttr() {
      auto &attr = getProperties().schedule_simd;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ArrayRef<NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, const WsloopOperands &clauses);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange linear_vars, ::mlir::ValueRange linear_step_vars, /*optional*/::mlir::UnitAttr nowait, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, /*optional*/::mlir::IntegerAttr ordered, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::omp::ClauseScheduleKindAttr schedule_kind, /*optional*/::mlir::Value schedule_chunk, /*optional*/::mlir::omp::ScheduleModifierAttr schedule_mod, /*optional*/::mlir::UnitAttr schedule_simd);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange linear_vars, ::mlir::ValueRange linear_step_vars, /*optional*/::mlir::UnitAttr nowait, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, /*optional*/::mlir::IntegerAttr ordered, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::omp::ClauseScheduleKindAttr schedule_kind, /*optional*/::mlir::Value schedule_chunk, /*optional*/::mlir::omp::ScheduleModifierAttr schedule_mod, /*optional*/::mlir::UnitAttr schedule_simd);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange linear_vars, ::mlir::ValueRange linear_step_vars, /*optional*/bool nowait, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, /*optional*/::mlir::IntegerAttr ordered, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::omp::ClauseScheduleKindAttr schedule_kind, /*optional*/::mlir::Value schedule_chunk, /*optional*/::mlir::omp::ScheduleModifierAttr schedule_mod, /*optional*/bool schedule_simd = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange allocate_vars, ::mlir::ValueRange allocator_vars, ::mlir::ValueRange linear_vars, ::mlir::ValueRange linear_step_vars, /*optional*/bool nowait, /*optional*/::mlir::omp::ClauseOrderKindAttr order, /*optional*/::mlir::omp::OrderModifierAttr order_mod, /*optional*/::mlir::IntegerAttr ordered, ::mlir::ValueRange private_vars, /*optional*/::mlir::ArrayAttr private_syms, ::mlir::ValueRange reduction_vars, /*optional*/::mlir::DenseBoolArrayAttr reduction_byref, /*optional*/::mlir::ArrayAttr reduction_syms, /*optional*/::mlir::omp::ClauseScheduleKindAttr schedule_kind, /*optional*/::mlir::Value schedule_chunk, /*optional*/::mlir::omp::ScheduleModifierAttr schedule_mod, /*optional*/bool schedule_simd = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::llvm::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 10 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  unsigned getNumAllocateVars() { return getAllocateVars().size(); }
  unsigned getNumAllocatorsVars() { return getAllocatorVars().size(); }







  /// Returns the number of reduction variables.
  unsigned getNumReductionVars() { return getReductionVars().size(); }

};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::WsloopOp)

namespace mlir {
namespace omp {

//===----------------------------------------------------------------------===//
// ::mlir::omp::YieldOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class YieldOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  YieldOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("omp.yield", odsAttrs.getContext());
  }

  YieldOpGenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class YieldOpGenericAdaptor : public detail::YieldOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::YieldOpGenericAdaptorBase;
public:
  YieldOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  YieldOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : YieldOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = YieldOp, typename = std::enable_if_t<std::is_same_v<LateInst, YieldOp>>>
  YieldOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getResults() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class YieldOpAdaptor : public YieldOpGenericAdaptor<::mlir::ValueRange> {
public:
  using YieldOpGenericAdaptor::YieldOpGenericAdaptor;
  YieldOpAdaptor(YieldOp op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class YieldOp : public ::mlir::Op<YieldOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::HasParent<AtomicUpdateOp, DeclareReductionOp, LoopNestOp, PrivateClauseOp>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::ConditionallySpeculatable::Trait, ::mlir::OpTrait::AlwaysSpeculatableImplTrait, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::RegionBranchTerminatorOpInterface::Trait, ::mlir::OpTrait::ReturnLike, ::mlir::OpTrait::IsTerminator> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = YieldOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = YieldOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("omp.yield");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getResults() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getResultsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange results);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  ::mlir::MutableOperandRange getMutableSuccessorOperands(::mlir::RegionBranchPoint point);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
public:
};
} // namespace omp
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::omp::YieldOp)


#endif  // GET_OP_CLASSES

