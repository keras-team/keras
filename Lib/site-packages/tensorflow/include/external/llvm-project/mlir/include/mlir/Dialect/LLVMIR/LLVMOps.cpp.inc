/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: LLVMOps.td                                                           *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::LLVM::AShrOp,
::mlir::LLVM::AddOp,
::mlir::LLVM::AddrSpaceCastOp,
::mlir::LLVM::AddressOfOp,
::mlir::LLVM::AllocaOp,
::mlir::LLVM::AndOp,
::mlir::LLVM::AtomicCmpXchgOp,
::mlir::LLVM::AtomicRMWOp,
::mlir::LLVM::BitcastOp,
::mlir::LLVM::BrOp,
::mlir::LLVM::CallIntrinsicOp,
::mlir::LLVM::CallOp,
::mlir::LLVM::ComdatOp,
::mlir::LLVM::ComdatSelectorOp,
::mlir::LLVM::CondBrOp,
::mlir::LLVM::ConstantOp,
::mlir::LLVM::ExtractElementOp,
::mlir::LLVM::ExtractValueOp,
::mlir::LLVM::FAddOp,
::mlir::LLVM::FCmpOp,
::mlir::LLVM::FDivOp,
::mlir::LLVM::FMulOp,
::mlir::LLVM::FNegOp,
::mlir::LLVM::FPExtOp,
::mlir::LLVM::FPToSIOp,
::mlir::LLVM::FPToUIOp,
::mlir::LLVM::FPTruncOp,
::mlir::LLVM::FRemOp,
::mlir::LLVM::FSubOp,
::mlir::LLVM::FenceOp,
::mlir::LLVM::FreezeOp,
::mlir::LLVM::GEPOp,
::mlir::LLVM::GlobalCtorsOp,
::mlir::LLVM::GlobalDtorsOp,
::mlir::LLVM::GlobalOp,
::mlir::LLVM::ICmpOp,
::mlir::LLVM::InlineAsmOp,
::mlir::LLVM::InsertElementOp,
::mlir::LLVM::InsertValueOp,
::mlir::LLVM::IntToPtrOp,
::mlir::LLVM::InvokeOp,
::mlir::LLVM::LLVMFuncOp,
::mlir::LLVM::LShrOp,
::mlir::LLVM::LandingpadOp,
::mlir::LLVM::LinkerOptionsOp,
::mlir::LLVM::LoadOp,
::mlir::LLVM::MulOp,
::mlir::LLVM::NoneTokenOp,
::mlir::LLVM::OrOp,
::mlir::LLVM::PoisonOp,
::mlir::LLVM::PtrToIntOp,
::mlir::LLVM::ResumeOp,
::mlir::LLVM::ReturnOp,
::mlir::LLVM::SDivOp,
::mlir::LLVM::SExtOp,
::mlir::LLVM::SIToFPOp,
::mlir::LLVM::SRemOp,
::mlir::LLVM::SelectOp,
::mlir::LLVM::ShlOp,
::mlir::LLVM::ShuffleVectorOp,
::mlir::LLVM::StoreOp,
::mlir::LLVM::SubOp,
::mlir::LLVM::SwitchOp,
::mlir::LLVM::TruncOp,
::mlir::LLVM::UDivOp,
::mlir::LLVM::UIToFPOp,
::mlir::LLVM::URemOp,
::mlir::LLVM::UndefOp,
::mlir::LLVM::UnreachableOp,
::mlir::LLVM::VaArgOp,
::mlir::LLVM::XOrOp,
::mlir::LLVM::ZExtOp,
::mlir::LLVM::ZeroOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace LLVM {

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps1(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isSignlessInteger())) || (((::mlir::LLVM::isCompatibleVectorType(type))) && ((::mlir::LLVM::getVectorElementType(type).isSignlessInteger()))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be signless integer or LLVM dialect-compatible vector of signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps2(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((::llvm::isa<::mlir::LLVM::LLVMPointerType>(type))) || (((::mlir::LLVM::isCompatibleVectorType(type))) && ((::llvm::isa<::mlir::LLVM::LLVMPointerType>(::mlir::LLVM::getVectorElementType(type))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps3(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::LLVM::LLVMPointerType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps4(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isSignlessInteger()))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps5(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isSignlessInteger())) || ((::llvm::isa<::mlir::LLVM::LLVMPointerType>(type))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be signless integer or LLVM pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps6(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::LLVM::LLVMStructType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM structure type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps7(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((::mlir::LLVM::isCompatibleFloatingPointType(type))) || ((::llvm::isa<::mlir::LLVM::LLVMPointerType>(type))) || ((type.isSignlessInteger())))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be floating point LLVM type or LLVM pointer type or signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps8(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((::mlir::LLVM::isCompatibleOuterType(type))) && (!((::llvm::isa<::mlir::LLVM::LLVMStructType, ::mlir::LLVM::LLVMArrayType>(type)))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM-compatible non-aggregate type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps9(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::mlir::LLVM::isCompatibleOuterType(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of LLVM dialect-compatible type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps10(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::mlir::LLVM::isCompatibleOuterType(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM dialect-compatible type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps11(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isSignlessInteger(1)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 1-bit signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps12(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::mlir::LLVM::isCompatibleVectorType(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM dialect-compatible vector type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps13(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::LLVM::LLVMStructType, ::mlir::LLVM::LLVMArrayType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM aggregate type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps14(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((::mlir::LLVM::isCompatibleFloatingPointType(type))) || (((::mlir::LLVM::isCompatibleVectorType(type))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType(type))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps15(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isSignlessInteger(1))) || (((::mlir::LLVM::isCompatibleVectorType(type))) && ((::mlir::LLVM::getVectorElementType(type).isSignlessInteger(1)))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 1-bit signless integer or LLVM dialect-compatible vector of 1-bit signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps16(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isSignlessInteger())) || (((::mlir::LLVM::isCompatibleVectorType(type))) && ((::mlir::LLVM::getVectorElementType(type).isSignlessInteger()))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of signless integer or LLVM dialect-compatible vector of signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps17(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isSignlessInteger())) || (((::mlir::LLVM::isCompatibleVectorType(type))) && ((::mlir::LLVM::getVectorElementType(type).isSignlessInteger())))) || (((::llvm::isa<::mlir::LLVM::LLVMPointerType>(type))) || (((::mlir::LLVM::isCompatibleVectorType(type))) && ((::llvm::isa<::mlir::LLVM::LLVMPointerType>(::mlir::LLVM::getVectorElementType(type)))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be signless integer or LLVM dialect-compatible vector of signless integer or LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps18(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((::mlir::LLVM::isCompatibleOuterType(type))) && ((!::llvm::isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>(type))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be primitive LLVM type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps19(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((((::mlir::LLVM::isCompatibleOuterType(type))) && ((!::llvm::isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>(type)))) && (!(((::llvm::isa<::mlir::LLVM::LLVMStructType>(type))) && ((::llvm::cast<::mlir::LLVM::LLVMStructType>(type).isOpaque())))) && (!(((::llvm::isa<::mlir::LLVM::LLVMTargetExtType>(type))) && ((!::llvm::cast<::mlir::LLVM::LLVMTargetExtType>(type).supportsMemOps()))))) || ((::llvm::isa<::mlir::LLVM::PointerElementTypeInterface>(type))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM type with size, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps20(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::LLVM::LLVMTokenType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be LLVM token type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_LLVMOps21(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of any type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps1(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::FlatSymbolRefAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: flat symbol reference attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps1(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps1(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps2(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(64)))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: 64-bit signless integer attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps2(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps2(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps3(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::TypeAttr>(attr))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(attr).getValue()))) && ((true))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: any type attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps3(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps3(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps4(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::UnitAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: unit attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps4(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps4(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps5(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::AtomicOrderingAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: Atomic ordering for LLVM's memory model";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps5(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps5(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps6(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::StringAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: string attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps6(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps6(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps7(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AccessGroupAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM dialect access group metadata array";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps7(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps7(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps8(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM dialect alias scope array";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps8(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps8(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps9(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::TBAATagAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM dialect TBAA tag metadata array";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps9(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps9(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps10(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::AtomicBinOpAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: llvm.atomicrmw binary operations";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps10(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps10(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps11(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::LoopAnnotationAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: ";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps11(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps11(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps12(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM fastmath flags";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps12(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps12(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps13(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::TypeAttr>(attr))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(attr).getValue()))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(attr).getValue())))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: type attribute of LLVM function type";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps13(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps13(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps14(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: i32 dense array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps14(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps14(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps15(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::CConvAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM Calling Convention specification";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps15(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps15(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps16(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::TailCallKindAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM Calling Convention specification";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps16(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps16(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps17(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::MemoryEffectsAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: ";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps17(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps17(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps18(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::comdat::ComdatAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM Comdat Types";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps18(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps18(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps19(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((true)))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: any attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps19(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps19(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps20(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::DenseI64ArrayAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: i64 dense array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps20(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps20(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps21(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::FCmpPredicateAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: llvm.fcmp comparison predicate";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps21(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps21(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps22(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::FlatSymbolRefAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: flat symbol ref array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps22(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps22(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps23(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && (((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(32)))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: 32-bit integer array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps23(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps23(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps24(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::LinkageAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM Linkage specification";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps24(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps24(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps25(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(32)))) && ((!::llvm::cast<::mlir::IntegerAttr>(attr).getValue().isNegative()))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: 32-bit signless integer attribute whose value is non-negative";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps25(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps25(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps26(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::UnnamedAddrAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM GlobalValue UnnamedAddr";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps26(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps26(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps27(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::SymbolRefAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: symbol reference attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps27(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps27(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps28(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::DIGlobalVariableExpressionAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: ";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps28(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps28(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps29(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::VisibilityAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM GlobalValue Visibility";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps29(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps29(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps30(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::ICmpPredicateAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: lvm.icmp comparison predicate";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps30(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps30(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps31(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::AsmDialectAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: ATT (0) or Intel (1) asm dialect";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps31(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps31(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps32(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::ArrayAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps32(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps32(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps33(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::DictionaryAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: Array of dictionary attributes";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps33(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps33(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps34(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::VScaleRangeAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: ";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps34(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps34(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps35(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::FramePointerKindAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: ";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps35(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps35(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps36(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::TargetFeaturesAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: LLVM target features attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps36(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps36(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps37(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::BoolAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: bool attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps37(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps37(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps38(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::LLVM::VecTypeHintAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: Explicit vectorization compiler hint";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps38(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps38(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps39(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(32)))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: 32-bit signless integer attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps39(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps39(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps40(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::StringAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: string array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps40(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps40(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps41(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::DenseIntElementsAttr>(attr))) && ((true))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: integer elements attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_LLVMOps41(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_LLVMOps41(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_region_constraint_LLVMOps1(
    ::mlir::Operation *op, ::mlir::Region &region, ::llvm::StringRef regionName,
    unsigned regionIndex) {
  if (!((::llvm::hasNItems(region, 1)))) {
    return op->emitOpError("region #") << regionIndex
        << (regionName.empty() ? " " : " ('" + regionName + "') ")
        << "failed to verify constraint: region with 1 blocks";
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_region_constraint_LLVMOps2(
    ::mlir::Operation *op, ::mlir::Region &region, ::llvm::StringRef regionName,
    unsigned regionIndex) {
  if (!((true))) {
    return op->emitOpError("region #") << regionIndex
        << (regionName.empty() ? " " : " ('" + regionName + "') ")
        << "failed to verify constraint: any region";
  }
  return ::mlir::success();
}
} // namespace LLVM
} // namespace mlir
namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AShrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AShrOpAdaptor::AShrOpAdaptor(AShrOp op) : AShrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AShrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void AShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void AShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(AShrOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void AShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AShrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(AShrOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult AShrOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AShrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult AShrOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult AShrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AShrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void AShrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AShrOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AddOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
AddOpGenericAdaptorBase::AddOpGenericAdaptorBase(AddOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

} // namespace detail
AddOpAdaptor::AddOpAdaptor(AddOp op) : AddOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::LogicalResult AddOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }
    {

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("overflowFlags");;
;
      if (attr) {
        if (::mlir::failed(setFromAttr(prop.overflowFlags, attr, emitError)))
          return ::mlir::failure();
      } else {
        prop.overflowFlags = IntegerOverflowFlags::none;
      }
  }
  return ::mlir::success();
}

::mlir::Attribute AddOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.overflowFlags;
      auto attr = [&]() -> ::mlir::Attribute {
        return convertToAttribute(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("overflowFlags", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AddOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    ::llvm::hash_value(prop.overflowFlags));
}

std::optional<mlir::Attribute> AddOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
  return std::nullopt;
}

void AddOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
}

void AddOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
}

::llvm::LogicalResult AddOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    return ::mlir::success();
}

::llvm::LogicalResult AddOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  {
    auto &propStorage = prop.overflowFlags;
    auto readProp = [&]() {
      uint64_t val;
    if (failed(reader.readVarInt(val)))
      return ::mlir::failure();
    propStorage = static_cast<IntegerOverflowFlags>(val);;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void AddOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  {
    auto &propStorage = prop.overflowFlags;
    writer.writeVarInt(static_cast<uint64_t>(propStorage));;
  }
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  odsState.addTypes(res);
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(AddOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AddOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AddOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(AddOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult AddOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AddOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult AddOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult AddOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseOverflowFlags(parser, result.getOrAddProperties<Properties>().overflowFlags);
    if (odsResult) return ::mlir::failure();
  }
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AddOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  printOverflowFlags(_odsPrinter, *this, getProperties().overflowFlags);
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void AddOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AddOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AddrSpaceCastOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AddrSpaceCastOpAdaptor::AddrSpaceCastOpAdaptor(AddrSpaceCastOp op) : AddrSpaceCastOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AddrSpaceCastOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AddrSpaceCastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void AddrSpaceCastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void AddrSpaceCastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddrSpaceCastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AddrSpaceCastOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AddrSpaceCastOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult AddrSpaceCastOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AddrSpaceCastOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void AddrSpaceCastOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AddrSpaceCastOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AddressOfOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
AddressOfOpGenericAdaptorBase::AddressOfOpGenericAdaptorBase(AddressOfOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef AddressOfOpGenericAdaptorBase::getGlobalName() {
  auto attr = getGlobalNameAttr();
  return attr.getValue();
}

} // namespace detail
AddressOfOpAdaptor::AddressOfOpAdaptor(AddressOfOp op) : AddressOfOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AddressOfOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_global_name = getProperties().global_name; (void)tblgen_global_name;
  if (!tblgen_global_name) return emitError(loc, "'llvm.mlir.addressof' op ""requires attribute 'global_name'");

  if (tblgen_global_name && !((::llvm::isa<::mlir::FlatSymbolRefAttr>(tblgen_global_name))))
    return emitError(loc, "'llvm.mlir.addressof' op ""attribute 'global_name' failed to satisfy constraint: flat symbol reference attribute");
  return ::mlir::success();
}

::llvm::LogicalResult AddressOfOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.global_name;
       auto attr = dict.get("global_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `global_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AddressOfOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.global_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("global_name",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AddressOfOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.global_name.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AddressOfOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "global_name")
      return prop.global_name;
  return std::nullopt;
}

void AddressOfOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "global_name") {
       prop.global_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.global_name)>>(value);
       return;
    }
}

void AddressOfOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.global_name) attrs.append("global_name", prop.global_name);
}

::llvm::LogicalResult AddressOfOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getGlobalNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(attr, "global_name", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AddressOfOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.global_name)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AddressOfOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.global_name);
}

::llvm::StringRef AddressOfOp::getGlobalName() {
  auto attr = getGlobalNameAttr();
  return attr.getValue();
}

void AddressOfOp::setGlobalName(::llvm::StringRef attrValue) {
  getProperties().global_name = ::mlir::SymbolRefAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, GlobalOp global, ArrayRef<NamedAttribute> attrs) {
      build(odsBuilder, odsState,
            LLVM::LLVMPointerType::get(odsBuilder.getContext(), global.getAddrSpace()),
            global.getSymName());
      odsState.addAttributes(attrs);
    
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, LLVMFuncOp func, ArrayRef<NamedAttribute> attrs) {
      build(odsBuilder, odsState,
            LLVM::LLVMPointerType::get(odsBuilder.getContext()), func.getName());
      odsState.addAttributes(attrs);
    
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::FlatSymbolRefAttr global_name) {
  odsState.getOrAddProperties<Properties>().global_name = global_name;
  odsState.addTypes(res);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::FlatSymbolRefAttr global_name) {
  odsState.getOrAddProperties<Properties>().global_name = global_name;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::llvm::StringRef global_name) {
  odsState.getOrAddProperties<Properties>().global_name = ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), global_name);
  odsState.addTypes(res);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef global_name) {
  odsState.getOrAddProperties<Properties>().global_name = ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), global_name);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddressOfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AddressOfOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AddressOfOp::verifyInvariantsImpl() {
  auto tblgen_global_name = getProperties().global_name; (void)tblgen_global_name;
  if (!tblgen_global_name) return emitOpError("requires attribute 'global_name'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(*this, tblgen_global_name, "global_name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AddressOfOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult AddressOfOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::FlatSymbolRefAttr global_nameAttr;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  if (parser.parseCustomAttributeWithFallback(global_nameAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (global_nameAttr) result.getOrAddProperties<AddressOfOp::Properties>().global_name = global_nameAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resRawType))
    return ::mlir::failure();
  result.addTypes(resTypes);
  return ::mlir::success();
}

void AddressOfOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getGlobalNameAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("global_name");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
   _odsPrinter << getRes().getType();
}

void AddressOfOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AddressOfOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AllocaOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
AllocaOpGenericAdaptorBase::AllocaOpGenericAdaptorBase(AllocaOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::std::optional<uint64_t> AllocaOpGenericAdaptorBase::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::mlir::Type AllocaOpGenericAdaptorBase::getElemType() {
  auto attr = getElemTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

::mlir::UnitAttr AllocaOpGenericAdaptorBase::getInallocaAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().inalloca);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool AllocaOpGenericAdaptorBase::getInalloca() {
  auto attr = getInallocaAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
AllocaOpAdaptor::AllocaOpAdaptor(AllocaOp op) : AllocaOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AllocaOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_elem_type = getProperties().elem_type; (void)tblgen_elem_type;
  if (!tblgen_elem_type) return emitError(loc, "'llvm.alloca' op ""requires attribute 'elem_type'");
  auto tblgen_inalloca = getProperties().inalloca; (void)tblgen_inalloca;

  if (tblgen_alignment && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_alignment))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_alignment).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.alloca' op ""attribute 'alignment' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_elem_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_elem_type))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(tblgen_elem_type).getValue()))) && ((true))))
    return emitError(loc, "'llvm.alloca' op ""attribute 'elem_type' failed to satisfy constraint: any type attribute");

  if (tblgen_inalloca && !((::llvm::isa<::mlir::UnitAttr>(tblgen_inalloca))))
    return emitError(loc, "'llvm.alloca' op ""attribute 'inalloca' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

::llvm::LogicalResult AllocaOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.alignment;
       auto attr = dict.get("alignment");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alignment` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.elem_type;
       auto attr = dict.get("elem_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `elem_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.inalloca;
       auto attr = dict.get("inalloca");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `inalloca` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AllocaOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.alignment;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alignment",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.elem_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("elem_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.inalloca;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("inalloca",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AllocaOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.alignment.getAsOpaquePointer()), 
    llvm::hash_value(prop.elem_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.inalloca.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AllocaOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "alignment")
      return prop.alignment;

    if (name == "elem_type")
      return prop.elem_type;

    if (name == "inalloca")
      return prop.inalloca;
  return std::nullopt;
}

void AllocaOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "alignment") {
       prop.alignment = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alignment)>>(value);
       return;
    }

    if (name == "elem_type") {
       prop.elem_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.elem_type)>>(value);
       return;
    }

    if (name == "inalloca") {
       prop.inalloca = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.inalloca)>>(value);
       return;
    }
}

void AllocaOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.alignment) attrs.append("alignment", prop.alignment);

    if (prop.elem_type) attrs.append("elem_type", prop.elem_type);

    if (prop.inalloca) attrs.append("inalloca", prop.inalloca);
}

::llvm::LogicalResult AllocaOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAlignmentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "alignment", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getElemTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps3(attr, "elem_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInallocaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "inalloca", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AllocaOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.alignment)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.elem_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.inalloca)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AllocaOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.alignment);
  writer.writeAttribute(prop.elem_type);

  writer.writeOptionalAttribute(prop.inalloca);
}

::std::optional<uint64_t> AllocaOp::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::mlir::Type AllocaOp::getElemType() {
  auto attr = getElemTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

bool AllocaOp::getInalloca() {
  auto attr = getInallocaAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void AllocaOp::setAlignment(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().alignment;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void AllocaOp::setElemType(::mlir::Type attrValue) {
  getProperties().elem_type = ::mlir::TypeAttr::get(attrValue);
}

void AllocaOp::setInalloca(bool attrValue) {
    auto &odsProp = getProperties().inalloca;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void AllocaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, Type elementType, Value arraySize, unsigned alignment) {
      build(odsBuilder, odsState, resultType, arraySize,
            alignment == 0 ? IntegerAttr()
                           : odsBuilder.getI64IntegerAttr(alignment),
            elementType, false);

    
}

void AllocaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arraySize, /*optional*/::mlir::IntegerAttr alignment, ::mlir::TypeAttr elem_type, /*optional*/::mlir::UnitAttr inalloca) {
  odsState.addOperands(arraySize);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  odsState.getOrAddProperties<Properties>().elem_type = elem_type;
  if (inalloca) {
    odsState.getOrAddProperties<Properties>().inalloca = inalloca;
  }
  odsState.addTypes(res);
}

void AllocaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arraySize, /*optional*/::mlir::IntegerAttr alignment, ::mlir::TypeAttr elem_type, /*optional*/::mlir::UnitAttr inalloca) {
  odsState.addOperands(arraySize);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  odsState.getOrAddProperties<Properties>().elem_type = elem_type;
  if (inalloca) {
    odsState.getOrAddProperties<Properties>().inalloca = inalloca;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllocaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arraySize, /*optional*/::mlir::IntegerAttr alignment, ::mlir::Type elem_type, /*optional*/bool inalloca) {
  odsState.addOperands(arraySize);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  odsState.getOrAddProperties<Properties>().elem_type = ::mlir::TypeAttr::get(elem_type);
  if (inalloca) {
    odsState.getOrAddProperties<Properties>().inalloca = ((inalloca) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.addTypes(res);
}

void AllocaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arraySize, /*optional*/::mlir::IntegerAttr alignment, ::mlir::Type elem_type, /*optional*/bool inalloca) {
  odsState.addOperands(arraySize);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  odsState.getOrAddProperties<Properties>().elem_type = ::mlir::TypeAttr::get(elem_type);
  if (inalloca) {
    odsState.getOrAddProperties<Properties>().inalloca = ((inalloca) ? odsBuilder.getUnitAttr() : nullptr);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllocaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AllocaOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AllocaOp::verifyInvariantsImpl() {
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_elem_type = getProperties().elem_type; (void)tblgen_elem_type;
  if (!tblgen_elem_type) return emitOpError("requires attribute 'elem_type'");
  auto tblgen_inalloca = getProperties().inalloca; (void)tblgen_inalloca;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_alignment, "alignment")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps3(*this, tblgen_elem_type, "elem_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_inalloca, "inalloca")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AllocaOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void AllocaOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  {
    auto valueRange = getODSResultIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Allocate::get(), getOperation()->getOpResult(idx), 0, false, ::mlir::SideEffects::AutomaticAllocationScopeResource::get());
    }
  }
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AllocaOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AndOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AndOpAdaptor::AndOpAdaptor(AndOp op) : AndOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(AndOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(AndOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult AndOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AndOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult AndOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult AndOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AndOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void AndOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AndOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AtomicCmpXchgOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
AtomicCmpXchgOpGenericAdaptorBase::AtomicCmpXchgOpGenericAdaptorBase(AtomicCmpXchgOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::AtomicOrdering AtomicCmpXchgOpGenericAdaptorBase::getSuccessOrdering() {
  auto attr = getSuccessOrderingAttr();
  return attr.getValue();
}

::mlir::LLVM::AtomicOrdering AtomicCmpXchgOpGenericAdaptorBase::getFailureOrdering() {
  auto attr = getFailureOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > AtomicCmpXchgOpGenericAdaptorBase::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<uint64_t> AtomicCmpXchgOpGenericAdaptorBase::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::mlir::UnitAttr AtomicCmpXchgOpGenericAdaptorBase::getWeakAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().weak);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool AtomicCmpXchgOpGenericAdaptorBase::getWeak() {
  auto attr = getWeakAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr AtomicCmpXchgOpGenericAdaptorBase::getVolatile_Attr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().volatile_);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool AtomicCmpXchgOpGenericAdaptorBase::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOpGenericAdaptorBase::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOpGenericAdaptorBase::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOpGenericAdaptorBase::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOpGenericAdaptorBase::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
AtomicCmpXchgOpAdaptor::AtomicCmpXchgOpAdaptor(AtomicCmpXchgOp op) : AtomicCmpXchgOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AtomicCmpXchgOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_failure_ordering = getProperties().failure_ordering; (void)tblgen_failure_ordering;
  if (!tblgen_failure_ordering) return emitError(loc, "'llvm.cmpxchg' op ""requires attribute 'failure_ordering'");
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_success_ordering = getProperties().success_ordering; (void)tblgen_success_ordering;
  if (!tblgen_success_ordering) return emitError(loc, "'llvm.cmpxchg' op ""requires attribute 'success_ordering'");
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;
  auto tblgen_weak = getProperties().weak; (void)tblgen_weak;

  if (tblgen_success_ordering && !((::llvm::isa<::mlir::LLVM::AtomicOrderingAttr>(tblgen_success_ordering))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'success_ordering' failed to satisfy constraint: Atomic ordering for LLVM's memory model");

  if (tblgen_failure_ordering && !((::llvm::isa<::mlir::LLVM::AtomicOrderingAttr>(tblgen_failure_ordering))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'failure_ordering' failed to satisfy constraint: Atomic ordering for LLVM's memory model");

  if (tblgen_syncscope && !((::llvm::isa<::mlir::StringAttr>(tblgen_syncscope))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'syncscope' failed to satisfy constraint: string attribute");

  if (tblgen_alignment && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_alignment))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_alignment).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'alignment' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_weak && !((::llvm::isa<::mlir::UnitAttr>(tblgen_weak))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'weak' failed to satisfy constraint: unit attribute");

  if (tblgen_volatile_ && !((::llvm::isa<::mlir::UnitAttr>(tblgen_volatile_))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'volatile_' failed to satisfy constraint: unit attribute");

  if (tblgen_access_groups && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_access_groups))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_access_groups), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AccessGroupAttr>(attr))); }))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'access_groups' failed to satisfy constraint: LLVM dialect access group metadata array");

  if (tblgen_alias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_alias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_alias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'alias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_noalias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_noalias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_noalias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'noalias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_tbaa && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_tbaa))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_tbaa), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::TBAATagAttr>(attr))); }))))
    return emitError(loc, "'llvm.cmpxchg' op ""attribute 'tbaa' failed to satisfy constraint: LLVM dialect TBAA tag metadata array");
  return ::mlir::success();
}

::llvm::LogicalResult AtomicCmpXchgOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.access_groups;
       auto attr = dict.get("access_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `access_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alias_scopes;
       auto attr = dict.get("alias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alignment;
       auto attr = dict.get("alignment");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alignment` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.failure_ordering;
       auto attr = dict.get("failure_ordering");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `failure_ordering` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.noalias_scopes;
       auto attr = dict.get("noalias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `noalias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.success_ordering;
       auto attr = dict.get("success_ordering");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `success_ordering` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.syncscope;
       auto attr = dict.get("syncscope");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `syncscope` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tbaa;
       auto attr = dict.get("tbaa");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tbaa` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.volatile_;
       auto attr = dict.get("volatile_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `volatile_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.weak;
       auto attr = dict.get("weak");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `weak` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AtomicCmpXchgOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.access_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("access_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alignment;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alignment",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.failure_ordering;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("failure_ordering",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.noalias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("noalias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.success_ordering;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("success_ordering",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.syncscope;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("syncscope",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tbaa;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tbaa",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.volatile_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("volatile_",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.weak;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("weak",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AtomicCmpXchgOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.access_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.alias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.alignment.getAsOpaquePointer()), 
    llvm::hash_value(prop.failure_ordering.getAsOpaquePointer()), 
    llvm::hash_value(prop.noalias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.success_ordering.getAsOpaquePointer()), 
    llvm::hash_value(prop.syncscope.getAsOpaquePointer()), 
    llvm::hash_value(prop.tbaa.getAsOpaquePointer()), 
    llvm::hash_value(prop.volatile_.getAsOpaquePointer()), 
    llvm::hash_value(prop.weak.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AtomicCmpXchgOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "access_groups")
      return prop.access_groups;

    if (name == "alias_scopes")
      return prop.alias_scopes;

    if (name == "alignment")
      return prop.alignment;

    if (name == "failure_ordering")
      return prop.failure_ordering;

    if (name == "noalias_scopes")
      return prop.noalias_scopes;

    if (name == "success_ordering")
      return prop.success_ordering;

    if (name == "syncscope")
      return prop.syncscope;

    if (name == "tbaa")
      return prop.tbaa;

    if (name == "volatile_")
      return prop.volatile_;

    if (name == "weak")
      return prop.weak;
  return std::nullopt;
}

void AtomicCmpXchgOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "access_groups") {
       prop.access_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.access_groups)>>(value);
       return;
    }

    if (name == "alias_scopes") {
       prop.alias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alias_scopes)>>(value);
       return;
    }

    if (name == "alignment") {
       prop.alignment = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alignment)>>(value);
       return;
    }

    if (name == "failure_ordering") {
       prop.failure_ordering = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.failure_ordering)>>(value);
       return;
    }

    if (name == "noalias_scopes") {
       prop.noalias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.noalias_scopes)>>(value);
       return;
    }

    if (name == "success_ordering") {
       prop.success_ordering = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.success_ordering)>>(value);
       return;
    }

    if (name == "syncscope") {
       prop.syncscope = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.syncscope)>>(value);
       return;
    }

    if (name == "tbaa") {
       prop.tbaa = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tbaa)>>(value);
       return;
    }

    if (name == "volatile_") {
       prop.volatile_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.volatile_)>>(value);
       return;
    }

    if (name == "weak") {
       prop.weak = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.weak)>>(value);
       return;
    }
}

void AtomicCmpXchgOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.access_groups) attrs.append("access_groups", prop.access_groups);

    if (prop.alias_scopes) attrs.append("alias_scopes", prop.alias_scopes);

    if (prop.alignment) attrs.append("alignment", prop.alignment);

    if (prop.failure_ordering) attrs.append("failure_ordering", prop.failure_ordering);

    if (prop.noalias_scopes) attrs.append("noalias_scopes", prop.noalias_scopes);

    if (prop.success_ordering) attrs.append("success_ordering", prop.success_ordering);

    if (prop.syncscope) attrs.append("syncscope", prop.syncscope);

    if (prop.tbaa) attrs.append("tbaa", prop.tbaa);

    if (prop.volatile_) attrs.append("volatile_", prop.volatile_);

    if (prop.weak) attrs.append("weak", prop.weak);
}

::llvm::LogicalResult AtomicCmpXchgOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAccessGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(attr, "access_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "alias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAlignmentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "alignment", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFailureOrderingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(attr, "failure_ordering", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoaliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "noalias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSuccessOrderingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(attr, "success_ordering", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSyncscopeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "syncscope", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTbaaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(attr, "tbaa", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVolatile_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "volatile_", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWeakAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "weak", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AtomicCmpXchgOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.access_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alignment)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.failure_ordering)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.noalias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.success_ordering)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.syncscope)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tbaa)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.volatile_)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.weak)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicCmpXchgOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.access_groups);

  writer.writeOptionalAttribute(prop.alias_scopes);

  writer.writeOptionalAttribute(prop.alignment);
  writer.writeAttribute(prop.failure_ordering);

  writer.writeOptionalAttribute(prop.noalias_scopes);
  writer.writeAttribute(prop.success_ordering);

  writer.writeOptionalAttribute(prop.syncscope);

  writer.writeOptionalAttribute(prop.tbaa);

  writer.writeOptionalAttribute(prop.volatile_);

  writer.writeOptionalAttribute(prop.weak);
}

::mlir::LLVM::AtomicOrdering AtomicCmpXchgOp::getSuccessOrdering() {
  auto attr = getSuccessOrderingAttr();
  return attr.getValue();
}

::mlir::LLVM::AtomicOrdering AtomicCmpXchgOp::getFailureOrdering() {
  auto attr = getFailureOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > AtomicCmpXchgOp::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<uint64_t> AtomicCmpXchgOp::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

bool AtomicCmpXchgOp::getWeak() {
  auto attr = getWeakAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool AtomicCmpXchgOp::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOp::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOp::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOp::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicCmpXchgOp::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void AtomicCmpXchgOp::setSuccessOrdering(::mlir::LLVM::AtomicOrdering attrValue) {
  getProperties().success_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void AtomicCmpXchgOp::setFailureOrdering(::mlir::LLVM::AtomicOrdering attrValue) {
  getProperties().failure_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void AtomicCmpXchgOp::setSyncscope(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().syncscope;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void AtomicCmpXchgOp::setAlignment(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().alignment;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void AtomicCmpXchgOp::setWeak(bool attrValue) {
    auto &odsProp = getProperties().weak;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void AtomicCmpXchgOp::setVolatile_(bool attrValue) {
    auto &odsProp = getProperties().volatile_;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value ptr, ::mlir::Value cmp, ::mlir::Value val, ::mlir::LLVM::AtomicOrderingAttr success_ordering, ::mlir::LLVM::AtomicOrderingAttr failure_ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr weak, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(cmp);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().success_ordering = success_ordering;
  odsState.getOrAddProperties<Properties>().failure_ordering = failure_ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (weak) {
    odsState.getOrAddProperties<Properties>().weak = weak;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(res);
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ptr, ::mlir::Value cmp, ::mlir::Value val, ::mlir::LLVM::AtomicOrderingAttr success_ordering, ::mlir::LLVM::AtomicOrderingAttr failure_ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr weak, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(cmp);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().success_ordering = success_ordering;
  odsState.getOrAddProperties<Properties>().failure_ordering = failure_ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (weak) {
    odsState.getOrAddProperties<Properties>().weak = weak;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(AtomicCmpXchgOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ptr, ::mlir::Value cmp, ::mlir::Value val, ::mlir::LLVM::AtomicOrderingAttr success_ordering, ::mlir::LLVM::AtomicOrderingAttr failure_ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr weak, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(cmp);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().success_ordering = success_ordering;
  odsState.getOrAddProperties<Properties>().failure_ordering = failure_ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (weak) {
    odsState.getOrAddProperties<Properties>().weak = weak;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value ptr, ::mlir::Value cmp, ::mlir::Value val, ::mlir::LLVM::AtomicOrdering success_ordering, ::mlir::LLVM::AtomicOrdering failure_ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool weak, /*optional*/bool volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(cmp);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().success_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), success_ordering);
  odsState.getOrAddProperties<Properties>().failure_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), failure_ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (weak) {
    odsState.getOrAddProperties<Properties>().weak = ((weak) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(res);
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ptr, ::mlir::Value cmp, ::mlir::Value val, ::mlir::LLVM::AtomicOrdering success_ordering, ::mlir::LLVM::AtomicOrdering failure_ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool weak, /*optional*/bool volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(cmp);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().success_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), success_ordering);
  odsState.getOrAddProperties<Properties>().failure_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), failure_ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (weak) {
    odsState.getOrAddProperties<Properties>().weak = ((weak) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(AtomicCmpXchgOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ptr, ::mlir::Value cmp, ::mlir::Value val, ::mlir::LLVM::AtomicOrdering success_ordering, ::mlir::LLVM::AtomicOrdering failure_ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool weak, /*optional*/bool volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(cmp);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().success_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), success_ordering);
  odsState.getOrAddProperties<Properties>().failure_ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), failure_ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (weak) {
    odsState.getOrAddProperties<Properties>().weak = ((weak) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AtomicCmpXchgOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void AtomicCmpXchgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AtomicCmpXchgOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(AtomicCmpXchgOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult AtomicCmpXchgOp::verifyInvariantsImpl() {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_failure_ordering = getProperties().failure_ordering; (void)tblgen_failure_ordering;
  if (!tblgen_failure_ordering) return emitOpError("requires attribute 'failure_ordering'");
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_success_ordering = getProperties().success_ordering; (void)tblgen_success_ordering;
  if (!tblgen_success_ordering) return emitOpError("requires attribute 'success_ordering'");
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;
  auto tblgen_weak = getProperties().weak; (void)tblgen_weak;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(*this, tblgen_success_ordering, "success_ordering")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(*this, tblgen_failure_ordering, "failure_ordering")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_syncscope, "syncscope")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_alignment, "alignment")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_weak, "weak")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_volatile_, "volatile_")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(*this, tblgen_access_groups, "access_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_alias_scopes, "alias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_noalias_scopes, "noalias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(*this, tblgen_tbaa, "tbaa")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps6(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(2).begin()).getType(), (*this->getODSOperands(1).begin()).getType()))))
    return emitOpError("failed to verify that operand #1 and operand #2 have the same type");
  if (!((std::equal_to<>()(getValAndBoolStructType((*this->getODSOperands(2).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result #0 has an LLVM struct type consisting of the type of operand #2 and a bool");
  return ::mlir::success();
}

::llvm::LogicalResult AtomicCmpXchgOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::llvm::LogicalResult AtomicCmpXchgOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = getValAndBoolStructType(operands[2].getType());
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult AtomicCmpXchgOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand ptrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> ptrOperands(&ptrRawOperand, 1);  ::llvm::SMLoc ptrOperandsLoc;
  (void)ptrOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand cmpRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> cmpOperands(&cmpRawOperand, 1);  ::llvm::SMLoc cmpOperandsLoc;
  (void)cmpOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand valRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valOperands(&valRawOperand, 1);  ::llvm::SMLoc valOperandsLoc;
  (void)valOperandsLoc;
  ::mlir::StringAttr syncscopeAttr;
  ::mlir::LLVM::AtomicOrderingAttr success_orderingAttr;
  ::mlir::LLVM::AtomicOrderingAttr failure_orderingAttr;
  ::mlir::Type ptrRawType{};
  ::llvm::ArrayRef<::mlir::Type> ptrTypes(&ptrRawType, 1);
  ::mlir::Type valRawType{};
  ::llvm::ArrayRef<::mlir::Type> valTypes(&valRawType, 1);
  if (::mlir::succeeded(parser.parseOptionalKeyword("weak"))) {
    result.getOrAddProperties<AtomicCmpXchgOp::Properties>().weak = parser.getBuilder().getUnitAttr();  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("volatile"))) {
    result.getOrAddProperties<AtomicCmpXchgOp::Properties>().volatile_ = parser.getBuilder().getUnitAttr();  }

  ptrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(ptrRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  cmpOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(cmpRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  valOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valRawOperand))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("syncscope"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(syncscopeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (syncscopeAttr) result.getOrAddProperties<AtomicCmpXchgOp::Properties>().syncscope = syncscopeAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  }

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"not_atomic","unordered","monotonic","acquire","release","acq_rel","seq_cst"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "success_ordering", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'success_ordering' [not_atomic, unordered, monotonic, acquire, release, acq_rel, seq_cst]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAtomicOrdering(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "success_ordering attribute specification: \"" << attrStr << '"';;

      success_orderingAttr = ::mlir::LLVM::AtomicOrderingAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<AtomicCmpXchgOp::Properties>().success_ordering = success_orderingAttr;
    }
  }

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"not_atomic","unordered","monotonic","acquire","release","acq_rel","seq_cst"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "failure_ordering", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'failure_ordering' [not_atomic, unordered, monotonic, acquire, release, acq_rel, seq_cst]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAtomicOrdering(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "failure_ordering attribute specification: \"" << attrStr << '"';;

      failure_orderingAttr = ::mlir::LLVM::AtomicOrderingAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<AtomicCmpXchgOp::Properties>().failure_ordering = failure_orderingAttr;
    }
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(ptrRawType))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valRawType = type;
  }
  for (::mlir::Type type : valTypes) {
    (void)type;
    if (!(((type.isSignlessInteger())) || ((::llvm::isa<::mlir::LLVM::LLVMPointerType>(type))))) {
      return parser.emitError(parser.getNameLoc()) << "'val' must be signless integer or LLVM pointer type, but got " << type;
    }
  }
  result.addTypes(getValAndBoolStructType(valTypes[0]));
  if (parser.resolveOperands(ptrOperands, ptrTypes, ptrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(cmpOperands, valTypes[0], cmpOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(valOperands, valTypes, valOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicCmpXchgOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getWeakAttr() && getWeakAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "weak";
  }
  if ((getVolatile_Attr() && getVolatile_Attr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "volatile";
  }
  _odsPrinter << ' ';
  _odsPrinter << getPtr();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getCmp();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getVal();
  if (getSyncscopeAttr()) {
    _odsPrinter << ' ' << "syncscope";
    _odsPrinter << "(";
    _odsPrinter.printAttributeWithoutType(getSyncscopeAttr());
    _odsPrinter << ")";
  }
  _odsPrinter << ' ';

  {
    auto caseValue = getSuccessOrdering();
    auto caseValueStr = stringifyAtomicOrdering(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ' ';

  {
    auto caseValue = getFailureOrdering();
    auto caseValueStr = stringifyAtomicOrdering(caseValue);
    _odsPrinter << caseValueStr;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("weak");
  elidedAttrs.push_back("volatile_");
  elidedAttrs.push_back("syncscope");
  elidedAttrs.push_back("success_ordering");
  elidedAttrs.push_back("failure_ordering");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getWeakAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("weak");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getVolatile_Attr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("volatile_");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
   _odsPrinter << getPtr().getType();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = getVal().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AtomicCmpXchgOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::AtomicRMWOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
AtomicRMWOpGenericAdaptorBase::AtomicRMWOpGenericAdaptorBase(AtomicRMWOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::AtomicBinOp AtomicRMWOpGenericAdaptorBase::getBinOp() {
  auto attr = getBinOpAttr();
  return attr.getValue();
}

::mlir::LLVM::AtomicOrdering AtomicRMWOpGenericAdaptorBase::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > AtomicRMWOpGenericAdaptorBase::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<uint64_t> AtomicRMWOpGenericAdaptorBase::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::mlir::UnitAttr AtomicRMWOpGenericAdaptorBase::getVolatile_Attr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().volatile_);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool AtomicRMWOpGenericAdaptorBase::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOpGenericAdaptorBase::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOpGenericAdaptorBase::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOpGenericAdaptorBase::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOpGenericAdaptorBase::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
AtomicRMWOpAdaptor::AtomicRMWOpAdaptor(AtomicRMWOp op) : AtomicRMWOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AtomicRMWOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_bin_op = getProperties().bin_op; (void)tblgen_bin_op;
  if (!tblgen_bin_op) return emitError(loc, "'llvm.atomicrmw' op ""requires attribute 'bin_op'");
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  if (!tblgen_ordering) return emitError(loc, "'llvm.atomicrmw' op ""requires attribute 'ordering'");
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;

  if (tblgen_bin_op && !((::llvm::isa<::mlir::LLVM::AtomicBinOpAttr>(tblgen_bin_op))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'bin_op' failed to satisfy constraint: llvm.atomicrmw binary operations");

  if (tblgen_ordering && !((::llvm::isa<::mlir::LLVM::AtomicOrderingAttr>(tblgen_ordering))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'ordering' failed to satisfy constraint: Atomic ordering for LLVM's memory model");

  if (tblgen_syncscope && !((::llvm::isa<::mlir::StringAttr>(tblgen_syncscope))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'syncscope' failed to satisfy constraint: string attribute");

  if (tblgen_alignment && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_alignment))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_alignment).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'alignment' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_volatile_ && !((::llvm::isa<::mlir::UnitAttr>(tblgen_volatile_))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'volatile_' failed to satisfy constraint: unit attribute");

  if (tblgen_access_groups && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_access_groups))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_access_groups), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AccessGroupAttr>(attr))); }))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'access_groups' failed to satisfy constraint: LLVM dialect access group metadata array");

  if (tblgen_alias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_alias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_alias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'alias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_noalias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_noalias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_noalias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'noalias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_tbaa && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_tbaa))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_tbaa), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::TBAATagAttr>(attr))); }))))
    return emitError(loc, "'llvm.atomicrmw' op ""attribute 'tbaa' failed to satisfy constraint: LLVM dialect TBAA tag metadata array");
  return ::mlir::success();
}

::llvm::LogicalResult AtomicRMWOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.access_groups;
       auto attr = dict.get("access_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `access_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alias_scopes;
       auto attr = dict.get("alias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alignment;
       auto attr = dict.get("alignment");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alignment` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.bin_op;
       auto attr = dict.get("bin_op");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `bin_op` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.noalias_scopes;
       auto attr = dict.get("noalias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `noalias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.ordering;
       auto attr = dict.get("ordering");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `ordering` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.syncscope;
       auto attr = dict.get("syncscope");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `syncscope` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tbaa;
       auto attr = dict.get("tbaa");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tbaa` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.volatile_;
       auto attr = dict.get("volatile_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `volatile_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AtomicRMWOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.access_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("access_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alignment;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alignment",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.bin_op;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("bin_op",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.noalias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("noalias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.ordering;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("ordering",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.syncscope;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("syncscope",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tbaa;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tbaa",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.volatile_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("volatile_",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AtomicRMWOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.access_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.alias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.alignment.getAsOpaquePointer()), 
    llvm::hash_value(prop.bin_op.getAsOpaquePointer()), 
    llvm::hash_value(prop.noalias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.ordering.getAsOpaquePointer()), 
    llvm::hash_value(prop.syncscope.getAsOpaquePointer()), 
    llvm::hash_value(prop.tbaa.getAsOpaquePointer()), 
    llvm::hash_value(prop.volatile_.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AtomicRMWOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "access_groups")
      return prop.access_groups;

    if (name == "alias_scopes")
      return prop.alias_scopes;

    if (name == "alignment")
      return prop.alignment;

    if (name == "bin_op")
      return prop.bin_op;

    if (name == "noalias_scopes")
      return prop.noalias_scopes;

    if (name == "ordering")
      return prop.ordering;

    if (name == "syncscope")
      return prop.syncscope;

    if (name == "tbaa")
      return prop.tbaa;

    if (name == "volatile_")
      return prop.volatile_;
  return std::nullopt;
}

void AtomicRMWOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "access_groups") {
       prop.access_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.access_groups)>>(value);
       return;
    }

    if (name == "alias_scopes") {
       prop.alias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alias_scopes)>>(value);
       return;
    }

    if (name == "alignment") {
       prop.alignment = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alignment)>>(value);
       return;
    }

    if (name == "bin_op") {
       prop.bin_op = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.bin_op)>>(value);
       return;
    }

    if (name == "noalias_scopes") {
       prop.noalias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.noalias_scopes)>>(value);
       return;
    }

    if (name == "ordering") {
       prop.ordering = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.ordering)>>(value);
       return;
    }

    if (name == "syncscope") {
       prop.syncscope = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.syncscope)>>(value);
       return;
    }

    if (name == "tbaa") {
       prop.tbaa = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tbaa)>>(value);
       return;
    }

    if (name == "volatile_") {
       prop.volatile_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.volatile_)>>(value);
       return;
    }
}

void AtomicRMWOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.access_groups) attrs.append("access_groups", prop.access_groups);

    if (prop.alias_scopes) attrs.append("alias_scopes", prop.alias_scopes);

    if (prop.alignment) attrs.append("alignment", prop.alignment);

    if (prop.bin_op) attrs.append("bin_op", prop.bin_op);

    if (prop.noalias_scopes) attrs.append("noalias_scopes", prop.noalias_scopes);

    if (prop.ordering) attrs.append("ordering", prop.ordering);

    if (prop.syncscope) attrs.append("syncscope", prop.syncscope);

    if (prop.tbaa) attrs.append("tbaa", prop.tbaa);

    if (prop.volatile_) attrs.append("volatile_", prop.volatile_);
}

::llvm::LogicalResult AtomicRMWOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAccessGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(attr, "access_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "alias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAlignmentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "alignment", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getBinOpAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps10(attr, "bin_op", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoaliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "noalias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOrderingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(attr, "ordering", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSyncscopeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "syncscope", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTbaaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(attr, "tbaa", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVolatile_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "volatile_", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AtomicRMWOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.access_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alignment)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.bin_op)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.noalias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.ordering)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.syncscope)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tbaa)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.volatile_)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicRMWOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.access_groups);

  writer.writeOptionalAttribute(prop.alias_scopes);

  writer.writeOptionalAttribute(prop.alignment);
  writer.writeAttribute(prop.bin_op);

  writer.writeOptionalAttribute(prop.noalias_scopes);
  writer.writeAttribute(prop.ordering);

  writer.writeOptionalAttribute(prop.syncscope);

  writer.writeOptionalAttribute(prop.tbaa);

  writer.writeOptionalAttribute(prop.volatile_);
}

::mlir::LLVM::AtomicBinOp AtomicRMWOp::getBinOp() {
  auto attr = getBinOpAttr();
  return attr.getValue();
}

::mlir::LLVM::AtomicOrdering AtomicRMWOp::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > AtomicRMWOp::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<uint64_t> AtomicRMWOp::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

bool AtomicRMWOp::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOp::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOp::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOp::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AtomicRMWOp::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void AtomicRMWOp::setBinOp(::mlir::LLVM::AtomicBinOp attrValue) {
  getProperties().bin_op = ::mlir::LLVM::AtomicBinOpAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void AtomicRMWOp::setOrdering(::mlir::LLVM::AtomicOrdering attrValue) {
  getProperties().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void AtomicRMWOp::setSyncscope(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().syncscope;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void AtomicRMWOp::setAlignment(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().alignment;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void AtomicRMWOp::setVolatile_(bool attrValue) {
    auto &odsProp = getProperties().volatile_;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void AtomicRMWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::LLVM::AtomicBinOpAttr bin_op, ::mlir::Value ptr, ::mlir::Value val, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().bin_op = bin_op;
  odsState.getOrAddProperties<Properties>().ordering = ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(res);
}

void AtomicRMWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::AtomicBinOpAttr bin_op, ::mlir::Value ptr, ::mlir::Value val, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().bin_op = bin_op;
  odsState.getOrAddProperties<Properties>().ordering = ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(AtomicRMWOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void AtomicRMWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::AtomicBinOpAttr bin_op, ::mlir::Value ptr, ::mlir::Value val, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().bin_op = bin_op;
  odsState.getOrAddProperties<Properties>().ordering = ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicRMWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::LLVM::AtomicBinOp bin_op, ::mlir::Value ptr, ::mlir::Value val, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().bin_op = ::mlir::LLVM::AtomicBinOpAttr::get(odsBuilder.getContext(), bin_op);
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(res);
}

void AtomicRMWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::AtomicBinOp bin_op, ::mlir::Value ptr, ::mlir::Value val, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().bin_op = ::mlir::LLVM::AtomicBinOpAttr::get(odsBuilder.getContext(), bin_op);
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(AtomicRMWOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void AtomicRMWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::AtomicBinOp bin_op, ::mlir::Value ptr, ::mlir::Value val, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool volatile_, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(ptr);
  odsState.addOperands(val);
  odsState.getOrAddProperties<Properties>().bin_op = ::mlir::LLVM::AtomicBinOpAttr::get(odsBuilder.getContext(), bin_op);
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicRMWOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AtomicRMWOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void AtomicRMWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AtomicRMWOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(AtomicRMWOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult AtomicRMWOp::verifyInvariantsImpl() {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_bin_op = getProperties().bin_op; (void)tblgen_bin_op;
  if (!tblgen_bin_op) return emitOpError("requires attribute 'bin_op'");
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  if (!tblgen_ordering) return emitOpError("requires attribute 'ordering'");
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps10(*this, tblgen_bin_op, "bin_op")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(*this, tblgen_ordering, "ordering")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_syncscope, "syncscope")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_alignment, "alignment")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_volatile_, "volatile_")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(*this, tblgen_access_groups, "access_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_alias_scopes, "alias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_noalias_scopes, "noalias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(*this, tblgen_tbaa, "tbaa")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(1).begin()).getType(), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result #0 and operand #1 have the same type");
  return ::mlir::success();
}

::llvm::LogicalResult AtomicRMWOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::llvm::LogicalResult AtomicRMWOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[1].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult AtomicRMWOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::LLVM::AtomicBinOpAttr bin_opAttr;
  ::mlir::OpAsmParser::UnresolvedOperand ptrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> ptrOperands(&ptrRawOperand, 1);  ::llvm::SMLoc ptrOperandsLoc;
  (void)ptrOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand valRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valOperands(&valRawOperand, 1);  ::llvm::SMLoc valOperandsLoc;
  (void)valOperandsLoc;
  ::mlir::StringAttr syncscopeAttr;
  ::mlir::LLVM::AtomicOrderingAttr orderingAttr;
  ::mlir::Type ptrRawType{};
  ::llvm::ArrayRef<::mlir::Type> ptrTypes(&ptrRawType, 1);
  ::mlir::Type valRawType{};
  ::llvm::ArrayRef<::mlir::Type> valTypes(&valRawType, 1);
  if (::mlir::succeeded(parser.parseOptionalKeyword("volatile"))) {
    result.getOrAddProperties<AtomicRMWOp::Properties>().volatile_ = parser.getBuilder().getUnitAttr();  }

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"xchg","add","sub","_and","nand","_or","_xor","max","min","umax","umin","fadd","fsub","fmax","fmin","uinc_wrap","udec_wrap","usub_cond","usub_sat"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "bin_op", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'bin_op' [xchg, add, sub, _and, nand, _or, _xor, max, min, umax, umin, fadd, fsub, fmax, fmin, uinc_wrap, udec_wrap, usub_cond, usub_sat]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAtomicBinOp(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "bin_op attribute specification: \"" << attrStr << '"';;

      bin_opAttr = ::mlir::LLVM::AtomicBinOpAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<AtomicRMWOp::Properties>().bin_op = bin_opAttr;
    }
  }

  ptrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(ptrRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  valOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valRawOperand))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("syncscope"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(syncscopeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (syncscopeAttr) result.getOrAddProperties<AtomicRMWOp::Properties>().syncscope = syncscopeAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  }

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"not_atomic","unordered","monotonic","acquire","release","acq_rel","seq_cst"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "ordering", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'ordering' [not_atomic, unordered, monotonic, acquire, release, acq_rel, seq_cst]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAtomicOrdering(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "ordering attribute specification: \"" << attrStr << '"';;

      orderingAttr = ::mlir::LLVM::AtomicOrderingAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<AtomicRMWOp::Properties>().ordering = orderingAttr;
    }
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(ptrRawType))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valRawType = type;
  }
  for (::mlir::Type type : valTypes) {
    (void)type;
    if (!(((::mlir::LLVM::isCompatibleFloatingPointType(type))) || ((::llvm::isa<::mlir::LLVM::LLVMPointerType>(type))) || ((type.isSignlessInteger())))) {
      return parser.emitError(parser.getNameLoc()) << "'val' must be floating point LLVM type or LLVM pointer type or signless integer, but got " << type;
    }
  }
  result.addTypes(valTypes[0]);
  if (parser.resolveOperands(ptrOperands, ptrTypes, ptrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(valOperands, valTypes, valOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicRMWOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getVolatile_Attr() && getVolatile_Attr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "volatile";
  }
  _odsPrinter << ' ';

  {
    auto caseValue = getBinOp();
    auto caseValueStr = stringifyAtomicBinOp(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ' ';
  _odsPrinter << getPtr();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getVal();
  if (getSyncscopeAttr()) {
    _odsPrinter << ' ' << "syncscope";
    _odsPrinter << "(";
    _odsPrinter.printAttributeWithoutType(getSyncscopeAttr());
    _odsPrinter << ")";
  }
  _odsPrinter << ' ';

  {
    auto caseValue = getOrdering();
    auto caseValueStr = stringifyAtomicOrdering(caseValue);
    _odsPrinter << caseValueStr;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("volatile_");
  elidedAttrs.push_back("bin_op");
  elidedAttrs.push_back("syncscope");
  elidedAttrs.push_back("ordering");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getVolatile_Attr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("volatile_");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
   _odsPrinter << getPtr().getType();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = getVal().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::AtomicRMWOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::BitcastOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
BitcastOpAdaptor::BitcastOpAdaptor(BitcastOp op) : BitcastOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BitcastOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void BitcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void BitcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void BitcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitcastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult BitcastOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps8(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult BitcastOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult BitcastOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitcastOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitcastOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::BitcastOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::BrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
BrOpGenericAdaptorBase::BrOpGenericAdaptorBase(BrOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> BrOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::std::optional<::mlir::LLVM::LoopAnnotationAttr> BrOpGenericAdaptorBase::getLoopAnnotation() {
  auto attr = getLoopAnnotationAttr();
  return attr ? ::std::optional<::mlir::LLVM::LoopAnnotationAttr>(::llvm::cast<::mlir::LLVM::LoopAnnotationAttr>(attr)) : (::std::nullopt);
}

} // namespace detail
BrOpAdaptor::BrOpAdaptor(BrOp op) : BrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BrOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_loop_annotation = getProperties().loop_annotation; (void)tblgen_loop_annotation;

  if (tblgen_loop_annotation && !((::llvm::isa<::mlir::LLVM::LoopAnnotationAttr>(tblgen_loop_annotation))))
    return emitError(loc, "'llvm.br' op ""attribute 'loop_annotation' failed to satisfy constraint: ");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BrOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange BrOp::getDestOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::llvm::LogicalResult BrOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.loop_annotation;
       auto attr = dict.get("loop_annotation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `loop_annotation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute BrOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.loop_annotation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("loop_annotation",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code BrOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.loop_annotation.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> BrOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "loop_annotation")
      return prop.loop_annotation;
  return std::nullopt;
}

void BrOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "loop_annotation") {
       prop.loop_annotation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.loop_annotation)>>(value);
       return;
    }
}

void BrOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.loop_annotation) attrs.append("loop_annotation", prop.loop_annotation);
}

::llvm::LogicalResult BrOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getLoopAnnotationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps11(attr, "loop_annotation", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult BrOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.loop_annotation)))
    return ::mlir::failure();
  return ::mlir::success();
}

void BrOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.loop_annotation);
}

::std::optional<::mlir::LLVM::LoopAnnotationAttr> BrOp::getLoopAnnotation() {
  auto attr = getLoopAnnotationAttr();
  return attr ? ::std::optional<::mlir::LLVM::LoopAnnotationAttr>(::llvm::cast<::mlir::LLVM::LoopAnnotationAttr>(attr)) : (::std::nullopt);
}

void BrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Block *dest) {
      build(odsBuilder, odsState, ValueRange(), dest);
    
}

void BrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange operands, Block *dest) {
      build(odsBuilder, odsState, operands, /*loop_annotation=*/{}, dest);
    
}

void BrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange operands, SuccessorRange destinations, ArrayRef<NamedAttribute> attributes) {
    odsState.addOperands(operands);
    odsState.addSuccessors(destinations);
    odsState.addAttributes(attributes);
  
}

void BrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange destOperands, /*optional*/::mlir::LLVM::LoopAnnotationAttr loop_annotation, ::mlir::Block *dest) {
  odsState.addOperands(destOperands);
  if (loop_annotation) {
    odsState.getOrAddProperties<Properties>().loop_annotation = loop_annotation;
  }
  odsState.addSuccessors(dest);
}

void BrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange destOperands, /*optional*/::mlir::LLVM::LoopAnnotationAttr loop_annotation, ::mlir::Block *dest) {
  odsState.addOperands(destOperands);
  if (loop_annotation) {
    odsState.getOrAddProperties<Properties>().loop_annotation = loop_annotation;
  }
  odsState.addSuccessors(dest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<BrOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult BrOp::verifyInvariantsImpl() {
  auto tblgen_loop_annotation = getProperties().loop_annotation; (void)tblgen_loop_annotation;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps11(*this, tblgen_loop_annotation, "loop_annotation")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::llvm::LogicalResult BrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult BrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Block *destSuccessor = nullptr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> destOperandsOperands;
  ::llvm::SMLoc destOperandsOperandsLoc;
  (void)destOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> destOperandsTypes;

  if (parser.parseSuccessor(destSuccessor))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalLParen())) {

  destOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(destOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(destOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addSuccessors(destSuccessor);
  if (parser.resolveOperands(destOperandsOperands, destOperandsTypes, destOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getDest();
  if (!getDestOperands().empty()) {
    _odsPrinter << "(";
    _odsPrinter << getDestOperands();
    _odsPrinter << ' ' << ":";
    _odsPrinter << ' ';
    _odsPrinter << getDestOperands().getTypes();
    _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void BrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::BrOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::CallIntrinsicOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
CallIntrinsicOpGenericAdaptorBase::CallIntrinsicOpGenericAdaptorBase(CallIntrinsicOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CallIntrinsicOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::StringRef CallIntrinsicOpGenericAdaptorBase::getIntrin() {
  auto attr = getIntrinAttr();
  return attr.getValue();
}

::mlir::LLVM::FastmathFlagsAttr CallIntrinsicOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags CallIntrinsicOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
CallIntrinsicOpAdaptor::CallIntrinsicOpAdaptor(CallIntrinsicOp op) : CallIntrinsicOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CallIntrinsicOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;
  auto tblgen_intrin = getProperties().intrin; (void)tblgen_intrin;
  if (!tblgen_intrin) return emitError(loc, "'llvm.call_intrinsic' op ""requires attribute 'intrin'");

  if (tblgen_intrin && !((::llvm::isa<::mlir::StringAttr>(tblgen_intrin))))
    return emitError(loc, "'llvm.call_intrinsic' op ""attribute 'intrin' failed to satisfy constraint: string attribute");

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.call_intrinsic' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CallIntrinsicOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange CallIntrinsicOp::getArgsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CallIntrinsicOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult CallIntrinsicOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.intrin;
       auto attr = dict.get("intrin");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `intrin` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CallIntrinsicOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.intrin;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("intrin",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CallIntrinsicOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()), 
    llvm::hash_value(prop.intrin.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CallIntrinsicOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;

    if (name == "intrin")
      return prop.intrin;
  return std::nullopt;
}

void CallIntrinsicOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }

    if (name == "intrin") {
       prop.intrin = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.intrin)>>(value);
       return;
    }
}

void CallIntrinsicOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);

    if (prop.intrin) attrs.append("intrin", prop.intrin);
}

::llvm::LogicalResult CallIntrinsicOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIntrinAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "intrin", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CallIntrinsicOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.intrin)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CallIntrinsicOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
  writer.writeAttribute(prop.intrin);
}

::llvm::StringRef CallIntrinsicOp::getIntrin() {
  auto attr = getIntrinAttr();
  return attr.getValue();
}

::mlir::LLVM::FastmathFlags CallIntrinsicOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void CallIntrinsicOp::setIntrin(::llvm::StringRef attrValue) {
  getProperties().intrin = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void CallIntrinsicOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CallIntrinsicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type results, ::mlir::StringAttr intrin, ::mlir::ValueRange args, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(args);
  odsState.getOrAddProperties<Properties>().intrin = intrin;
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  if (results)
    odsState.addTypes(results);
}

void CallIntrinsicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr intrin, ::mlir::ValueRange args, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(args);
  odsState.getOrAddProperties<Properties>().intrin = intrin;
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(resultTypes);
}

void CallIntrinsicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type results, ::llvm::StringRef intrin, ::mlir::ValueRange args, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(args);
  odsState.getOrAddProperties<Properties>().intrin = odsBuilder.getStringAttr(intrin);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  if (results)
    odsState.addTypes(results);
}

void CallIntrinsicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef intrin, ::mlir::ValueRange args, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(args);
  odsState.getOrAddProperties<Properties>().intrin = odsBuilder.getStringAttr(intrin);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(resultTypes);
}

void CallIntrinsicOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CallIntrinsicOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void CallIntrinsicOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult CallIntrinsicOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;
  auto tblgen_intrin = getProperties().intrin; (void)tblgen_intrin;
  if (!tblgen_intrin) return emitOpError("requires attribute 'intrin'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_intrin, "intrin")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("result group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CallIntrinsicOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult CallIntrinsicOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr intrinAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> argsOperands;
  ::llvm::SMLoc argsOperandsLoc;
  (void)argsOperandsLoc;
  ::llvm::ArrayRef<::mlir::Type> argsTypes;
  ::llvm::ArrayRef<::mlir::Type> resultsTypes;

  if (parser.parseCustomAttributeWithFallback(intrinAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (intrinAttr) result.getOrAddProperties<CallIntrinsicOp::Properties>().intrin = intrinAttr;
  if (parser.parseLParen())
    return ::mlir::failure();

  argsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(argsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  ::mlir::FunctionType args__results_functionType;
  if (parser.parseType(args__results_functionType))
    return ::mlir::failure();
  argsTypes = args__results_functionType.getInputs();
  resultsTypes = args__results_functionType.getResults();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addTypes(resultsTypes);
  if (parser.resolveOperands(argsOperands, argsTypes, argsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CallIntrinsicOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getIntrinAttr());
  _odsPrinter << "(";
  _odsPrinter << getArgs();
  _odsPrinter << ")";
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printFunctionalType(getArgs().getTypes(), (getResults() ? ::llvm::ArrayRef<::mlir::Type>(getResults().getType()) : ::llvm::ArrayRef<::mlir::Type>()));
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("intrin");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getFastmathFlagsAttr();
     if(attr && (attr == ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {})))
       elidedAttrs.push_back("fastmathFlags");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::CallIntrinsicOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::CallOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
CallOpGenericAdaptorBase::CallOpGenericAdaptorBase(CallOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CallOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::std::optional<::mlir::LLVM::LLVMFunctionType> CallOpGenericAdaptorBase::getVarCalleeType() {
  auto attr = getVarCalleeTypeAttr();
  return attr ? ::std::optional<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::LLVM::LLVMFunctionType>(attr.getValue())) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > CallOpGenericAdaptorBase::getCallee() {
  auto attr = getCalleeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::mlir::LLVM::FastmathFlagsAttr CallOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags CallOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

::std::optional<::llvm::ArrayRef<int32_t>> CallOpGenericAdaptorBase::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::mlir::LLVM::CConvAttr CallOpGenericAdaptorBase::getCConvAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::CConvAttr>(getProperties().CConv);
  return attr;
}

::mlir::LLVM::cconv::CConv CallOpGenericAdaptorBase::getCConv() {
  auto attr = getCConvAttr();
  return attr.getCallingConv();
}

::mlir::LLVM::TailCallKindAttr CallOpGenericAdaptorBase::getTailCallKindAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::TailCallKindAttr>(getProperties().TailCallKind);
  return attr;
}

::mlir::LLVM::tailcallkind::TailCallKind CallOpGenericAdaptorBase::getTailCallKind() {
  auto attr = getTailCallKindAttr();
  return attr.getTailCallKind();
}

::std::optional<::mlir::LLVM::MemoryEffectsAttr> CallOpGenericAdaptorBase::getMemoryEffects() {
  auto attr = getMemoryEffectsAttr();
  return attr ? ::std::optional<::mlir::LLVM::MemoryEffectsAttr>(::llvm::cast<::mlir::LLVM::MemoryEffectsAttr>(attr)) : (::std::nullopt);
}

::std::optional<bool> CallOpGenericAdaptorBase::getConvergent() {
  auto attr = getConvergentAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> CallOpGenericAdaptorBase::getNoUnwind() {
  auto attr = getNoUnwindAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> CallOpGenericAdaptorBase::getWillReturn() {
  auto attr = getWillReturnAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOpGenericAdaptorBase::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOpGenericAdaptorBase::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOpGenericAdaptorBase::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOpGenericAdaptorBase::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
CallOpAdaptor::CallOpAdaptor(CallOp op) : CallOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CallOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_CConv = getProperties().CConv; (void)tblgen_CConv;
  auto tblgen_TailCallKind = getProperties().TailCallKind; (void)tblgen_TailCallKind;
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_callee = getProperties().callee; (void)tblgen_callee;
  auto tblgen_convergent = getProperties().convergent; (void)tblgen_convergent;
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;
  auto tblgen_memory_effects = getProperties().memory_effects; (void)tblgen_memory_effects;
  auto tblgen_no_unwind = getProperties().no_unwind; (void)tblgen_no_unwind;
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_var_callee_type = getProperties().var_callee_type; (void)tblgen_var_callee_type;
  auto tblgen_will_return = getProperties().will_return; (void)tblgen_will_return;

  if (tblgen_var_callee_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_var_callee_type))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(tblgen_var_callee_type).getValue()))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(tblgen_var_callee_type).getValue())))))
    return emitError(loc, "'llvm.call' op ""attribute 'var_callee_type' failed to satisfy constraint: type attribute of LLVM function type");

  if (tblgen_callee && !((::llvm::isa<::mlir::FlatSymbolRefAttr>(tblgen_callee))))
    return emitError(loc, "'llvm.call' op ""attribute 'callee' failed to satisfy constraint: flat symbol reference attribute");

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.call' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");

  if (tblgen_branch_weights && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_branch_weights))))
    return emitError(loc, "'llvm.call' op ""attribute 'branch_weights' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_CConv && !((::llvm::isa<::mlir::LLVM::CConvAttr>(tblgen_CConv))))
    return emitError(loc, "'llvm.call' op ""attribute 'CConv' failed to satisfy constraint: LLVM Calling Convention specification");

  if (tblgen_TailCallKind && !((::llvm::isa<::mlir::LLVM::TailCallKindAttr>(tblgen_TailCallKind))))
    return emitError(loc, "'llvm.call' op ""attribute 'TailCallKind' failed to satisfy constraint: LLVM Calling Convention specification");

  if (tblgen_memory_effects && !((::llvm::isa<::mlir::LLVM::MemoryEffectsAttr>(tblgen_memory_effects))))
    return emitError(loc, "'llvm.call' op ""attribute 'memory_effects' failed to satisfy constraint: ");

  if (tblgen_convergent && !((::llvm::isa<::mlir::UnitAttr>(tblgen_convergent))))
    return emitError(loc, "'llvm.call' op ""attribute 'convergent' failed to satisfy constraint: unit attribute");

  if (tblgen_no_unwind && !((::llvm::isa<::mlir::UnitAttr>(tblgen_no_unwind))))
    return emitError(loc, "'llvm.call' op ""attribute 'no_unwind' failed to satisfy constraint: unit attribute");

  if (tblgen_will_return && !((::llvm::isa<::mlir::UnitAttr>(tblgen_will_return))))
    return emitError(loc, "'llvm.call' op ""attribute 'will_return' failed to satisfy constraint: unit attribute");

  if (tblgen_access_groups && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_access_groups))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_access_groups), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AccessGroupAttr>(attr))); }))))
    return emitError(loc, "'llvm.call' op ""attribute 'access_groups' failed to satisfy constraint: LLVM dialect access group metadata array");

  if (tblgen_alias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_alias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_alias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.call' op ""attribute 'alias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_noalias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_noalias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_noalias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.call' op ""attribute 'noalias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_tbaa && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_tbaa))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_tbaa), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::TBAATagAttr>(attr))); }))))
    return emitError(loc, "'llvm.call' op ""attribute 'tbaa' failed to satisfy constraint: LLVM dialect TBAA tag metadata array");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CallOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange CallOp::getCalleeOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CallOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult CallOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.CConv;
       auto attr = dict.get("CConv");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `CConv` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.TailCallKind;
       auto attr = dict.get("TailCallKind");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `TailCallKind` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.access_groups;
       auto attr = dict.get("access_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `access_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alias_scopes;
       auto attr = dict.get("alias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.branch_weights;
       auto attr = dict.get("branch_weights");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `branch_weights` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.callee;
       auto attr = dict.get("callee");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `callee` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.convergent;
       auto attr = dict.get("convergent");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `convergent` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.memory_effects;
       auto attr = dict.get("memory_effects");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `memory_effects` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.no_unwind;
       auto attr = dict.get("no_unwind");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `no_unwind` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.noalias_scopes;
       auto attr = dict.get("noalias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `noalias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tbaa;
       auto attr = dict.get("tbaa");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tbaa` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.var_callee_type;
       auto attr = dict.get("var_callee_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `var_callee_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.will_return;
       auto attr = dict.get("will_return");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `will_return` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CallOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.CConv;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("CConv",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.TailCallKind;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("TailCallKind",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.access_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("access_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.branch_weights;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("branch_weights",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.callee;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("callee",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.convergent;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("convergent",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.memory_effects;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("memory_effects",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.no_unwind;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("no_unwind",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.noalias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("noalias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tbaa;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tbaa",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.var_callee_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("var_callee_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.will_return;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("will_return",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CallOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.CConv.getAsOpaquePointer()), 
    llvm::hash_value(prop.TailCallKind.getAsOpaquePointer()), 
    llvm::hash_value(prop.access_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.alias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.branch_weights.getAsOpaquePointer()), 
    llvm::hash_value(prop.callee.getAsOpaquePointer()), 
    llvm::hash_value(prop.convergent.getAsOpaquePointer()), 
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()), 
    llvm::hash_value(prop.memory_effects.getAsOpaquePointer()), 
    llvm::hash_value(prop.no_unwind.getAsOpaquePointer()), 
    llvm::hash_value(prop.noalias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.tbaa.getAsOpaquePointer()), 
    llvm::hash_value(prop.var_callee_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.will_return.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CallOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "CConv")
      return prop.CConv;

    if (name == "TailCallKind")
      return prop.TailCallKind;

    if (name == "access_groups")
      return prop.access_groups;

    if (name == "alias_scopes")
      return prop.alias_scopes;

    if (name == "branch_weights")
      return prop.branch_weights;

    if (name == "callee")
      return prop.callee;

    if (name == "convergent")
      return prop.convergent;

    if (name == "fastmathFlags")
      return prop.fastmathFlags;

    if (name == "memory_effects")
      return prop.memory_effects;

    if (name == "no_unwind")
      return prop.no_unwind;

    if (name == "noalias_scopes")
      return prop.noalias_scopes;

    if (name == "tbaa")
      return prop.tbaa;

    if (name == "var_callee_type")
      return prop.var_callee_type;

    if (name == "will_return")
      return prop.will_return;
  return std::nullopt;
}

void CallOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "CConv") {
       prop.CConv = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.CConv)>>(value);
       return;
    }

    if (name == "TailCallKind") {
       prop.TailCallKind = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.TailCallKind)>>(value);
       return;
    }

    if (name == "access_groups") {
       prop.access_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.access_groups)>>(value);
       return;
    }

    if (name == "alias_scopes") {
       prop.alias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alias_scopes)>>(value);
       return;
    }

    if (name == "branch_weights") {
       prop.branch_weights = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.branch_weights)>>(value);
       return;
    }

    if (name == "callee") {
       prop.callee = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.callee)>>(value);
       return;
    }

    if (name == "convergent") {
       prop.convergent = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.convergent)>>(value);
       return;
    }

    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }

    if (name == "memory_effects") {
       prop.memory_effects = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.memory_effects)>>(value);
       return;
    }

    if (name == "no_unwind") {
       prop.no_unwind = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.no_unwind)>>(value);
       return;
    }

    if (name == "noalias_scopes") {
       prop.noalias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.noalias_scopes)>>(value);
       return;
    }

    if (name == "tbaa") {
       prop.tbaa = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tbaa)>>(value);
       return;
    }

    if (name == "var_callee_type") {
       prop.var_callee_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.var_callee_type)>>(value);
       return;
    }

    if (name == "will_return") {
       prop.will_return = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.will_return)>>(value);
       return;
    }
}

void CallOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.CConv) attrs.append("CConv", prop.CConv);

    if (prop.TailCallKind) attrs.append("TailCallKind", prop.TailCallKind);

    if (prop.access_groups) attrs.append("access_groups", prop.access_groups);

    if (prop.alias_scopes) attrs.append("alias_scopes", prop.alias_scopes);

    if (prop.branch_weights) attrs.append("branch_weights", prop.branch_weights);

    if (prop.callee) attrs.append("callee", prop.callee);

    if (prop.convergent) attrs.append("convergent", prop.convergent);

    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);

    if (prop.memory_effects) attrs.append("memory_effects", prop.memory_effects);

    if (prop.no_unwind) attrs.append("no_unwind", prop.no_unwind);

    if (prop.noalias_scopes) attrs.append("noalias_scopes", prop.noalias_scopes);

    if (prop.tbaa) attrs.append("tbaa", prop.tbaa);

    if (prop.var_callee_type) attrs.append("var_callee_type", prop.var_callee_type);

    if (prop.will_return) attrs.append("will_return", prop.will_return);
}

::llvm::LogicalResult CallOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCConvAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps15(attr, "CConv", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTailCallKindAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps16(attr, "TailCallKind", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAccessGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(attr, "access_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "alias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getBranchWeightsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "branch_weights", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCalleeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(attr, "callee", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getConvergentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "convergent", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getMemoryEffectsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps17(attr, "memory_effects", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoUnwindAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "no_unwind", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoaliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "noalias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTbaaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(attr, "tbaa", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVarCalleeTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps13(attr, "var_callee_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWillReturnAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "will_return", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CallOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.CConv)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.TailCallKind)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.access_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.branch_weights)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.callee)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.convergent)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.memory_effects)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.no_unwind)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.noalias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tbaa)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.var_callee_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.will_return)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CallOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.CConv);

  writer.writeOptionalAttribute(prop.TailCallKind);

  writer.writeOptionalAttribute(prop.access_groups);

  writer.writeOptionalAttribute(prop.alias_scopes);

  writer.writeOptionalAttribute(prop.branch_weights);

  writer.writeOptionalAttribute(prop.callee);

  writer.writeOptionalAttribute(prop.convergent);

  writer.writeOptionalAttribute(prop.fastmathFlags);

  writer.writeOptionalAttribute(prop.memory_effects);

  writer.writeOptionalAttribute(prop.no_unwind);

  writer.writeOptionalAttribute(prop.noalias_scopes);

  writer.writeOptionalAttribute(prop.tbaa);

  writer.writeOptionalAttribute(prop.var_callee_type);

  writer.writeOptionalAttribute(prop.will_return);
}

::std::optional<::mlir::LLVM::LLVMFunctionType> CallOp::getVarCalleeType() {
  auto attr = getVarCalleeTypeAttr();
  return attr ? ::std::optional<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::LLVM::LLVMFunctionType>(attr.getValue())) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > CallOp::getCallee() {
  auto attr = getCalleeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::mlir::LLVM::FastmathFlags CallOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

::std::optional<::llvm::ArrayRef<int32_t>> CallOp::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::mlir::LLVM::cconv::CConv CallOp::getCConv() {
  auto attr = getCConvAttr();
  return attr.getCallingConv();
}

::mlir::LLVM::tailcallkind::TailCallKind CallOp::getTailCallKind() {
  auto attr = getTailCallKindAttr();
  return attr.getTailCallKind();
}

::std::optional<::mlir::LLVM::MemoryEffectsAttr> CallOp::getMemoryEffects() {
  auto attr = getMemoryEffectsAttr();
  return attr ? ::std::optional<::mlir::LLVM::MemoryEffectsAttr>(::llvm::cast<::mlir::LLVM::MemoryEffectsAttr>(attr)) : (::std::nullopt);
}

::std::optional<bool> CallOp::getConvergent() {
  auto attr = getConvergentAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> CallOp::getNoUnwind() {
  auto attr = getNoUnwindAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> CallOp::getWillReturn() {
  auto attr = getWillReturnAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOp::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOp::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOp::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CallOp::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void CallOp::setVarCalleeType(::std::optional<::mlir::LLVM::LLVMFunctionType> attrValue) {
    auto &odsProp = getProperties().var_callee_type;
    if (attrValue)
      odsProp = ::mlir::TypeAttr::get(*attrValue);
    else
      odsProp = nullptr;
}

void CallOp::setCallee(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().callee;
    if (attrValue)
      odsProp = ::mlir::SymbolRefAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void CallOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CallOp::setBranchWeights(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().branch_weights;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void CallOp::setCConv(::mlir::LLVM::cconv::CConv attrValue) {
  getProperties().CConv = ::mlir::LLVM::CConvAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CallOp::setTailCallKind(::mlir::LLVM::tailcallkind::TailCallKind attrValue) {
  getProperties().TailCallKind = ::mlir::LLVM::TailCallKindAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CallOp::setConvergent(bool attrValue) {
    auto &odsProp = getProperties().convergent;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void CallOp::setNoUnwind(bool attrValue) {
    auto &odsProp = getProperties().no_unwind;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void CallOp::setWillReturn(bool attrValue) {
    auto &odsProp = getProperties().will_return;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type result, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::CConvAttr CConv, ::mlir::LLVM::TailCallKindAttr TailCallKind, /*optional*/::mlir::LLVM::MemoryEffectsAttr memory_effects, /*optional*/::mlir::UnitAttr convergent, /*optional*/::mlir::UnitAttr no_unwind, /*optional*/::mlir::UnitAttr will_return, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(callee_operands);
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  if (CConv) {
    odsState.getOrAddProperties<Properties>().CConv = CConv;
  }
  if (TailCallKind) {
    odsState.getOrAddProperties<Properties>().TailCallKind = TailCallKind;
  }
  if (memory_effects) {
    odsState.getOrAddProperties<Properties>().memory_effects = memory_effects;
  }
  if (convergent) {
    odsState.getOrAddProperties<Properties>().convergent = convergent;
  }
  if (no_unwind) {
    odsState.getOrAddProperties<Properties>().no_unwind = no_unwind;
  }
  if (will_return) {
    odsState.getOrAddProperties<Properties>().will_return = will_return;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  if (result)
    odsState.addTypes(result);
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::CConvAttr CConv, ::mlir::LLVM::TailCallKindAttr TailCallKind, /*optional*/::mlir::LLVM::MemoryEffectsAttr memory_effects, /*optional*/::mlir::UnitAttr convergent, /*optional*/::mlir::UnitAttr no_unwind, /*optional*/::mlir::UnitAttr will_return, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(callee_operands);
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  if (CConv) {
    odsState.getOrAddProperties<Properties>().CConv = CConv;
  }
  if (TailCallKind) {
    odsState.getOrAddProperties<Properties>().TailCallKind = TailCallKind;
  }
  if (memory_effects) {
    odsState.getOrAddProperties<Properties>().memory_effects = memory_effects;
  }
  if (convergent) {
    odsState.getOrAddProperties<Properties>().convergent = convergent;
  }
  if (no_unwind) {
    odsState.getOrAddProperties<Properties>().no_unwind = no_unwind;
  }
  if (will_return) {
    odsState.getOrAddProperties<Properties>().will_return = will_return;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(resultTypes);
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type result, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::LLVM::FastmathFlags fastmathFlags, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::cconv::CConv CConv, ::mlir::LLVM::tailcallkind::TailCallKind TailCallKind, /*optional*/::mlir::LLVM::MemoryEffectsAttr memory_effects, /*optional*/::mlir::UnitAttr convergent, /*optional*/::mlir::UnitAttr no_unwind, /*optional*/::mlir::UnitAttr will_return, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(callee_operands);
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  odsState.getOrAddProperties<Properties>().CConv = ::mlir::LLVM::CConvAttr::get(odsBuilder.getContext(), CConv);
  odsState.getOrAddProperties<Properties>().TailCallKind = ::mlir::LLVM::TailCallKindAttr::get(odsBuilder.getContext(), TailCallKind);
  if (memory_effects) {
    odsState.getOrAddProperties<Properties>().memory_effects = memory_effects;
  }
  if (convergent) {
    odsState.getOrAddProperties<Properties>().convergent = convergent;
  }
  if (no_unwind) {
    odsState.getOrAddProperties<Properties>().no_unwind = no_unwind;
  }
  if (will_return) {
    odsState.getOrAddProperties<Properties>().will_return = will_return;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  if (result)
    odsState.addTypes(result);
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::LLVM::FastmathFlags fastmathFlags, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::cconv::CConv CConv, ::mlir::LLVM::tailcallkind::TailCallKind TailCallKind, /*optional*/::mlir::LLVM::MemoryEffectsAttr memory_effects, /*optional*/::mlir::UnitAttr convergent, /*optional*/::mlir::UnitAttr no_unwind, /*optional*/::mlir::UnitAttr will_return, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(callee_operands);
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  odsState.getOrAddProperties<Properties>().CConv = ::mlir::LLVM::CConvAttr::get(odsBuilder.getContext(), CConv);
  odsState.getOrAddProperties<Properties>().TailCallKind = ::mlir::LLVM::TailCallKindAttr::get(odsBuilder.getContext(), TailCallKind);
  if (memory_effects) {
    odsState.getOrAddProperties<Properties>().memory_effects = memory_effects;
  }
  if (convergent) {
    odsState.getOrAddProperties<Properties>().convergent = convergent;
  }
  if (no_unwind) {
    odsState.getOrAddProperties<Properties>().no_unwind = no_unwind;
  }
  if (will_return) {
    odsState.getOrAddProperties<Properties>().will_return = will_return;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(resultTypes);
}

void CallOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CallOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void CallOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
  if (!properties.CConv)
    properties.CConv = ::mlir::LLVM::CConvAttr::get(odsBuilder.getContext(), CConv::C);
  if (!properties.TailCallKind)
    properties.TailCallKind = ::mlir::LLVM::TailCallKindAttr::get(odsBuilder.getContext(), TailCallKind::None);
}

::llvm::LogicalResult CallOp::verifyInvariantsImpl() {
  auto tblgen_CConv = getProperties().CConv; (void)tblgen_CConv;
  auto tblgen_TailCallKind = getProperties().TailCallKind; (void)tblgen_TailCallKind;
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_callee = getProperties().callee; (void)tblgen_callee;
  auto tblgen_convergent = getProperties().convergent; (void)tblgen_convergent;
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;
  auto tblgen_memory_effects = getProperties().memory_effects; (void)tblgen_memory_effects;
  auto tblgen_no_unwind = getProperties().no_unwind; (void)tblgen_no_unwind;
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_var_callee_type = getProperties().var_callee_type; (void)tblgen_var_callee_type;
  auto tblgen_will_return = getProperties().will_return; (void)tblgen_will_return;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps13(*this, tblgen_var_callee_type, "var_callee_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(*this, tblgen_callee, "callee")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_branch_weights, "branch_weights")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps15(*this, tblgen_CConv, "CConv")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps16(*this, tblgen_TailCallKind, "TailCallKind")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps17(*this, tblgen_memory_effects, "memory_effects")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_convergent, "convergent")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_no_unwind, "no_unwind")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_will_return, "will_return")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(*this, tblgen_access_groups, "access_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_alias_scopes, "alias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_noalias_scopes, "noalias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(*this, tblgen_tbaa, "tbaa")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("result group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CallOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::CallOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ComdatOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ComdatOpGenericAdaptorBase::ComdatOpGenericAdaptorBase(ComdatOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef ComdatOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

} // namespace detail
ComdatOpAdaptor::ComdatOpAdaptor(ComdatOp op) : ComdatOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ComdatOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'llvm.comdat' op ""requires attribute 'sym_name'");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'llvm.comdat' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ComdatOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ComdatOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ComdatOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ComdatOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "sym_name")
      return prop.sym_name;
  return std::nullopt;
}

void ComdatOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }
}

void ComdatOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);
}

::llvm::LogicalResult ComdatOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ComdatOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ComdatOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.sym_name);
}

::llvm::StringRef ComdatOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

void ComdatOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

::llvm::LogicalResult ComdatOp::verifyInvariantsImpl() {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_LLVMOps1(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ComdatOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ComdatOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  std::unique_ptr<::mlir::Region> bodyRegion = std::make_unique<::mlir::Region>();

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<ComdatOp::Properties>().sym_name = sym_nameAttr;

  if (parser.parseRegion(*bodyRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(bodyRegion));
  return ::mlir::success();
}

void ComdatOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getBody());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ComdatOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ComdatSelectorOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ComdatSelectorOpGenericAdaptorBase::ComdatSelectorOpGenericAdaptorBase(ComdatSelectorOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef ComdatSelectorOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::LLVM::comdat::Comdat ComdatSelectorOpGenericAdaptorBase::getComdat() {
  auto attr = getComdatAttr();
  return attr.getValue();
}

} // namespace detail
ComdatSelectorOpAdaptor::ComdatSelectorOpAdaptor(ComdatSelectorOp op) : ComdatSelectorOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ComdatSelectorOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_comdat = getProperties().comdat; (void)tblgen_comdat;
  if (!tblgen_comdat) return emitError(loc, "'llvm.comdat_selector' op ""requires attribute 'comdat'");
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'llvm.comdat_selector' op ""requires attribute 'sym_name'");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'llvm.comdat_selector' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");

  if (tblgen_comdat && !((::llvm::isa<::mlir::LLVM::comdat::ComdatAttr>(tblgen_comdat))))
    return emitError(loc, "'llvm.comdat_selector' op ""attribute 'comdat' failed to satisfy constraint: LLVM Comdat Types");
  return ::mlir::success();
}

::llvm::LogicalResult ComdatSelectorOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.comdat;
       auto attr = dict.get("comdat");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `comdat` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ComdatSelectorOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.comdat;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("comdat",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ComdatSelectorOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.comdat.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ComdatSelectorOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "comdat")
      return prop.comdat;

    if (name == "sym_name")
      return prop.sym_name;
  return std::nullopt;
}

void ComdatSelectorOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "comdat") {
       prop.comdat = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.comdat)>>(value);
       return;
    }

    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }
}

void ComdatSelectorOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.comdat) attrs.append("comdat", prop.comdat);

    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);
}

::llvm::LogicalResult ComdatSelectorOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getComdatAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps18(attr, "comdat", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ComdatSelectorOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.comdat)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ComdatSelectorOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.comdat);
  writer.writeAttribute(prop.sym_name);
}

::llvm::StringRef ComdatSelectorOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::LLVM::comdat::Comdat ComdatSelectorOp::getComdat() {
  auto attr = getComdatAttr();
  return attr.getValue();
}

void ComdatSelectorOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void ComdatSelectorOp::setComdat(::mlir::LLVM::comdat::Comdat attrValue) {
  getProperties().comdat = ::mlir::LLVM::comdat::ComdatAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void ComdatSelectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::LLVM::comdat::ComdatAttr comdat) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().comdat = comdat;
}

void ComdatSelectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::LLVM::comdat::ComdatAttr comdat) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().comdat = comdat;
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ComdatSelectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::LLVM::comdat::Comdat comdat) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().comdat = ::mlir::LLVM::comdat::ComdatAttr::get(odsBuilder.getContext(), comdat);
}

void ComdatSelectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::LLVM::comdat::Comdat comdat) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().comdat = ::mlir::LLVM::comdat::ComdatAttr::get(odsBuilder.getContext(), comdat);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ComdatSelectorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ComdatSelectorOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ComdatSelectorOp::verifyInvariantsImpl() {
  auto tblgen_comdat = getProperties().comdat; (void)tblgen_comdat;
  if (!tblgen_comdat) return emitOpError("requires attribute 'comdat'");
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps18(*this, tblgen_comdat, "comdat")))
    return ::mlir::failure();
  return ::mlir::success();
}

::llvm::LogicalResult ComdatSelectorOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ComdatSelectorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  ::mlir::LLVM::comdat::ComdatAttr comdatAttr;

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<ComdatSelectorOp::Properties>().sym_name = sym_nameAttr;

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"any","exactmatch","largest","nodeduplicate","samesize"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "comdat", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'comdat' [any, exactmatch, largest, nodeduplicate, samesize]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::comdat::symbolizeComdat(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "comdat attribute specification: \"" << attrStr << '"';;

      comdatAttr = ::mlir::LLVM::comdat::ComdatAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<ComdatSelectorOp::Properties>().comdat = comdatAttr;
    }
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void ComdatSelectorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ';

  {
    auto caseValue = getComdat();
    auto caseValueStr = stringifyComdat(caseValue);
    _odsPrinter << caseValueStr;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  elidedAttrs.push_back("comdat");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ComdatSelectorOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::CondBrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
CondBrOpGenericAdaptorBase::CondBrOpGenericAdaptorBase(CondBrOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CondBrOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional<::llvm::ArrayRef<int32_t>> CondBrOpGenericAdaptorBase::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::LoopAnnotationAttr> CondBrOpGenericAdaptorBase::getLoopAnnotation() {
  auto attr = getLoopAnnotationAttr();
  return attr ? ::std::optional<::mlir::LLVM::LoopAnnotationAttr>(::llvm::cast<::mlir::LLVM::LoopAnnotationAttr>(attr)) : (::std::nullopt);
}

} // namespace detail
CondBrOpAdaptor::CondBrOpAdaptor(CondBrOp op) : CondBrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CondBrOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_loop_annotation = getProperties().loop_annotation; (void)tblgen_loop_annotation;

  if (tblgen_branch_weights && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_branch_weights))))
    return emitError(loc, "'llvm.cond_br' op ""attribute 'branch_weights' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_loop_annotation && !((::llvm::isa<::mlir::LLVM::LoopAnnotationAttr>(tblgen_loop_annotation))))
    return emitError(loc, "'llvm.cond_br' op ""attribute 'loop_annotation' failed to satisfy constraint: ");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CondBrOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange CondBrOp::getTrueDestOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CondBrOp::getFalseDestOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult CondBrOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.branch_weights;
       auto attr = dict.get("branch_weights");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `branch_weights` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.loop_annotation;
       auto attr = dict.get("loop_annotation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `loop_annotation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute CondBrOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.branch_weights;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("branch_weights",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.loop_annotation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("loop_annotation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CondBrOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.branch_weights.getAsOpaquePointer()), 
    llvm::hash_value(prop.loop_annotation.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> CondBrOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "branch_weights")
      return prop.branch_weights;

    if (name == "loop_annotation")
      return prop.loop_annotation;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void CondBrOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "branch_weights") {
       prop.branch_weights = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.branch_weights)>>(value);
       return;
    }

    if (name == "loop_annotation") {
       prop.loop_annotation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.loop_annotation)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void CondBrOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.branch_weights) attrs.append("branch_weights", prop.branch_weights);

    if (prop.loop_annotation) attrs.append("loop_annotation", prop.loop_annotation);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult CondBrOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBranchWeightsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "branch_weights", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLoopAnnotationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps11(attr, "loop_annotation", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CondBrOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.branch_weights)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.loop_annotation)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void CondBrOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.branch_weights);

  writer.writeOptionalAttribute(prop.loop_annotation);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional<::llvm::ArrayRef<int32_t>> CondBrOp::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::LoopAnnotationAttr> CondBrOp::getLoopAnnotation() {
  auto attr = getLoopAnnotationAttr();
  return attr ? ::std::optional<::mlir::LLVM::LoopAnnotationAttr>(::llvm::cast<::mlir::LLVM::LoopAnnotationAttr>(attr)) : (::std::nullopt);
}

void CondBrOp::setBranchWeights(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().branch_weights;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void CondBrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value condition, Block *trueDest, Block *falseDest, ValueRange falseOperands) {
      build(odsBuilder, odsState, condition, trueDest, ValueRange(), falseDest,
            falseOperands);
  
}

void CondBrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value condition, ValueRange trueOperands, ValueRange falseOperands, DenseI32ArrayAttr branchWeights, Block *trueDest, Block *falseDest) {
      build(odsBuilder, odsState, condition, trueOperands, falseOperands, branchWeights,
      {}, trueDest, falseDest);
  
}

void CondBrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange operands, SuccessorRange destinations, ArrayRef<NamedAttribute> attributes) {
    odsState.addOperands(operands);
    odsState.addSuccessors(destinations);
    odsState.addAttributes(attributes);
  
}

void CondBrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::ValueRange trueDestOperands, ::mlir::ValueRange falseDestOperands, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, /*optional*/::mlir::LLVM::LoopAnnotationAttr loop_annotation, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(condition);
  odsState.addOperands(trueDestOperands);
  odsState.addOperands(falseDestOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(trueDestOperands.size()), static_cast<int32_t>(falseDestOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  if (loop_annotation) {
    odsState.getOrAddProperties<Properties>().loop_annotation = loop_annotation;
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CondBrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::ValueRange trueDestOperands, ::mlir::ValueRange falseDestOperands, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, /*optional*/::mlir::LLVM::LoopAnnotationAttr loop_annotation, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(condition);
  odsState.addOperands(trueDestOperands);
  odsState.addOperands(falseDestOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(trueDestOperands.size()), static_cast<int32_t>(falseDestOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  if (loop_annotation) {
    odsState.getOrAddProperties<Properties>().loop_annotation = loop_annotation;
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CondBrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CondBrOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CondBrOp::verifyInvariantsImpl() {
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_loop_annotation = getProperties().loop_annotation; (void)tblgen_loop_annotation;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_branch_weights, "branch_weights")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps11(*this, tblgen_loop_annotation, "loop_annotation")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps11(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::llvm::LogicalResult CondBrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult CondBrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand conditionRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> conditionOperands(&conditionRawOperand, 1);  ::llvm::SMLoc conditionOperandsLoc;
  (void)conditionOperandsLoc;
  ::mlir::DenseI32ArrayAttr branch_weightsAttr;
  ::mlir::Block *trueDestSuccessor = nullptr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> trueDestOperandsOperands;
  ::llvm::SMLoc trueDestOperandsOperandsLoc;
  (void)trueDestOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> trueDestOperandsTypes;
  ::mlir::Block *falseDestSuccessor = nullptr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> falseDestOperandsOperands;
  ::llvm::SMLoc falseDestOperandsOperandsLoc;
  (void)falseDestOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> falseDestOperandsTypes;

  conditionOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(conditionRawOperand))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("weights"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(branch_weightsAttr, ::mlir::Type{})) {
    return ::mlir::failure();
  }
  if (branch_weightsAttr) result.getOrAddProperties<CondBrOp::Properties>().branch_weights = branch_weightsAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseSuccessor(trueDestSuccessor))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalLParen())) {

  trueDestOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(trueDestOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(trueDestOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseSuccessor(falseDestSuccessor))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalLParen())) {

  falseDestOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(falseDestOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(falseDestOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addSuccessors(trueDestSuccessor);
  result.addSuccessors(falseDestSuccessor);
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(trueDestOperandsOperands.size()), static_cast<int32_t>(falseDestOperandsOperands.size())}), result.getOrAddProperties<CondBrOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(conditionOperands, odsBuildableType0, conditionOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(trueDestOperandsOperands, trueDestOperandsTypes, trueDestOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(falseDestOperandsOperands, falseDestOperandsTypes, falseDestOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CondBrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getCondition();
  if (getBranchWeightsAttr()) {
    _odsPrinter << ' ' << "weights";
    _odsPrinter << "(";
  _odsPrinter.printStrippedAttrOrType(getBranchWeightsAttr());
    _odsPrinter << ")";
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getTrueDest();
  if (!getTrueDestOperands().empty()) {
    _odsPrinter << "(";
    _odsPrinter << getTrueDestOperands();
    _odsPrinter << ' ' << ":";
    _odsPrinter << ' ';
    _odsPrinter << getTrueDestOperands().getTypes();
    _odsPrinter << ")";
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getFalseDest();
  if (!getFalseDestOperands().empty()) {
    _odsPrinter << "(";
    _odsPrinter << getFalseDestOperands();
    _odsPrinter << ' ' << ":";
    _odsPrinter << ' ';
    _odsPrinter << getFalseDestOperands().getTypes();
    _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("branch_weights");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void CondBrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::CondBrOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ConstantOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(ConstantOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute ConstantOpGenericAdaptorBase::getValue() {
  auto attr = getValueAttr();
  return attr;
}

} // namespace detail
ConstantOpAdaptor::ConstantOpAdaptor(ConstantOp op) : ConstantOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ConstantOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_value = getProperties().value; (void)tblgen_value;
  if (!tblgen_value) return emitError(loc, "'llvm.mlir.constant' op ""requires attribute 'value'");

  if (tblgen_value && !((true)))
    return emitError(loc, "'llvm.mlir.constant' op ""attribute 'value' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ConstantOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.value;
       auto attr = dict.get("value");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `value` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ConstantOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.value;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("value",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ConstantOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.value.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ConstantOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "value")
      return prop.value;
  return std::nullopt;
}

void ConstantOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "value") {
       prop.value = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.value)>>(value);
       return;
    }
}

void ConstantOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.value) attrs.append("value", prop.value);
}

::llvm::LogicalResult ConstantOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getValueAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps19(attr, "value", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ConstantOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.value)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConstantOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.value);
}

::mlir::Attribute ConstantOp::getValue() {
  auto attr = getValueAttr();
  return attr;
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type type, int64_t value) {
      build(odsBuilder, odsState, type, odsBuilder.getIntegerAttr(type, value));
    
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type type, const APInt &value) {
      build(odsBuilder, odsState, type, odsBuilder.getIntegerAttr(type, value));
    
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type type, const APFloat &value) {
      build(odsBuilder, odsState, type, odsBuilder.getFloatAttr(type, value));
    
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypedAttr value) {
      build(odsBuilder, odsState, value.getType(), value);
    
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Attribute value) {
  odsState.getOrAddProperties<Properties>().value = value;
  odsState.addTypes(res);
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute value) {
  odsState.getOrAddProperties<Properties>().value = value;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstantOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ConstantOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ConstantOp::verifyInvariantsImpl() {
  auto tblgen_value = getProperties().value; (void)tblgen_value;
  if (!tblgen_value) return emitOpError("requires attribute 'value'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps19(*this, tblgen_value, "value")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ConstantOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ConstantOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Attribute valueAttr;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseAttribute(valueAttr, ::mlir::Type{}))
    return ::mlir::failure();
  if (valueAttr) result.getOrAddProperties<ConstantOp::Properties>().value = valueAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  return ::mlir::success();
}

void ConstantOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << "(";
  _odsPrinter.printAttribute(getValueAttr());
  _odsPrinter << ")";
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("value");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ConstantOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ConstantOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ExtractElementOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ExtractElementOpAdaptor::ExtractElementOpAdaptor(ExtractElementOp op) : ExtractElementOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ExtractElementOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ExtractElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value vector, ::mlir::Value position) {
  odsState.addOperands(vector);
  odsState.addOperands(position);
  odsState.addTypes(res);
}

void ExtractElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value vector, ::mlir::Value position) {
  odsState.addOperands(vector);
  odsState.addOperands(position);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(ExtractElementOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ExtractElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value vector, ::mlir::Value position) {
  odsState.addOperands(vector);
  odsState.addOperands(position);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExtractElementOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ExtractElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(ExtractElementOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult ExtractElementOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(LLVM::getVectorElementType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result type matches vector element type");
  return ::mlir::success();
}

::llvm::LogicalResult ExtractElementOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult ExtractElementOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = LLVM::getVectorElementType(operands[0].getType());
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult ExtractElementOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand vectorRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> vectorOperands(&vectorRawOperand, 1);  ::llvm::SMLoc vectorOperandsLoc;
  (void)vectorOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand positionRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> positionOperands(&positionRawOperand, 1);  ::llvm::SMLoc positionOperandsLoc;
  (void)positionOperandsLoc;
  ::mlir::Type positionRawType{};
  ::llvm::ArrayRef<::mlir::Type> positionTypes(&positionRawType, 1);
  ::mlir::Type vectorRawType{};
  ::llvm::ArrayRef<::mlir::Type> vectorTypes(&vectorRawType, 1);

  vectorOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(vectorRawOperand))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  positionOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(positionRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    positionRawType = type;
  }
  if (parser.parseRSquare())
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    vectorRawType = type;
  }
  for (::mlir::Type type : vectorTypes) {
    (void)type;
    if (!((::mlir::LLVM::isCompatibleVectorType(type)))) {
      return parser.emitError(parser.getNameLoc()) << "'vector' must be LLVM dialect-compatible vector type, but got " << type;
    }
  }
  result.addTypes(LLVM::getVectorElementType(vectorTypes[0]));
  if (parser.resolveOperands(vectorOperands, vectorTypes, vectorOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(positionOperands, positionTypes, positionOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ExtractElementOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getVector();
  _odsPrinter << "[";
  _odsPrinter << getPosition();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getPosition().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::IntegerType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << "]";
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVector().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ExtractElementOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ExtractElementOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ExtractValueOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ExtractValueOpGenericAdaptorBase::ExtractValueOpGenericAdaptorBase(ExtractValueOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::ArrayRef<int64_t> ExtractValueOpGenericAdaptorBase::getPosition() {
  auto attr = getPositionAttr();
  return attr;
}

} // namespace detail
ExtractValueOpAdaptor::ExtractValueOpAdaptor(ExtractValueOp op) : ExtractValueOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ExtractValueOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_position = getProperties().position; (void)tblgen_position;
  if (!tblgen_position) return emitError(loc, "'llvm.extractvalue' op ""requires attribute 'position'");

  if (tblgen_position && !((::llvm::isa<::mlir::DenseI64ArrayAttr>(tblgen_position))))
    return emitError(loc, "'llvm.extractvalue' op ""attribute 'position' failed to satisfy constraint: i64 dense array attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ExtractValueOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.position;
       auto attr = dict.get("position");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `position` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ExtractValueOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.position;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("position",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ExtractValueOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.position.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ExtractValueOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "position")
      return prop.position;
  return std::nullopt;
}

void ExtractValueOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "position") {
       prop.position = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.position)>>(value);
       return;
    }
}

void ExtractValueOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.position) attrs.append("position", prop.position);
}

::llvm::LogicalResult ExtractValueOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getPositionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps20(attr, "position", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ExtractValueOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.position)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ExtractValueOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.position);
}

::llvm::ArrayRef<int64_t> ExtractValueOp::getPosition() {
  auto attr = getPositionAttr();
  return attr;
}

void ExtractValueOp::setPosition(::llvm::ArrayRef<int64_t> attrValue) {
  getProperties().position = ::mlir::Builder((*this)->getContext()).getDenseI64ArrayAttr(attrValue);
}

void ExtractValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value container, ::mlir::DenseI64ArrayAttr position) {
  odsState.addOperands(container);
  odsState.getOrAddProperties<Properties>().position = position;
  odsState.addTypes(res);
}

void ExtractValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value container, ::mlir::DenseI64ArrayAttr position) {
  odsState.addOperands(container);
  odsState.getOrAddProperties<Properties>().position = position;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExtractValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value container, ::llvm::ArrayRef<int64_t> position) {
  odsState.addOperands(container);
  odsState.getOrAddProperties<Properties>().position = odsBuilder.getDenseI64ArrayAttr(position);
  odsState.addTypes(res);
}

void ExtractValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value container, ::llvm::ArrayRef<int64_t> position) {
  odsState.addOperands(container);
  odsState.getOrAddProperties<Properties>().position = odsBuilder.getDenseI64ArrayAttr(position);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExtractValueOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ExtractValueOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ExtractValueOp::verifyInvariantsImpl() {
  auto tblgen_position = getProperties().position; (void)tblgen_position;
  if (!tblgen_position) return emitOpError("requires attribute 'position'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps20(*this, tblgen_position, "position")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ExtractValueOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ExtractValueOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand containerRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> containerOperands(&containerRawOperand, 1);  ::llvm::SMLoc containerOperandsLoc;
  (void)containerOperandsLoc;
  ::mlir::DenseI64ArrayAttr positionAttr;
  ::mlir::Type containerRawType{};
  ::llvm::ArrayRef<::mlir::Type> containerTypes(&containerRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  containerOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(containerRawOperand))
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(positionAttr, ::mlir::Type{})) {
    return ::mlir::failure();
  }
  if (positionAttr) result.getOrAddProperties<ExtractValueOp::Properties>().position = positionAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    containerRawType = type;
  }
  {
    auto odsResult = parseInsertExtractValueElementType(parser, resRawType, containerRawType, positionAttr);
    if (odsResult) return ::mlir::failure();
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(containerOperands, containerTypes, containerOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ExtractValueOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getContainer();
_odsPrinter.printStrippedAttrOrType(getPositionAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("position");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getContainer().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ';
  printInsertExtractValueElementType(_odsPrinter, *this, getRes().getType(), getContainer().getType(), getPositionAttr());
}

void ExtractValueOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ExtractValueOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FAddOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FAddOpGenericAdaptorBase::FAddOpGenericAdaptorBase(FAddOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FastmathFlagsAttr FAddOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags FAddOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
FAddOpAdaptor::FAddOpAdaptor(FAddOp op) : FAddOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FAddOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.fadd' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult FAddOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FAddOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FAddOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FAddOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;
  return std::nullopt;
}

void FAddOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }
}

void FAddOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);
}

::llvm::LogicalResult FAddOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FAddOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FAddOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
}

::mlir::LLVM::FastmathFlags FAddOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void FAddOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FAddOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FAddOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FAddOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FAddOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FAddOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void FAddOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult FAddOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FAddOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FAddOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult FAddOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FAddOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FAddOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FAddOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FCmpOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FCmpOpGenericAdaptorBase::FCmpOpGenericAdaptorBase(FCmpOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FCmpPredicate FCmpOpGenericAdaptorBase::getPredicate() {
  auto attr = getPredicateAttr();
  return attr.getValue();
}

::mlir::LLVM::FastmathFlagsAttr FCmpOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags FCmpOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
FCmpOpAdaptor::FCmpOpAdaptor(FCmpOp op) : FCmpOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FCmpOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;
  auto tblgen_predicate = getProperties().predicate; (void)tblgen_predicate;
  if (!tblgen_predicate) return emitError(loc, "'llvm.fcmp' op ""requires attribute 'predicate'");

  if (tblgen_predicate && !((::llvm::isa<::mlir::LLVM::FCmpPredicateAttr>(tblgen_predicate))))
    return emitError(loc, "'llvm.fcmp' op ""attribute 'predicate' failed to satisfy constraint: llvm.fcmp comparison predicate");

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.fcmp' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult FCmpOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.predicate;
       auto attr = dict.get("predicate");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `predicate` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FCmpOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.predicate;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("predicate",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FCmpOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()), 
    llvm::hash_value(prop.predicate.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FCmpOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;

    if (name == "predicate")
      return prop.predicate;
  return std::nullopt;
}

void FCmpOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }

    if (name == "predicate") {
       prop.predicate = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.predicate)>>(value);
       return;
    }
}

void FCmpOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);

    if (prop.predicate) attrs.append("predicate", prop.predicate);
}

::llvm::LogicalResult FCmpOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPredicateAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps21(attr, "predicate", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FCmpOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.predicate)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FCmpOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
  writer.writeAttribute(prop.predicate);
}

::mlir::LLVM::FCmpPredicate FCmpOp::getPredicate() {
  auto attr = getPredicateAttr();
  return attr.getValue();
}

::mlir::LLVM::FastmathFlags FCmpOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void FCmpOp::setPredicate(::mlir::LLVM::FCmpPredicate attrValue) {
  getProperties().predicate = ::mlir::LLVM::FCmpPredicateAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FCmpOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FCmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::LLVM::FCmpPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = predicate;
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void FCmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::FCmpPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = predicate;
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FCmpOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FCmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::FCmpPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = predicate;
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FCmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::LLVM::FCmpPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = ::mlir::LLVM::FCmpPredicateAttr::get(odsBuilder.getContext(), predicate);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void FCmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::FCmpPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = ::mlir::LLVM::FCmpPredicateAttr::get(odsBuilder.getContext(), predicate);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FCmpOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FCmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::FCmpPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = ::mlir::LLVM::FCmpPredicateAttr::get(odsBuilder.getContext(), predicate);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FCmpOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FCmpOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FCmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FCmpOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FCmpOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void FCmpOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult FCmpOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;
  auto tblgen_predicate = getProperties().predicate; (void)tblgen_predicate;
  if (!tblgen_predicate) return emitOpError("requires attribute 'predicate'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps21(*this, tblgen_predicate, "predicate")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(::getI1SameShape((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result type has i1 element type and same shape as operands");
  return ::mlir::success();
}

::llvm::LogicalResult FCmpOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FCmpOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = ::getI1SameShape(operands[0].getType());
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

void FCmpOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FCmpOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FDivOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FDivOpGenericAdaptorBase::FDivOpGenericAdaptorBase(FDivOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FastmathFlagsAttr FDivOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags FDivOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
FDivOpAdaptor::FDivOpAdaptor(FDivOp op) : FDivOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FDivOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.fdiv' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult FDivOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FDivOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FDivOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FDivOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;
  return std::nullopt;
}

void FDivOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }
}

void FDivOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);
}

::llvm::LogicalResult FDivOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FDivOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FDivOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
}

::mlir::LLVM::FastmathFlags FDivOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void FDivOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FDivOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FDivOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FDivOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FDivOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FDivOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void FDivOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult FDivOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FDivOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FDivOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult FDivOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FDivOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FDivOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FDivOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FMulOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FMulOpGenericAdaptorBase::FMulOpGenericAdaptorBase(FMulOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FastmathFlagsAttr FMulOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags FMulOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
FMulOpAdaptor::FMulOpAdaptor(FMulOp op) : FMulOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FMulOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.fmul' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult FMulOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FMulOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FMulOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FMulOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;
  return std::nullopt;
}

void FMulOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }
}

void FMulOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);
}

::llvm::LogicalResult FMulOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FMulOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FMulOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
}

::mlir::LLVM::FastmathFlags FMulOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void FMulOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FMulOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FMulOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FMulOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FMulOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FMulOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void FMulOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult FMulOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FMulOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FMulOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult FMulOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FMulOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FMulOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FMulOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FNegOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FNegOpGenericAdaptorBase::FNegOpGenericAdaptorBase(FNegOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FastmathFlagsAttr FNegOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags FNegOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
FNegOpAdaptor::FNegOpAdaptor(FNegOp op) : FNegOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FNegOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.fneg' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult FNegOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FNegOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FNegOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FNegOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;
  return std::nullopt;
}

void FNegOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }
}

void FNegOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);
}

::llvm::LogicalResult FNegOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FNegOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FNegOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
}

::mlir::LLVM::FastmathFlags FNegOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void FNegOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value operand, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(operand);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(operand);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FNegOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(operand);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value operand, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FNegOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FNegOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FNegOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FNegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FNegOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FNegOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void FNegOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult FNegOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FNegOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FNegOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult FNegOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand operandRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> operandOperands(&operandRawOperand, 1);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(operandOperands, resTypes[0], operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FNegOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperand();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FNegOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FNegOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FPExtOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
FPExtOpAdaptor::FPExtOpAdaptor(FPExtOp op) : FPExtOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FPExtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void FPExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FPExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void FPExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FPExtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult FPExtOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FPExtOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FPExtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FPExtOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FPExtOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FPExtOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FPToSIOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
FPToSIOpAdaptor::FPToSIOpAdaptor(FPToSIOp op) : FPToSIOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FPToSIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void FPToSIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FPToSIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void FPToSIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FPToSIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult FPToSIOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FPToSIOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FPToSIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FPToSIOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FPToSIOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FPToSIOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FPToUIOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
FPToUIOpAdaptor::FPToUIOpAdaptor(FPToUIOp op) : FPToUIOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FPToUIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void FPToUIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FPToUIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void FPToUIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FPToUIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult FPToUIOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FPToUIOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FPToUIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FPToUIOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FPToUIOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FPToUIOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FPTruncOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
FPTruncOpAdaptor::FPTruncOpAdaptor(FPTruncOp op) : FPTruncOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FPTruncOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void FPTruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FPTruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void FPTruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FPTruncOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult FPTruncOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FPTruncOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FPTruncOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FPTruncOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FPTruncOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FPTruncOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FRemOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FRemOpGenericAdaptorBase::FRemOpGenericAdaptorBase(FRemOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FastmathFlagsAttr FRemOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags FRemOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
FRemOpAdaptor::FRemOpAdaptor(FRemOp op) : FRemOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FRemOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.frem' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult FRemOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FRemOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FRemOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FRemOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;
  return std::nullopt;
}

void FRemOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }
}

void FRemOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);
}

::llvm::LogicalResult FRemOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FRemOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FRemOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
}

::mlir::LLVM::FastmathFlags FRemOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void FRemOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FRemOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FRemOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FRemOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FRemOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FRemOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FRemOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void FRemOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult FRemOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FRemOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FRemOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult FRemOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FRemOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FRemOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FRemOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FSubOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FSubOpGenericAdaptorBase::FSubOpGenericAdaptorBase(FSubOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FastmathFlagsAttr FSubOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags FSubOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
FSubOpAdaptor::FSubOpAdaptor(FSubOp op) : FSubOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FSubOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.fsub' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult FSubOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FSubOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FSubOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FSubOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;
  return std::nullopt;
}

void FSubOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }
}

void FSubOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);
}

::llvm::LogicalResult FSubOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FSubOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FSubOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
}

::mlir::LLVM::FastmathFlags FSubOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void FSubOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FSubOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FSubOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FSubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FSubOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FSubOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FSubOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void FSubOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult FSubOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FSubOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FSubOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult FSubOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FSubOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FSubOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FSubOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FenceOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FenceOpGenericAdaptorBase::FenceOpGenericAdaptorBase(FenceOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::AtomicOrdering FenceOpGenericAdaptorBase::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > FenceOpGenericAdaptorBase::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
FenceOpAdaptor::FenceOpAdaptor(FenceOp op) : FenceOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FenceOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  if (!tblgen_ordering) return emitError(loc, "'llvm.fence' op ""requires attribute 'ordering'");
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;

  if (tblgen_ordering && !((::llvm::isa<::mlir::LLVM::AtomicOrderingAttr>(tblgen_ordering))))
    return emitError(loc, "'llvm.fence' op ""attribute 'ordering' failed to satisfy constraint: Atomic ordering for LLVM's memory model");

  if (tblgen_syncscope && !((::llvm::isa<::mlir::StringAttr>(tblgen_syncscope))))
    return emitError(loc, "'llvm.fence' op ""attribute 'syncscope' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

::llvm::LogicalResult FenceOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.ordering;
       auto attr = dict.get("ordering");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `ordering` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.syncscope;
       auto attr = dict.get("syncscope");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `syncscope` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FenceOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.ordering;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("ordering",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.syncscope;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("syncscope",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FenceOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.ordering.getAsOpaquePointer()), 
    llvm::hash_value(prop.syncscope.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FenceOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "ordering")
      return prop.ordering;

    if (name == "syncscope")
      return prop.syncscope;
  return std::nullopt;
}

void FenceOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "ordering") {
       prop.ordering = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.ordering)>>(value);
       return;
    }

    if (name == "syncscope") {
       prop.syncscope = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.syncscope)>>(value);
       return;
    }
}

void FenceOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.ordering) attrs.append("ordering", prop.ordering);

    if (prop.syncscope) attrs.append("syncscope", prop.syncscope);
}

::llvm::LogicalResult FenceOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getOrderingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(attr, "ordering", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSyncscopeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "syncscope", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FenceOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.ordering)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.syncscope)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FenceOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.ordering);

  writer.writeOptionalAttribute(prop.syncscope);
}

::mlir::LLVM::AtomicOrdering FenceOp::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > FenceOp::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void FenceOp::setOrdering(::mlir::LLVM::AtomicOrdering attrValue) {
  getProperties().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FenceOp::setSyncscope(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().syncscope;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void FenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    assert(isCompatibleType(resultType) && "result must be an LLVM type");
    assert(::llvm::isa<LLVMVoidType>(resultType) &&
           "for zero-result operands, only 'void' is accepted as result type");
    build(odsBuilder, odsState, operands, attributes);
  
}

void FenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope) {
  odsState.getOrAddProperties<Properties>().ordering = ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
}

void FenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope) {
  odsState.getOrAddProperties<Properties>().ordering = ordering;
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope) {
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
}

void FenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope) {
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FenceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FenceOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult FenceOp::verifyInvariantsImpl() {
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  if (!tblgen_ordering) return emitOpError("requires attribute 'ordering'");
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(*this, tblgen_ordering, "ordering")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_syncscope, "syncscope")))
    return ::mlir::failure();
  return ::mlir::success();
}

::llvm::LogicalResult FenceOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult FenceOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr syncscopeAttr;
  ::mlir::LLVM::AtomicOrderingAttr orderingAttr;
  if (::mlir::succeeded(parser.parseOptionalKeyword("syncscope"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(syncscopeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (syncscopeAttr) result.getOrAddProperties<FenceOp::Properties>().syncscope = syncscopeAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  }

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"not_atomic","unordered","monotonic","acquire","release","acq_rel","seq_cst"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "ordering", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'ordering' [not_atomic, unordered, monotonic, acquire, release, acq_rel, seq_cst]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAtomicOrdering(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "ordering attribute specification: \"" << attrStr << '"';;

      orderingAttr = ::mlir::LLVM::AtomicOrderingAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<FenceOp::Properties>().ordering = orderingAttr;
    }
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void FenceOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (getSyncscopeAttr()) {
    _odsPrinter << ' ' << "syncscope";
    _odsPrinter << "(";
    _odsPrinter.printAttributeWithoutType(getSyncscopeAttr());
    _odsPrinter << ")";
  }
  _odsPrinter << ' ';

  {
    auto caseValue = getOrdering();
    auto caseValueStr = stringifyAtomicOrdering(caseValue);
    _odsPrinter << caseValueStr;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("syncscope");
  elidedAttrs.push_back("ordering");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FenceOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::FreezeOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
FreezeOpAdaptor::FreezeOpAdaptor(FreezeOp op) : FreezeOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FreezeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void FreezeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void FreezeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value val) {
  odsState.addOperands(val);
  odsState.addTypes(res);
}

void FreezeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value val) {
  odsState.addOperands(val);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(FreezeOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FreezeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value val) {
  odsState.addOperands(val);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FreezeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FreezeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(FreezeOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult FreezeOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FreezeOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult FreezeOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult FreezeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand valRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valOperands(&valRawOperand, 1);  ::llvm::SMLoc valOperandsLoc;
  (void)valOperandsLoc;
  ::mlir::Type valRawType{};
  ::llvm::ArrayRef<::mlir::Type> valTypes(&valRawType, 1);

  valOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valRawType = type;
  }
  result.addTypes(valTypes[0]);
  if (parser.resolveOperands(valOperands, valTypes, valOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FreezeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getVal();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVal().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FreezeOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::FreezeOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::GEPOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
GEPOpGenericAdaptorBase::GEPOpGenericAdaptorBase(GEPOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> GEPOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::ArrayRef<int32_t> GEPOpGenericAdaptorBase::getRawConstantIndices() {
  auto attr = getRawConstantIndicesAttr();
  return attr;
}

::mlir::Type GEPOpGenericAdaptorBase::getElemType() {
  auto attr = getElemTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

::mlir::UnitAttr GEPOpGenericAdaptorBase::getInboundsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().inbounds);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool GEPOpGenericAdaptorBase::getInbounds() {
  auto attr = getInboundsAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
GEPOpAdaptor::GEPOpAdaptor(GEPOp op) : GEPOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GEPOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_elem_type = getProperties().elem_type; (void)tblgen_elem_type;
  if (!tblgen_elem_type) return emitError(loc, "'llvm.getelementptr' op ""requires attribute 'elem_type'");
  auto tblgen_inbounds = getProperties().inbounds; (void)tblgen_inbounds;
  auto tblgen_rawConstantIndices = getProperties().rawConstantIndices; (void)tblgen_rawConstantIndices;
  if (!tblgen_rawConstantIndices) return emitError(loc, "'llvm.getelementptr' op ""requires attribute 'rawConstantIndices'");

  if (tblgen_rawConstantIndices && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_rawConstantIndices))))
    return emitError(loc, "'llvm.getelementptr' op ""attribute 'rawConstantIndices' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_elem_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_elem_type))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(tblgen_elem_type).getValue()))) && ((true))))
    return emitError(loc, "'llvm.getelementptr' op ""attribute 'elem_type' failed to satisfy constraint: any type attribute");

  if (tblgen_inbounds && !((::llvm::isa<::mlir::UnitAttr>(tblgen_inbounds))))
    return emitError(loc, "'llvm.getelementptr' op ""attribute 'inbounds' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GEPOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange GEPOp::getDynamicIndicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::llvm::LogicalResult GEPOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.elem_type;
       auto attr = dict.get("elem_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `elem_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.inbounds;
       auto attr = dict.get("inbounds");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `inbounds` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rawConstantIndices;
       auto attr = dict.get("rawConstantIndices");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rawConstantIndices` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GEPOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.elem_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("elem_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.inbounds;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("inbounds",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rawConstantIndices;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rawConstantIndices",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GEPOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.elem_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.inbounds.getAsOpaquePointer()), 
    llvm::hash_value(prop.rawConstantIndices.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GEPOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "elem_type")
      return prop.elem_type;

    if (name == "inbounds")
      return prop.inbounds;

    if (name == "rawConstantIndices")
      return prop.rawConstantIndices;
  return std::nullopt;
}

void GEPOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "elem_type") {
       prop.elem_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.elem_type)>>(value);
       return;
    }

    if (name == "inbounds") {
       prop.inbounds = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.inbounds)>>(value);
       return;
    }

    if (name == "rawConstantIndices") {
       prop.rawConstantIndices = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rawConstantIndices)>>(value);
       return;
    }
}

void GEPOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.elem_type) attrs.append("elem_type", prop.elem_type);

    if (prop.inbounds) attrs.append("inbounds", prop.inbounds);

    if (prop.rawConstantIndices) attrs.append("rawConstantIndices", prop.rawConstantIndices);
}

::llvm::LogicalResult GEPOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getElemTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps3(attr, "elem_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInboundsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "inbounds", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRawConstantIndicesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "rawConstantIndices", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GEPOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.elem_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.inbounds)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rawConstantIndices)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GEPOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.elem_type);

  writer.writeOptionalAttribute(prop.inbounds);
  writer.writeAttribute(prop.rawConstantIndices);
}

::llvm::ArrayRef<int32_t> GEPOp::getRawConstantIndices() {
  auto attr = getRawConstantIndicesAttr();
  return attr;
}

::mlir::Type GEPOp::getElemType() {
  auto attr = getElemTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

bool GEPOp::getInbounds() {
  auto attr = getInboundsAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void GEPOp::setRawConstantIndices(::llvm::ArrayRef<int32_t> attrValue) {
  getProperties().rawConstantIndices = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(attrValue);
}

void GEPOp::setElemType(::mlir::Type attrValue) {
  getProperties().elem_type = ::mlir::TypeAttr::get(attrValue);
}

void GEPOp::setInbounds(bool attrValue) {
    auto &odsProp = getProperties().inbounds;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

::llvm::LogicalResult GEPOp::verifyInvariantsImpl() {
  auto tblgen_elem_type = getProperties().elem_type; (void)tblgen_elem_type;
  if (!tblgen_elem_type) return emitOpError("requires attribute 'elem_type'");
  auto tblgen_inbounds = getProperties().inbounds; (void)tblgen_inbounds;
  auto tblgen_rawConstantIndices = getProperties().rawConstantIndices; (void)tblgen_rawConstantIndices;
  if (!tblgen_rawConstantIndices) return emitOpError("requires attribute 'rawConstantIndices'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_rawConstantIndices, "rawConstantIndices")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps3(*this, tblgen_elem_type, "elem_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_inbounds, "inbounds")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps16(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult GEPOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult GEPOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand baseRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> baseOperands(&baseRawOperand, 1);  ::llvm::SMLoc baseOperandsLoc;
  (void)baseOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dynamicIndicesOperands;
  ::llvm::SMLoc dynamicIndicesOperandsLoc;
  (void)dynamicIndicesOperandsLoc;
  ::mlir::DenseI32ArrayAttr rawConstantIndicesAttr;
  ::llvm::ArrayRef<::mlir::Type> allOperandTypes;
  ::llvm::ArrayRef<::mlir::Type> allResultTypes;
  ::mlir::TypeAttr elem_typeAttr;
  if (::mlir::succeeded(parser.parseOptionalKeyword("inbounds"))) {
    result.getOrAddProperties<GEPOp::Properties>().inbounds = parser.getBuilder().getUnitAttr();  }

  baseOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(baseRawOperand))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();
  {
    dynamicIndicesOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseGEPIndices(parser, dynamicIndicesOperands, rawConstantIndicesAttr);
    if (odsResult) return ::mlir::failure();
    result.getOrAddProperties<GEPOp::Properties>().rawConstantIndices = rawConstantIndicesAttr;
  }
  if (parser.parseRSquare())
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  ::mlir::FunctionType allOperand__allResult_functionType;
  if (parser.parseType(allOperand__allResult_functionType))
    return ::mlir::failure();
  allOperandTypes = allOperand__allResult_functionType.getInputs();
  allResultTypes = allOperand__allResult_functionType.getResults();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(elem_typeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (elem_typeAttr) result.getOrAddProperties<GEPOp::Properties>().elem_type = elem_typeAttr;
  result.addTypes(allResultTypes);
  if (parser.resolveOperands(::llvm::concat<const ::mlir::OpAsmParser::UnresolvedOperand>(baseOperands, dynamicIndicesOperands), allOperandTypes, parser.getNameLoc(), result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GEPOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getInboundsAttr() && getInboundsAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "inbounds";
  }
  _odsPrinter << ' ';
  _odsPrinter << getBase();
  _odsPrinter << "[";
  printGEPIndices(_odsPrinter, *this, getDynamicIndices(), getRawConstantIndicesAttr());
  _odsPrinter << "]";
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("inbounds");
  elidedAttrs.push_back("rawConstantIndices");
  elidedAttrs.push_back("elem_type");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getInboundsAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("inbounds");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printFunctionalType(getOperation()->getOperandTypes(), getOperation()->getResultTypes());
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getElemTypeAttr());
}

void GEPOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::GEPOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::GlobalCtorsOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
GlobalCtorsOpGenericAdaptorBase::GlobalCtorsOpGenericAdaptorBase(GlobalCtorsOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::ArrayAttr GlobalCtorsOpGenericAdaptorBase::getCtors() {
  auto attr = getCtorsAttr();
  return attr;
}

::mlir::ArrayAttr GlobalCtorsOpGenericAdaptorBase::getPriorities() {
  auto attr = getPrioritiesAttr();
  return attr;
}

} // namespace detail
GlobalCtorsOpAdaptor::GlobalCtorsOpAdaptor(GlobalCtorsOp op) : GlobalCtorsOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GlobalCtorsOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_ctors = getProperties().ctors; (void)tblgen_ctors;
  if (!tblgen_ctors) return emitError(loc, "'llvm.mlir.global_ctors' op ""requires attribute 'ctors'");
  auto tblgen_priorities = getProperties().priorities; (void)tblgen_priorities;
  if (!tblgen_priorities) return emitError(loc, "'llvm.mlir.global_ctors' op ""requires attribute 'priorities'");

  if (tblgen_ctors && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_ctors))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_ctors), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::FlatSymbolRefAttr>(attr))); }))))
    return emitError(loc, "'llvm.mlir.global_ctors' op ""attribute 'ctors' failed to satisfy constraint: flat symbol ref array attribute");

  if (tblgen_priorities && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_priorities))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_priorities), [&](::mlir::Attribute attr) { return attr && (((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(32)))); }))))
    return emitError(loc, "'llvm.mlir.global_ctors' op ""attribute 'priorities' failed to satisfy constraint: 32-bit integer array attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GlobalCtorsOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.ctors;
       auto attr = dict.get("ctors");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `ctors` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.priorities;
       auto attr = dict.get("priorities");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `priorities` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GlobalCtorsOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.ctors;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("ctors",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.priorities;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("priorities",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GlobalCtorsOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.ctors.getAsOpaquePointer()), 
    llvm::hash_value(prop.priorities.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GlobalCtorsOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "ctors")
      return prop.ctors;

    if (name == "priorities")
      return prop.priorities;
  return std::nullopt;
}

void GlobalCtorsOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "ctors") {
       prop.ctors = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.ctors)>>(value);
       return;
    }

    if (name == "priorities") {
       prop.priorities = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.priorities)>>(value);
       return;
    }
}

void GlobalCtorsOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.ctors) attrs.append("ctors", prop.ctors);

    if (prop.priorities) attrs.append("priorities", prop.priorities);
}

::llvm::LogicalResult GlobalCtorsOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCtorsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps22(attr, "ctors", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrioritiesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps23(attr, "priorities", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GlobalCtorsOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.ctors)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.priorities)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GlobalCtorsOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.ctors);
  writer.writeAttribute(prop.priorities);
}

::mlir::ArrayAttr GlobalCtorsOp::getCtors() {
  auto attr = getCtorsAttr();
  return attr;
}

::mlir::ArrayAttr GlobalCtorsOp::getPriorities() {
  auto attr = getPrioritiesAttr();
  return attr;
}

void GlobalCtorsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ArrayAttr ctors, ::mlir::ArrayAttr priorities) {
  odsState.getOrAddProperties<Properties>().ctors = ctors;
  odsState.getOrAddProperties<Properties>().priorities = priorities;
}

void GlobalCtorsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr ctors, ::mlir::ArrayAttr priorities) {
  odsState.getOrAddProperties<Properties>().ctors = ctors;
  odsState.getOrAddProperties<Properties>().priorities = priorities;
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalCtorsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GlobalCtorsOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GlobalCtorsOp::verifyInvariantsImpl() {
  auto tblgen_ctors = getProperties().ctors; (void)tblgen_ctors;
  if (!tblgen_ctors) return emitOpError("requires attribute 'ctors'");
  auto tblgen_priorities = getProperties().priorities; (void)tblgen_priorities;
  if (!tblgen_priorities) return emitOpError("requires attribute 'priorities'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps22(*this, tblgen_ctors, "ctors")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps23(*this, tblgen_priorities, "priorities")))
    return ::mlir::failure();
  return ::mlir::success();
}

::llvm::LogicalResult GlobalCtorsOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult GlobalCtorsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void GlobalCtorsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::GlobalCtorsOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::GlobalDtorsOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
GlobalDtorsOpGenericAdaptorBase::GlobalDtorsOpGenericAdaptorBase(GlobalDtorsOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::ArrayAttr GlobalDtorsOpGenericAdaptorBase::getDtors() {
  auto attr = getDtorsAttr();
  return attr;
}

::mlir::ArrayAttr GlobalDtorsOpGenericAdaptorBase::getPriorities() {
  auto attr = getPrioritiesAttr();
  return attr;
}

} // namespace detail
GlobalDtorsOpAdaptor::GlobalDtorsOpAdaptor(GlobalDtorsOp op) : GlobalDtorsOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GlobalDtorsOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_dtors = getProperties().dtors; (void)tblgen_dtors;
  if (!tblgen_dtors) return emitError(loc, "'llvm.mlir.global_dtors' op ""requires attribute 'dtors'");
  auto tblgen_priorities = getProperties().priorities; (void)tblgen_priorities;
  if (!tblgen_priorities) return emitError(loc, "'llvm.mlir.global_dtors' op ""requires attribute 'priorities'");

  if (tblgen_dtors && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_dtors))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_dtors), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::FlatSymbolRefAttr>(attr))); }))))
    return emitError(loc, "'llvm.mlir.global_dtors' op ""attribute 'dtors' failed to satisfy constraint: flat symbol ref array attribute");

  if (tblgen_priorities && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_priorities))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_priorities), [&](::mlir::Attribute attr) { return attr && (((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(32)))); }))))
    return emitError(loc, "'llvm.mlir.global_dtors' op ""attribute 'priorities' failed to satisfy constraint: 32-bit integer array attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GlobalDtorsOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dtors;
       auto attr = dict.get("dtors");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dtors` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.priorities;
       auto attr = dict.get("priorities");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `priorities` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GlobalDtorsOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dtors;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dtors",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.priorities;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("priorities",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GlobalDtorsOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dtors.getAsOpaquePointer()), 
    llvm::hash_value(prop.priorities.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GlobalDtorsOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dtors")
      return prop.dtors;

    if (name == "priorities")
      return prop.priorities;
  return std::nullopt;
}

void GlobalDtorsOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dtors") {
       prop.dtors = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dtors)>>(value);
       return;
    }

    if (name == "priorities") {
       prop.priorities = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.priorities)>>(value);
       return;
    }
}

void GlobalDtorsOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dtors) attrs.append("dtors", prop.dtors);

    if (prop.priorities) attrs.append("priorities", prop.priorities);
}

::llvm::LogicalResult GlobalDtorsOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDtorsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps22(attr, "dtors", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrioritiesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps23(attr, "priorities", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GlobalDtorsOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dtors)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.priorities)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GlobalDtorsOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dtors);
  writer.writeAttribute(prop.priorities);
}

::mlir::ArrayAttr GlobalDtorsOp::getDtors() {
  auto attr = getDtorsAttr();
  return attr;
}

::mlir::ArrayAttr GlobalDtorsOp::getPriorities() {
  auto attr = getPrioritiesAttr();
  return attr;
}

void GlobalDtorsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ArrayAttr dtors, ::mlir::ArrayAttr priorities) {
  odsState.getOrAddProperties<Properties>().dtors = dtors;
  odsState.getOrAddProperties<Properties>().priorities = priorities;
}

void GlobalDtorsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr dtors, ::mlir::ArrayAttr priorities) {
  odsState.getOrAddProperties<Properties>().dtors = dtors;
  odsState.getOrAddProperties<Properties>().priorities = priorities;
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalDtorsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GlobalDtorsOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GlobalDtorsOp::verifyInvariantsImpl() {
  auto tblgen_dtors = getProperties().dtors; (void)tblgen_dtors;
  if (!tblgen_dtors) return emitOpError("requires attribute 'dtors'");
  auto tblgen_priorities = getProperties().priorities; (void)tblgen_priorities;
  if (!tblgen_priorities) return emitOpError("requires attribute 'priorities'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps22(*this, tblgen_dtors, "dtors")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps23(*this, tblgen_priorities, "priorities")))
    return ::mlir::failure();
  return ::mlir::success();
}

::llvm::LogicalResult GlobalDtorsOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult GlobalDtorsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void GlobalDtorsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::GlobalDtorsOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::GlobalOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
GlobalOpGenericAdaptorBase::GlobalOpGenericAdaptorBase(GlobalOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Type GlobalOpGenericAdaptorBase::getGlobalType() {
  auto attr = getGlobalTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

::mlir::UnitAttr GlobalOpGenericAdaptorBase::getConstantAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().constant);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool GlobalOpGenericAdaptorBase::getConstant() {
  auto attr = getConstantAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::llvm::StringRef GlobalOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::LLVM::Linkage GlobalOpGenericAdaptorBase::getLinkage() {
  auto attr = getLinkageAttr();
  return attr.getLinkage();
}

::mlir::UnitAttr GlobalOpGenericAdaptorBase::getDsoLocalAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().dso_local);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool GlobalOpGenericAdaptorBase::getDsoLocal() {
  auto attr = getDsoLocalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr GlobalOpGenericAdaptorBase::getThreadLocal_Attr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().thread_local_);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool GlobalOpGenericAdaptorBase::getThreadLocal_() {
  auto attr = getThreadLocal_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr GlobalOpGenericAdaptorBase::getExternallyInitializedAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().externally_initialized);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool GlobalOpGenericAdaptorBase::getExternallyInitialized() {
  auto attr = getExternallyInitializedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional<::mlir::Attribute> GlobalOpGenericAdaptorBase::getValue() {
  auto attr = getValueAttr();
  return attr ? ::std::optional<::mlir::Attribute>(attr) : (::std::nullopt);
}

::std::optional<uint64_t> GlobalOpGenericAdaptorBase::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::mlir::IntegerAttr GlobalOpGenericAdaptorBase::getAddrSpaceAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().addr_space);
  return attr;
}

uint32_t GlobalOpGenericAdaptorBase::getAddrSpace() {
  auto attr = getAddrSpaceAttr();
  return attr.getValue().getZExtValue();
}

::std::optional<::mlir::LLVM::UnnamedAddr> GlobalOpGenericAdaptorBase::getUnnamedAddr() {
  auto attr = getUnnamedAddrAttr();
  return attr ? ::std::optional<::mlir::LLVM::UnnamedAddr>(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > GlobalOpGenericAdaptorBase::getSection() {
  auto attr = getSectionAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::SymbolRefAttr > GlobalOpGenericAdaptorBase::getComdat() {
  auto attr = getComdatAttr();
  return attr ? ::std::optional< ::mlir::SymbolRefAttr >(attr) : (::std::nullopt);
}

::mlir::LLVM::DIGlobalVariableExpressionAttr GlobalOpGenericAdaptorBase::getDbgExprAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::DIGlobalVariableExpressionAttr>(getProperties().dbg_expr);
  return attr;
}

::mlir::LLVM::DIGlobalVariableExpressionAttr GlobalOpGenericAdaptorBase::getDbgExpr() {
  auto attr = getDbgExprAttr();
  return ::llvm::cast<::mlir::LLVM::DIGlobalVariableExpressionAttr>(attr);
}

::mlir::LLVM::VisibilityAttr GlobalOpGenericAdaptorBase::getVisibility_Attr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::VisibilityAttr>(getProperties().visibility_);
  return attr;
}

::mlir::LLVM::Visibility GlobalOpGenericAdaptorBase::getVisibility_() {
  auto attr = getVisibility_Attr();
  return attr.getValue();
}

} // namespace detail
GlobalOpAdaptor::GlobalOpAdaptor(GlobalOp op) : GlobalOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GlobalOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_addr_space = getProperties().addr_space; (void)tblgen_addr_space;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_comdat = getProperties().comdat; (void)tblgen_comdat;
  auto tblgen_constant = getProperties().constant; (void)tblgen_constant;
  auto tblgen_dbg_expr = getProperties().dbg_expr; (void)tblgen_dbg_expr;
  auto tblgen_dso_local = getProperties().dso_local; (void)tblgen_dso_local;
  auto tblgen_externally_initialized = getProperties().externally_initialized; (void)tblgen_externally_initialized;
  auto tblgen_global_type = getProperties().global_type; (void)tblgen_global_type;
  if (!tblgen_global_type) return emitError(loc, "'llvm.mlir.global' op ""requires attribute 'global_type'");
  auto tblgen_linkage = getProperties().linkage; (void)tblgen_linkage;
  if (!tblgen_linkage) return emitError(loc, "'llvm.mlir.global' op ""requires attribute 'linkage'");
  auto tblgen_section = getProperties().section; (void)tblgen_section;
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'llvm.mlir.global' op ""requires attribute 'sym_name'");
  auto tblgen_thread_local_ = getProperties().thread_local_; (void)tblgen_thread_local_;
  auto tblgen_unnamed_addr = getProperties().unnamed_addr; (void)tblgen_unnamed_addr;
  auto tblgen_value = getProperties().value; (void)tblgen_value;
  auto tblgen_visibility_ = getProperties().visibility_; (void)tblgen_visibility_;

  if (tblgen_global_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_global_type))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(tblgen_global_type).getValue()))) && ((true))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'global_type' failed to satisfy constraint: any type attribute");

  if (tblgen_constant && !((::llvm::isa<::mlir::UnitAttr>(tblgen_constant))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'constant' failed to satisfy constraint: unit attribute");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");

  if (tblgen_linkage && !((::llvm::isa<::mlir::LLVM::LinkageAttr>(tblgen_linkage))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'linkage' failed to satisfy constraint: LLVM Linkage specification");

  if (tblgen_dso_local && !((::llvm::isa<::mlir::UnitAttr>(tblgen_dso_local))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'dso_local' failed to satisfy constraint: unit attribute");

  if (tblgen_thread_local_ && !((::llvm::isa<::mlir::UnitAttr>(tblgen_thread_local_))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'thread_local_' failed to satisfy constraint: unit attribute");

  if (tblgen_externally_initialized && !((::llvm::isa<::mlir::UnitAttr>(tblgen_externally_initialized))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'externally_initialized' failed to satisfy constraint: unit attribute");

  if (tblgen_value && !((true)))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'value' failed to satisfy constraint: any attribute");

  if (tblgen_alignment && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_alignment))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_alignment).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'alignment' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_addr_space && !((((::llvm::isa<::mlir::IntegerAttr>(tblgen_addr_space))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_addr_space).getType().isSignlessInteger(32)))) && ((!::llvm::cast<::mlir::IntegerAttr>(tblgen_addr_space).getValue().isNegative()))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'addr_space' failed to satisfy constraint: 32-bit signless integer attribute whose value is non-negative");

  if (tblgen_unnamed_addr && !((::llvm::isa<::mlir::LLVM::UnnamedAddrAttr>(tblgen_unnamed_addr))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'unnamed_addr' failed to satisfy constraint: LLVM GlobalValue UnnamedAddr");

  if (tblgen_section && !((::llvm::isa<::mlir::StringAttr>(tblgen_section))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'section' failed to satisfy constraint: string attribute");

  if (tblgen_comdat && !((::llvm::isa<::mlir::SymbolRefAttr>(tblgen_comdat))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'comdat' failed to satisfy constraint: symbol reference attribute");

  if (tblgen_dbg_expr && !((::llvm::isa<::mlir::LLVM::DIGlobalVariableExpressionAttr>(tblgen_dbg_expr))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'dbg_expr' failed to satisfy constraint: ");

  if (tblgen_visibility_ && !((::llvm::isa<::mlir::LLVM::VisibilityAttr>(tblgen_visibility_))))
    return emitError(loc, "'llvm.mlir.global' op ""attribute 'visibility_' failed to satisfy constraint: LLVM GlobalValue Visibility");
  return ::mlir::success();
}

::llvm::LogicalResult GlobalOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.addr_space;
       auto attr = dict.get("addr_space");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `addr_space` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alignment;
       auto attr = dict.get("alignment");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alignment` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.comdat;
       auto attr = dict.get("comdat");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `comdat` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.constant;
       auto attr = dict.get("constant");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `constant` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dbg_expr;
       auto attr = dict.get("dbg_expr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dbg_expr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dso_local;
       auto attr = dict.get("dso_local");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dso_local` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.externally_initialized;
       auto attr = dict.get("externally_initialized");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `externally_initialized` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.global_type;
       auto attr = dict.get("global_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `global_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.linkage;
       auto attr = dict.get("linkage");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `linkage` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.section;
       auto attr = dict.get("section");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `section` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.thread_local_;
       auto attr = dict.get("thread_local_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `thread_local_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.unnamed_addr;
       auto attr = dict.get("unnamed_addr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `unnamed_addr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.value;
       auto attr = dict.get("value");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `value` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.visibility_;
       auto attr = dict.get("visibility_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `visibility_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GlobalOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.addr_space;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("addr_space",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alignment;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alignment",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.comdat;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("comdat",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.constant;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("constant",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dbg_expr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dbg_expr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dso_local;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dso_local",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.externally_initialized;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("externally_initialized",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.global_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("global_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.linkage;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("linkage",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.section;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("section",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.thread_local_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("thread_local_",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.unnamed_addr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("unnamed_addr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.value;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("value",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.visibility_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("visibility_",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GlobalOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.addr_space.getAsOpaquePointer()), 
    llvm::hash_value(prop.alignment.getAsOpaquePointer()), 
    llvm::hash_value(prop.comdat.getAsOpaquePointer()), 
    llvm::hash_value(prop.constant.getAsOpaquePointer()), 
    llvm::hash_value(prop.dbg_expr.getAsOpaquePointer()), 
    llvm::hash_value(prop.dso_local.getAsOpaquePointer()), 
    llvm::hash_value(prop.externally_initialized.getAsOpaquePointer()), 
    llvm::hash_value(prop.global_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.linkage.getAsOpaquePointer()), 
    llvm::hash_value(prop.section.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.thread_local_.getAsOpaquePointer()), 
    llvm::hash_value(prop.unnamed_addr.getAsOpaquePointer()), 
    llvm::hash_value(prop.value.getAsOpaquePointer()), 
    llvm::hash_value(prop.visibility_.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GlobalOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "addr_space")
      return prop.addr_space;

    if (name == "alignment")
      return prop.alignment;

    if (name == "comdat")
      return prop.comdat;

    if (name == "constant")
      return prop.constant;

    if (name == "dbg_expr")
      return prop.dbg_expr;

    if (name == "dso_local")
      return prop.dso_local;

    if (name == "externally_initialized")
      return prop.externally_initialized;

    if (name == "global_type")
      return prop.global_type;

    if (name == "linkage")
      return prop.linkage;

    if (name == "section")
      return prop.section;

    if (name == "sym_name")
      return prop.sym_name;

    if (name == "thread_local_")
      return prop.thread_local_;

    if (name == "unnamed_addr")
      return prop.unnamed_addr;

    if (name == "value")
      return prop.value;

    if (name == "visibility_")
      return prop.visibility_;
  return std::nullopt;
}

void GlobalOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "addr_space") {
       prop.addr_space = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.addr_space)>>(value);
       return;
    }

    if (name == "alignment") {
       prop.alignment = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alignment)>>(value);
       return;
    }

    if (name == "comdat") {
       prop.comdat = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.comdat)>>(value);
       return;
    }

    if (name == "constant") {
       prop.constant = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.constant)>>(value);
       return;
    }

    if (name == "dbg_expr") {
       prop.dbg_expr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dbg_expr)>>(value);
       return;
    }

    if (name == "dso_local") {
       prop.dso_local = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dso_local)>>(value);
       return;
    }

    if (name == "externally_initialized") {
       prop.externally_initialized = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.externally_initialized)>>(value);
       return;
    }

    if (name == "global_type") {
       prop.global_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.global_type)>>(value);
       return;
    }

    if (name == "linkage") {
       prop.linkage = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.linkage)>>(value);
       return;
    }

    if (name == "section") {
       prop.section = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.section)>>(value);
       return;
    }

    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }

    if (name == "thread_local_") {
       prop.thread_local_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.thread_local_)>>(value);
       return;
    }

    if (name == "unnamed_addr") {
       prop.unnamed_addr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.unnamed_addr)>>(value);
       return;
    }

    if (name == "value") {
       prop.value = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.value)>>(value);
       return;
    }

    if (name == "visibility_") {
       prop.visibility_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.visibility_)>>(value);
       return;
    }
}

void GlobalOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.addr_space) attrs.append("addr_space", prop.addr_space);

    if (prop.alignment) attrs.append("alignment", prop.alignment);

    if (prop.comdat) attrs.append("comdat", prop.comdat);

    if (prop.constant) attrs.append("constant", prop.constant);

    if (prop.dbg_expr) attrs.append("dbg_expr", prop.dbg_expr);

    if (prop.dso_local) attrs.append("dso_local", prop.dso_local);

    if (prop.externally_initialized) attrs.append("externally_initialized", prop.externally_initialized);

    if (prop.global_type) attrs.append("global_type", prop.global_type);

    if (prop.linkage) attrs.append("linkage", prop.linkage);

    if (prop.section) attrs.append("section", prop.section);

    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);

    if (prop.thread_local_) attrs.append("thread_local_", prop.thread_local_);

    if (prop.unnamed_addr) attrs.append("unnamed_addr", prop.unnamed_addr);

    if (prop.value) attrs.append("value", prop.value);

    if (prop.visibility_) attrs.append("visibility_", prop.visibility_);
}

::llvm::LogicalResult GlobalOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAddrSpaceAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps25(attr, "addr_space", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAlignmentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "alignment", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getComdatAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps27(attr, "comdat", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getConstantAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "constant", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDbgExprAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps28(attr, "dbg_expr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDsoLocalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "dso_local", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getExternallyInitializedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "externally_initialized", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGlobalTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps3(attr, "global_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLinkageAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps24(attr, "linkage", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSectionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "section", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getThreadLocal_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "thread_local_", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUnnamedAddrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps26(attr, "unnamed_addr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getValueAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps19(attr, "value", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVisibility_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps29(attr, "visibility_", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GlobalOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.addr_space)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alignment)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.comdat)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.constant)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dbg_expr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dso_local)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.externally_initialized)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.global_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.linkage)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.section)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.thread_local_)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.unnamed_addr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.value)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.visibility_)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GlobalOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.addr_space);

  writer.writeOptionalAttribute(prop.alignment);

  writer.writeOptionalAttribute(prop.comdat);

  writer.writeOptionalAttribute(prop.constant);

  writer.writeOptionalAttribute(prop.dbg_expr);

  writer.writeOptionalAttribute(prop.dso_local);

  writer.writeOptionalAttribute(prop.externally_initialized);
  writer.writeAttribute(prop.global_type);
  writer.writeAttribute(prop.linkage);

  writer.writeOptionalAttribute(prop.section);
  writer.writeAttribute(prop.sym_name);

  writer.writeOptionalAttribute(prop.thread_local_);

  writer.writeOptionalAttribute(prop.unnamed_addr);

  writer.writeOptionalAttribute(prop.value);

  writer.writeOptionalAttribute(prop.visibility_);
}

::mlir::Type GlobalOp::getGlobalType() {
  auto attr = getGlobalTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

bool GlobalOp::getConstant() {
  auto attr = getConstantAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::llvm::StringRef GlobalOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::LLVM::Linkage GlobalOp::getLinkage() {
  auto attr = getLinkageAttr();
  return attr.getLinkage();
}

bool GlobalOp::getDsoLocal() {
  auto attr = getDsoLocalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool GlobalOp::getThreadLocal_() {
  auto attr = getThreadLocal_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool GlobalOp::getExternallyInitialized() {
  auto attr = getExternallyInitializedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional<::mlir::Attribute> GlobalOp::getValue() {
  auto attr = getValueAttr();
  return attr ? ::std::optional<::mlir::Attribute>(attr) : (::std::nullopt);
}

::std::optional<uint64_t> GlobalOp::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

uint32_t GlobalOp::getAddrSpace() {
  auto attr = getAddrSpaceAttr();
  return attr.getValue().getZExtValue();
}

::std::optional<::mlir::LLVM::UnnamedAddr> GlobalOp::getUnnamedAddr() {
  auto attr = getUnnamedAddrAttr();
  return attr ? ::std::optional<::mlir::LLVM::UnnamedAddr>(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > GlobalOp::getSection() {
  auto attr = getSectionAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::SymbolRefAttr > GlobalOp::getComdat() {
  auto attr = getComdatAttr();
  return attr ? ::std::optional< ::mlir::SymbolRefAttr >(attr) : (::std::nullopt);
}

::mlir::LLVM::DIGlobalVariableExpressionAttr GlobalOp::getDbgExpr() {
  auto attr = getDbgExprAttr();
  return ::llvm::cast<::mlir::LLVM::DIGlobalVariableExpressionAttr>(attr);
}

::mlir::LLVM::Visibility GlobalOp::getVisibility_() {
  auto attr = getVisibility_Attr();
  return attr.getValue();
}

void GlobalOp::setGlobalType(::mlir::Type attrValue) {
  getProperties().global_type = ::mlir::TypeAttr::get(attrValue);
}

void GlobalOp::setConstant(bool attrValue) {
    auto &odsProp = getProperties().constant;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void GlobalOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void GlobalOp::setLinkage(::mlir::LLVM::Linkage attrValue) {
  getProperties().linkage = ::mlir::LLVM::LinkageAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void GlobalOp::setDsoLocal(bool attrValue) {
    auto &odsProp = getProperties().dso_local;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void GlobalOp::setThreadLocal_(bool attrValue) {
    auto &odsProp = getProperties().thread_local_;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void GlobalOp::setExternallyInitialized(bool attrValue) {
    auto &odsProp = getProperties().externally_initialized;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void GlobalOp::setAlignment(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().alignment;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void GlobalOp::setAddrSpace(uint32_t attrValue) {
  getProperties().addr_space = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(32), attrValue);
}

void GlobalOp::setUnnamedAddr(::std::optional<::mlir::LLVM::UnnamedAddr> attrValue) {
    auto &odsProp = getProperties().unnamed_addr;
    if (attrValue)
      odsProp = ::mlir::LLVM::UnnamedAddrAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void GlobalOp::setSection(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().section;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void GlobalOp::setVisibility_(::mlir::LLVM::Visibility attrValue) {
  getProperties().visibility_ = ::mlir::LLVM::VisibilityAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void GlobalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeAttr global_type, /*optional*/::mlir::UnitAttr constant, ::mlir::StringAttr sym_name, ::mlir::LLVM::LinkageAttr linkage, /*optional*/::mlir::UnitAttr dso_local, /*optional*/::mlir::UnitAttr thread_local_, /*optional*/::mlir::UnitAttr externally_initialized, /*optional*/::mlir::Attribute value, /*optional*/::mlir::IntegerAttr alignment, ::mlir::IntegerAttr addr_space, /*optional*/::mlir::LLVM::UnnamedAddrAttr unnamed_addr, /*optional*/::mlir::StringAttr section, /*optional*/::mlir::SymbolRefAttr comdat, ::mlir::LLVM::DIGlobalVariableExpressionAttr dbg_expr, ::mlir::LLVM::VisibilityAttr visibility_) {
  odsState.getOrAddProperties<Properties>().global_type = global_type;
  if (constant) {
    odsState.getOrAddProperties<Properties>().constant = constant;
  }
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().linkage = linkage;
  if (dso_local) {
    odsState.getOrAddProperties<Properties>().dso_local = dso_local;
  }
  if (thread_local_) {
    odsState.getOrAddProperties<Properties>().thread_local_ = thread_local_;
  }
  if (externally_initialized) {
    odsState.getOrAddProperties<Properties>().externally_initialized = externally_initialized;
  }
  if (value) {
    odsState.getOrAddProperties<Properties>().value = value;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (addr_space) {
    odsState.getOrAddProperties<Properties>().addr_space = addr_space;
  }
  if (unnamed_addr) {
    odsState.getOrAddProperties<Properties>().unnamed_addr = unnamed_addr;
  }
  if (section) {
    odsState.getOrAddProperties<Properties>().section = section;
  }
  if (comdat) {
    odsState.getOrAddProperties<Properties>().comdat = comdat;
  }
  if (dbg_expr) {
    odsState.getOrAddProperties<Properties>().dbg_expr = dbg_expr;
  }
  if (visibility_) {
    odsState.getOrAddProperties<Properties>().visibility_ = visibility_;
  }
  (void)odsState.addRegion();
}

void GlobalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::TypeAttr global_type, /*optional*/::mlir::UnitAttr constant, ::mlir::StringAttr sym_name, ::mlir::LLVM::LinkageAttr linkage, /*optional*/::mlir::UnitAttr dso_local, /*optional*/::mlir::UnitAttr thread_local_, /*optional*/::mlir::UnitAttr externally_initialized, /*optional*/::mlir::Attribute value, /*optional*/::mlir::IntegerAttr alignment, ::mlir::IntegerAttr addr_space, /*optional*/::mlir::LLVM::UnnamedAddrAttr unnamed_addr, /*optional*/::mlir::StringAttr section, /*optional*/::mlir::SymbolRefAttr comdat, ::mlir::LLVM::DIGlobalVariableExpressionAttr dbg_expr, ::mlir::LLVM::VisibilityAttr visibility_) {
  odsState.getOrAddProperties<Properties>().global_type = global_type;
  if (constant) {
    odsState.getOrAddProperties<Properties>().constant = constant;
  }
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().linkage = linkage;
  if (dso_local) {
    odsState.getOrAddProperties<Properties>().dso_local = dso_local;
  }
  if (thread_local_) {
    odsState.getOrAddProperties<Properties>().thread_local_ = thread_local_;
  }
  if (externally_initialized) {
    odsState.getOrAddProperties<Properties>().externally_initialized = externally_initialized;
  }
  if (value) {
    odsState.getOrAddProperties<Properties>().value = value;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (addr_space) {
    odsState.getOrAddProperties<Properties>().addr_space = addr_space;
  }
  if (unnamed_addr) {
    odsState.getOrAddProperties<Properties>().unnamed_addr = unnamed_addr;
  }
  if (section) {
    odsState.getOrAddProperties<Properties>().section = section;
  }
  if (comdat) {
    odsState.getOrAddProperties<Properties>().comdat = comdat;
  }
  if (dbg_expr) {
    odsState.getOrAddProperties<Properties>().dbg_expr = dbg_expr;
  }
  if (visibility_) {
    odsState.getOrAddProperties<Properties>().visibility_ = visibility_;
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type global_type, /*optional*/bool constant, ::llvm::StringRef sym_name, ::mlir::LLVM::Linkage linkage, /*optional*/bool dso_local, /*optional*/bool thread_local_, /*optional*/bool externally_initialized, /*optional*/::mlir::Attribute value, /*optional*/::mlir::IntegerAttr alignment, uint32_t addr_space, /*optional*/::mlir::LLVM::UnnamedAddrAttr unnamed_addr, /*optional*/::mlir::StringAttr section, /*optional*/::mlir::SymbolRefAttr comdat, ::mlir::LLVM::DIGlobalVariableExpressionAttr dbg_expr, ::mlir::LLVM::Visibility visibility_) {
  odsState.getOrAddProperties<Properties>().global_type = ::mlir::TypeAttr::get(global_type);
  if (constant) {
    odsState.getOrAddProperties<Properties>().constant = ((constant) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().linkage = ::mlir::LLVM::LinkageAttr::get(odsBuilder.getContext(), linkage);
  if (dso_local) {
    odsState.getOrAddProperties<Properties>().dso_local = ((dso_local) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (thread_local_) {
    odsState.getOrAddProperties<Properties>().thread_local_ = ((thread_local_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (externally_initialized) {
    odsState.getOrAddProperties<Properties>().externally_initialized = ((externally_initialized) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (value) {
    odsState.getOrAddProperties<Properties>().value = value;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  odsState.getOrAddProperties<Properties>().addr_space = odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), addr_space);
  if (unnamed_addr) {
    odsState.getOrAddProperties<Properties>().unnamed_addr = unnamed_addr;
  }
  if (section) {
    odsState.getOrAddProperties<Properties>().section = section;
  }
  if (comdat) {
    odsState.getOrAddProperties<Properties>().comdat = comdat;
  }
  odsState.getOrAddProperties<Properties>().dbg_expr = dbg_expr;
  odsState.getOrAddProperties<Properties>().visibility_ = ::mlir::LLVM::VisibilityAttr::get(odsBuilder.getContext(), visibility_);
  (void)odsState.addRegion();
}

void GlobalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Type global_type, /*optional*/bool constant, ::llvm::StringRef sym_name, ::mlir::LLVM::Linkage linkage, /*optional*/bool dso_local, /*optional*/bool thread_local_, /*optional*/bool externally_initialized, /*optional*/::mlir::Attribute value, /*optional*/::mlir::IntegerAttr alignment, uint32_t addr_space, /*optional*/::mlir::LLVM::UnnamedAddrAttr unnamed_addr, /*optional*/::mlir::StringAttr section, /*optional*/::mlir::SymbolRefAttr comdat, ::mlir::LLVM::DIGlobalVariableExpressionAttr dbg_expr, ::mlir::LLVM::Visibility visibility_) {
  odsState.getOrAddProperties<Properties>().global_type = ::mlir::TypeAttr::get(global_type);
  if (constant) {
    odsState.getOrAddProperties<Properties>().constant = ((constant) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().linkage = ::mlir::LLVM::LinkageAttr::get(odsBuilder.getContext(), linkage);
  if (dso_local) {
    odsState.getOrAddProperties<Properties>().dso_local = ((dso_local) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (thread_local_) {
    odsState.getOrAddProperties<Properties>().thread_local_ = ((thread_local_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (externally_initialized) {
    odsState.getOrAddProperties<Properties>().externally_initialized = ((externally_initialized) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (value) {
    odsState.getOrAddProperties<Properties>().value = value;
  }
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  odsState.getOrAddProperties<Properties>().addr_space = odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), addr_space);
  if (unnamed_addr) {
    odsState.getOrAddProperties<Properties>().unnamed_addr = unnamed_addr;
  }
  if (section) {
    odsState.getOrAddProperties<Properties>().section = section;
  }
  if (comdat) {
    odsState.getOrAddProperties<Properties>().comdat = comdat;
  }
  odsState.getOrAddProperties<Properties>().dbg_expr = dbg_expr;
  odsState.getOrAddProperties<Properties>().visibility_ = ::mlir::LLVM::VisibilityAttr::get(odsBuilder.getContext(), visibility_);
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GlobalOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void GlobalOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.addr_space)
    properties.addr_space = odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), 0);
  if (!properties.dbg_expr)
    properties.dbg_expr = {};
  if (!properties.visibility_)
    properties.visibility_ = ::mlir::LLVM::VisibilityAttr::get(odsBuilder.getContext(), mlir::LLVM::Visibility::Default);
}

::llvm::LogicalResult GlobalOp::verifyInvariantsImpl() {
  auto tblgen_addr_space = getProperties().addr_space; (void)tblgen_addr_space;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_comdat = getProperties().comdat; (void)tblgen_comdat;
  auto tblgen_constant = getProperties().constant; (void)tblgen_constant;
  auto tblgen_dbg_expr = getProperties().dbg_expr; (void)tblgen_dbg_expr;
  auto tblgen_dso_local = getProperties().dso_local; (void)tblgen_dso_local;
  auto tblgen_externally_initialized = getProperties().externally_initialized; (void)tblgen_externally_initialized;
  auto tblgen_global_type = getProperties().global_type; (void)tblgen_global_type;
  if (!tblgen_global_type) return emitOpError("requires attribute 'global_type'");
  auto tblgen_linkage = getProperties().linkage; (void)tblgen_linkage;
  if (!tblgen_linkage) return emitOpError("requires attribute 'linkage'");
  auto tblgen_section = getProperties().section; (void)tblgen_section;
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");
  auto tblgen_thread_local_ = getProperties().thread_local_; (void)tblgen_thread_local_;
  auto tblgen_unnamed_addr = getProperties().unnamed_addr; (void)tblgen_unnamed_addr;
  auto tblgen_value = getProperties().value; (void)tblgen_value;
  auto tblgen_visibility_ = getProperties().visibility_; (void)tblgen_visibility_;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps3(*this, tblgen_global_type, "global_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_constant, "constant")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps24(*this, tblgen_linkage, "linkage")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_dso_local, "dso_local")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_thread_local_, "thread_local_")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_externally_initialized, "externally_initialized")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps19(*this, tblgen_value, "value")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_alignment, "alignment")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps25(*this, tblgen_addr_space, "addr_space")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps26(*this, tblgen_unnamed_addr, "unnamed_addr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_section, "section")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps27(*this, tblgen_comdat, "comdat")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps28(*this, tblgen_dbg_expr, "dbg_expr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps29(*this, tblgen_visibility_, "visibility_")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_LLVMOps2(*this, region, "initializer", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult GlobalOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::GlobalOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ICmpOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ICmpOpGenericAdaptorBase::ICmpOpGenericAdaptorBase(ICmpOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::ICmpPredicate ICmpOpGenericAdaptorBase::getPredicate() {
  auto attr = getPredicateAttr();
  return attr.getValue();
}

} // namespace detail
ICmpOpAdaptor::ICmpOpAdaptor(ICmpOp op) : ICmpOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ICmpOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_predicate = getProperties().predicate; (void)tblgen_predicate;
  if (!tblgen_predicate) return emitError(loc, "'llvm.icmp' op ""requires attribute 'predicate'");

  if (tblgen_predicate && !((::llvm::isa<::mlir::LLVM::ICmpPredicateAttr>(tblgen_predicate))))
    return emitError(loc, "'llvm.icmp' op ""attribute 'predicate' failed to satisfy constraint: lvm.icmp comparison predicate");
  return ::mlir::success();
}

::llvm::LogicalResult ICmpOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.predicate;
       auto attr = dict.get("predicate");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `predicate` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ICmpOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.predicate;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("predicate",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ICmpOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.predicate.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ICmpOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "predicate")
      return prop.predicate;
  return std::nullopt;
}

void ICmpOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "predicate") {
       prop.predicate = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.predicate)>>(value);
       return;
    }
}

void ICmpOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.predicate) attrs.append("predicate", prop.predicate);
}

::llvm::LogicalResult ICmpOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getPredicateAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps30(attr, "predicate", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ICmpOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.predicate)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ICmpOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.predicate);
}

::mlir::LLVM::ICmpPredicate ICmpOp::getPredicate() {
  auto attr = getPredicateAttr();
  return attr.getValue();
}

void ICmpOp::setPredicate(::mlir::LLVM::ICmpPredicate attrValue) {
  getProperties().predicate = ::mlir::LLVM::ICmpPredicateAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void ICmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::LLVM::ICmpPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = predicate;
  odsState.addTypes(res);
}

void ICmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::ICmpPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = predicate;

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(ICmpOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ICmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::ICmpPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = predicate;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ICmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::LLVM::ICmpPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = ::mlir::LLVM::ICmpPredicateAttr::get(odsBuilder.getContext(), predicate);
  odsState.addTypes(res);
}

void ICmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::LLVM::ICmpPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = ::mlir::LLVM::ICmpPredicateAttr::get(odsBuilder.getContext(), predicate);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(ICmpOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ICmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::LLVM::ICmpPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().predicate = ::mlir::LLVM::ICmpPredicateAttr::get(odsBuilder.getContext(), predicate);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ICmpOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ICmpOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void ICmpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ICmpOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(ICmpOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult ICmpOp::verifyInvariantsImpl() {
  auto tblgen_predicate = getProperties().predicate; (void)tblgen_predicate;
  if (!tblgen_predicate) return emitOpError("requires attribute 'predicate'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps30(*this, tblgen_predicate, "predicate")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps17(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps17(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(::getI1SameShape((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result type has i1 element type and same shape as operands");
  return ::mlir::success();
}

::llvm::LogicalResult ICmpOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult ICmpOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = ::getI1SameShape(operands[0].getType());
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

void ICmpOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ICmpOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::InlineAsmOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
InlineAsmOpGenericAdaptorBase::InlineAsmOpGenericAdaptorBase(InlineAsmOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> InlineAsmOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::StringRef InlineAsmOpGenericAdaptorBase::getAsmString() {
  auto attr = getAsmStringAttr();
  return attr.getValue();
}

::llvm::StringRef InlineAsmOpGenericAdaptorBase::getConstraints() {
  auto attr = getConstraintsAttr();
  return attr.getValue();
}

::mlir::UnitAttr InlineAsmOpGenericAdaptorBase::getHasSideEffectsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().has_side_effects);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool InlineAsmOpGenericAdaptorBase::getHasSideEffects() {
  auto attr = getHasSideEffectsAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr InlineAsmOpGenericAdaptorBase::getIsAlignStackAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().is_align_stack);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool InlineAsmOpGenericAdaptorBase::getIsAlignStack() {
  auto attr = getIsAlignStackAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional<::mlir::LLVM::AsmDialect> InlineAsmOpGenericAdaptorBase::getAsmDialect() {
  auto attr = getAsmDialectAttr();
  return attr ? ::std::optional<::mlir::LLVM::AsmDialect>(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > InlineAsmOpGenericAdaptorBase::getOperandAttrs() {
  auto attr = getOperandAttrsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
InlineAsmOpAdaptor::InlineAsmOpAdaptor(InlineAsmOp op) : InlineAsmOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult InlineAsmOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asm_dialect = getProperties().asm_dialect; (void)tblgen_asm_dialect;
  auto tblgen_asm_string = getProperties().asm_string; (void)tblgen_asm_string;
  if (!tblgen_asm_string) return emitError(loc, "'llvm.inline_asm' op ""requires attribute 'asm_string'");
  auto tblgen_constraints = getProperties().constraints; (void)tblgen_constraints;
  if (!tblgen_constraints) return emitError(loc, "'llvm.inline_asm' op ""requires attribute 'constraints'");
  auto tblgen_has_side_effects = getProperties().has_side_effects; (void)tblgen_has_side_effects;
  auto tblgen_is_align_stack = getProperties().is_align_stack; (void)tblgen_is_align_stack;
  auto tblgen_operand_attrs = getProperties().operand_attrs; (void)tblgen_operand_attrs;

  if (tblgen_asm_string && !((::llvm::isa<::mlir::StringAttr>(tblgen_asm_string))))
    return emitError(loc, "'llvm.inline_asm' op ""attribute 'asm_string' failed to satisfy constraint: string attribute");

  if (tblgen_constraints && !((::llvm::isa<::mlir::StringAttr>(tblgen_constraints))))
    return emitError(loc, "'llvm.inline_asm' op ""attribute 'constraints' failed to satisfy constraint: string attribute");

  if (tblgen_has_side_effects && !((::llvm::isa<::mlir::UnitAttr>(tblgen_has_side_effects))))
    return emitError(loc, "'llvm.inline_asm' op ""attribute 'has_side_effects' failed to satisfy constraint: unit attribute");

  if (tblgen_is_align_stack && !((::llvm::isa<::mlir::UnitAttr>(tblgen_is_align_stack))))
    return emitError(loc, "'llvm.inline_asm' op ""attribute 'is_align_stack' failed to satisfy constraint: unit attribute");

  if (tblgen_asm_dialect && !((::llvm::isa<::mlir::LLVM::AsmDialectAttr>(tblgen_asm_dialect))))
    return emitError(loc, "'llvm.inline_asm' op ""attribute 'asm_dialect' failed to satisfy constraint: ATT (0) or Intel (1) asm dialect");

  if (tblgen_operand_attrs && !((::llvm::isa<::mlir::ArrayAttr>(tblgen_operand_attrs))))
    return emitError(loc, "'llvm.inline_asm' op ""attribute 'operand_attrs' failed to satisfy constraint: array attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> InlineAsmOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange InlineAsmOp::getOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> InlineAsmOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult InlineAsmOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asm_dialect;
       auto attr = dict.get("asm_dialect");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asm_dialect` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asm_string;
       auto attr = dict.get("asm_string");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asm_string` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.constraints;
       auto attr = dict.get("constraints");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `constraints` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.has_side_effects;
       auto attr = dict.get("has_side_effects");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `has_side_effects` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.is_align_stack;
       auto attr = dict.get("is_align_stack");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `is_align_stack` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.operand_attrs;
       auto attr = dict.get("operand_attrs");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `operand_attrs` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute InlineAsmOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asm_dialect;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asm_dialect",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asm_string;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asm_string",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.constraints;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("constraints",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.has_side_effects;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("has_side_effects",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.is_align_stack;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("is_align_stack",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operand_attrs;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("operand_attrs",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code InlineAsmOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.asm_dialect.getAsOpaquePointer()), 
    llvm::hash_value(prop.asm_string.getAsOpaquePointer()), 
    llvm::hash_value(prop.constraints.getAsOpaquePointer()), 
    llvm::hash_value(prop.has_side_effects.getAsOpaquePointer()), 
    llvm::hash_value(prop.is_align_stack.getAsOpaquePointer()), 
    llvm::hash_value(prop.operand_attrs.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> InlineAsmOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asm_dialect")
      return prop.asm_dialect;

    if (name == "asm_string")
      return prop.asm_string;

    if (name == "constraints")
      return prop.constraints;

    if (name == "has_side_effects")
      return prop.has_side_effects;

    if (name == "is_align_stack")
      return prop.is_align_stack;

    if (name == "operand_attrs")
      return prop.operand_attrs;
  return std::nullopt;
}

void InlineAsmOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asm_dialect") {
       prop.asm_dialect = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asm_dialect)>>(value);
       return;
    }

    if (name == "asm_string") {
       prop.asm_string = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asm_string)>>(value);
       return;
    }

    if (name == "constraints") {
       prop.constraints = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.constraints)>>(value);
       return;
    }

    if (name == "has_side_effects") {
       prop.has_side_effects = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.has_side_effects)>>(value);
       return;
    }

    if (name == "is_align_stack") {
       prop.is_align_stack = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.is_align_stack)>>(value);
       return;
    }

    if (name == "operand_attrs") {
       prop.operand_attrs = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.operand_attrs)>>(value);
       return;
    }
}

void InlineAsmOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asm_dialect) attrs.append("asm_dialect", prop.asm_dialect);

    if (prop.asm_string) attrs.append("asm_string", prop.asm_string);

    if (prop.constraints) attrs.append("constraints", prop.constraints);

    if (prop.has_side_effects) attrs.append("has_side_effects", prop.has_side_effects);

    if (prop.is_align_stack) attrs.append("is_align_stack", prop.is_align_stack);

    if (prop.operand_attrs) attrs.append("operand_attrs", prop.operand_attrs);
}

::llvm::LogicalResult InlineAsmOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsmDialectAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps31(attr, "asm_dialect", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsmStringAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "asm_string", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getConstraintsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "constraints", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getHasSideEffectsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "has_side_effects", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIsAlignStackAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "is_align_stack", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOperandAttrsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps32(attr, "operand_attrs", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult InlineAsmOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asm_dialect)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.asm_string)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.constraints)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.has_side_effects)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.is_align_stack)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.operand_attrs)))
    return ::mlir::failure();
  return ::mlir::success();
}

void InlineAsmOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asm_dialect);
  writer.writeAttribute(prop.asm_string);
  writer.writeAttribute(prop.constraints);

  writer.writeOptionalAttribute(prop.has_side_effects);

  writer.writeOptionalAttribute(prop.is_align_stack);

  writer.writeOptionalAttribute(prop.operand_attrs);
}

::llvm::StringRef InlineAsmOp::getAsmString() {
  auto attr = getAsmStringAttr();
  return attr.getValue();
}

::llvm::StringRef InlineAsmOp::getConstraints() {
  auto attr = getConstraintsAttr();
  return attr.getValue();
}

bool InlineAsmOp::getHasSideEffects() {
  auto attr = getHasSideEffectsAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool InlineAsmOp::getIsAlignStack() {
  auto attr = getIsAlignStackAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional<::mlir::LLVM::AsmDialect> InlineAsmOp::getAsmDialect() {
  auto attr = getAsmDialectAttr();
  return attr ? ::std::optional<::mlir::LLVM::AsmDialect>(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > InlineAsmOp::getOperandAttrs() {
  auto attr = getOperandAttrsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void InlineAsmOp::setAsmString(::llvm::StringRef attrValue) {
  getProperties().asm_string = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void InlineAsmOp::setConstraints(::llvm::StringRef attrValue) {
  getProperties().constraints = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void InlineAsmOp::setHasSideEffects(bool attrValue) {
    auto &odsProp = getProperties().has_side_effects;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void InlineAsmOp::setIsAlignStack(bool attrValue) {
    auto &odsProp = getProperties().is_align_stack;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void InlineAsmOp::setAsmDialect(::std::optional<::mlir::LLVM::AsmDialect> attrValue) {
    auto &odsProp = getProperties().asm_dialect;
    if (attrValue)
      odsProp = ::mlir::LLVM::AsmDialectAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void InlineAsmOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type res, ::mlir::ValueRange operands, ::mlir::StringAttr asm_string, ::mlir::StringAttr constraints, /*optional*/::mlir::UnitAttr has_side_effects, /*optional*/::mlir::UnitAttr is_align_stack, /*optional*/::mlir::LLVM::AsmDialectAttr asm_dialect, /*optional*/::mlir::ArrayAttr operand_attrs) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().asm_string = asm_string;
  odsState.getOrAddProperties<Properties>().constraints = constraints;
  if (has_side_effects) {
    odsState.getOrAddProperties<Properties>().has_side_effects = has_side_effects;
  }
  if (is_align_stack) {
    odsState.getOrAddProperties<Properties>().is_align_stack = is_align_stack;
  }
  if (asm_dialect) {
    odsState.getOrAddProperties<Properties>().asm_dialect = asm_dialect;
  }
  if (operand_attrs) {
    odsState.getOrAddProperties<Properties>().operand_attrs = operand_attrs;
  }
  if (res)
    odsState.addTypes(res);
}

void InlineAsmOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::mlir::StringAttr asm_string, ::mlir::StringAttr constraints, /*optional*/::mlir::UnitAttr has_side_effects, /*optional*/::mlir::UnitAttr is_align_stack, /*optional*/::mlir::LLVM::AsmDialectAttr asm_dialect, /*optional*/::mlir::ArrayAttr operand_attrs) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().asm_string = asm_string;
  odsState.getOrAddProperties<Properties>().constraints = constraints;
  if (has_side_effects) {
    odsState.getOrAddProperties<Properties>().has_side_effects = has_side_effects;
  }
  if (is_align_stack) {
    odsState.getOrAddProperties<Properties>().is_align_stack = is_align_stack;
  }
  if (asm_dialect) {
    odsState.getOrAddProperties<Properties>().asm_dialect = asm_dialect;
  }
  if (operand_attrs) {
    odsState.getOrAddProperties<Properties>().operand_attrs = operand_attrs;
  }
  odsState.addTypes(resultTypes);
}

void InlineAsmOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type res, ::mlir::ValueRange operands, ::llvm::StringRef asm_string, ::llvm::StringRef constraints, /*optional*/bool has_side_effects, /*optional*/bool is_align_stack, /*optional*/::mlir::LLVM::AsmDialectAttr asm_dialect, /*optional*/::mlir::ArrayAttr operand_attrs) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().asm_string = odsBuilder.getStringAttr(asm_string);
  odsState.getOrAddProperties<Properties>().constraints = odsBuilder.getStringAttr(constraints);
  if (has_side_effects) {
    odsState.getOrAddProperties<Properties>().has_side_effects = ((has_side_effects) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (is_align_stack) {
    odsState.getOrAddProperties<Properties>().is_align_stack = ((is_align_stack) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (asm_dialect) {
    odsState.getOrAddProperties<Properties>().asm_dialect = asm_dialect;
  }
  if (operand_attrs) {
    odsState.getOrAddProperties<Properties>().operand_attrs = operand_attrs;
  }
  if (res)
    odsState.addTypes(res);
}

void InlineAsmOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::StringRef asm_string, ::llvm::StringRef constraints, /*optional*/bool has_side_effects, /*optional*/bool is_align_stack, /*optional*/::mlir::LLVM::AsmDialectAttr asm_dialect, /*optional*/::mlir::ArrayAttr operand_attrs) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().asm_string = odsBuilder.getStringAttr(asm_string);
  odsState.getOrAddProperties<Properties>().constraints = odsBuilder.getStringAttr(constraints);
  if (has_side_effects) {
    odsState.getOrAddProperties<Properties>().has_side_effects = ((has_side_effects) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (is_align_stack) {
    odsState.getOrAddProperties<Properties>().is_align_stack = ((is_align_stack) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (asm_dialect) {
    odsState.getOrAddProperties<Properties>().asm_dialect = asm_dialect;
  }
  if (operand_attrs) {
    odsState.getOrAddProperties<Properties>().operand_attrs = operand_attrs;
  }
  odsState.addTypes(resultTypes);
}

void InlineAsmOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<InlineAsmOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult InlineAsmOp::verifyInvariantsImpl() {
  auto tblgen_asm_dialect = getProperties().asm_dialect; (void)tblgen_asm_dialect;
  auto tblgen_asm_string = getProperties().asm_string; (void)tblgen_asm_string;
  if (!tblgen_asm_string) return emitOpError("requires attribute 'asm_string'");
  auto tblgen_constraints = getProperties().constraints; (void)tblgen_constraints;
  if (!tblgen_constraints) return emitOpError("requires attribute 'constraints'");
  auto tblgen_has_side_effects = getProperties().has_side_effects; (void)tblgen_has_side_effects;
  auto tblgen_is_align_stack = getProperties().is_align_stack; (void)tblgen_is_align_stack;
  auto tblgen_operand_attrs = getProperties().operand_attrs; (void)tblgen_operand_attrs;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_asm_string, "asm_string")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_constraints, "constraints")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_has_side_effects, "has_side_effects")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_is_align_stack, "is_align_stack")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps31(*this, tblgen_asm_dialect, "asm_dialect")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps32(*this, tblgen_operand_attrs, "operand_attrs")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("result group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult InlineAsmOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult InlineAsmOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::LLVM::AsmDialectAttr asm_dialectAttr;
  ::mlir::ArrayAttr operand_attrsAttr;
  ::mlir::StringAttr asm_stringAttr;
  ::mlir::StringAttr constraintsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> allOperands;
  ::llvm::ArrayRef<::mlir::Type> allOperandTypes;
  ::llvm::ArrayRef<::mlir::Type> allResultTypes;
  if (::mlir::succeeded(parser.parseOptionalKeyword("has_side_effects"))) {
    result.getOrAddProperties<InlineAsmOp::Properties>().has_side_effects = parser.getBuilder().getUnitAttr();  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("is_align_stack"))) {
    result.getOrAddProperties<InlineAsmOp::Properties>().is_align_stack = parser.getBuilder().getUnitAttr();  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("asm_dialect"))) {
  if (parser.parseEqual())
    return ::mlir::failure();

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"att","intel"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "asm_dialect", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'asm_dialect' [att, intel]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAsmDialect(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "asm_dialect attribute specification: \"" << attrStr << '"';;

      asm_dialectAttr = ::mlir::LLVM::AsmDialectAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<InlineAsmOp::Properties>().asm_dialect = asm_dialectAttr;
    }
  }
  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("operand_attrs"))) {
  if (parser.parseEqual())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(operand_attrsAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (operand_attrsAttr) result.getOrAddProperties<InlineAsmOp::Properties>().operand_attrs = operand_attrsAttr;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }

  if (parser.parseCustomAttributeWithFallback(asm_stringAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (asm_stringAttr) result.getOrAddProperties<InlineAsmOp::Properties>().asm_string = asm_stringAttr;
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(constraintsAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (constraintsAttr) result.getOrAddProperties<InlineAsmOp::Properties>().constraints = constraintsAttr;
  [[maybe_unused]] ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  ::mlir::FunctionType allOperand__allResult_functionType;
  if (parser.parseType(allOperand__allResult_functionType))
    return ::mlir::failure();
  allOperandTypes = allOperand__allResult_functionType.getInputs();
  allResultTypes = allOperand__allResult_functionType.getResults();
  result.addTypes(allResultTypes);
  if (parser.resolveOperands(allOperands, allOperandTypes, allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void InlineAsmOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getHasSideEffectsAttr() && getHasSideEffectsAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "has_side_effects";
  }
  if ((getIsAlignStackAttr() && getIsAlignStackAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "is_align_stack";
  }
  if (getAsmDialectAttr()) {
    _odsPrinter << ' ' << "asm_dialect";
    _odsPrinter << ' ' << "=";
    _odsPrinter << ' ';

    {
      auto caseValue = *getAsmDialect();
      auto caseValueStr = stringifyAsmDialect(caseValue);
      _odsPrinter << caseValueStr;
    }
  }
  if (getOperandAttrsAttr()) {
    _odsPrinter << ' ' << "operand_attrs";
    _odsPrinter << ' ' << "=";
    _odsPrinter << ' ';
    _odsPrinter.printAttributeWithoutType(getOperandAttrsAttr());
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("has_side_effects");
  elidedAttrs.push_back("is_align_stack");
  elidedAttrs.push_back("asm_dialect");
  elidedAttrs.push_back("operand_attrs");
  elidedAttrs.push_back("asm_string");
  elidedAttrs.push_back("constraints");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getHasSideEffectsAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("has_side_effects");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getIsAlignStackAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("is_align_stack");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getAsmStringAttr());
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getConstraintsAttr());
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printFunctionalType(getOperation()->getOperandTypes(), getOperation()->getResultTypes());
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::InlineAsmOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::InsertElementOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
InsertElementOpAdaptor::InsertElementOpAdaptor(InsertElementOp op) : InsertElementOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult InsertElementOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void InsertElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void InsertElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value vector, ::mlir::Value value, ::mlir::Value position) {
  odsState.addOperands(vector);
  odsState.addOperands(value);
  odsState.addOperands(position);
  odsState.addTypes(res);
}

void InsertElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value vector, ::mlir::Value value, ::mlir::Value position) {
  odsState.addOperands(vector);
  odsState.addOperands(value);
  odsState.addOperands(position);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(InsertElementOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void InsertElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value vector, ::mlir::Value value, ::mlir::Value position) {
  odsState.addOperands(vector);
  odsState.addOperands(value);
  odsState.addOperands(position);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InsertElementOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void InsertElementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(InsertElementOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult InsertElementOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps18(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps12(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(LLVM::getVectorElementType((*this->getODSOperands(0).begin()).getType()), (*this->getODSOperands(1).begin()).getType()))))
    return emitOpError("failed to verify that argument type matches vector element type");
  if (!((((*this->getODSResults(0).begin()).getType()) == ((*this->getODSOperands(0).begin()).getType()) && ((*this->getODSOperands(0).begin()).getType()) == ((*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that all of {res, vector} have same type");
  return ::mlir::success();
}

::llvm::LogicalResult InsertElementOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult InsertElementOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult InsertElementOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand valueRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valueOperands(&valueRawOperand, 1);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand vectorRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> vectorOperands(&vectorRawOperand, 1);  ::llvm::SMLoc vectorOperandsLoc;
  (void)vectorOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand positionRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> positionOperands(&positionRawOperand, 1);  ::llvm::SMLoc positionOperandsLoc;
  (void)positionOperandsLoc;
  ::mlir::Type positionRawType{};
  ::llvm::ArrayRef<::mlir::Type> positionTypes(&positionRawType, 1);
  ::mlir::Type vectorRawType{};
  ::llvm::ArrayRef<::mlir::Type> vectorTypes(&vectorRawType, 1);

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  vectorOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(vectorRawOperand))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  positionOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(positionRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    positionRawType = type;
  }
  if (parser.parseRSquare())
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    vectorRawType = type;
  }
  for (::mlir::Type type : vectorTypes) {
    (void)type;
    if (!((::mlir::LLVM::isCompatibleVectorType(type)))) {
      return parser.emitError(parser.getNameLoc()) << "'vector' must be LLVM dialect-compatible vector type, but got " << type;
    }
  }
  result.addTypes(vectorTypes[0]);
  if (parser.resolveOperands(vectorOperands, vectorTypes, vectorOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(valueOperands, LLVM::getVectorElementType(vectorTypes[0]), valueOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(positionOperands, positionTypes, positionOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void InsertElementOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getValue();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getVector();
  _odsPrinter << "[";
  _odsPrinter << getPosition();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getPosition().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::IntegerType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << "]";
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVector().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void InsertElementOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::InsertElementOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::InsertValueOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
InsertValueOpGenericAdaptorBase::InsertValueOpGenericAdaptorBase(InsertValueOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::ArrayRef<int64_t> InsertValueOpGenericAdaptorBase::getPosition() {
  auto attr = getPositionAttr();
  return attr;
}

} // namespace detail
InsertValueOpAdaptor::InsertValueOpAdaptor(InsertValueOp op) : InsertValueOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult InsertValueOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_position = getProperties().position; (void)tblgen_position;
  if (!tblgen_position) return emitError(loc, "'llvm.insertvalue' op ""requires attribute 'position'");

  if (tblgen_position && !((::llvm::isa<::mlir::DenseI64ArrayAttr>(tblgen_position))))
    return emitError(loc, "'llvm.insertvalue' op ""attribute 'position' failed to satisfy constraint: i64 dense array attribute");
  return ::mlir::success();
}

::llvm::LogicalResult InsertValueOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.position;
       auto attr = dict.get("position");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `position` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute InsertValueOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.position;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("position",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code InsertValueOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.position.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> InsertValueOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "position")
      return prop.position;
  return std::nullopt;
}

void InsertValueOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "position") {
       prop.position = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.position)>>(value);
       return;
    }
}

void InsertValueOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.position) attrs.append("position", prop.position);
}

::llvm::LogicalResult InsertValueOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getPositionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps20(attr, "position", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult InsertValueOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.position)))
    return ::mlir::failure();
  return ::mlir::success();
}

void InsertValueOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.position);
}

::llvm::ArrayRef<int64_t> InsertValueOp::getPosition() {
  auto attr = getPositionAttr();
  return attr;
}

void InsertValueOp::setPosition(::llvm::ArrayRef<int64_t> attrValue) {
  getProperties().position = ::mlir::Builder((*this)->getContext()).getDenseI64ArrayAttr(attrValue);
}

void InsertValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value container, ::mlir::Value value, ::mlir::DenseI64ArrayAttr position) {
  odsState.addOperands(container);
  odsState.addOperands(value);
  odsState.getOrAddProperties<Properties>().position = position;
  odsState.addTypes(res);
}

void InsertValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value container, ::mlir::Value value, ::mlir::DenseI64ArrayAttr position) {
  odsState.addOperands(container);
  odsState.addOperands(value);
  odsState.getOrAddProperties<Properties>().position = position;

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(InsertValueOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void InsertValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value container, ::mlir::Value value, ::mlir::DenseI64ArrayAttr position) {
  odsState.addOperands(container);
  odsState.addOperands(value);
  odsState.getOrAddProperties<Properties>().position = position;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InsertValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value container, ::mlir::Value value, ::llvm::ArrayRef<int64_t> position) {
  odsState.addOperands(container);
  odsState.addOperands(value);
  odsState.getOrAddProperties<Properties>().position = odsBuilder.getDenseI64ArrayAttr(position);
  odsState.addTypes(res);
}

void InsertValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value container, ::mlir::Value value, ::llvm::ArrayRef<int64_t> position) {
  odsState.addOperands(container);
  odsState.addOperands(value);
  odsState.getOrAddProperties<Properties>().position = odsBuilder.getDenseI64ArrayAttr(position);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(InsertValueOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void InsertValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value container, ::mlir::Value value, ::llvm::ArrayRef<int64_t> position) {
  odsState.addOperands(container);
  odsState.addOperands(value);
  odsState.getOrAddProperties<Properties>().position = odsBuilder.getDenseI64ArrayAttr(position);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InsertValueOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<InsertValueOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void InsertValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<InsertValueOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(InsertValueOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult InsertValueOp::verifyInvariantsImpl() {
  auto tblgen_position = getProperties().position; (void)tblgen_position;
  if (!tblgen_position) return emitOpError("requires attribute 'position'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps20(*this, tblgen_position, "position")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps18(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((((*this->getODSOperands(0).begin()).getType()) == ((*this->getODSResults(0).begin()).getType()) && ((*this->getODSResults(0).begin()).getType()) == ((*this->getODSOperands(0).begin()).getType()))))
    return emitOpError("failed to verify that all of {container, res} have same type");
  return ::mlir::success();
}

::llvm::LogicalResult InsertValueOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::llvm::LogicalResult InsertValueOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult InsertValueOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand valueRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valueOperands(&valueRawOperand, 1);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand containerRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> containerOperands(&containerRawOperand, 1);  ::llvm::SMLoc containerOperandsLoc;
  (void)containerOperandsLoc;
  ::mlir::DenseI64ArrayAttr positionAttr;
  ::mlir::Type containerRawType{};
  ::llvm::ArrayRef<::mlir::Type> containerTypes(&containerRawType, 1);
  ::mlir::Type valueRawType{};
  ::llvm::ArrayRef<::mlir::Type> valueTypes(&valueRawType, 1);

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  containerOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(containerRawOperand))
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(positionAttr, ::mlir::Type{})) {
    return ::mlir::failure();
  }
  if (positionAttr) result.getOrAddProperties<InsertValueOp::Properties>().position = positionAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    containerRawType = type;
  }
  {
    auto odsResult = parseInsertExtractValueElementType(parser, valueRawType, containerRawType, positionAttr);
    if (odsResult) return ::mlir::failure();
  }
  result.addTypes(containerTypes[0]);
  if (parser.resolveOperands(containerOperands, containerTypes, containerOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void InsertValueOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getValue();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getContainer();
_odsPrinter.printStrippedAttrOrType(getPositionAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("position");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getContainer().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ';
  printInsertExtractValueElementType(_odsPrinter, *this, getValue().getType(), getContainer().getType(), getPositionAttr());
}

void InsertValueOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::InsertValueOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::IntToPtrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
IntToPtrOpAdaptor::IntToPtrOpAdaptor(IntToPtrOp op) : IntToPtrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult IntToPtrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void IntToPtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void IntToPtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void IntToPtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IntToPtrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult IntToPtrOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult IntToPtrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult IntToPtrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IntToPtrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void IntToPtrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::IntToPtrOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::InvokeOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
InvokeOpGenericAdaptorBase::InvokeOpGenericAdaptorBase(InvokeOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> InvokeOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional<::mlir::LLVM::LLVMFunctionType> InvokeOpGenericAdaptorBase::getVarCalleeType() {
  auto attr = getVarCalleeTypeAttr();
  return attr ? ::std::optional<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::LLVM::LLVMFunctionType>(attr.getValue())) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > InvokeOpGenericAdaptorBase::getCallee() {
  auto attr = getCalleeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> InvokeOpGenericAdaptorBase::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::mlir::LLVM::CConvAttr InvokeOpGenericAdaptorBase::getCConvAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::CConvAttr>(getProperties().CConv);
  return attr;
}

::mlir::LLVM::cconv::CConv InvokeOpGenericAdaptorBase::getCConv() {
  auto attr = getCConvAttr();
  return attr.getCallingConv();
}

} // namespace detail
InvokeOpAdaptor::InvokeOpAdaptor(InvokeOp op) : InvokeOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult InvokeOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_CConv = getProperties().CConv; (void)tblgen_CConv;
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_callee = getProperties().callee; (void)tblgen_callee;
  auto tblgen_var_callee_type = getProperties().var_callee_type; (void)tblgen_var_callee_type;

  if (tblgen_var_callee_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_var_callee_type))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(tblgen_var_callee_type).getValue()))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(tblgen_var_callee_type).getValue())))))
    return emitError(loc, "'llvm.invoke' op ""attribute 'var_callee_type' failed to satisfy constraint: type attribute of LLVM function type");

  if (tblgen_callee && !((::llvm::isa<::mlir::FlatSymbolRefAttr>(tblgen_callee))))
    return emitError(loc, "'llvm.invoke' op ""attribute 'callee' failed to satisfy constraint: flat symbol reference attribute");

  if (tblgen_branch_weights && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_branch_weights))))
    return emitError(loc, "'llvm.invoke' op ""attribute 'branch_weights' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_CConv && !((::llvm::isa<::mlir::LLVM::CConvAttr>(tblgen_CConv))))
    return emitError(loc, "'llvm.invoke' op ""attribute 'CConv' failed to satisfy constraint: LLVM Calling Convention specification");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> InvokeOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange InvokeOp::getCalleeOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange InvokeOp::getNormalDestOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange InvokeOp::getUnwindDestOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

std::pair<unsigned, unsigned> InvokeOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult InvokeOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.CConv;
       auto attr = dict.get("CConv");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `CConv` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.branch_weights;
       auto attr = dict.get("branch_weights");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `branch_weights` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.callee;
       auto attr = dict.get("callee");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `callee` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.var_callee_type;
       auto attr = dict.get("var_callee_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `var_callee_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute InvokeOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.CConv;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("CConv",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.branch_weights;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("branch_weights",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.callee;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("callee",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.var_callee_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("var_callee_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code InvokeOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.CConv.getAsOpaquePointer()), 
    llvm::hash_value(prop.branch_weights.getAsOpaquePointer()), 
    llvm::hash_value(prop.callee.getAsOpaquePointer()), 
    llvm::hash_value(prop.var_callee_type.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> InvokeOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "CConv")
      return prop.CConv;

    if (name == "branch_weights")
      return prop.branch_weights;

    if (name == "callee")
      return prop.callee;

    if (name == "var_callee_type")
      return prop.var_callee_type;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void InvokeOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "CConv") {
       prop.CConv = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.CConv)>>(value);
       return;
    }

    if (name == "branch_weights") {
       prop.branch_weights = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.branch_weights)>>(value);
       return;
    }

    if (name == "callee") {
       prop.callee = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.callee)>>(value);
       return;
    }

    if (name == "var_callee_type") {
       prop.var_callee_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.var_callee_type)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void InvokeOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.CConv) attrs.append("CConv", prop.CConv);

    if (prop.branch_weights) attrs.append("branch_weights", prop.branch_weights);

    if (prop.callee) attrs.append("callee", prop.callee);

    if (prop.var_callee_type) attrs.append("var_callee_type", prop.var_callee_type);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult InvokeOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCConvAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps15(attr, "CConv", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getBranchWeightsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "branch_weights", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCalleeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(attr, "callee", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVarCalleeTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps13(attr, "var_callee_type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult InvokeOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.CConv)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.branch_weights)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.callee)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.var_callee_type)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void InvokeOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.CConv);

  writer.writeOptionalAttribute(prop.branch_weights);

  writer.writeOptionalAttribute(prop.callee);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.var_callee_type);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional<::mlir::LLVM::LLVMFunctionType> InvokeOp::getVarCalleeType() {
  auto attr = getVarCalleeTypeAttr();
  return attr ? ::std::optional<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::LLVM::LLVMFunctionType>(attr.getValue())) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > InvokeOp::getCallee() {
  auto attr = getCalleeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> InvokeOp::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::mlir::LLVM::cconv::CConv InvokeOp::getCConv() {
  auto attr = getCConvAttr();
  return attr.getCallingConv();
}

void InvokeOp::setVarCalleeType(::std::optional<::mlir::LLVM::LLVMFunctionType> attrValue) {
    auto &odsProp = getProperties().var_callee_type;
    if (attrValue)
      odsProp = ::mlir::TypeAttr::get(*attrValue);
    else
      odsProp = nullptr;
}

void InvokeOp::setCallee(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().callee;
    if (attrValue)
      odsProp = ::mlir::SymbolRefAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void InvokeOp::setBranchWeights(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().branch_weights;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void InvokeOp::setCConv(::mlir::LLVM::cconv::CConv attrValue) {
  getProperties().CConv = ::mlir::LLVM::CConvAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void InvokeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type result, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::ValueRange normalDestOperands, ::mlir::ValueRange unwindDestOperands, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::CConvAttr CConv, ::mlir::Block *normalDest, ::mlir::Block *unwindDest) {
  odsState.addOperands(callee_operands);
  odsState.addOperands(normalDestOperands);
  odsState.addOperands(unwindDestOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(callee_operands.size()), static_cast<int32_t>(normalDestOperands.size()), static_cast<int32_t>(unwindDestOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  if (CConv) {
    odsState.getOrAddProperties<Properties>().CConv = CConv;
  }
  odsState.addSuccessors(normalDest);
  odsState.addSuccessors(unwindDest);
  if (result)
    odsState.addTypes(result);
}

void InvokeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::ValueRange normalDestOperands, ::mlir::ValueRange unwindDestOperands, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::CConvAttr CConv, ::mlir::Block *normalDest, ::mlir::Block *unwindDest) {
  odsState.addOperands(callee_operands);
  odsState.addOperands(normalDestOperands);
  odsState.addOperands(unwindDestOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(callee_operands.size()), static_cast<int32_t>(normalDestOperands.size()), static_cast<int32_t>(unwindDestOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  if (CConv) {
    odsState.getOrAddProperties<Properties>().CConv = CConv;
  }
  odsState.addSuccessors(normalDest);
  odsState.addSuccessors(unwindDest);
  odsState.addTypes(resultTypes);
}

void InvokeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type result, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::ValueRange normalDestOperands, ::mlir::ValueRange unwindDestOperands, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::cconv::CConv CConv, ::mlir::Block *normalDest, ::mlir::Block *unwindDest) {
  odsState.addOperands(callee_operands);
  odsState.addOperands(normalDestOperands);
  odsState.addOperands(unwindDestOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(callee_operands.size()), static_cast<int32_t>(normalDestOperands.size()), static_cast<int32_t>(unwindDestOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  odsState.getOrAddProperties<Properties>().CConv = ::mlir::LLVM::CConvAttr::get(odsBuilder.getContext(), CConv);
  odsState.addSuccessors(normalDest);
  odsState.addSuccessors(unwindDest);
  if (result)
    odsState.addTypes(result);
}

void InvokeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::TypeAttr var_callee_type, /*optional*/::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange callee_operands, ::mlir::ValueRange normalDestOperands, ::mlir::ValueRange unwindDestOperands, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::LLVM::cconv::CConv CConv, ::mlir::Block *normalDest, ::mlir::Block *unwindDest) {
  odsState.addOperands(callee_operands);
  odsState.addOperands(normalDestOperands);
  odsState.addOperands(unwindDestOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(callee_operands.size()), static_cast<int32_t>(normalDestOperands.size()), static_cast<int32_t>(unwindDestOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (var_callee_type) {
    odsState.getOrAddProperties<Properties>().var_callee_type = var_callee_type;
  }
  if (callee) {
    odsState.getOrAddProperties<Properties>().callee = callee;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  odsState.getOrAddProperties<Properties>().CConv = ::mlir::LLVM::CConvAttr::get(odsBuilder.getContext(), CConv);
  odsState.addSuccessors(normalDest);
  odsState.addSuccessors(unwindDest);
  odsState.addTypes(resultTypes);
}

void InvokeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<InvokeOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void InvokeOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.CConv)
    properties.CConv = ::mlir::LLVM::CConvAttr::get(odsBuilder.getContext(), CConv::C);
}

::llvm::LogicalResult InvokeOp::verifyInvariantsImpl() {
  auto tblgen_CConv = getProperties().CConv; (void)tblgen_CConv;
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_callee = getProperties().callee; (void)tblgen_callee;
  auto tblgen_var_callee_type = getProperties().var_callee_type; (void)tblgen_var_callee_type;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps13(*this, tblgen_var_callee_type, "var_callee_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(*this, tblgen_callee, "callee")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_branch_weights, "branch_weights")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps15(*this, tblgen_CConv, "CConv")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("result group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::llvm::LogicalResult InvokeOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::InvokeOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::LLVMFuncOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
LLVMFuncOpGenericAdaptorBase::LLVMFuncOpGenericAdaptorBase(LLVMFuncOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef LLVMFuncOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getSymVisibility() {
  auto attr = getSymVisibilityAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::mlir::LLVM::LLVMFunctionType LLVMFuncOpGenericAdaptorBase::getFunctionType() {
  auto attr = getFunctionTypeAttr();
  return ::llvm::cast<::mlir::LLVM::LLVMFunctionType>(attr.getValue());
}

::mlir::LLVM::LinkageAttr LLVMFuncOpGenericAdaptorBase::getLinkageAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::LinkageAttr>(getProperties().linkage);
  return attr;
}

::mlir::LLVM::Linkage LLVMFuncOpGenericAdaptorBase::getLinkage() {
  auto attr = getLinkageAttr();
  return attr.getLinkage();
}

::mlir::UnitAttr LLVMFuncOpGenericAdaptorBase::getDsoLocalAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().dso_local);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool LLVMFuncOpGenericAdaptorBase::getDsoLocal() {
  auto attr = getDsoLocalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::LLVM::CConvAttr LLVMFuncOpGenericAdaptorBase::getCConvAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::CConvAttr>(getProperties().CConv);
  return attr;
}

::mlir::LLVM::cconv::CConv LLVMFuncOpGenericAdaptorBase::getCConv() {
  auto attr = getCConvAttr();
  return attr.getCallingConv();
}

::std::optional< ::mlir::SymbolRefAttr > LLVMFuncOpGenericAdaptorBase::getComdat() {
  auto attr = getComdatAttr();
  return attr ? ::std::optional< ::mlir::SymbolRefAttr >(attr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getConvergent() {
  auto attr = getConvergentAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getPersonality() {
  auto attr = getPersonalityAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getGarbageCollector() {
  auto attr = getGarbageCollectorAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LLVMFuncOpGenericAdaptorBase::getPassthrough() {
  auto attr = getPassthroughAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LLVMFuncOpGenericAdaptorBase::getArgAttrs() {
  auto attr = getArgAttrsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LLVMFuncOpGenericAdaptorBase::getResAttrs() {
  auto attr = getResAttrsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<uint64_t> LLVMFuncOpGenericAdaptorBase::getFunctionEntryCount() {
  auto attr = getFunctionEntryCountAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::MemoryEffectsAttr> LLVMFuncOpGenericAdaptorBase::getMemoryEffects() {
  auto attr = getMemoryEffectsAttr();
  return attr ? ::std::optional<::mlir::LLVM::MemoryEffectsAttr>(::llvm::cast<::mlir::LLVM::MemoryEffectsAttr>(attr)) : (::std::nullopt);
}

::mlir::LLVM::VisibilityAttr LLVMFuncOpGenericAdaptorBase::getVisibility_Attr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::VisibilityAttr>(getProperties().visibility_);
  return attr;
}

::mlir::LLVM::Visibility LLVMFuncOpGenericAdaptorBase::getVisibility_() {
  auto attr = getVisibility_Attr();
  return attr.getValue();
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmStreaming() {
  auto attr = getArmStreamingAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmLocallyStreaming() {
  auto attr = getArmLocallyStreamingAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmStreamingCompatible() {
  auto attr = getArmStreamingCompatibleAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmNewZa() {
  auto attr = getArmNewZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmInZa() {
  auto attr = getArmInZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmOutZa() {
  auto attr = getArmOutZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmInoutZa() {
  auto attr = getArmInoutZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getArmPreservesZa() {
  auto attr = getArmPreservesZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getSection() {
  auto attr = getSectionAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::UnnamedAddr> LLVMFuncOpGenericAdaptorBase::getUnnamedAddr() {
  auto attr = getUnnamedAddrAttr();
  return attr ? ::std::optional<::mlir::LLVM::UnnamedAddr>(attr.getValue()) : (::std::nullopt);
}

::std::optional<uint64_t> LLVMFuncOpGenericAdaptorBase::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::VScaleRangeAttr> LLVMFuncOpGenericAdaptorBase::getVscaleRange() {
  auto attr = getVscaleRangeAttr();
  return attr ? ::std::optional<::mlir::LLVM::VScaleRangeAttr>(::llvm::cast<::mlir::LLVM::VScaleRangeAttr>(attr)) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::FramePointerKindAttr> LLVMFuncOpGenericAdaptorBase::getFramePointer() {
  auto attr = getFramePointerAttr();
  return attr ? ::std::optional<::mlir::LLVM::FramePointerKindAttr>(::llvm::cast<::mlir::LLVM::FramePointerKindAttr>(attr)) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getTargetCpu() {
  auto attr = getTargetCpuAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getTuneCpu() {
  auto attr = getTuneCpuAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::TargetFeaturesAttr> LLVMFuncOpGenericAdaptorBase::getTargetFeatures() {
  auto attr = getTargetFeaturesAttr();
  return attr ? ::std::optional<::mlir::LLVM::TargetFeaturesAttr>(::llvm::cast<::mlir::LLVM::TargetFeaturesAttr>(attr)) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOpGenericAdaptorBase::getUnsafeFpMath() {
  auto attr = getUnsafeFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOpGenericAdaptorBase::getNoInfsFpMath() {
  auto attr = getNoInfsFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOpGenericAdaptorBase::getNoNansFpMath() {
  auto attr = getNoNansFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOpGenericAdaptorBase::getApproxFuncFpMath() {
  auto attr = getApproxFuncFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOpGenericAdaptorBase::getNoSignedZerosFpMath() {
  auto attr = getNoSignedZerosFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getDenormalFpMath() {
  auto attr = getDenormalFpMathAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getDenormalFpMathF32() {
  auto attr = getDenormalFpMathF32Attr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOpGenericAdaptorBase::getFpContract() {
  auto attr = getFpContractAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getNoInline() {
  auto attr = getNoInlineAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getAlwaysInline() {
  auto attr = getAlwaysInlineAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getNoUnwind() {
  auto attr = getNoUnwindAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getWillReturn() {
  auto attr = getWillReturnAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOpGenericAdaptorBase::getOptimizeNone() {
  auto attr = getOptimizeNoneAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::VecTypeHintAttr> LLVMFuncOpGenericAdaptorBase::getVecTypeHint() {
  auto attr = getVecTypeHintAttr();
  return attr ? ::std::optional<::mlir::LLVM::VecTypeHintAttr>(::llvm::cast<::mlir::LLVM::VecTypeHintAttr>(attr)) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LLVMFuncOpGenericAdaptorBase::getWorkGroupSizeHint() {
  auto attr = getWorkGroupSizeHintAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LLVMFuncOpGenericAdaptorBase::getReqdWorkGroupSize() {
  auto attr = getReqdWorkGroupSizeAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional<uint32_t> LLVMFuncOpGenericAdaptorBase::getIntelReqdSubGroupSize() {
  auto attr = getIntelReqdSubGroupSizeAttr();
  return attr ? ::std::optional<uint32_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

} // namespace detail
LLVMFuncOpAdaptor::LLVMFuncOpAdaptor(LLVMFuncOp op) : LLVMFuncOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LLVMFuncOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_CConv = getProperties().CConv; (void)tblgen_CConv;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_always_inline = getProperties().always_inline; (void)tblgen_always_inline;
  auto tblgen_approx_func_fp_math = getProperties().approx_func_fp_math; (void)tblgen_approx_func_fp_math;
  auto tblgen_arg_attrs = getProperties().arg_attrs; (void)tblgen_arg_attrs;
  auto tblgen_arm_in_za = getProperties().arm_in_za; (void)tblgen_arm_in_za;
  auto tblgen_arm_inout_za = getProperties().arm_inout_za; (void)tblgen_arm_inout_za;
  auto tblgen_arm_locally_streaming = getProperties().arm_locally_streaming; (void)tblgen_arm_locally_streaming;
  auto tblgen_arm_new_za = getProperties().arm_new_za; (void)tblgen_arm_new_za;
  auto tblgen_arm_out_za = getProperties().arm_out_za; (void)tblgen_arm_out_za;
  auto tblgen_arm_preserves_za = getProperties().arm_preserves_za; (void)tblgen_arm_preserves_za;
  auto tblgen_arm_streaming = getProperties().arm_streaming; (void)tblgen_arm_streaming;
  auto tblgen_arm_streaming_compatible = getProperties().arm_streaming_compatible; (void)tblgen_arm_streaming_compatible;
  auto tblgen_comdat = getProperties().comdat; (void)tblgen_comdat;
  auto tblgen_convergent = getProperties().convergent; (void)tblgen_convergent;
  auto tblgen_denormal_fp_math = getProperties().denormal_fp_math; (void)tblgen_denormal_fp_math;
  auto tblgen_denormal_fp_math_f32 = getProperties().denormal_fp_math_f32; (void)tblgen_denormal_fp_math_f32;
  auto tblgen_dso_local = getProperties().dso_local; (void)tblgen_dso_local;
  auto tblgen_fp_contract = getProperties().fp_contract; (void)tblgen_fp_contract;
  auto tblgen_frame_pointer = getProperties().frame_pointer; (void)tblgen_frame_pointer;
  auto tblgen_function_entry_count = getProperties().function_entry_count; (void)tblgen_function_entry_count;
  auto tblgen_function_type = getProperties().function_type; (void)tblgen_function_type;
  if (!tblgen_function_type) return emitError(loc, "'llvm.func' op ""requires attribute 'function_type'");
  auto tblgen_garbageCollector = getProperties().garbageCollector; (void)tblgen_garbageCollector;
  auto tblgen_intel_reqd_sub_group_size = getProperties().intel_reqd_sub_group_size; (void)tblgen_intel_reqd_sub_group_size;
  auto tblgen_linkage = getProperties().linkage; (void)tblgen_linkage;
  auto tblgen_memory_effects = getProperties().memory_effects; (void)tblgen_memory_effects;
  auto tblgen_no_infs_fp_math = getProperties().no_infs_fp_math; (void)tblgen_no_infs_fp_math;
  auto tblgen_no_inline = getProperties().no_inline; (void)tblgen_no_inline;
  auto tblgen_no_nans_fp_math = getProperties().no_nans_fp_math; (void)tblgen_no_nans_fp_math;
  auto tblgen_no_signed_zeros_fp_math = getProperties().no_signed_zeros_fp_math; (void)tblgen_no_signed_zeros_fp_math;
  auto tblgen_no_unwind = getProperties().no_unwind; (void)tblgen_no_unwind;
  auto tblgen_optimize_none = getProperties().optimize_none; (void)tblgen_optimize_none;
  auto tblgen_passthrough = getProperties().passthrough; (void)tblgen_passthrough;
  auto tblgen_personality = getProperties().personality; (void)tblgen_personality;
  auto tblgen_reqd_work_group_size = getProperties().reqd_work_group_size; (void)tblgen_reqd_work_group_size;
  auto tblgen_res_attrs = getProperties().res_attrs; (void)tblgen_res_attrs;
  auto tblgen_section = getProperties().section; (void)tblgen_section;
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'llvm.func' op ""requires attribute 'sym_name'");
  auto tblgen_sym_visibility = getProperties().sym_visibility; (void)tblgen_sym_visibility;
  auto tblgen_target_cpu = getProperties().target_cpu; (void)tblgen_target_cpu;
  auto tblgen_target_features = getProperties().target_features; (void)tblgen_target_features;
  auto tblgen_tune_cpu = getProperties().tune_cpu; (void)tblgen_tune_cpu;
  auto tblgen_unnamed_addr = getProperties().unnamed_addr; (void)tblgen_unnamed_addr;
  auto tblgen_unsafe_fp_math = getProperties().unsafe_fp_math; (void)tblgen_unsafe_fp_math;
  auto tblgen_vec_type_hint = getProperties().vec_type_hint; (void)tblgen_vec_type_hint;
  auto tblgen_visibility_ = getProperties().visibility_; (void)tblgen_visibility_;
  auto tblgen_vscale_range = getProperties().vscale_range; (void)tblgen_vscale_range;
  auto tblgen_will_return = getProperties().will_return; (void)tblgen_will_return;
  auto tblgen_work_group_size_hint = getProperties().work_group_size_hint; (void)tblgen_work_group_size_hint;

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'llvm.func' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");

  if (tblgen_sym_visibility && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_visibility))))
    return emitError(loc, "'llvm.func' op ""attribute 'sym_visibility' failed to satisfy constraint: string attribute");

  if (tblgen_function_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_function_type))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(tblgen_function_type).getValue()))) && ((::llvm::isa<::mlir::LLVM::LLVMFunctionType>(::llvm::cast<::mlir::TypeAttr>(tblgen_function_type).getValue())))))
    return emitError(loc, "'llvm.func' op ""attribute 'function_type' failed to satisfy constraint: type attribute of LLVM function type");

  if (tblgen_linkage && !((::llvm::isa<::mlir::LLVM::LinkageAttr>(tblgen_linkage))))
    return emitError(loc, "'llvm.func' op ""attribute 'linkage' failed to satisfy constraint: LLVM Linkage specification");

  if (tblgen_dso_local && !((::llvm::isa<::mlir::UnitAttr>(tblgen_dso_local))))
    return emitError(loc, "'llvm.func' op ""attribute 'dso_local' failed to satisfy constraint: unit attribute");

  if (tblgen_CConv && !((::llvm::isa<::mlir::LLVM::CConvAttr>(tblgen_CConv))))
    return emitError(loc, "'llvm.func' op ""attribute 'CConv' failed to satisfy constraint: LLVM Calling Convention specification");

  if (tblgen_comdat && !((::llvm::isa<::mlir::SymbolRefAttr>(tblgen_comdat))))
    return emitError(loc, "'llvm.func' op ""attribute 'comdat' failed to satisfy constraint: symbol reference attribute");

  if (tblgen_convergent && !((::llvm::isa<::mlir::UnitAttr>(tblgen_convergent))))
    return emitError(loc, "'llvm.func' op ""attribute 'convergent' failed to satisfy constraint: unit attribute");

  if (tblgen_personality && !((::llvm::isa<::mlir::FlatSymbolRefAttr>(tblgen_personality))))
    return emitError(loc, "'llvm.func' op ""attribute 'personality' failed to satisfy constraint: flat symbol reference attribute");

  if (tblgen_garbageCollector && !((::llvm::isa<::mlir::StringAttr>(tblgen_garbageCollector))))
    return emitError(loc, "'llvm.func' op ""attribute 'garbageCollector' failed to satisfy constraint: string attribute");

  if (tblgen_passthrough && !((::llvm::isa<::mlir::ArrayAttr>(tblgen_passthrough))))
    return emitError(loc, "'llvm.func' op ""attribute 'passthrough' failed to satisfy constraint: array attribute");

  if (tblgen_arg_attrs && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_arg_attrs))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_arg_attrs), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::DictionaryAttr>(attr))); }))))
    return emitError(loc, "'llvm.func' op ""attribute 'arg_attrs' failed to satisfy constraint: Array of dictionary attributes");

  if (tblgen_res_attrs && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_res_attrs))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_res_attrs), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::DictionaryAttr>(attr))); }))))
    return emitError(loc, "'llvm.func' op ""attribute 'res_attrs' failed to satisfy constraint: Array of dictionary attributes");

  if (tblgen_function_entry_count && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_function_entry_count))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_function_entry_count).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.func' op ""attribute 'function_entry_count' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_memory_effects && !((::llvm::isa<::mlir::LLVM::MemoryEffectsAttr>(tblgen_memory_effects))))
    return emitError(loc, "'llvm.func' op ""attribute 'memory_effects' failed to satisfy constraint: ");

  if (tblgen_visibility_ && !((::llvm::isa<::mlir::LLVM::VisibilityAttr>(tblgen_visibility_))))
    return emitError(loc, "'llvm.func' op ""attribute 'visibility_' failed to satisfy constraint: LLVM GlobalValue Visibility");

  if (tblgen_arm_streaming && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_streaming))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_streaming' failed to satisfy constraint: unit attribute");

  if (tblgen_arm_locally_streaming && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_locally_streaming))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_locally_streaming' failed to satisfy constraint: unit attribute");

  if (tblgen_arm_streaming_compatible && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_streaming_compatible))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_streaming_compatible' failed to satisfy constraint: unit attribute");

  if (tblgen_arm_new_za && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_new_za))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_new_za' failed to satisfy constraint: unit attribute");

  if (tblgen_arm_in_za && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_in_za))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_in_za' failed to satisfy constraint: unit attribute");

  if (tblgen_arm_out_za && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_out_za))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_out_za' failed to satisfy constraint: unit attribute");

  if (tblgen_arm_inout_za && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_inout_za))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_inout_za' failed to satisfy constraint: unit attribute");

  if (tblgen_arm_preserves_za && !((::llvm::isa<::mlir::UnitAttr>(tblgen_arm_preserves_za))))
    return emitError(loc, "'llvm.func' op ""attribute 'arm_preserves_za' failed to satisfy constraint: unit attribute");

  if (tblgen_section && !((::llvm::isa<::mlir::StringAttr>(tblgen_section))))
    return emitError(loc, "'llvm.func' op ""attribute 'section' failed to satisfy constraint: string attribute");

  if (tblgen_unnamed_addr && !((::llvm::isa<::mlir::LLVM::UnnamedAddrAttr>(tblgen_unnamed_addr))))
    return emitError(loc, "'llvm.func' op ""attribute 'unnamed_addr' failed to satisfy constraint: LLVM GlobalValue UnnamedAddr");

  if (tblgen_alignment && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_alignment))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_alignment).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.func' op ""attribute 'alignment' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_vscale_range && !((::llvm::isa<::mlir::LLVM::VScaleRangeAttr>(tblgen_vscale_range))))
    return emitError(loc, "'llvm.func' op ""attribute 'vscale_range' failed to satisfy constraint: ");

  if (tblgen_frame_pointer && !((::llvm::isa<::mlir::LLVM::FramePointerKindAttr>(tblgen_frame_pointer))))
    return emitError(loc, "'llvm.func' op ""attribute 'frame_pointer' failed to satisfy constraint: ");

  if (tblgen_target_cpu && !((::llvm::isa<::mlir::StringAttr>(tblgen_target_cpu))))
    return emitError(loc, "'llvm.func' op ""attribute 'target_cpu' failed to satisfy constraint: string attribute");

  if (tblgen_tune_cpu && !((::llvm::isa<::mlir::StringAttr>(tblgen_tune_cpu))))
    return emitError(loc, "'llvm.func' op ""attribute 'tune_cpu' failed to satisfy constraint: string attribute");

  if (tblgen_target_features && !((::llvm::isa<::mlir::LLVM::TargetFeaturesAttr>(tblgen_target_features))))
    return emitError(loc, "'llvm.func' op ""attribute 'target_features' failed to satisfy constraint: LLVM target features attribute");

  if (tblgen_unsafe_fp_math && !((::llvm::isa<::mlir::BoolAttr>(tblgen_unsafe_fp_math))))
    return emitError(loc, "'llvm.func' op ""attribute 'unsafe_fp_math' failed to satisfy constraint: bool attribute");

  if (tblgen_no_infs_fp_math && !((::llvm::isa<::mlir::BoolAttr>(tblgen_no_infs_fp_math))))
    return emitError(loc, "'llvm.func' op ""attribute 'no_infs_fp_math' failed to satisfy constraint: bool attribute");

  if (tblgen_no_nans_fp_math && !((::llvm::isa<::mlir::BoolAttr>(tblgen_no_nans_fp_math))))
    return emitError(loc, "'llvm.func' op ""attribute 'no_nans_fp_math' failed to satisfy constraint: bool attribute");

  if (tblgen_approx_func_fp_math && !((::llvm::isa<::mlir::BoolAttr>(tblgen_approx_func_fp_math))))
    return emitError(loc, "'llvm.func' op ""attribute 'approx_func_fp_math' failed to satisfy constraint: bool attribute");

  if (tblgen_no_signed_zeros_fp_math && !((::llvm::isa<::mlir::BoolAttr>(tblgen_no_signed_zeros_fp_math))))
    return emitError(loc, "'llvm.func' op ""attribute 'no_signed_zeros_fp_math' failed to satisfy constraint: bool attribute");

  if (tblgen_denormal_fp_math && !((::llvm::isa<::mlir::StringAttr>(tblgen_denormal_fp_math))))
    return emitError(loc, "'llvm.func' op ""attribute 'denormal_fp_math' failed to satisfy constraint: string attribute");

  if (tblgen_denormal_fp_math_f32 && !((::llvm::isa<::mlir::StringAttr>(tblgen_denormal_fp_math_f32))))
    return emitError(loc, "'llvm.func' op ""attribute 'denormal_fp_math_f32' failed to satisfy constraint: string attribute");

  if (tblgen_fp_contract && !((::llvm::isa<::mlir::StringAttr>(tblgen_fp_contract))))
    return emitError(loc, "'llvm.func' op ""attribute 'fp_contract' failed to satisfy constraint: string attribute");

  if (tblgen_no_inline && !((::llvm::isa<::mlir::UnitAttr>(tblgen_no_inline))))
    return emitError(loc, "'llvm.func' op ""attribute 'no_inline' failed to satisfy constraint: unit attribute");

  if (tblgen_always_inline && !((::llvm::isa<::mlir::UnitAttr>(tblgen_always_inline))))
    return emitError(loc, "'llvm.func' op ""attribute 'always_inline' failed to satisfy constraint: unit attribute");

  if (tblgen_no_unwind && !((::llvm::isa<::mlir::UnitAttr>(tblgen_no_unwind))))
    return emitError(loc, "'llvm.func' op ""attribute 'no_unwind' failed to satisfy constraint: unit attribute");

  if (tblgen_will_return && !((::llvm::isa<::mlir::UnitAttr>(tblgen_will_return))))
    return emitError(loc, "'llvm.func' op ""attribute 'will_return' failed to satisfy constraint: unit attribute");

  if (tblgen_optimize_none && !((::llvm::isa<::mlir::UnitAttr>(tblgen_optimize_none))))
    return emitError(loc, "'llvm.func' op ""attribute 'optimize_none' failed to satisfy constraint: unit attribute");

  if (tblgen_vec_type_hint && !((::llvm::isa<::mlir::LLVM::VecTypeHintAttr>(tblgen_vec_type_hint))))
    return emitError(loc, "'llvm.func' op ""attribute 'vec_type_hint' failed to satisfy constraint: Explicit vectorization compiler hint");

  if (tblgen_work_group_size_hint && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_work_group_size_hint))))
    return emitError(loc, "'llvm.func' op ""attribute 'work_group_size_hint' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_reqd_work_group_size && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_reqd_work_group_size))))
    return emitError(loc, "'llvm.func' op ""attribute 'reqd_work_group_size' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_intel_reqd_sub_group_size && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_intel_reqd_sub_group_size))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_intel_reqd_sub_group_size).getType().isSignlessInteger(32)))))
    return emitError(loc, "'llvm.func' op ""attribute 'intel_reqd_sub_group_size' failed to satisfy constraint: 32-bit signless integer attribute");
  return ::mlir::success();
}

::llvm::LogicalResult LLVMFuncOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.CConv;
       auto attr = dict.get("CConv");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `CConv` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alignment;
       auto attr = dict.get("alignment");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alignment` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.always_inline;
       auto attr = dict.get("always_inline");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `always_inline` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.approx_func_fp_math;
       auto attr = dict.get("approx_func_fp_math");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `approx_func_fp_math` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arg_attrs;
       auto attr = dict.get("arg_attrs");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arg_attrs` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_in_za;
       auto attr = dict.get("arm_in_za");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_in_za` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_inout_za;
       auto attr = dict.get("arm_inout_za");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_inout_za` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_locally_streaming;
       auto attr = dict.get("arm_locally_streaming");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_locally_streaming` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_new_za;
       auto attr = dict.get("arm_new_za");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_new_za` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_out_za;
       auto attr = dict.get("arm_out_za");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_out_za` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_preserves_za;
       auto attr = dict.get("arm_preserves_za");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_preserves_za` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_streaming;
       auto attr = dict.get("arm_streaming");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_streaming` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.arm_streaming_compatible;
       auto attr = dict.get("arm_streaming_compatible");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arm_streaming_compatible` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.comdat;
       auto attr = dict.get("comdat");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `comdat` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.convergent;
       auto attr = dict.get("convergent");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `convergent` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.denormal_fp_math;
       auto attr = dict.get("denormal_fp_math");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `denormal_fp_math` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.denormal_fp_math_f32;
       auto attr = dict.get("denormal_fp_math_f32");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `denormal_fp_math_f32` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dso_local;
       auto attr = dict.get("dso_local");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dso_local` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.fp_contract;
       auto attr = dict.get("fp_contract");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fp_contract` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.frame_pointer;
       auto attr = dict.get("frame_pointer");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `frame_pointer` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.function_entry_count;
       auto attr = dict.get("function_entry_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `function_entry_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.function_type;
       auto attr = dict.get("function_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `function_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.garbageCollector;
       auto attr = dict.get("garbageCollector");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `garbageCollector` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.intel_reqd_sub_group_size;
       auto attr = dict.get("intel_reqd_sub_group_size");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `intel_reqd_sub_group_size` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.linkage;
       auto attr = dict.get("linkage");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `linkage` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.memory_effects;
       auto attr = dict.get("memory_effects");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `memory_effects` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.no_infs_fp_math;
       auto attr = dict.get("no_infs_fp_math");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `no_infs_fp_math` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.no_inline;
       auto attr = dict.get("no_inline");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `no_inline` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.no_nans_fp_math;
       auto attr = dict.get("no_nans_fp_math");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `no_nans_fp_math` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.no_signed_zeros_fp_math;
       auto attr = dict.get("no_signed_zeros_fp_math");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `no_signed_zeros_fp_math` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.no_unwind;
       auto attr = dict.get("no_unwind");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `no_unwind` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.optimize_none;
       auto attr = dict.get("optimize_none");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `optimize_none` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.passthrough;
       auto attr = dict.get("passthrough");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `passthrough` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.personality;
       auto attr = dict.get("personality");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `personality` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.reqd_work_group_size;
       auto attr = dict.get("reqd_work_group_size");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `reqd_work_group_size` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.res_attrs;
       auto attr = dict.get("res_attrs");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `res_attrs` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.section;
       auto attr = dict.get("section");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `section` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_visibility;
       auto attr = dict.get("sym_visibility");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_visibility` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.target_cpu;
       auto attr = dict.get("target_cpu");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `target_cpu` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.target_features;
       auto attr = dict.get("target_features");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `target_features` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tune_cpu;
       auto attr = dict.get("tune_cpu");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tune_cpu` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.unnamed_addr;
       auto attr = dict.get("unnamed_addr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `unnamed_addr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.unsafe_fp_math;
       auto attr = dict.get("unsafe_fp_math");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `unsafe_fp_math` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.vec_type_hint;
       auto attr = dict.get("vec_type_hint");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `vec_type_hint` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.visibility_;
       auto attr = dict.get("visibility_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `visibility_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.vscale_range;
       auto attr = dict.get("vscale_range");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `vscale_range` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.will_return;
       auto attr = dict.get("will_return");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `will_return` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.work_group_size_hint;
       auto attr = dict.get("work_group_size_hint");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `work_group_size_hint` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute LLVMFuncOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.CConv;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("CConv",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alignment;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alignment",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.always_inline;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("always_inline",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.approx_func_fp_math;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("approx_func_fp_math",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arg_attrs;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arg_attrs",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_in_za;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_in_za",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_inout_za;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_inout_za",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_locally_streaming;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_locally_streaming",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_new_za;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_new_za",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_out_za;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_out_za",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_preserves_za;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_preserves_za",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_streaming;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_streaming",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.arm_streaming_compatible;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arm_streaming_compatible",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.comdat;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("comdat",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.convergent;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("convergent",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.denormal_fp_math;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("denormal_fp_math",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.denormal_fp_math_f32;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("denormal_fp_math_f32",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dso_local;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dso_local",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.fp_contract;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fp_contract",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.frame_pointer;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("frame_pointer",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.function_entry_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("function_entry_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.function_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("function_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.garbageCollector;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("garbageCollector",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.intel_reqd_sub_group_size;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("intel_reqd_sub_group_size",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.linkage;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("linkage",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.memory_effects;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("memory_effects",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.no_infs_fp_math;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("no_infs_fp_math",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.no_inline;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("no_inline",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.no_nans_fp_math;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("no_nans_fp_math",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.no_signed_zeros_fp_math;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("no_signed_zeros_fp_math",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.no_unwind;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("no_unwind",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.optimize_none;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("optimize_none",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.passthrough;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("passthrough",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.personality;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("personality",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.reqd_work_group_size;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("reqd_work_group_size",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.res_attrs;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("res_attrs",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.section;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("section",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_visibility;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_visibility",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.target_cpu;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("target_cpu",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.target_features;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("target_features",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tune_cpu;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tune_cpu",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.unnamed_addr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("unnamed_addr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.unsafe_fp_math;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("unsafe_fp_math",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.vec_type_hint;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("vec_type_hint",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.visibility_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("visibility_",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.vscale_range;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("vscale_range",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.will_return;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("will_return",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.work_group_size_hint;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("work_group_size_hint",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code LLVMFuncOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.CConv.getAsOpaquePointer()), 
    llvm::hash_value(prop.alignment.getAsOpaquePointer()), 
    llvm::hash_value(prop.always_inline.getAsOpaquePointer()), 
    llvm::hash_value(prop.approx_func_fp_math.getAsOpaquePointer()), 
    llvm::hash_value(prop.arg_attrs.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_in_za.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_inout_za.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_locally_streaming.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_new_za.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_out_za.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_preserves_za.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_streaming.getAsOpaquePointer()), 
    llvm::hash_value(prop.arm_streaming_compatible.getAsOpaquePointer()), 
    llvm::hash_value(prop.comdat.getAsOpaquePointer()), 
    llvm::hash_value(prop.convergent.getAsOpaquePointer()), 
    llvm::hash_value(prop.denormal_fp_math.getAsOpaquePointer()), 
    llvm::hash_value(prop.denormal_fp_math_f32.getAsOpaquePointer()), 
    llvm::hash_value(prop.dso_local.getAsOpaquePointer()), 
    llvm::hash_value(prop.fp_contract.getAsOpaquePointer()), 
    llvm::hash_value(prop.frame_pointer.getAsOpaquePointer()), 
    llvm::hash_value(prop.function_entry_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.function_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.garbageCollector.getAsOpaquePointer()), 
    llvm::hash_value(prop.intel_reqd_sub_group_size.getAsOpaquePointer()), 
    llvm::hash_value(prop.linkage.getAsOpaquePointer()), 
    llvm::hash_value(prop.memory_effects.getAsOpaquePointer()), 
    llvm::hash_value(prop.no_infs_fp_math.getAsOpaquePointer()), 
    llvm::hash_value(prop.no_inline.getAsOpaquePointer()), 
    llvm::hash_value(prop.no_nans_fp_math.getAsOpaquePointer()), 
    llvm::hash_value(prop.no_signed_zeros_fp_math.getAsOpaquePointer()), 
    llvm::hash_value(prop.no_unwind.getAsOpaquePointer()), 
    llvm::hash_value(prop.optimize_none.getAsOpaquePointer()), 
    llvm::hash_value(prop.passthrough.getAsOpaquePointer()), 
    llvm::hash_value(prop.personality.getAsOpaquePointer()), 
    llvm::hash_value(prop.reqd_work_group_size.getAsOpaquePointer()), 
    llvm::hash_value(prop.res_attrs.getAsOpaquePointer()), 
    llvm::hash_value(prop.section.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_visibility.getAsOpaquePointer()), 
    llvm::hash_value(prop.target_cpu.getAsOpaquePointer()), 
    llvm::hash_value(prop.target_features.getAsOpaquePointer()), 
    llvm::hash_value(prop.tune_cpu.getAsOpaquePointer()), 
    llvm::hash_value(prop.unnamed_addr.getAsOpaquePointer()), 
    llvm::hash_value(prop.unsafe_fp_math.getAsOpaquePointer()), 
    llvm::hash_value(prop.vec_type_hint.getAsOpaquePointer()), 
    llvm::hash_value(prop.visibility_.getAsOpaquePointer()), 
    llvm::hash_value(prop.vscale_range.getAsOpaquePointer()), 
    llvm::hash_value(prop.will_return.getAsOpaquePointer()), 
    llvm::hash_value(prop.work_group_size_hint.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> LLVMFuncOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "CConv")
      return prop.CConv;

    if (name == "alignment")
      return prop.alignment;

    if (name == "always_inline")
      return prop.always_inline;

    if (name == "approx_func_fp_math")
      return prop.approx_func_fp_math;

    if (name == "arg_attrs")
      return prop.arg_attrs;

    if (name == "arm_in_za")
      return prop.arm_in_za;

    if (name == "arm_inout_za")
      return prop.arm_inout_za;

    if (name == "arm_locally_streaming")
      return prop.arm_locally_streaming;

    if (name == "arm_new_za")
      return prop.arm_new_za;

    if (name == "arm_out_za")
      return prop.arm_out_za;

    if (name == "arm_preserves_za")
      return prop.arm_preserves_za;

    if (name == "arm_streaming")
      return prop.arm_streaming;

    if (name == "arm_streaming_compatible")
      return prop.arm_streaming_compatible;

    if (name == "comdat")
      return prop.comdat;

    if (name == "convergent")
      return prop.convergent;

    if (name == "denormal_fp_math")
      return prop.denormal_fp_math;

    if (name == "denormal_fp_math_f32")
      return prop.denormal_fp_math_f32;

    if (name == "dso_local")
      return prop.dso_local;

    if (name == "fp_contract")
      return prop.fp_contract;

    if (name == "frame_pointer")
      return prop.frame_pointer;

    if (name == "function_entry_count")
      return prop.function_entry_count;

    if (name == "function_type")
      return prop.function_type;

    if (name == "garbageCollector")
      return prop.garbageCollector;

    if (name == "intel_reqd_sub_group_size")
      return prop.intel_reqd_sub_group_size;

    if (name == "linkage")
      return prop.linkage;

    if (name == "memory_effects")
      return prop.memory_effects;

    if (name == "no_infs_fp_math")
      return prop.no_infs_fp_math;

    if (name == "no_inline")
      return prop.no_inline;

    if (name == "no_nans_fp_math")
      return prop.no_nans_fp_math;

    if (name == "no_signed_zeros_fp_math")
      return prop.no_signed_zeros_fp_math;

    if (name == "no_unwind")
      return prop.no_unwind;

    if (name == "optimize_none")
      return prop.optimize_none;

    if (name == "passthrough")
      return prop.passthrough;

    if (name == "personality")
      return prop.personality;

    if (name == "reqd_work_group_size")
      return prop.reqd_work_group_size;

    if (name == "res_attrs")
      return prop.res_attrs;

    if (name == "section")
      return prop.section;

    if (name == "sym_name")
      return prop.sym_name;

    if (name == "sym_visibility")
      return prop.sym_visibility;

    if (name == "target_cpu")
      return prop.target_cpu;

    if (name == "target_features")
      return prop.target_features;

    if (name == "tune_cpu")
      return prop.tune_cpu;

    if (name == "unnamed_addr")
      return prop.unnamed_addr;

    if (name == "unsafe_fp_math")
      return prop.unsafe_fp_math;

    if (name == "vec_type_hint")
      return prop.vec_type_hint;

    if (name == "visibility_")
      return prop.visibility_;

    if (name == "vscale_range")
      return prop.vscale_range;

    if (name == "will_return")
      return prop.will_return;

    if (name == "work_group_size_hint")
      return prop.work_group_size_hint;
  return std::nullopt;
}

void LLVMFuncOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "CConv") {
       prop.CConv = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.CConv)>>(value);
       return;
    }

    if (name == "alignment") {
       prop.alignment = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alignment)>>(value);
       return;
    }

    if (name == "always_inline") {
       prop.always_inline = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.always_inline)>>(value);
       return;
    }

    if (name == "approx_func_fp_math") {
       prop.approx_func_fp_math = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.approx_func_fp_math)>>(value);
       return;
    }

    if (name == "arg_attrs") {
       prop.arg_attrs = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arg_attrs)>>(value);
       return;
    }

    if (name == "arm_in_za") {
       prop.arm_in_za = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_in_za)>>(value);
       return;
    }

    if (name == "arm_inout_za") {
       prop.arm_inout_za = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_inout_za)>>(value);
       return;
    }

    if (name == "arm_locally_streaming") {
       prop.arm_locally_streaming = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_locally_streaming)>>(value);
       return;
    }

    if (name == "arm_new_za") {
       prop.arm_new_za = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_new_za)>>(value);
       return;
    }

    if (name == "arm_out_za") {
       prop.arm_out_za = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_out_za)>>(value);
       return;
    }

    if (name == "arm_preserves_za") {
       prop.arm_preserves_za = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_preserves_za)>>(value);
       return;
    }

    if (name == "arm_streaming") {
       prop.arm_streaming = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_streaming)>>(value);
       return;
    }

    if (name == "arm_streaming_compatible") {
       prop.arm_streaming_compatible = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arm_streaming_compatible)>>(value);
       return;
    }

    if (name == "comdat") {
       prop.comdat = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.comdat)>>(value);
       return;
    }

    if (name == "convergent") {
       prop.convergent = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.convergent)>>(value);
       return;
    }

    if (name == "denormal_fp_math") {
       prop.denormal_fp_math = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.denormal_fp_math)>>(value);
       return;
    }

    if (name == "denormal_fp_math_f32") {
       prop.denormal_fp_math_f32 = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.denormal_fp_math_f32)>>(value);
       return;
    }

    if (name == "dso_local") {
       prop.dso_local = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dso_local)>>(value);
       return;
    }

    if (name == "fp_contract") {
       prop.fp_contract = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fp_contract)>>(value);
       return;
    }

    if (name == "frame_pointer") {
       prop.frame_pointer = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.frame_pointer)>>(value);
       return;
    }

    if (name == "function_entry_count") {
       prop.function_entry_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.function_entry_count)>>(value);
       return;
    }

    if (name == "function_type") {
       prop.function_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.function_type)>>(value);
       return;
    }

    if (name == "garbageCollector") {
       prop.garbageCollector = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.garbageCollector)>>(value);
       return;
    }

    if (name == "intel_reqd_sub_group_size") {
       prop.intel_reqd_sub_group_size = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.intel_reqd_sub_group_size)>>(value);
       return;
    }

    if (name == "linkage") {
       prop.linkage = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.linkage)>>(value);
       return;
    }

    if (name == "memory_effects") {
       prop.memory_effects = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.memory_effects)>>(value);
       return;
    }

    if (name == "no_infs_fp_math") {
       prop.no_infs_fp_math = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.no_infs_fp_math)>>(value);
       return;
    }

    if (name == "no_inline") {
       prop.no_inline = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.no_inline)>>(value);
       return;
    }

    if (name == "no_nans_fp_math") {
       prop.no_nans_fp_math = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.no_nans_fp_math)>>(value);
       return;
    }

    if (name == "no_signed_zeros_fp_math") {
       prop.no_signed_zeros_fp_math = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.no_signed_zeros_fp_math)>>(value);
       return;
    }

    if (name == "no_unwind") {
       prop.no_unwind = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.no_unwind)>>(value);
       return;
    }

    if (name == "optimize_none") {
       prop.optimize_none = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.optimize_none)>>(value);
       return;
    }

    if (name == "passthrough") {
       prop.passthrough = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.passthrough)>>(value);
       return;
    }

    if (name == "personality") {
       prop.personality = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.personality)>>(value);
       return;
    }

    if (name == "reqd_work_group_size") {
       prop.reqd_work_group_size = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.reqd_work_group_size)>>(value);
       return;
    }

    if (name == "res_attrs") {
       prop.res_attrs = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.res_attrs)>>(value);
       return;
    }

    if (name == "section") {
       prop.section = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.section)>>(value);
       return;
    }

    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }

    if (name == "sym_visibility") {
       prop.sym_visibility = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_visibility)>>(value);
       return;
    }

    if (name == "target_cpu") {
       prop.target_cpu = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.target_cpu)>>(value);
       return;
    }

    if (name == "target_features") {
       prop.target_features = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.target_features)>>(value);
       return;
    }

    if (name == "tune_cpu") {
       prop.tune_cpu = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tune_cpu)>>(value);
       return;
    }

    if (name == "unnamed_addr") {
       prop.unnamed_addr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.unnamed_addr)>>(value);
       return;
    }

    if (name == "unsafe_fp_math") {
       prop.unsafe_fp_math = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.unsafe_fp_math)>>(value);
       return;
    }

    if (name == "vec_type_hint") {
       prop.vec_type_hint = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.vec_type_hint)>>(value);
       return;
    }

    if (name == "visibility_") {
       prop.visibility_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.visibility_)>>(value);
       return;
    }

    if (name == "vscale_range") {
       prop.vscale_range = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.vscale_range)>>(value);
       return;
    }

    if (name == "will_return") {
       prop.will_return = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.will_return)>>(value);
       return;
    }

    if (name == "work_group_size_hint") {
       prop.work_group_size_hint = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.work_group_size_hint)>>(value);
       return;
    }
}

void LLVMFuncOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.CConv) attrs.append("CConv", prop.CConv);

    if (prop.alignment) attrs.append("alignment", prop.alignment);

    if (prop.always_inline) attrs.append("always_inline", prop.always_inline);

    if (prop.approx_func_fp_math) attrs.append("approx_func_fp_math", prop.approx_func_fp_math);

    if (prop.arg_attrs) attrs.append("arg_attrs", prop.arg_attrs);

    if (prop.arm_in_za) attrs.append("arm_in_za", prop.arm_in_za);

    if (prop.arm_inout_za) attrs.append("arm_inout_za", prop.arm_inout_za);

    if (prop.arm_locally_streaming) attrs.append("arm_locally_streaming", prop.arm_locally_streaming);

    if (prop.arm_new_za) attrs.append("arm_new_za", prop.arm_new_za);

    if (prop.arm_out_za) attrs.append("arm_out_za", prop.arm_out_za);

    if (prop.arm_preserves_za) attrs.append("arm_preserves_za", prop.arm_preserves_za);

    if (prop.arm_streaming) attrs.append("arm_streaming", prop.arm_streaming);

    if (prop.arm_streaming_compatible) attrs.append("arm_streaming_compatible", prop.arm_streaming_compatible);

    if (prop.comdat) attrs.append("comdat", prop.comdat);

    if (prop.convergent) attrs.append("convergent", prop.convergent);

    if (prop.denormal_fp_math) attrs.append("denormal_fp_math", prop.denormal_fp_math);

    if (prop.denormal_fp_math_f32) attrs.append("denormal_fp_math_f32", prop.denormal_fp_math_f32);

    if (prop.dso_local) attrs.append("dso_local", prop.dso_local);

    if (prop.fp_contract) attrs.append("fp_contract", prop.fp_contract);

    if (prop.frame_pointer) attrs.append("frame_pointer", prop.frame_pointer);

    if (prop.function_entry_count) attrs.append("function_entry_count", prop.function_entry_count);

    if (prop.function_type) attrs.append("function_type", prop.function_type);

    if (prop.garbageCollector) attrs.append("garbageCollector", prop.garbageCollector);

    if (prop.intel_reqd_sub_group_size) attrs.append("intel_reqd_sub_group_size", prop.intel_reqd_sub_group_size);

    if (prop.linkage) attrs.append("linkage", prop.linkage);

    if (prop.memory_effects) attrs.append("memory_effects", prop.memory_effects);

    if (prop.no_infs_fp_math) attrs.append("no_infs_fp_math", prop.no_infs_fp_math);

    if (prop.no_inline) attrs.append("no_inline", prop.no_inline);

    if (prop.no_nans_fp_math) attrs.append("no_nans_fp_math", prop.no_nans_fp_math);

    if (prop.no_signed_zeros_fp_math) attrs.append("no_signed_zeros_fp_math", prop.no_signed_zeros_fp_math);

    if (prop.no_unwind) attrs.append("no_unwind", prop.no_unwind);

    if (prop.optimize_none) attrs.append("optimize_none", prop.optimize_none);

    if (prop.passthrough) attrs.append("passthrough", prop.passthrough);

    if (prop.personality) attrs.append("personality", prop.personality);

    if (prop.reqd_work_group_size) attrs.append("reqd_work_group_size", prop.reqd_work_group_size);

    if (prop.res_attrs) attrs.append("res_attrs", prop.res_attrs);

    if (prop.section) attrs.append("section", prop.section);

    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);

    if (prop.sym_visibility) attrs.append("sym_visibility", prop.sym_visibility);

    if (prop.target_cpu) attrs.append("target_cpu", prop.target_cpu);

    if (prop.target_features) attrs.append("target_features", prop.target_features);

    if (prop.tune_cpu) attrs.append("tune_cpu", prop.tune_cpu);

    if (prop.unnamed_addr) attrs.append("unnamed_addr", prop.unnamed_addr);

    if (prop.unsafe_fp_math) attrs.append("unsafe_fp_math", prop.unsafe_fp_math);

    if (prop.vec_type_hint) attrs.append("vec_type_hint", prop.vec_type_hint);

    if (prop.visibility_) attrs.append("visibility_", prop.visibility_);

    if (prop.vscale_range) attrs.append("vscale_range", prop.vscale_range);

    if (prop.will_return) attrs.append("will_return", prop.will_return);

    if (prop.work_group_size_hint) attrs.append("work_group_size_hint", prop.work_group_size_hint);
}

::llvm::LogicalResult LLVMFuncOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCConvAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps15(attr, "CConv", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAlignmentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "alignment", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAlwaysInlineAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "always_inline", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getApproxFuncFpMathAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(attr, "approx_func_fp_math", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArgAttrsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps33(attr, "arg_attrs", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmInZaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_in_za", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmInoutZaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_inout_za", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmLocallyStreamingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_locally_streaming", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmNewZaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_new_za", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmOutZaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_out_za", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmPreservesZaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_preserves_za", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmStreamingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_streaming", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getArmStreamingCompatibleAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "arm_streaming_compatible", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getComdatAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps27(attr, "comdat", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getConvergentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "convergent", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDenormalFpMathAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "denormal_fp_math", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDenormalFpMathF32AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "denormal_fp_math_f32", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDsoLocalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "dso_local", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFpContractAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "fp_contract", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFramePointerAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps35(attr, "frame_pointer", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFunctionEntryCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "function_entry_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFunctionTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps13(attr, "function_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGarbageCollectorAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "garbageCollector", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIntelReqdSubGroupSizeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps39(attr, "intel_reqd_sub_group_size", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLinkageAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps24(attr, "linkage", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getMemoryEffectsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps17(attr, "memory_effects", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoInfsFpMathAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(attr, "no_infs_fp_math", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoInlineAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "no_inline", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoNansFpMathAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(attr, "no_nans_fp_math", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoSignedZerosFpMathAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(attr, "no_signed_zeros_fp_math", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoUnwindAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "no_unwind", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOptimizeNoneAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "optimize_none", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPassthroughAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps32(attr, "passthrough", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPersonalityAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(attr, "personality", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReqdWorkGroupSizeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "reqd_work_group_size", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getResAttrsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps33(attr, "res_attrs", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSectionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "section", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymVisibilityAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "sym_visibility", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTargetCpuAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "target_cpu", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTargetFeaturesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps36(attr, "target_features", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTuneCpuAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "tune_cpu", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUnnamedAddrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps26(attr, "unnamed_addr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUnsafeFpMathAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(attr, "unsafe_fp_math", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVecTypeHintAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps38(attr, "vec_type_hint", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVisibility_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps29(attr, "visibility_", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVscaleRangeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps34(attr, "vscale_range", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWillReturnAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "will_return", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWorkGroupSizeHintAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "work_group_size_hint", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult LLVMFuncOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.CConv)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alignment)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.always_inline)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.approx_func_fp_math)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arg_attrs)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_in_za)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_inout_za)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_locally_streaming)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_new_za)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_out_za)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_preserves_za)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_streaming)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.arm_streaming_compatible)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.comdat)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.convergent)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.denormal_fp_math)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.denormal_fp_math_f32)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dso_local)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.fp_contract)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.frame_pointer)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.function_entry_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.function_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.garbageCollector)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.intel_reqd_sub_group_size)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.linkage)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.memory_effects)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.no_infs_fp_math)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.no_inline)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.no_nans_fp_math)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.no_signed_zeros_fp_math)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.no_unwind)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.optimize_none)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.passthrough)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.personality)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.reqd_work_group_size)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.res_attrs)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.section)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.sym_visibility)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.target_cpu)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.target_features)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tune_cpu)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.unnamed_addr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.unsafe_fp_math)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.vec_type_hint)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.visibility_)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.vscale_range)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.will_return)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.work_group_size_hint)))
    return ::mlir::failure();
  return ::mlir::success();
}

void LLVMFuncOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.CConv);

  writer.writeOptionalAttribute(prop.alignment);

  writer.writeOptionalAttribute(prop.always_inline);

  writer.writeOptionalAttribute(prop.approx_func_fp_math);

  writer.writeOptionalAttribute(prop.arg_attrs);

  writer.writeOptionalAttribute(prop.arm_in_za);

  writer.writeOptionalAttribute(prop.arm_inout_za);

  writer.writeOptionalAttribute(prop.arm_locally_streaming);

  writer.writeOptionalAttribute(prop.arm_new_za);

  writer.writeOptionalAttribute(prop.arm_out_za);

  writer.writeOptionalAttribute(prop.arm_preserves_za);

  writer.writeOptionalAttribute(prop.arm_streaming);

  writer.writeOptionalAttribute(prop.arm_streaming_compatible);

  writer.writeOptionalAttribute(prop.comdat);

  writer.writeOptionalAttribute(prop.convergent);

  writer.writeOptionalAttribute(prop.denormal_fp_math);

  writer.writeOptionalAttribute(prop.denormal_fp_math_f32);

  writer.writeOptionalAttribute(prop.dso_local);

  writer.writeOptionalAttribute(prop.fp_contract);

  writer.writeOptionalAttribute(prop.frame_pointer);

  writer.writeOptionalAttribute(prop.function_entry_count);
  writer.writeAttribute(prop.function_type);

  writer.writeOptionalAttribute(prop.garbageCollector);

  writer.writeOptionalAttribute(prop.intel_reqd_sub_group_size);

  writer.writeOptionalAttribute(prop.linkage);

  writer.writeOptionalAttribute(prop.memory_effects);

  writer.writeOptionalAttribute(prop.no_infs_fp_math);

  writer.writeOptionalAttribute(prop.no_inline);

  writer.writeOptionalAttribute(prop.no_nans_fp_math);

  writer.writeOptionalAttribute(prop.no_signed_zeros_fp_math);

  writer.writeOptionalAttribute(prop.no_unwind);

  writer.writeOptionalAttribute(prop.optimize_none);

  writer.writeOptionalAttribute(prop.passthrough);

  writer.writeOptionalAttribute(prop.personality);

  writer.writeOptionalAttribute(prop.reqd_work_group_size);

  writer.writeOptionalAttribute(prop.res_attrs);

  writer.writeOptionalAttribute(prop.section);
  writer.writeAttribute(prop.sym_name);

  writer.writeOptionalAttribute(prop.sym_visibility);

  writer.writeOptionalAttribute(prop.target_cpu);

  writer.writeOptionalAttribute(prop.target_features);

  writer.writeOptionalAttribute(prop.tune_cpu);

  writer.writeOptionalAttribute(prop.unnamed_addr);

  writer.writeOptionalAttribute(prop.unsafe_fp_math);

  writer.writeOptionalAttribute(prop.vec_type_hint);

  writer.writeOptionalAttribute(prop.visibility_);

  writer.writeOptionalAttribute(prop.vscale_range);

  writer.writeOptionalAttribute(prop.will_return);

  writer.writeOptionalAttribute(prop.work_group_size_hint);
}

::llvm::StringRef LLVMFuncOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getSymVisibility() {
  auto attr = getSymVisibilityAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::mlir::LLVM::LLVMFunctionType LLVMFuncOp::getFunctionType() {
  auto attr = getFunctionTypeAttr();
  return ::llvm::cast<::mlir::LLVM::LLVMFunctionType>(attr.getValue());
}

::mlir::LLVM::Linkage LLVMFuncOp::getLinkage() {
  auto attr = getLinkageAttr();
  return attr.getLinkage();
}

bool LLVMFuncOp::getDsoLocal() {
  auto attr = getDsoLocalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::LLVM::cconv::CConv LLVMFuncOp::getCConv() {
  auto attr = getCConvAttr();
  return attr.getCallingConv();
}

::std::optional< ::mlir::SymbolRefAttr > LLVMFuncOp::getComdat() {
  auto attr = getComdatAttr();
  return attr ? ::std::optional< ::mlir::SymbolRefAttr >(attr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getConvergent() {
  auto attr = getConvergentAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getPersonality() {
  auto attr = getPersonalityAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getGarbageCollector() {
  auto attr = getGarbageCollectorAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LLVMFuncOp::getPassthrough() {
  auto attr = getPassthroughAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LLVMFuncOp::getArgAttrs() {
  auto attr = getArgAttrsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LLVMFuncOp::getResAttrs() {
  auto attr = getResAttrsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<uint64_t> LLVMFuncOp::getFunctionEntryCount() {
  auto attr = getFunctionEntryCountAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::MemoryEffectsAttr> LLVMFuncOp::getMemoryEffects() {
  auto attr = getMemoryEffectsAttr();
  return attr ? ::std::optional<::mlir::LLVM::MemoryEffectsAttr>(::llvm::cast<::mlir::LLVM::MemoryEffectsAttr>(attr)) : (::std::nullopt);
}

::mlir::LLVM::Visibility LLVMFuncOp::getVisibility_() {
  auto attr = getVisibility_Attr();
  return attr.getValue();
}

::std::optional<bool> LLVMFuncOp::getArmStreaming() {
  auto attr = getArmStreamingAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getArmLocallyStreaming() {
  auto attr = getArmLocallyStreamingAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getArmStreamingCompatible() {
  auto attr = getArmStreamingCompatibleAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getArmNewZa() {
  auto attr = getArmNewZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getArmInZa() {
  auto attr = getArmInZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getArmOutZa() {
  auto attr = getArmOutZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getArmInoutZa() {
  auto attr = getArmInoutZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getArmPreservesZa() {
  auto attr = getArmPreservesZaAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getSection() {
  auto attr = getSectionAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::UnnamedAddr> LLVMFuncOp::getUnnamedAddr() {
  auto attr = getUnnamedAddrAttr();
  return attr ? ::std::optional<::mlir::LLVM::UnnamedAddr>(attr.getValue()) : (::std::nullopt);
}

::std::optional<uint64_t> LLVMFuncOp::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::VScaleRangeAttr> LLVMFuncOp::getVscaleRange() {
  auto attr = getVscaleRangeAttr();
  return attr ? ::std::optional<::mlir::LLVM::VScaleRangeAttr>(::llvm::cast<::mlir::LLVM::VScaleRangeAttr>(attr)) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::FramePointerKindAttr> LLVMFuncOp::getFramePointer() {
  auto attr = getFramePointerAttr();
  return attr ? ::std::optional<::mlir::LLVM::FramePointerKindAttr>(::llvm::cast<::mlir::LLVM::FramePointerKindAttr>(attr)) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getTargetCpu() {
  auto attr = getTargetCpuAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getTuneCpu() {
  auto attr = getTuneCpuAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::TargetFeaturesAttr> LLVMFuncOp::getTargetFeatures() {
  auto attr = getTargetFeaturesAttr();
  return attr ? ::std::optional<::mlir::LLVM::TargetFeaturesAttr>(::llvm::cast<::mlir::LLVM::TargetFeaturesAttr>(attr)) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOp::getUnsafeFpMath() {
  auto attr = getUnsafeFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOp::getNoInfsFpMath() {
  auto attr = getNoInfsFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOp::getNoNansFpMath() {
  auto attr = getNoNansFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOp::getApproxFuncFpMath() {
  auto attr = getApproxFuncFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< bool > LLVMFuncOp::getNoSignedZerosFpMath() {
  auto attr = getNoSignedZerosFpMathAttr();
  return attr ? ::std::optional< bool >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getDenormalFpMath() {
  auto attr = getDenormalFpMathAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getDenormalFpMathF32() {
  auto attr = getDenormalFpMathF32Attr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::llvm::StringRef > LLVMFuncOp::getFpContract() {
  auto attr = getFpContractAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getNoInline() {
  auto attr = getNoInlineAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getAlwaysInline() {
  auto attr = getAlwaysInlineAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getNoUnwind() {
  auto attr = getNoUnwindAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getWillReturn() {
  auto attr = getWillReturnAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<bool> LLVMFuncOp::getOptimizeNone() {
  auto attr = getOptimizeNoneAttr();
  return attr ? ::std::optional<bool>(attr != nullptr) : (::std::nullopt);
}

::std::optional<::mlir::LLVM::VecTypeHintAttr> LLVMFuncOp::getVecTypeHint() {
  auto attr = getVecTypeHintAttr();
  return attr ? ::std::optional<::mlir::LLVM::VecTypeHintAttr>(::llvm::cast<::mlir::LLVM::VecTypeHintAttr>(attr)) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LLVMFuncOp::getWorkGroupSizeHint() {
  auto attr = getWorkGroupSizeHintAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LLVMFuncOp::getReqdWorkGroupSize() {
  auto attr = getReqdWorkGroupSizeAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional<uint32_t> LLVMFuncOp::getIntelReqdSubGroupSize() {
  auto attr = getIntelReqdSubGroupSizeAttr();
  return attr ? ::std::optional<uint32_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

void LLVMFuncOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void LLVMFuncOp::setSymVisibility(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().sym_visibility;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setFunctionType(::mlir::LLVM::LLVMFunctionType attrValue) {
  getProperties().function_type = ::mlir::TypeAttr::get(attrValue);
}

void LLVMFuncOp::setLinkage(::mlir::LLVM::Linkage attrValue) {
  getProperties().linkage = ::mlir::LLVM::LinkageAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void LLVMFuncOp::setDsoLocal(bool attrValue) {
    auto &odsProp = getProperties().dso_local;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setCConv(::mlir::LLVM::cconv::CConv attrValue) {
  getProperties().CConv = ::mlir::LLVM::CConvAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void LLVMFuncOp::setConvergent(bool attrValue) {
    auto &odsProp = getProperties().convergent;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setPersonality(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().personality;
    if (attrValue)
      odsProp = ::mlir::SymbolRefAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setGarbageCollector(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().garbageCollector;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setFunctionEntryCount(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().function_entry_count;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setVisibility_(::mlir::LLVM::Visibility attrValue) {
  getProperties().visibility_ = ::mlir::LLVM::VisibilityAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void LLVMFuncOp::setArmStreaming(bool attrValue) {
    auto &odsProp = getProperties().arm_streaming;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setArmLocallyStreaming(bool attrValue) {
    auto &odsProp = getProperties().arm_locally_streaming;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setArmStreamingCompatible(bool attrValue) {
    auto &odsProp = getProperties().arm_streaming_compatible;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setArmNewZa(bool attrValue) {
    auto &odsProp = getProperties().arm_new_za;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setArmInZa(bool attrValue) {
    auto &odsProp = getProperties().arm_in_za;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setArmOutZa(bool attrValue) {
    auto &odsProp = getProperties().arm_out_za;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setArmInoutZa(bool attrValue) {
    auto &odsProp = getProperties().arm_inout_za;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setArmPreservesZa(bool attrValue) {
    auto &odsProp = getProperties().arm_preserves_za;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setSection(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().section;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setUnnamedAddr(::std::optional<::mlir::LLVM::UnnamedAddr> attrValue) {
    auto &odsProp = getProperties().unnamed_addr;
    if (attrValue)
      odsProp = ::mlir::LLVM::UnnamedAddrAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setAlignment(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().alignment;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setTargetCpu(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().target_cpu;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setTuneCpu(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().tune_cpu;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setUnsafeFpMath(::std::optional<bool> attrValue) {
    auto &odsProp = getProperties().unsafe_fp_math;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getBoolAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setNoInfsFpMath(::std::optional<bool> attrValue) {
    auto &odsProp = getProperties().no_infs_fp_math;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getBoolAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setNoNansFpMath(::std::optional<bool> attrValue) {
    auto &odsProp = getProperties().no_nans_fp_math;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getBoolAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setApproxFuncFpMath(::std::optional<bool> attrValue) {
    auto &odsProp = getProperties().approx_func_fp_math;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getBoolAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setNoSignedZerosFpMath(::std::optional<bool> attrValue) {
    auto &odsProp = getProperties().no_signed_zeros_fp_math;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getBoolAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setDenormalFpMath(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().denormal_fp_math;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setDenormalFpMathF32(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().denormal_fp_math_f32;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setFpContract(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().fp_contract;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setNoInline(bool attrValue) {
    auto &odsProp = getProperties().no_inline;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setAlwaysInline(bool attrValue) {
    auto &odsProp = getProperties().always_inline;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setNoUnwind(bool attrValue) {
    auto &odsProp = getProperties().no_unwind;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setWillReturn(bool attrValue) {
    auto &odsProp = getProperties().will_return;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setOptimizeNone(bool attrValue) {
    auto &odsProp = getProperties().optimize_none;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setWorkGroupSizeHint(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().work_group_size_hint;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setReqdWorkGroupSize(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().reqd_work_group_size;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::setIntelReqdSubGroupSize(::std::optional<uint32_t> attrValue) {
    auto &odsProp = getProperties().intel_reqd_sub_group_size;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(32), *attrValue);
    else
      odsProp = nullptr;
}

void LLVMFuncOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.linkage)
    properties.linkage = ::mlir::LLVM::LinkageAttr::get(odsBuilder.getContext(), Linkage::External);
  if (!properties.CConv)
    properties.CConv = ::mlir::LLVM::CConvAttr::get(odsBuilder.getContext(), CConv::C);
  if (!properties.visibility_)
    properties.visibility_ = ::mlir::LLVM::VisibilityAttr::get(odsBuilder.getContext(), mlir::LLVM::Visibility::Default);
}

::llvm::LogicalResult LLVMFuncOp::verifyInvariantsImpl() {
  auto tblgen_CConv = getProperties().CConv; (void)tblgen_CConv;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_always_inline = getProperties().always_inline; (void)tblgen_always_inline;
  auto tblgen_approx_func_fp_math = getProperties().approx_func_fp_math; (void)tblgen_approx_func_fp_math;
  auto tblgen_arg_attrs = getProperties().arg_attrs; (void)tblgen_arg_attrs;
  auto tblgen_arm_in_za = getProperties().arm_in_za; (void)tblgen_arm_in_za;
  auto tblgen_arm_inout_za = getProperties().arm_inout_za; (void)tblgen_arm_inout_za;
  auto tblgen_arm_locally_streaming = getProperties().arm_locally_streaming; (void)tblgen_arm_locally_streaming;
  auto tblgen_arm_new_za = getProperties().arm_new_za; (void)tblgen_arm_new_za;
  auto tblgen_arm_out_za = getProperties().arm_out_za; (void)tblgen_arm_out_za;
  auto tblgen_arm_preserves_za = getProperties().arm_preserves_za; (void)tblgen_arm_preserves_za;
  auto tblgen_arm_streaming = getProperties().arm_streaming; (void)tblgen_arm_streaming;
  auto tblgen_arm_streaming_compatible = getProperties().arm_streaming_compatible; (void)tblgen_arm_streaming_compatible;
  auto tblgen_comdat = getProperties().comdat; (void)tblgen_comdat;
  auto tblgen_convergent = getProperties().convergent; (void)tblgen_convergent;
  auto tblgen_denormal_fp_math = getProperties().denormal_fp_math; (void)tblgen_denormal_fp_math;
  auto tblgen_denormal_fp_math_f32 = getProperties().denormal_fp_math_f32; (void)tblgen_denormal_fp_math_f32;
  auto tblgen_dso_local = getProperties().dso_local; (void)tblgen_dso_local;
  auto tblgen_fp_contract = getProperties().fp_contract; (void)tblgen_fp_contract;
  auto tblgen_frame_pointer = getProperties().frame_pointer; (void)tblgen_frame_pointer;
  auto tblgen_function_entry_count = getProperties().function_entry_count; (void)tblgen_function_entry_count;
  auto tblgen_function_type = getProperties().function_type; (void)tblgen_function_type;
  if (!tblgen_function_type) return emitOpError("requires attribute 'function_type'");
  auto tblgen_garbageCollector = getProperties().garbageCollector; (void)tblgen_garbageCollector;
  auto tblgen_intel_reqd_sub_group_size = getProperties().intel_reqd_sub_group_size; (void)tblgen_intel_reqd_sub_group_size;
  auto tblgen_linkage = getProperties().linkage; (void)tblgen_linkage;
  auto tblgen_memory_effects = getProperties().memory_effects; (void)tblgen_memory_effects;
  auto tblgen_no_infs_fp_math = getProperties().no_infs_fp_math; (void)tblgen_no_infs_fp_math;
  auto tblgen_no_inline = getProperties().no_inline; (void)tblgen_no_inline;
  auto tblgen_no_nans_fp_math = getProperties().no_nans_fp_math; (void)tblgen_no_nans_fp_math;
  auto tblgen_no_signed_zeros_fp_math = getProperties().no_signed_zeros_fp_math; (void)tblgen_no_signed_zeros_fp_math;
  auto tblgen_no_unwind = getProperties().no_unwind; (void)tblgen_no_unwind;
  auto tblgen_optimize_none = getProperties().optimize_none; (void)tblgen_optimize_none;
  auto tblgen_passthrough = getProperties().passthrough; (void)tblgen_passthrough;
  auto tblgen_personality = getProperties().personality; (void)tblgen_personality;
  auto tblgen_reqd_work_group_size = getProperties().reqd_work_group_size; (void)tblgen_reqd_work_group_size;
  auto tblgen_res_attrs = getProperties().res_attrs; (void)tblgen_res_attrs;
  auto tblgen_section = getProperties().section; (void)tblgen_section;
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");
  auto tblgen_sym_visibility = getProperties().sym_visibility; (void)tblgen_sym_visibility;
  auto tblgen_target_cpu = getProperties().target_cpu; (void)tblgen_target_cpu;
  auto tblgen_target_features = getProperties().target_features; (void)tblgen_target_features;
  auto tblgen_tune_cpu = getProperties().tune_cpu; (void)tblgen_tune_cpu;
  auto tblgen_unnamed_addr = getProperties().unnamed_addr; (void)tblgen_unnamed_addr;
  auto tblgen_unsafe_fp_math = getProperties().unsafe_fp_math; (void)tblgen_unsafe_fp_math;
  auto tblgen_vec_type_hint = getProperties().vec_type_hint; (void)tblgen_vec_type_hint;
  auto tblgen_visibility_ = getProperties().visibility_; (void)tblgen_visibility_;
  auto tblgen_vscale_range = getProperties().vscale_range; (void)tblgen_vscale_range;
  auto tblgen_will_return = getProperties().will_return; (void)tblgen_will_return;
  auto tblgen_work_group_size_hint = getProperties().work_group_size_hint; (void)tblgen_work_group_size_hint;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_sym_visibility, "sym_visibility")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps13(*this, tblgen_function_type, "function_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps24(*this, tblgen_linkage, "linkage")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_dso_local, "dso_local")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps15(*this, tblgen_CConv, "CConv")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps27(*this, tblgen_comdat, "comdat")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_convergent, "convergent")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps1(*this, tblgen_personality, "personality")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_garbageCollector, "garbageCollector")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps32(*this, tblgen_passthrough, "passthrough")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps33(*this, tblgen_arg_attrs, "arg_attrs")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps33(*this, tblgen_res_attrs, "res_attrs")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_function_entry_count, "function_entry_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps17(*this, tblgen_memory_effects, "memory_effects")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps29(*this, tblgen_visibility_, "visibility_")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_streaming, "arm_streaming")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_locally_streaming, "arm_locally_streaming")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_streaming_compatible, "arm_streaming_compatible")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_new_za, "arm_new_za")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_in_za, "arm_in_za")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_out_za, "arm_out_za")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_inout_za, "arm_inout_za")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_arm_preserves_za, "arm_preserves_za")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_section, "section")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps26(*this, tblgen_unnamed_addr, "unnamed_addr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_alignment, "alignment")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps34(*this, tblgen_vscale_range, "vscale_range")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps35(*this, tblgen_frame_pointer, "frame_pointer")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_target_cpu, "target_cpu")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_tune_cpu, "tune_cpu")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps36(*this, tblgen_target_features, "target_features")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(*this, tblgen_unsafe_fp_math, "unsafe_fp_math")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(*this, tblgen_no_infs_fp_math, "no_infs_fp_math")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(*this, tblgen_no_nans_fp_math, "no_nans_fp_math")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(*this, tblgen_approx_func_fp_math, "approx_func_fp_math")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps37(*this, tblgen_no_signed_zeros_fp_math, "no_signed_zeros_fp_math")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_denormal_fp_math, "denormal_fp_math")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_denormal_fp_math_f32, "denormal_fp_math_f32")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_fp_contract, "fp_contract")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_no_inline, "no_inline")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_always_inline, "always_inline")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_no_unwind, "no_unwind")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_will_return, "will_return")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_optimize_none, "optimize_none")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps38(*this, tblgen_vec_type_hint, "vec_type_hint")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_work_group_size_hint, "work_group_size_hint")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_reqd_work_group_size, "reqd_work_group_size")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps39(*this, tblgen_intel_reqd_sub_group_size, "intel_reqd_sub_group_size")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_LLVMOps2(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult LLVMFuncOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LLVMFuncOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::LShrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
LShrOpAdaptor::LShrOpAdaptor(LShrOp op) : LShrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LShrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void LShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void LShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void LShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(LShrOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void LShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LShrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LShrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(LShrOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult LShrOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult LShrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult LShrOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult LShrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LShrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void LShrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LShrOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::LandingpadOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
LandingpadOpGenericAdaptorBase::LandingpadOpGenericAdaptorBase(LandingpadOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> LandingpadOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::UnitAttr LandingpadOpGenericAdaptorBase::getCleanupAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().cleanup);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool LandingpadOpGenericAdaptorBase::getCleanup() {
  auto attr = getCleanupAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
LandingpadOpAdaptor::LandingpadOpAdaptor(LandingpadOp op) : LandingpadOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LandingpadOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_cleanup = getProperties().cleanup; (void)tblgen_cleanup;

  if (tblgen_cleanup && !((::llvm::isa<::mlir::UnitAttr>(tblgen_cleanup))))
    return emitError(loc, "'llvm.landingpad' op ""attribute 'cleanup' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LandingpadOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult LandingpadOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.cleanup;
       auto attr = dict.get("cleanup");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `cleanup` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute LandingpadOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.cleanup;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("cleanup",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code LandingpadOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.cleanup.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> LandingpadOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "cleanup")
      return prop.cleanup;
  return std::nullopt;
}

void LandingpadOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "cleanup") {
       prop.cleanup = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.cleanup)>>(value);
       return;
    }
}

void LandingpadOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.cleanup) attrs.append("cleanup", prop.cleanup);
}

::llvm::LogicalResult LandingpadOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCleanupAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "cleanup", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult LandingpadOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.cleanup)))
    return ::mlir::failure();
  return ::mlir::success();
}

void LandingpadOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.cleanup);
}

bool LandingpadOp::getCleanup() {
  auto attr = getCleanupAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void LandingpadOp::setCleanup(bool attrValue) {
    auto &odsProp = getProperties().cleanup;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LandingpadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void LandingpadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, /*optional*/::mlir::UnitAttr cleanup, ::mlir::ValueRange odsArg_0) {
  odsState.addOperands(odsArg_0);
  if (cleanup) {
    odsState.getOrAddProperties<Properties>().cleanup = cleanup;
  }
  odsState.addTypes(res);
}

void LandingpadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::UnitAttr cleanup, ::mlir::ValueRange odsArg_0) {
  odsState.addOperands(odsArg_0);
  if (cleanup) {
    odsState.getOrAddProperties<Properties>().cleanup = cleanup;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LandingpadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, /*optional*/bool cleanup, ::mlir::ValueRange odsArg_0) {
  odsState.addOperands(odsArg_0);
  if (cleanup) {
    odsState.getOrAddProperties<Properties>().cleanup = ((cleanup) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.addTypes(res);
}

void LandingpadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/bool cleanup, ::mlir::ValueRange odsArg_0) {
  odsState.addOperands(odsArg_0);
  if (cleanup) {
    odsState.getOrAddProperties<Properties>().cleanup = ((cleanup) ? odsBuilder.getUnitAttr() : nullptr);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LandingpadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<LandingpadOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult LandingpadOp::verifyInvariantsImpl() {
  auto tblgen_cleanup = getProperties().cleanup; (void)tblgen_cleanup;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_cleanup, "cleanup")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult LandingpadOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LandingpadOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::LinkerOptionsOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
LinkerOptionsOpGenericAdaptorBase::LinkerOptionsOpGenericAdaptorBase(LinkerOptionsOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::ArrayAttr LinkerOptionsOpGenericAdaptorBase::getOptions() {
  auto attr = getOptionsAttr();
  return attr;
}

} // namespace detail
LinkerOptionsOpAdaptor::LinkerOptionsOpAdaptor(LinkerOptionsOp op) : LinkerOptionsOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LinkerOptionsOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_options = getProperties().options; (void)tblgen_options;
  if (!tblgen_options) return emitError(loc, "'llvm.linker_options' op ""requires attribute 'options'");

  if (tblgen_options && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_options))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_options), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::StringAttr>(attr))); }))))
    return emitError(loc, "'llvm.linker_options' op ""attribute 'options' failed to satisfy constraint: string array attribute");
  return ::mlir::success();
}

::llvm::LogicalResult LinkerOptionsOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.options;
       auto attr = dict.get("options");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `options` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute LinkerOptionsOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.options;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("options",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code LinkerOptionsOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.options.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> LinkerOptionsOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "options")
      return prop.options;
  return std::nullopt;
}

void LinkerOptionsOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "options") {
       prop.options = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.options)>>(value);
       return;
    }
}

void LinkerOptionsOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.options) attrs.append("options", prop.options);
}

::llvm::LogicalResult LinkerOptionsOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getOptionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps40(attr, "options", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult LinkerOptionsOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.options)))
    return ::mlir::failure();
  return ::mlir::success();
}

void LinkerOptionsOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.options);
}

::mlir::ArrayAttr LinkerOptionsOp::getOptions() {
  auto attr = getOptionsAttr();
  return attr;
}

void LinkerOptionsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ArrayAttr options) {
  odsState.getOrAddProperties<Properties>().options = options;
}

void LinkerOptionsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr options) {
  odsState.getOrAddProperties<Properties>().options = options;
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LinkerOptionsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<LinkerOptionsOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult LinkerOptionsOp::verifyInvariantsImpl() {
  auto tblgen_options = getProperties().options; (void)tblgen_options;
  if (!tblgen_options) return emitOpError("requires attribute 'options'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps40(*this, tblgen_options, "options")))
    return ::mlir::failure();
  return ::mlir::success();
}

::llvm::LogicalResult LinkerOptionsOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult LinkerOptionsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::ArrayAttr optionsAttr;

  if (parser.parseCustomAttributeWithFallback(optionsAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (optionsAttr) result.getOrAddProperties<LinkerOptionsOp::Properties>().options = optionsAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void LinkerOptionsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getOptionsAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("options");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LinkerOptionsOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::LoadOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
LoadOpGenericAdaptorBase::LoadOpGenericAdaptorBase(LoadOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::std::optional<uint64_t> LoadOpGenericAdaptorBase::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::mlir::UnitAttr LoadOpGenericAdaptorBase::getVolatile_Attr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().volatile_);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool LoadOpGenericAdaptorBase::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr LoadOpGenericAdaptorBase::getNontemporalAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nontemporal);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool LoadOpGenericAdaptorBase::getNontemporal() {
  auto attr = getNontemporalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr LoadOpGenericAdaptorBase::getInvariantAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().invariant);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool LoadOpGenericAdaptorBase::getInvariant() {
  auto attr = getInvariantAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::LLVM::AtomicOrderingAttr LoadOpGenericAdaptorBase::getOrderingAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::AtomicOrderingAttr>(getProperties().ordering);
  return attr;
}

::mlir::LLVM::AtomicOrdering LoadOpGenericAdaptorBase::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > LoadOpGenericAdaptorBase::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOpGenericAdaptorBase::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOpGenericAdaptorBase::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOpGenericAdaptorBase::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOpGenericAdaptorBase::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
LoadOpAdaptor::LoadOpAdaptor(LoadOp op) : LoadOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LoadOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_invariant = getProperties().invariant; (void)tblgen_invariant;
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_nontemporal = getProperties().nontemporal; (void)tblgen_nontemporal;
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;

  if (tblgen_alignment && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_alignment))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_alignment).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.load' op ""attribute 'alignment' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_volatile_ && !((::llvm::isa<::mlir::UnitAttr>(tblgen_volatile_))))
    return emitError(loc, "'llvm.load' op ""attribute 'volatile_' failed to satisfy constraint: unit attribute");

  if (tblgen_nontemporal && !((::llvm::isa<::mlir::UnitAttr>(tblgen_nontemporal))))
    return emitError(loc, "'llvm.load' op ""attribute 'nontemporal' failed to satisfy constraint: unit attribute");

  if (tblgen_invariant && !((::llvm::isa<::mlir::UnitAttr>(tblgen_invariant))))
    return emitError(loc, "'llvm.load' op ""attribute 'invariant' failed to satisfy constraint: unit attribute");

  if (tblgen_ordering && !((::llvm::isa<::mlir::LLVM::AtomicOrderingAttr>(tblgen_ordering))))
    return emitError(loc, "'llvm.load' op ""attribute 'ordering' failed to satisfy constraint: Atomic ordering for LLVM's memory model");

  if (tblgen_syncscope && !((::llvm::isa<::mlir::StringAttr>(tblgen_syncscope))))
    return emitError(loc, "'llvm.load' op ""attribute 'syncscope' failed to satisfy constraint: string attribute");

  if (tblgen_access_groups && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_access_groups))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_access_groups), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AccessGroupAttr>(attr))); }))))
    return emitError(loc, "'llvm.load' op ""attribute 'access_groups' failed to satisfy constraint: LLVM dialect access group metadata array");

  if (tblgen_alias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_alias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_alias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.load' op ""attribute 'alias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_noalias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_noalias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_noalias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.load' op ""attribute 'noalias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_tbaa && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_tbaa))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_tbaa), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::TBAATagAttr>(attr))); }))))
    return emitError(loc, "'llvm.load' op ""attribute 'tbaa' failed to satisfy constraint: LLVM dialect TBAA tag metadata array");
  return ::mlir::success();
}

::llvm::LogicalResult LoadOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.access_groups;
       auto attr = dict.get("access_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `access_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alias_scopes;
       auto attr = dict.get("alias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alignment;
       auto attr = dict.get("alignment");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alignment` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.invariant;
       auto attr = dict.get("invariant");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `invariant` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.noalias_scopes;
       auto attr = dict.get("noalias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `noalias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.nontemporal;
       auto attr = dict.get("nontemporal");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `nontemporal` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.ordering;
       auto attr = dict.get("ordering");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `ordering` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.syncscope;
       auto attr = dict.get("syncscope");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `syncscope` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tbaa;
       auto attr = dict.get("tbaa");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tbaa` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.volatile_;
       auto attr = dict.get("volatile_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `volatile_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute LoadOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.access_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("access_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alignment;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alignment",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.invariant;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("invariant",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.noalias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("noalias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.nontemporal;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("nontemporal",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.ordering;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("ordering",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.syncscope;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("syncscope",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tbaa;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tbaa",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.volatile_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("volatile_",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code LoadOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.access_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.alias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.alignment.getAsOpaquePointer()), 
    llvm::hash_value(prop.invariant.getAsOpaquePointer()), 
    llvm::hash_value(prop.noalias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.nontemporal.getAsOpaquePointer()), 
    llvm::hash_value(prop.ordering.getAsOpaquePointer()), 
    llvm::hash_value(prop.syncscope.getAsOpaquePointer()), 
    llvm::hash_value(prop.tbaa.getAsOpaquePointer()), 
    llvm::hash_value(prop.volatile_.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> LoadOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "access_groups")
      return prop.access_groups;

    if (name == "alias_scopes")
      return prop.alias_scopes;

    if (name == "alignment")
      return prop.alignment;

    if (name == "invariant")
      return prop.invariant;

    if (name == "noalias_scopes")
      return prop.noalias_scopes;

    if (name == "nontemporal")
      return prop.nontemporal;

    if (name == "ordering")
      return prop.ordering;

    if (name == "syncscope")
      return prop.syncscope;

    if (name == "tbaa")
      return prop.tbaa;

    if (name == "volatile_")
      return prop.volatile_;
  return std::nullopt;
}

void LoadOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "access_groups") {
       prop.access_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.access_groups)>>(value);
       return;
    }

    if (name == "alias_scopes") {
       prop.alias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alias_scopes)>>(value);
       return;
    }

    if (name == "alignment") {
       prop.alignment = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alignment)>>(value);
       return;
    }

    if (name == "invariant") {
       prop.invariant = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.invariant)>>(value);
       return;
    }

    if (name == "noalias_scopes") {
       prop.noalias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.noalias_scopes)>>(value);
       return;
    }

    if (name == "nontemporal") {
       prop.nontemporal = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.nontemporal)>>(value);
       return;
    }

    if (name == "ordering") {
       prop.ordering = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.ordering)>>(value);
       return;
    }

    if (name == "syncscope") {
       prop.syncscope = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.syncscope)>>(value);
       return;
    }

    if (name == "tbaa") {
       prop.tbaa = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tbaa)>>(value);
       return;
    }

    if (name == "volatile_") {
       prop.volatile_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.volatile_)>>(value);
       return;
    }
}

void LoadOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.access_groups) attrs.append("access_groups", prop.access_groups);

    if (prop.alias_scopes) attrs.append("alias_scopes", prop.alias_scopes);

    if (prop.alignment) attrs.append("alignment", prop.alignment);

    if (prop.invariant) attrs.append("invariant", prop.invariant);

    if (prop.noalias_scopes) attrs.append("noalias_scopes", prop.noalias_scopes);

    if (prop.nontemporal) attrs.append("nontemporal", prop.nontemporal);

    if (prop.ordering) attrs.append("ordering", prop.ordering);

    if (prop.syncscope) attrs.append("syncscope", prop.syncscope);

    if (prop.tbaa) attrs.append("tbaa", prop.tbaa);

    if (prop.volatile_) attrs.append("volatile_", prop.volatile_);
}

::llvm::LogicalResult LoadOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAccessGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(attr, "access_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "alias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAlignmentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "alignment", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInvariantAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "invariant", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoaliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "noalias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNontemporalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "nontemporal", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOrderingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(attr, "ordering", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSyncscopeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "syncscope", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTbaaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(attr, "tbaa", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVolatile_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "volatile_", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult LoadOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.access_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alignment)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.invariant)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.noalias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.nontemporal)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.ordering)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.syncscope)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tbaa)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.volatile_)))
    return ::mlir::failure();
  return ::mlir::success();
}

void LoadOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.access_groups);

  writer.writeOptionalAttribute(prop.alias_scopes);

  writer.writeOptionalAttribute(prop.alignment);

  writer.writeOptionalAttribute(prop.invariant);

  writer.writeOptionalAttribute(prop.noalias_scopes);

  writer.writeOptionalAttribute(prop.nontemporal);

  writer.writeOptionalAttribute(prop.ordering);

  writer.writeOptionalAttribute(prop.syncscope);

  writer.writeOptionalAttribute(prop.tbaa);

  writer.writeOptionalAttribute(prop.volatile_);
}

::std::optional<uint64_t> LoadOp::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

bool LoadOp::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool LoadOp::getNontemporal() {
  auto attr = getNontemporalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool LoadOp::getInvariant() {
  auto attr = getInvariantAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::LLVM::AtomicOrdering LoadOp::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > LoadOp::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOp::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOp::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOp::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoadOp::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void LoadOp::setAlignment(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().alignment;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void LoadOp::setVolatile_(bool attrValue) {
    auto &odsProp = getProperties().volatile_;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LoadOp::setNontemporal(bool attrValue) {
    auto &odsProp = getProperties().nontemporal;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LoadOp::setInvariant(bool attrValue) {
    auto &odsProp = getProperties().invariant;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void LoadOp::setOrdering(::mlir::LLVM::AtomicOrdering attrValue) {
  getProperties().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void LoadOp::setSyncscope(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().syncscope;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::UnitAttr nontemporal, /*optional*/::mlir::UnitAttr invariant, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = nontemporal;
  }
  if (invariant) {
    odsState.getOrAddProperties<Properties>().invariant = invariant;
  }
  if (ordering) {
    odsState.getOrAddProperties<Properties>().ordering = ordering;
  }
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(res);
}

void LoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::UnitAttr nontemporal, /*optional*/::mlir::UnitAttr invariant, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = nontemporal;
  }
  if (invariant) {
    odsState.getOrAddProperties<Properties>().invariant = invariant;
  }
  if (ordering) {
    odsState.getOrAddProperties<Properties>().ordering = ordering;
  }
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool volatile_, /*optional*/bool nontemporal, /*optional*/bool invariant, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = ((nontemporal) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (invariant) {
    odsState.getOrAddProperties<Properties>().invariant = ((invariant) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  odsState.addTypes(res);
}

void LoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool volatile_, /*optional*/bool nontemporal, /*optional*/bool invariant, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = ((nontemporal) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (invariant) {
    odsState.getOrAddProperties<Properties>().invariant = ((invariant) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LoadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<LoadOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void LoadOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.ordering)
    properties.ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), AtomicOrdering::not_atomic);
}

::llvm::LogicalResult LoadOp::verifyInvariantsImpl() {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_invariant = getProperties().invariant; (void)tblgen_invariant;
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_nontemporal = getProperties().nontemporal; (void)tblgen_nontemporal;
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_alignment, "alignment")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_volatile_, "volatile_")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_nontemporal, "nontemporal")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_invariant, "invariant")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(*this, tblgen_ordering, "ordering")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_syncscope, "syncscope")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(*this, tblgen_access_groups, "access_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_alias_scopes, "alias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_noalias_scopes, "noalias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(*this, tblgen_tbaa, "tbaa")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps19(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult LoadOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult LoadOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand addrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> addrOperands(&addrRawOperand, 1);  ::llvm::SMLoc addrOperandsLoc;
  (void)addrOperandsLoc;
  ::mlir::StringAttr syncscopeAttr;
  ::mlir::LLVM::AtomicOrderingAttr orderingAttr;
  ::mlir::Type addrRawType{};
  ::llvm::ArrayRef<::mlir::Type> addrTypes(&addrRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);
  if (::mlir::succeeded(parser.parseOptionalKeyword("volatile"))) {
    result.getOrAddProperties<LoadOp::Properties>().volatile_ = parser.getBuilder().getUnitAttr();  }

  addrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(addrRawOperand))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("atomic"))) {
  if (::mlir::succeeded(parser.parseOptionalKeyword("syncscope"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(syncscopeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (syncscopeAttr) result.getOrAddProperties<LoadOp::Properties>().syncscope = syncscopeAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  }

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"not_atomic","unordered","monotonic","acquire","release","acq_rel","seq_cst"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "ordering", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'ordering' [not_atomic, unordered, monotonic, acquire, release, acq_rel, seq_cst]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAtomicOrdering(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "ordering attribute specification: \"" << attrStr << '"';;

      orderingAttr = ::mlir::LLVM::AtomicOrderingAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<LoadOp::Properties>().ordering = orderingAttr;
    }
  }
  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("invariant"))) {
    result.getOrAddProperties<LoadOp::Properties>().invariant = parser.getBuilder().getUnitAttr();  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(addrRawType))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(addrOperands, addrTypes, addrOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LoadOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getVolatile_Attr() && getVolatile_Attr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "volatile";
  }
  _odsPrinter << ' ';
  _odsPrinter << getAddr();
  if (getOrderingAttr() != ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::OpBuilder((*this)->getContext()).getContext(), AtomicOrdering::not_atomic)) {
    _odsPrinter << ' ' << "atomic";
    if (getSyncscopeAttr()) {
      _odsPrinter << ' ' << "syncscope";
      _odsPrinter << "(";
      _odsPrinter.printAttributeWithoutType(getSyncscopeAttr());
      _odsPrinter << ")";
    }
    _odsPrinter << ' ';

    {
      auto caseValue = getOrdering();
      auto caseValueStr = stringifyAtomicOrdering(caseValue);
      _odsPrinter << caseValueStr;
    }
  }
  if ((getInvariantAttr() && getInvariantAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "invariant";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("volatile_");
  elidedAttrs.push_back("syncscope");
  elidedAttrs.push_back("ordering");
  elidedAttrs.push_back("invariant");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getVolatile_Attr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("volatile_");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getNontemporalAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("nontemporal");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getInvariantAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("invariant");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getOrderingAttr();
     if(attr && (attr == ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), AtomicOrdering::not_atomic)))
       elidedAttrs.push_back("ordering");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
   _odsPrinter << getAddr().getType();
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::LoadOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::MulOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
MulOpGenericAdaptorBase::MulOpGenericAdaptorBase(MulOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

} // namespace detail
MulOpAdaptor::MulOpAdaptor(MulOp op) : MulOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult MulOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::LogicalResult MulOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }
    {

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("overflowFlags");;
;
      if (attr) {
        if (::mlir::failed(setFromAttr(prop.overflowFlags, attr, emitError)))
          return ::mlir::failure();
      } else {
        prop.overflowFlags = IntegerOverflowFlags::none;
      }
  }
  return ::mlir::success();
}

::mlir::Attribute MulOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.overflowFlags;
      auto attr = [&]() -> ::mlir::Attribute {
        return convertToAttribute(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("overflowFlags", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code MulOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    ::llvm::hash_value(prop.overflowFlags));
}

std::optional<mlir::Attribute> MulOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
  return std::nullopt;
}

void MulOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
}

void MulOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
}

::llvm::LogicalResult MulOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    return ::mlir::success();
}

::llvm::LogicalResult MulOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  {
    auto &propStorage = prop.overflowFlags;
    auto readProp = [&]() {
      uint64_t val;
    if (failed(reader.readVarInt(val)))
      return ::mlir::failure();
    propStorage = static_cast<IntegerOverflowFlags>(val);;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void MulOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  {
    auto &propStorage = prop.overflowFlags;
    writer.writeVarInt(static_cast<uint64_t>(propStorage));;
  }
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  odsState.addTypes(res);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(MulOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<MulOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<MulOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(MulOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult MulOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult MulOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult MulOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult MulOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseOverflowFlags(parser, result.getOrAddProperties<Properties>().overflowFlags);
    if (odsResult) return ::mlir::failure();
  }
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void MulOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  printOverflowFlags(_odsPrinter, *this, getProperties().overflowFlags);
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void MulOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::MulOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::NoneTokenOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
NoneTokenOpAdaptor::NoneTokenOpAdaptor(NoneTokenOp op) : NoneTokenOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult NoneTokenOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void NoneTokenOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void NoneTokenOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res) {
  odsState.addTypes(res);
}

void NoneTokenOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(NoneTokenOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void NoneTokenOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NoneTokenOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void NoneTokenOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(NoneTokenOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult NoneTokenOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps20(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult NoneTokenOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult NoneTokenOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = ::mlir::LLVM::LLVMTokenType::get(odsBuilder.getContext());
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult NoneTokenOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  return ::mlir::success();
}

void NoneTokenOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void NoneTokenOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::NoneTokenOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::OrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
OrOpAdaptor::OrOpAdaptor(OrOp op) : OrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult OrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(OrOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(OrOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult OrOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult OrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult OrOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult OrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void OrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::OrOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::PoisonOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
PoisonOpAdaptor::PoisonOpAdaptor(PoisonOp op) : PoisonOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PoisonOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void PoisonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void PoisonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res) {
  odsState.addTypes(res);
}

void PoisonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PoisonOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult PoisonOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PoisonOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult PoisonOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  return ::mlir::success();
}

void PoisonOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void PoisonOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::PoisonOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::PtrToIntOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
PtrToIntOpAdaptor::PtrToIntOpAdaptor(PtrToIntOp op) : PtrToIntOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PtrToIntOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void PtrToIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void PtrToIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void PtrToIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PtrToIntOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult PtrToIntOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PtrToIntOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult PtrToIntOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void PtrToIntOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void PtrToIntOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::PtrToIntOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ResumeOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ResumeOpAdaptor::ResumeOpAdaptor(ResumeOp op) : ResumeOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ResumeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ResumeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value) {
  odsState.addOperands(value);
}

void ResumeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value) {
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResumeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ResumeOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ResumeOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ResumeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand valueRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valueOperands(&valueRawOperand, 1);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::Type valueRawType{};
  ::llvm::ArrayRef<::mlir::Type> valueTypes(&valueRawType, 1);

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valueRawType = type;
  }
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ResumeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getValue();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getValue().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ResumeOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ReturnOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> ReturnOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
ReturnOpAdaptor::ReturnOpAdaptor(ReturnOp op) : ReturnOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReturnOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReturnOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange ReturnOp::getArgMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void ReturnOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange args) {
      build(odsBuilder, odsState, TypeRange(), args);
    
}

void ReturnOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value arg) {
  if (arg)
    odsState.addOperands(arg);
}

void ReturnOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value arg) {
  if (arg)
    odsState.addOperands(arg);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReturnOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ReturnOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReturnOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ReturnOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> argOperands;
  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> argTypes;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }

  {
    argOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      argOperands.push_back(operand);
    }
  }
  if (!argOperands.empty()) {
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      argTypes.push_back(optionalType);
    }
  }
  }
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReturnOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  if (getArg()) {
    _odsPrinter << ' ';
    if (::mlir::Value value = getArg())
      _odsPrinter << value;
    _odsPrinter << ' ' << ":";
    _odsPrinter << ' ';
    _odsPrinter << (getArg() ? ::llvm::ArrayRef<::mlir::Type>(getArg().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  }
}

void ReturnOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

::mlir::MutableOperandRange ReturnOp::getMutableSuccessorOperands(
  ::mlir::RegionBranchPoint point) {
  return ::mlir::MutableOperandRange(*this);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ReturnOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::SDivOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SDivOpAdaptor::SDivOpAdaptor(SDivOp op) : SDivOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(SDivOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(SDivOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult SDivOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SDivOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult SDivOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult SDivOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SDivOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SDivOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::SDivOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::SExtOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SExtOpAdaptor::SExtOpAdaptor(SExtOp op) : SExtOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SExtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void SExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void SExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SExtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult SExtOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SExtOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult SExtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SExtOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SExtOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::SExtOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::SIToFPOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SIToFPOpAdaptor::SIToFPOpAdaptor(SIToFPOp op) : SIToFPOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SIToFPOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void SIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void SIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SIToFPOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult SIToFPOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SIToFPOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SIToFPOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SIToFPOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SIToFPOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::SIToFPOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::SRemOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SRemOpAdaptor::SRemOpAdaptor(SRemOp op) : SRemOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SRemOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(SRemOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SRemOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(SRemOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult SRemOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SRemOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult SRemOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult SRemOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SRemOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SRemOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::SRemOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::SelectOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase(SelectOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::LLVM::FastmathFlagsAttr SelectOpGenericAdaptorBase::getFastmathFlagsAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::FastmathFlagsAttr>(getProperties().fastmathFlags);
  return attr;
}

::mlir::LLVM::FastmathFlags SelectOpGenericAdaptorBase::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

} // namespace detail
SelectOpAdaptor::SelectOpAdaptor(SelectOp op) : SelectOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SelectOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (tblgen_fastmathFlags && !((::llvm::isa<::mlir::LLVM::FastmathFlagsAttr>(tblgen_fastmathFlags))))
    return emitError(loc, "'llvm.select' op ""attribute 'fastmathFlags' failed to satisfy constraint: LLVM fastmath flags");
  return ::mlir::success();
}

::llvm::LogicalResult SelectOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fastmathFlags;
       auto attr = dict.get("fastmathFlags");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fastmathFlags` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute SelectOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fastmathFlags;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fastmathFlags",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SelectOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fastmathFlags.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> SelectOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fastmathFlags")
      return prop.fastmathFlags;
  return std::nullopt;
}

void SelectOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fastmathFlags") {
       prop.fastmathFlags = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fastmathFlags)>>(value);
       return;
    }
}

void SelectOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fastmathFlags) attrs.append("fastmathFlags", prop.fastmathFlags);
}

::llvm::LogicalResult SelectOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFastmathFlagsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(attr, "fastmathFlags", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SelectOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.fastmathFlags)))
    return ::mlir::failure();
  return ::mlir::success();
}

void SelectOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.fastmathFlags);
}

::mlir::LLVM::FastmathFlags SelectOp::getFastmathFlags() {
  auto attr = getFastmathFlagsAttr();
  return attr.getValue();
}

void SelectOp::setFastmathFlags(::mlir::LLVM::FastmathFlags attrValue) {
  getProperties().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value condition, ::mlir::Value trueValue, ::mlir::Value falseValue, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(condition);
  odsState.addOperands(trueValue);
  odsState.addOperands(falseValue);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  odsState.addTypes(res);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::Value trueValue, ::mlir::Value falseValue, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(condition);
  odsState.addOperands(trueValue);
  odsState.addOperands(falseValue);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(SelectOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value trueValue, ::mlir::Value falseValue, ::mlir::LLVM::FastmathFlagsAttr fastmathFlags) {
  odsState.addOperands(condition);
  odsState.addOperands(trueValue);
  odsState.addOperands(falseValue);
  if (fastmathFlags) {
    odsState.getOrAddProperties<Properties>().fastmathFlags = fastmathFlags;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value condition, ::mlir::Value trueValue, ::mlir::Value falseValue, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(condition);
  odsState.addOperands(trueValue);
  odsState.addOperands(falseValue);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  odsState.addTypes(res);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::Value trueValue, ::mlir::Value falseValue, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(condition);
  odsState.addOperands(trueValue);
  odsState.addOperands(falseValue);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(SelectOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value trueValue, ::mlir::Value falseValue, ::mlir::LLVM::FastmathFlags fastmathFlags) {
  odsState.addOperands(condition);
  odsState.addOperands(trueValue);
  odsState.addOperands(falseValue);
  odsState.getOrAddProperties<Properties>().fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), fastmathFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SelectOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SelectOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(SelectOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

void SelectOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.fastmathFlags)
    properties.fastmathFlags = ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {});
}

::llvm::LogicalResult SelectOp::verifyInvariantsImpl() {
  auto tblgen_fastmathFlags = getProperties().fastmathFlags; (void)tblgen_fastmathFlags;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps12(*this, tblgen_fastmathFlags, "fastmathFlags")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((((*this->getODSOperands(1).begin()).getType()) == ((*this->getODSOperands(2).begin()).getType()) && ((*this->getODSOperands(2).begin()).getType()) == ((*this->getODSResults(0).begin()).getType()) && ((*this->getODSResults(0).begin()).getType()) == ((*this->getODSOperands(1).begin()).getType()))))
    return emitOpError("failed to verify that all of {trueValue, falseValue, res} have same type");
  return ::mlir::success();
}

::llvm::LogicalResult SelectOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult SelectOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[2].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult SelectOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> allOperands;
  ::mlir::Type conditionRawType{};
  ::llvm::ArrayRef<::mlir::Type> conditionTypes(&conditionRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);
  [[maybe_unused]] ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    conditionRawType = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(conditionTypes), ::llvm::ArrayRef<::mlir::Type>(resTypes[0]), ::llvm::ArrayRef<::mlir::Type>(resTypes[0])), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SelectOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getFastmathFlagsAttr();
     if(attr && (attr == ::mlir::LLVM::FastmathFlagsAttr::get(odsBuilder.getContext(), {})))
       elidedAttrs.push_back("fastmathFlags");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getCondition().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SelectOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::SelectOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ShlOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ShlOpGenericAdaptorBase::ShlOpGenericAdaptorBase(ShlOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

} // namespace detail
ShlOpAdaptor::ShlOpAdaptor(ShlOp op) : ShlOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ShlOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::LogicalResult ShlOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }
    {

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("overflowFlags");;
;
      if (attr) {
        if (::mlir::failed(setFromAttr(prop.overflowFlags, attr, emitError)))
          return ::mlir::failure();
      } else {
        prop.overflowFlags = IntegerOverflowFlags::none;
      }
  }
  return ::mlir::success();
}

::mlir::Attribute ShlOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.overflowFlags;
      auto attr = [&]() -> ::mlir::Attribute {
        return convertToAttribute(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("overflowFlags", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ShlOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    ::llvm::hash_value(prop.overflowFlags));
}

std::optional<mlir::Attribute> ShlOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
  return std::nullopt;
}

void ShlOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
}

void ShlOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
}

::llvm::LogicalResult ShlOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    return ::mlir::success();
}

::llvm::LogicalResult ShlOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  {
    auto &propStorage = prop.overflowFlags;
    auto readProp = [&]() {
      uint64_t val;
    if (failed(reader.readVarInt(val)))
      return ::mlir::failure();
    propStorage = static_cast<IntegerOverflowFlags>(val);;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void ShlOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  {
    auto &propStorage = prop.overflowFlags;
    writer.writeVarInt(static_cast<uint64_t>(propStorage));;
  }
}

void ShlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void ShlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  odsState.addTypes(res);
}

void ShlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(ShlOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ShlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShlOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ShlOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void ShlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ShlOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(ShlOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult ShlOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ShlOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult ShlOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult ShlOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseOverflowFlags(parser, result.getOrAddProperties<Properties>().overflowFlags);
    if (odsResult) return ::mlir::failure();
  }
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ShlOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  printOverflowFlags(_odsPrinter, *this, getProperties().overflowFlags);
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ShlOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ShlOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ShuffleVectorOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ShuffleVectorOpGenericAdaptorBase::ShuffleVectorOpGenericAdaptorBase(ShuffleVectorOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::ArrayRef<int32_t> ShuffleVectorOpGenericAdaptorBase::getMask() {
  auto attr = getMaskAttr();
  return attr;
}

} // namespace detail
ShuffleVectorOpAdaptor::ShuffleVectorOpAdaptor(ShuffleVectorOp op) : ShuffleVectorOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ShuffleVectorOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_mask = getProperties().mask; (void)tblgen_mask;
  if (!tblgen_mask) return emitError(loc, "'llvm.shufflevector' op ""requires attribute 'mask'");

  if (tblgen_mask && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_mask))))
    return emitError(loc, "'llvm.shufflevector' op ""attribute 'mask' failed to satisfy constraint: i32 dense array attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ShuffleVectorOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.mask;
       auto attr = dict.get("mask");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `mask` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ShuffleVectorOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.mask;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("mask",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ShuffleVectorOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.mask.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ShuffleVectorOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "mask")
      return prop.mask;
  return std::nullopt;
}

void ShuffleVectorOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "mask") {
       prop.mask = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.mask)>>(value);
       return;
    }
}

void ShuffleVectorOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.mask) attrs.append("mask", prop.mask);
}

::llvm::LogicalResult ShuffleVectorOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getMaskAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "mask", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ShuffleVectorOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.mask)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ShuffleVectorOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.mask);
}

::llvm::ArrayRef<int32_t> ShuffleVectorOp::getMask() {
  auto attr = getMaskAttr();
  return attr;
}

void ShuffleVectorOp::setMask(::llvm::ArrayRef<int32_t> attrValue) {
  getProperties().mask = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(attrValue);
}

void ShuffleVectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value v1, ::mlir::Value v2, ::mlir::DenseI32ArrayAttr mask) {
  odsState.addOperands(v1);
  odsState.addOperands(v2);
  odsState.getOrAddProperties<Properties>().mask = mask;
  odsState.addTypes(res);
}

void ShuffleVectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value v1, ::mlir::Value v2, ::mlir::DenseI32ArrayAttr mask) {
  odsState.addOperands(v1);
  odsState.addOperands(v2);
  odsState.getOrAddProperties<Properties>().mask = mask;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShuffleVectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value v1, ::mlir::Value v2, ::llvm::ArrayRef<int32_t> mask) {
  odsState.addOperands(v1);
  odsState.addOperands(v2);
  odsState.getOrAddProperties<Properties>().mask = odsBuilder.getDenseI32ArrayAttr(mask);
  odsState.addTypes(res);
}

void ShuffleVectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value v1, ::mlir::Value v2, ::llvm::ArrayRef<int32_t> mask) {
  odsState.addOperands(v1);
  odsState.addOperands(v2);
  odsState.getOrAddProperties<Properties>().mask = odsBuilder.getDenseI32ArrayAttr(mask);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShuffleVectorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ShuffleVectorOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ShuffleVectorOp::verifyInvariantsImpl() {
  auto tblgen_mask = getProperties().mask; (void)tblgen_mask;
  if (!tblgen_mask) return emitOpError("requires attribute 'mask'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_mask, "mask")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps12(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((((*this->getODSOperands(0).begin()).getType()) == ((*this->getODSOperands(1).begin()).getType()) && ((*this->getODSOperands(1).begin()).getType()) == ((*this->getODSOperands(0).begin()).getType()))))
    return emitOpError("failed to verify that all of {v1, v2} have same type");
  return ::mlir::success();
}

::llvm::LogicalResult ShuffleVectorOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ShuffleVectorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand v1RawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> v1Operands(&v1RawOperand, 1);  ::llvm::SMLoc v1OperandsLoc;
  (void)v1OperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand v2RawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> v2Operands(&v2RawOperand, 1);  ::llvm::SMLoc v2OperandsLoc;
  (void)v2OperandsLoc;
  ::mlir::DenseI32ArrayAttr maskAttr;
  ::mlir::Type v1RawType{};
  ::llvm::ArrayRef<::mlir::Type> v1Types(&v1RawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  v1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(v1RawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  v2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(v2RawOperand))
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(maskAttr, ::mlir::Type{})) {
    return ::mlir::failure();
  }
  if (maskAttr) result.getOrAddProperties<ShuffleVectorOp::Properties>().mask = maskAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    v1RawType = type;
  }
  {
    auto odsResult = parseShuffleType(parser, v1RawType, resRawType, maskAttr);
    if (odsResult) return ::mlir::failure();
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(v1Operands, v1Types, v1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(v2Operands, v1Types[0], v2OperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ShuffleVectorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getV1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getV2();
  _odsPrinter << ' ';
_odsPrinter.printStrippedAttrOrType(getMaskAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("mask");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getV1().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ';
  printShuffleType(_odsPrinter, *this, getV1().getType(), getRes().getType(), getMaskAttr());
}

void ShuffleVectorOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ShuffleVectorOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::StoreOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
StoreOpGenericAdaptorBase::StoreOpGenericAdaptorBase(StoreOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::std::optional<uint64_t> StoreOpGenericAdaptorBase::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

::mlir::UnitAttr StoreOpGenericAdaptorBase::getVolatile_Attr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().volatile_);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool StoreOpGenericAdaptorBase::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr StoreOpGenericAdaptorBase::getNontemporalAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nontemporal);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool StoreOpGenericAdaptorBase::getNontemporal() {
  auto attr = getNontemporalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::LLVM::AtomicOrderingAttr StoreOpGenericAdaptorBase::getOrderingAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::LLVM::AtomicOrderingAttr>(getProperties().ordering);
  return attr;
}

::mlir::LLVM::AtomicOrdering StoreOpGenericAdaptorBase::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > StoreOpGenericAdaptorBase::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOpGenericAdaptorBase::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOpGenericAdaptorBase::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOpGenericAdaptorBase::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOpGenericAdaptorBase::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
StoreOpAdaptor::StoreOpAdaptor(StoreOp op) : StoreOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult StoreOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_nontemporal = getProperties().nontemporal; (void)tblgen_nontemporal;
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;

  if (tblgen_alignment && !(((::llvm::isa<::mlir::IntegerAttr>(tblgen_alignment))) && ((::llvm::cast<::mlir::IntegerAttr>(tblgen_alignment).getType().isSignlessInteger(64)))))
    return emitError(loc, "'llvm.store' op ""attribute 'alignment' failed to satisfy constraint: 64-bit signless integer attribute");

  if (tblgen_volatile_ && !((::llvm::isa<::mlir::UnitAttr>(tblgen_volatile_))))
    return emitError(loc, "'llvm.store' op ""attribute 'volatile_' failed to satisfy constraint: unit attribute");

  if (tblgen_nontemporal && !((::llvm::isa<::mlir::UnitAttr>(tblgen_nontemporal))))
    return emitError(loc, "'llvm.store' op ""attribute 'nontemporal' failed to satisfy constraint: unit attribute");

  if (tblgen_ordering && !((::llvm::isa<::mlir::LLVM::AtomicOrderingAttr>(tblgen_ordering))))
    return emitError(loc, "'llvm.store' op ""attribute 'ordering' failed to satisfy constraint: Atomic ordering for LLVM's memory model");

  if (tblgen_syncscope && !((::llvm::isa<::mlir::StringAttr>(tblgen_syncscope))))
    return emitError(loc, "'llvm.store' op ""attribute 'syncscope' failed to satisfy constraint: string attribute");

  if (tblgen_access_groups && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_access_groups))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_access_groups), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AccessGroupAttr>(attr))); }))))
    return emitError(loc, "'llvm.store' op ""attribute 'access_groups' failed to satisfy constraint: LLVM dialect access group metadata array");

  if (tblgen_alias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_alias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_alias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.store' op ""attribute 'alias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_noalias_scopes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_noalias_scopes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_noalias_scopes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::AliasScopeAttr>(attr))); }))))
    return emitError(loc, "'llvm.store' op ""attribute 'noalias_scopes' failed to satisfy constraint: LLVM dialect alias scope array");

  if (tblgen_tbaa && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_tbaa))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_tbaa), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::LLVM::TBAATagAttr>(attr))); }))))
    return emitError(loc, "'llvm.store' op ""attribute 'tbaa' failed to satisfy constraint: LLVM dialect TBAA tag metadata array");
  return ::mlir::success();
}

::llvm::LogicalResult StoreOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.access_groups;
       auto attr = dict.get("access_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `access_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alias_scopes;
       auto attr = dict.get("alias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.alignment;
       auto attr = dict.get("alignment");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `alignment` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.noalias_scopes;
       auto attr = dict.get("noalias_scopes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `noalias_scopes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.nontemporal;
       auto attr = dict.get("nontemporal");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `nontemporal` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.ordering;
       auto attr = dict.get("ordering");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `ordering` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.syncscope;
       auto attr = dict.get("syncscope");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `syncscope` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tbaa;
       auto attr = dict.get("tbaa");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tbaa` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.volatile_;
       auto attr = dict.get("volatile_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `volatile_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute StoreOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.access_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("access_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.alignment;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("alignment",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.noalias_scopes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("noalias_scopes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.nontemporal;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("nontemporal",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.ordering;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("ordering",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.syncscope;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("syncscope",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tbaa;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tbaa",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.volatile_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("volatile_",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code StoreOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.access_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.alias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.alignment.getAsOpaquePointer()), 
    llvm::hash_value(prop.noalias_scopes.getAsOpaquePointer()), 
    llvm::hash_value(prop.nontemporal.getAsOpaquePointer()), 
    llvm::hash_value(prop.ordering.getAsOpaquePointer()), 
    llvm::hash_value(prop.syncscope.getAsOpaquePointer()), 
    llvm::hash_value(prop.tbaa.getAsOpaquePointer()), 
    llvm::hash_value(prop.volatile_.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> StoreOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "access_groups")
      return prop.access_groups;

    if (name == "alias_scopes")
      return prop.alias_scopes;

    if (name == "alignment")
      return prop.alignment;

    if (name == "noalias_scopes")
      return prop.noalias_scopes;

    if (name == "nontemporal")
      return prop.nontemporal;

    if (name == "ordering")
      return prop.ordering;

    if (name == "syncscope")
      return prop.syncscope;

    if (name == "tbaa")
      return prop.tbaa;

    if (name == "volatile_")
      return prop.volatile_;
  return std::nullopt;
}

void StoreOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "access_groups") {
       prop.access_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.access_groups)>>(value);
       return;
    }

    if (name == "alias_scopes") {
       prop.alias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alias_scopes)>>(value);
       return;
    }

    if (name == "alignment") {
       prop.alignment = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.alignment)>>(value);
       return;
    }

    if (name == "noalias_scopes") {
       prop.noalias_scopes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.noalias_scopes)>>(value);
       return;
    }

    if (name == "nontemporal") {
       prop.nontemporal = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.nontemporal)>>(value);
       return;
    }

    if (name == "ordering") {
       prop.ordering = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.ordering)>>(value);
       return;
    }

    if (name == "syncscope") {
       prop.syncscope = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.syncscope)>>(value);
       return;
    }

    if (name == "tbaa") {
       prop.tbaa = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tbaa)>>(value);
       return;
    }

    if (name == "volatile_") {
       prop.volatile_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.volatile_)>>(value);
       return;
    }
}

void StoreOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.access_groups) attrs.append("access_groups", prop.access_groups);

    if (prop.alias_scopes) attrs.append("alias_scopes", prop.alias_scopes);

    if (prop.alignment) attrs.append("alignment", prop.alignment);

    if (prop.noalias_scopes) attrs.append("noalias_scopes", prop.noalias_scopes);

    if (prop.nontemporal) attrs.append("nontemporal", prop.nontemporal);

    if (prop.ordering) attrs.append("ordering", prop.ordering);

    if (prop.syncscope) attrs.append("syncscope", prop.syncscope);

    if (prop.tbaa) attrs.append("tbaa", prop.tbaa);

    if (prop.volatile_) attrs.append("volatile_", prop.volatile_);
}

::llvm::LogicalResult StoreOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAccessGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(attr, "access_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "alias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAlignmentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(attr, "alignment", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNoaliasScopesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(attr, "noalias_scopes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNontemporalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "nontemporal", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOrderingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(attr, "ordering", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSyncscopeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(attr, "syncscope", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTbaaAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(attr, "tbaa", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVolatile_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(attr, "volatile_", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult StoreOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.access_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.alignment)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.noalias_scopes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.nontemporal)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.ordering)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.syncscope)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tbaa)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.volatile_)))
    return ::mlir::failure();
  return ::mlir::success();
}

void StoreOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.access_groups);

  writer.writeOptionalAttribute(prop.alias_scopes);

  writer.writeOptionalAttribute(prop.alignment);

  writer.writeOptionalAttribute(prop.noalias_scopes);

  writer.writeOptionalAttribute(prop.nontemporal);

  writer.writeOptionalAttribute(prop.ordering);

  writer.writeOptionalAttribute(prop.syncscope);

  writer.writeOptionalAttribute(prop.tbaa);

  writer.writeOptionalAttribute(prop.volatile_);
}

::std::optional<uint64_t> StoreOp::getAlignment() {
  auto attr = getAlignmentAttr();
  return attr ? ::std::optional<uint64_t>(attr.getValue().getZExtValue()) : (::std::nullopt);
}

bool StoreOp::getVolatile_() {
  auto attr = getVolatile_Attr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool StoreOp::getNontemporal() {
  auto attr = getNontemporalAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::LLVM::AtomicOrdering StoreOp::getOrdering() {
  auto attr = getOrderingAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > StoreOp::getSyncscope() {
  auto attr = getSyncscopeAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOp::getAccessGroups() {
  auto attr = getAccessGroupsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOp::getAliasScopes() {
  auto attr = getAliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOp::getNoaliasScopes() {
  auto attr = getNoaliasScopesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > StoreOp::getTbaa() {
  auto attr = getTbaaAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void StoreOp::setAlignment(::std::optional<uint64_t> attrValue) {
    auto &odsProp = getProperties().alignment;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getIntegerAttr(::mlir::Builder((*this)->getContext()).getIntegerType(64), *attrValue);
    else
      odsProp = nullptr;
}

void StoreOp::setVolatile_(bool attrValue) {
    auto &odsProp = getProperties().volatile_;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void StoreOp::setNontemporal(bool attrValue) {
    auto &odsProp = getProperties().nontemporal;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void StoreOp::setOrdering(::mlir::LLVM::AtomicOrdering attrValue) {
  getProperties().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void StoreOp::setSyncscope(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().syncscope;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void StoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::UnitAttr nontemporal, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(value);
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = nontemporal;
  }
  if (ordering) {
    odsState.getOrAddProperties<Properties>().ordering = ordering;
  }
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
}

void StoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::UnitAttr volatile_, /*optional*/::mlir::UnitAttr nontemporal, ::mlir::LLVM::AtomicOrderingAttr ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(value);
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = volatile_;
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = nontemporal;
  }
  if (ordering) {
    odsState.getOrAddProperties<Properties>().ordering = ordering;
  }
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool volatile_, /*optional*/bool nontemporal, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(value);
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = ((nontemporal) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
}

void StoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value addr, /*optional*/::mlir::IntegerAttr alignment, /*optional*/bool volatile_, /*optional*/bool nontemporal, ::mlir::LLVM::AtomicOrdering ordering, /*optional*/::mlir::StringAttr syncscope, /*optional*/::mlir::ArrayAttr access_groups, /*optional*/::mlir::ArrayAttr alias_scopes, /*optional*/::mlir::ArrayAttr noalias_scopes, /*optional*/::mlir::ArrayAttr tbaa) {
  odsState.addOperands(value);
  odsState.addOperands(addr);
  if (alignment) {
    odsState.getOrAddProperties<Properties>().alignment = alignment;
  }
  if (volatile_) {
    odsState.getOrAddProperties<Properties>().volatile_ = ((volatile_) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (nontemporal) {
    odsState.getOrAddProperties<Properties>().nontemporal = ((nontemporal) ? odsBuilder.getUnitAttr() : nullptr);
  }
  odsState.getOrAddProperties<Properties>().ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), ordering);
  if (syncscope) {
    odsState.getOrAddProperties<Properties>().syncscope = syncscope;
  }
  if (access_groups) {
    odsState.getOrAddProperties<Properties>().access_groups = access_groups;
  }
  if (alias_scopes) {
    odsState.getOrAddProperties<Properties>().alias_scopes = alias_scopes;
  }
  if (noalias_scopes) {
    odsState.getOrAddProperties<Properties>().noalias_scopes = noalias_scopes;
  }
  if (tbaa) {
    odsState.getOrAddProperties<Properties>().tbaa = tbaa;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StoreOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<StoreOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void StoreOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.ordering)
    properties.ordering = ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), AtomicOrdering::not_atomic);
}

::llvm::LogicalResult StoreOp::verifyInvariantsImpl() {
  auto tblgen_access_groups = getProperties().access_groups; (void)tblgen_access_groups;
  auto tblgen_alias_scopes = getProperties().alias_scopes; (void)tblgen_alias_scopes;
  auto tblgen_alignment = getProperties().alignment; (void)tblgen_alignment;
  auto tblgen_noalias_scopes = getProperties().noalias_scopes; (void)tblgen_noalias_scopes;
  auto tblgen_nontemporal = getProperties().nontemporal; (void)tblgen_nontemporal;
  auto tblgen_ordering = getProperties().ordering; (void)tblgen_ordering;
  auto tblgen_syncscope = getProperties().syncscope; (void)tblgen_syncscope;
  auto tblgen_tbaa = getProperties().tbaa; (void)tblgen_tbaa;
  auto tblgen_volatile_ = getProperties().volatile_; (void)tblgen_volatile_;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps2(*this, tblgen_alignment, "alignment")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_volatile_, "volatile_")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps4(*this, tblgen_nontemporal, "nontemporal")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps5(*this, tblgen_ordering, "ordering")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps6(*this, tblgen_syncscope, "syncscope")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps7(*this, tblgen_access_groups, "access_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_alias_scopes, "alias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps8(*this, tblgen_noalias_scopes, "noalias_scopes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps9(*this, tblgen_tbaa, "tbaa")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps19(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult StoreOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult StoreOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand valueRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valueOperands(&valueRawOperand, 1);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand addrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> addrOperands(&addrRawOperand, 1);  ::llvm::SMLoc addrOperandsLoc;
  (void)addrOperandsLoc;
  ::mlir::StringAttr syncscopeAttr;
  ::mlir::LLVM::AtomicOrderingAttr orderingAttr;
  ::mlir::Type valueRawType{};
  ::llvm::ArrayRef<::mlir::Type> valueTypes(&valueRawType, 1);
  ::mlir::Type addrRawType{};
  ::llvm::ArrayRef<::mlir::Type> addrTypes(&addrRawType, 1);
  if (::mlir::succeeded(parser.parseOptionalKeyword("volatile"))) {
    result.getOrAddProperties<StoreOp::Properties>().volatile_ = parser.getBuilder().getUnitAttr();  }

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  addrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(addrRawOperand))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("atomic"))) {
  if (::mlir::succeeded(parser.parseOptionalKeyword("syncscope"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(syncscopeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (syncscopeAttr) result.getOrAddProperties<StoreOp::Properties>().syncscope = syncscopeAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  }

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"not_atomic","unordered","monotonic","acquire","release","acq_rel","seq_cst"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "ordering", attrStorage);
      if (parseResult.has_value()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'ordering' [not_atomic, unordered, monotonic, acquire, release, acq_rel, seq_cst]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::LLVM::symbolizeAtomicOrdering(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "ordering attribute specification: \"" << attrStr << '"';;

      orderingAttr = ::mlir::LLVM::AtomicOrderingAttr::get(parser.getBuilder().getContext(), *attrOptional);
        result.getOrAddProperties<StoreOp::Properties>().ordering = orderingAttr;
    }
  }
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valueRawType = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(addrRawType))
    return ::mlir::failure();
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(addrOperands, addrTypes, addrOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void StoreOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getVolatile_Attr() && getVolatile_Attr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "volatile";
  }
  _odsPrinter << ' ';
  _odsPrinter << getValue();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getAddr();
  if (getOrderingAttr() != ::mlir::LLVM::AtomicOrderingAttr::get(::mlir::OpBuilder((*this)->getContext()).getContext(), AtomicOrdering::not_atomic)) {
    _odsPrinter << ' ' << "atomic";
    if (getSyncscopeAttr()) {
      _odsPrinter << ' ' << "syncscope";
      _odsPrinter << "(";
      _odsPrinter.printAttributeWithoutType(getSyncscopeAttr());
      _odsPrinter << ")";
    }
    _odsPrinter << ' ';

    {
      auto caseValue = getOrdering();
      auto caseValueStr = stringifyAtomicOrdering(caseValue);
      _odsPrinter << caseValueStr;
    }
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("volatile_");
  elidedAttrs.push_back("syncscope");
  elidedAttrs.push_back("ordering");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getVolatile_Attr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("volatile_");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getNontemporalAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("nontemporal");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getOrderingAttr();
     if(attr && (attr == ::mlir::LLVM::AtomicOrderingAttr::get(odsBuilder.getContext(), AtomicOrdering::not_atomic)))
       elidedAttrs.push_back("ordering");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getValue().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
   _odsPrinter << getAddr().getType();
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::StoreOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::SubOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
SubOpGenericAdaptorBase::SubOpGenericAdaptorBase(SubOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

} // namespace detail
SubOpAdaptor::SubOpAdaptor(SubOp op) : SubOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SubOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::LogicalResult SubOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }
    {

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("overflowFlags");;
;
      if (attr) {
        if (::mlir::failed(setFromAttr(prop.overflowFlags, attr, emitError)))
          return ::mlir::failure();
      } else {
        prop.overflowFlags = IntegerOverflowFlags::none;
      }
  }
  return ::mlir::success();
}

::mlir::Attribute SubOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.overflowFlags;
      auto attr = [&]() -> ::mlir::Attribute {
        return convertToAttribute(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("overflowFlags", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SubOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    ::llvm::hash_value(prop.overflowFlags));
}

std::optional<mlir::Attribute> SubOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
  return std::nullopt;
}

void SubOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
}

void SubOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
}

::llvm::LogicalResult SubOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    return ::mlir::success();
}

::llvm::LogicalResult SubOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  {
    auto &propStorage = prop.overflowFlags;
    auto readProp = [&]() {
      uint64_t val;
    if (failed(reader.readVarInt(val)))
      return ::mlir::failure();
    propStorage = static_cast<IntegerOverflowFlags>(val);;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void SubOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  {
    auto &propStorage = prop.overflowFlags;
    writer.writeVarInt(static_cast<uint64_t>(propStorage));;
  }
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  odsState.addTypes(res);
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(SubOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/IntegerOverflowFlags overflowFlags) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().setOverflowFlags(overflowFlags);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SubOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SubOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(SubOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult SubOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SubOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult SubOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult SubOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseOverflowFlags(parser, result.getOrAddProperties<Properties>().overflowFlags);
    if (odsResult) return ::mlir::failure();
  }
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SubOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  printOverflowFlags(_odsPrinter, *this, getProperties().overflowFlags);
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SubOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::SubOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::SwitchOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
SwitchOpGenericAdaptorBase::SwitchOpGenericAdaptorBase(SwitchOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> SwitchOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::DenseIntElementsAttr > SwitchOpGenericAdaptorBase::getCaseValues() {
  auto attr = getCaseValuesAttr();
  return attr ? ::std::optional< ::mlir::DenseIntElementsAttr >(attr) : (::std::nullopt);
}

::llvm::ArrayRef<int32_t> SwitchOpGenericAdaptorBase::getCaseOperandSegments() {
  auto attr = getCaseOperandSegmentsAttr();
  return attr;
}

::std::optional<::llvm::ArrayRef<int32_t>> SwitchOpGenericAdaptorBase::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

} // namespace detail
SwitchOpAdaptor::SwitchOpAdaptor(SwitchOp op) : SwitchOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SwitchOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_case_operand_segments = getProperties().case_operand_segments; (void)tblgen_case_operand_segments;
  if (!tblgen_case_operand_segments) return emitError(loc, "'llvm.switch' op ""requires attribute 'case_operand_segments'");
  auto tblgen_case_values = getProperties().case_values; (void)tblgen_case_values;

  if (tblgen_case_values && !(((::llvm::isa<::mlir::DenseIntElementsAttr>(tblgen_case_values))) && ((true))))
    return emitError(loc, "'llvm.switch' op ""attribute 'case_values' failed to satisfy constraint: integer elements attribute");

  if (tblgen_case_operand_segments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_case_operand_segments))))
    return emitError(loc, "'llvm.switch' op ""attribute 'case_operand_segments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_branch_weights && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_branch_weights))))
    return emitError(loc, "'llvm.switch' op ""attribute 'branch_weights' failed to satisfy constraint: i32 dense array attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SwitchOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange SwitchOp::getDefaultOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRangeRange SwitchOp::getCaseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange.split(*(*this)->getAttrDictionary().getNamed(getCaseOperandSegmentsAttrName()));
}

::llvm::LogicalResult SwitchOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.branch_weights;
       auto attr = dict.get("branch_weights");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `branch_weights` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.case_operand_segments;
       auto attr = dict.get("case_operand_segments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `case_operand_segments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.case_values;
       auto attr = dict.get("case_values");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `case_values` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute SwitchOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.branch_weights;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("branch_weights",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.case_operand_segments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("case_operand_segments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.case_values;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("case_values",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SwitchOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.branch_weights.getAsOpaquePointer()), 
    llvm::hash_value(prop.case_operand_segments.getAsOpaquePointer()), 
    llvm::hash_value(prop.case_values.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> SwitchOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "branch_weights")
      return prop.branch_weights;

    if (name == "case_operand_segments")
      return prop.case_operand_segments;

    if (name == "case_values")
      return prop.case_values;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void SwitchOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "branch_weights") {
       prop.branch_weights = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.branch_weights)>>(value);
       return;
    }

    if (name == "case_operand_segments") {
       prop.case_operand_segments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.case_operand_segments)>>(value);
       return;
    }

    if (name == "case_values") {
       prop.case_values = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.case_values)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void SwitchOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.branch_weights) attrs.append("branch_weights", prop.branch_weights);

    if (prop.case_operand_segments) attrs.append("case_operand_segments", prop.case_operand_segments);

    if (prop.case_values) attrs.append("case_values", prop.case_values);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult SwitchOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBranchWeightsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "branch_weights", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCaseOperandSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(attr, "case_operand_segments", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCaseValuesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps41(attr, "case_values", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SwitchOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.branch_weights)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.case_operand_segments)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.case_values)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void SwitchOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.branch_weights);
  writer.writeAttribute(prop.case_operand_segments);

  writer.writeOptionalAttribute(prop.case_values);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::DenseIntElementsAttr > SwitchOp::getCaseValues() {
  auto attr = getCaseValuesAttr();
  return attr ? ::std::optional< ::mlir::DenseIntElementsAttr >(attr) : (::std::nullopt);
}

::llvm::ArrayRef<int32_t> SwitchOp::getCaseOperandSegments() {
  auto attr = getCaseOperandSegmentsAttr();
  return attr;
}

::std::optional<::llvm::ArrayRef<int32_t>> SwitchOp::getBranchWeights() {
  auto attr = getBranchWeightsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

void SwitchOp::setCaseOperandSegments(::llvm::ArrayRef<int32_t> attrValue) {
  getProperties().case_operand_segments = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(attrValue);
}

void SwitchOp::setBranchWeights(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().branch_weights;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void SwitchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange operands, SuccessorRange destinations, ArrayRef<NamedAttribute> attributes) {
    odsState.addOperands(operands);
    odsState.addSuccessors(destinations);
    odsState.addAttributes(attributes);
  
}

void SwitchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::ValueRange defaultOperands, ::llvm::ArrayRef<::mlir::ValueRange> caseOperands, /*optional*/::mlir::DenseIntElementsAttr case_values, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::Block *defaultDestination, ::mlir::BlockRange caseDestinations) {
  odsState.addOperands(value);
  odsState.addOperands(defaultOperands);
  for (::mlir::ValueRange range : caseOperands)
   odsState.addOperands(range);
  {
    ::llvm::SmallVector<int32_t> rangeSegments;
    for (::mlir::ValueRange range : caseOperands)
      rangeSegments.push_back(range.size());
    auto rangeAttr = odsBuilder.getDenseI32ArrayAttr(rangeSegments);
    odsState.getOrAddProperties<Properties>().case_operand_segments = rangeAttr;  }
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(defaultOperands.size()), static_cast<int32_t>(std::accumulate(caseOperands.begin(), caseOperands.end(), 0, [](int32_t curSum, ::mlir::ValueRange range) { return curSum + static_cast<int32_t>(range.size()); }))}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (case_values) {
    odsState.getOrAddProperties<Properties>().case_values = case_values;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  odsState.addSuccessors(defaultDestination);
  odsState.addSuccessors(caseDestinations);
}

void SwitchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::ValueRange defaultOperands, ::llvm::ArrayRef<::mlir::ValueRange> caseOperands, /*optional*/::mlir::DenseIntElementsAttr case_values, /*optional*/::mlir::DenseI32ArrayAttr branch_weights, ::mlir::Block *defaultDestination, ::mlir::BlockRange caseDestinations) {
  odsState.addOperands(value);
  odsState.addOperands(defaultOperands);
  for (::mlir::ValueRange range : caseOperands)
   odsState.addOperands(range);
  {
    ::llvm::SmallVector<int32_t> rangeSegments;
    for (::mlir::ValueRange range : caseOperands)
      rangeSegments.push_back(range.size());
    auto rangeAttr = odsBuilder.getDenseI32ArrayAttr(rangeSegments);
    odsState.getOrAddProperties<Properties>().case_operand_segments = rangeAttr;  }
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(defaultOperands.size()), static_cast<int32_t>(std::accumulate(caseOperands.begin(), caseOperands.end(), 0, [](int32_t curSum, ::mlir::ValueRange range) { return curSum + static_cast<int32_t>(range.size()); }))}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (case_values) {
    odsState.getOrAddProperties<Properties>().case_values = case_values;
  }
  if (branch_weights) {
    odsState.getOrAddProperties<Properties>().branch_weights = branch_weights;
  }
  odsState.addSuccessors(defaultDestination);
  odsState.addSuccessors(caseDestinations);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SwitchOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SwitchOp::verifyInvariantsImpl() {
  auto tblgen_branch_weights = getProperties().branch_weights; (void)tblgen_branch_weights;
  auto tblgen_case_operand_segments = getProperties().case_operand_segments; (void)tblgen_case_operand_segments;
  if (!tblgen_case_operand_segments) return emitOpError("requires attribute 'case_operand_segments'");
  auto tblgen_case_values = getProperties().case_values; (void)tblgen_case_values;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps41(*this, tblgen_case_values, "case_values")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_case_operand_segments, "case_operand_segments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_LLVMOps14(*this, tblgen_branch_weights, "branch_weights")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps21(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);
    if (::mlir::failed(::mlir::OpTrait::impl::verifyValueSizeAttr(*this, "case_operand_segments", "caseOperands", valueGroup2.size())))
      return ::mlir::failure();

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps21(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::llvm::LogicalResult SwitchOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult SwitchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand valueRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> valueOperands(&valueRawOperand, 1);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::Type valueRawType{};
  ::llvm::ArrayRef<::mlir::Type> valueTypes(&valueRawType, 1);
  ::mlir::Block *defaultDestinationSuccessor = nullptr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> defaultOperandsOperands;
  ::llvm::SMLoc defaultOperandsOperandsLoc;
  (void)defaultOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> defaultOperandsTypes;
  ::mlir::DenseIntElementsAttr case_valuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> caseDestinationsSuccessors;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> caseOperandsOperands;
    llvm::SmallVector<int32_t> caseOperandsOperandGroupSizes;
  ::llvm::SMLoc caseOperandsOperandsLoc;
  (void)caseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> caseOperandsTypes;

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valueRawType = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseSuccessor(defaultDestinationSuccessor))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalLParen())) {

  defaultOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(defaultOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(defaultOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  {
    caseOperandsOperandsLoc = parser.getCurrentLocation();
    ::llvm::SmallVector<::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand>> caseOperandsOperandGroups;
    ::llvm::SmallVector<llvm::SmallVector<::mlir::Type>> caseOperandsTypeGroups;
    auto odsResult = parseSwitchOpCases(parser, valueRawType, case_valuesAttr, caseDestinationsSuccessors, caseOperandsOperandGroups, caseOperandsTypeGroups);
    if (odsResult) return ::mlir::failure();
    if (case_valuesAttr)
      result.getOrAddProperties<SwitchOp::Properties>().case_values = case_valuesAttr;
    for (const auto &subRange : caseOperandsOperandGroups) {
      caseOperandsOperands.append(subRange.begin(), subRange.end());
      caseOperandsOperandGroupSizes.push_back(subRange.size());
    }
    for (const auto &subRange : caseOperandsTypeGroups)
      caseOperandsTypes.append(subRange.begin(), subRange.end());
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addSuccessors(defaultDestinationSuccessor);
  result.addSuccessors(caseDestinationsSuccessors);
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(defaultOperandsOperands.size()), static_cast<int32_t>(caseOperandsOperands.size())}), result.getOrAddProperties<SwitchOp::Properties>().operandSegmentSizes.begin());
  result.getOrAddProperties<SwitchOp::Properties>().case_operand_segments = parser.getBuilder().getDenseI32ArrayAttr(caseOperandsOperandGroupSizes);
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(defaultOperandsOperands, defaultOperandsTypes, defaultOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(caseOperandsOperands, caseOperandsTypes, caseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SwitchOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getValue();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getValue().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::IntegerType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getDefaultDestination();
  if (!getDefaultOperands().empty()) {
    _odsPrinter << "(";
    _odsPrinter << getDefaultOperands();
    _odsPrinter << ' ' << ":";
    _odsPrinter << ' ';
    _odsPrinter << getDefaultOperands().getTypes();
    _odsPrinter << ")";
  }
  _odsPrinter << ' ';
  printSwitchOpCases(_odsPrinter, *this, getValue().getType(), getCaseValuesAttr(), getCaseDestinations(), getCaseOperands(), getCaseOperands().getTypes());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("case_operand_segments");
  elidedAttrs.push_back("case_values");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void SwitchOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::SwitchOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::TruncOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
TruncOpAdaptor::TruncOpAdaptor(TruncOp op) : TruncOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TruncOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void TruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void TruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void TruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TruncOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult TruncOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult TruncOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult TruncOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void TruncOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void TruncOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::TruncOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::UDivOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
UDivOpAdaptor::UDivOpAdaptor(UDivOp op) : UDivOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(UDivOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(UDivOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult UDivOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UDivOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult UDivOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult UDivOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UDivOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void UDivOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::UDivOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::UIToFPOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
UIToFPOpAdaptor::UIToFPOpAdaptor(UIToFPOp op) : UIToFPOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UIToFPOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void UIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void UIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void UIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UIToFPOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult UIToFPOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UIToFPOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UIToFPOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UIToFPOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void UIToFPOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::UIToFPOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::URemOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
URemOpAdaptor::URemOpAdaptor(URemOp op) : URemOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult URemOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void URemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void URemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void URemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(URemOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void URemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void URemOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void URemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(URemOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult URemOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult URemOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult URemOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult URemOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void URemOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void URemOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::URemOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::UndefOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
UndefOpAdaptor::UndefOpAdaptor(UndefOp op) : UndefOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UndefOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void UndefOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void UndefOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res) {
  odsState.addTypes(res);
}

void UndefOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UndefOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult UndefOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UndefOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UndefOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  return ::mlir::success();
}

void UndefOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void UndefOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::UndefOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::UnreachableOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
UnreachableOpAdaptor::UnreachableOpAdaptor(UnreachableOp op) : UnreachableOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UnreachableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void UnreachableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
}

void UnreachableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnreachableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult UnreachableOp::verifyInvariantsImpl() {
  return ::mlir::success();
}

::llvm::LogicalResult UnreachableOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UnreachableOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void UnreachableOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::UnreachableOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::VaArgOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
VaArgOpAdaptor::VaArgOpAdaptor(VaArgOp op) : VaArgOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult VaArgOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void VaArgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void VaArgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void VaArgOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VaArgOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult VaArgOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult VaArgOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult VaArgOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::llvm::ArrayRef<::mlir::Type> argTypes;
  ::llvm::ArrayRef<::mlir::Type> resTypes;

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  ::mlir::FunctionType arg__res_functionType;
  if (parser.parseType(arg__res_functionType))
    return ::mlir::failure();
  argTypes = arg__res_functionType.getInputs();
  resTypes = arg__res_functionType.getResults();
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void VaArgOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printFunctionalType(::llvm::ArrayRef<::mlir::Type>(getArg().getType()), ::llvm::ArrayRef<::mlir::Type>(getRes().getType()));
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::VaArgOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::XOrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
XOrOpAdaptor::XOrOpAdaptor(XOrOp op) : XOrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult XOrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(res);
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(XOrOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      odsState.getRawProperties(),
                      odsState.regions, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(XOrOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.getRawProperties(),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::llvm::LogicalResult XOrOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult XOrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::llvm::LogicalResult XOrOp::inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  ::mlir::Type odsInferredType0 = operands[0].getType();
  inferredReturnTypes[0] = odsInferredType0;
  return ::mlir::success();
}

::mlir::ParseResult XOrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand lhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> lhsOperands(&lhsRawOperand, 1);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand rhsRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> rhsOperands(&rhsRawOperand, 1);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperand))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperand))
    return ::mlir::failure();
  {
    auto odsResult = parseLLVMOpAttrs(parser, result.attributes);
    if (odsResult) return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(lhsOperands, resTypes[0], lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resTypes[0], rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void XOrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getLhs();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << getRhs();
  _odsPrinter << ' ';
  printLLVMOpAttrs(_odsPrinter, *this, getOperation()->getAttrDictionary());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void XOrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::XOrOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ZExtOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ZExtOpAdaptor::ZExtOpAdaptor(ZExtOp op) : ZExtOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ZExtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ZExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void ZExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(res);
}

void ZExtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ZExtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ZExtOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ZExtOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ZExtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand argRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> argOperands(&argRawOperand, 1);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawType{};
  ::llvm::ArrayRef<::mlir::Type> argTypes(&argRawType, 1);
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperand))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    argRawType = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ZExtOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getArg();
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getArg().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ZExtOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ZExtOp)

namespace mlir {
namespace LLVM {

//===----------------------------------------------------------------------===//
// ::mlir::LLVM::ZeroOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ZeroOpAdaptor::ZeroOpAdaptor(ZeroOp op) : ZeroOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ZeroOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ZeroOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, ValueRange operands, ArrayRef<NamedAttribute> attributes) {
    if (resultType) odsState.addTypes(resultType);
    odsState.addOperands(operands);
    for (auto namedAttr : attributes)
      odsState.addAttribute(namedAttr.getName(), namedAttr.getValue());
  
}

void ZeroOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res) {
  odsState.addTypes(res);
}

void ZeroOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ZeroOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ZeroOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LLVMOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ZeroOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ZeroOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Type resRawType{};
  ::llvm::ArrayRef<::mlir::Type> resTypes(&resRawType, 1);
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resRawType = type;
  }
  result.addTypes(resTypes);
  return ::mlir::success();
}

void ZeroOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getRes().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ZeroOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace LLVM
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::LLVM::ZeroOp)


#endif  // GET_OP_CLASSES

