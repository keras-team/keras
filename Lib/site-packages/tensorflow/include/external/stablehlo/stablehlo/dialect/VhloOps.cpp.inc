/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: VhloOps.td                                                           *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::vhlo::AbsOpV1,
::mlir::vhlo::AddOpV1,
::mlir::vhlo::AfterAllOpV1,
::mlir::vhlo::AllGatherOpV1,
::mlir::vhlo::AllGatherOpV2,
::mlir::vhlo::AllReduceOpV1,
::mlir::vhlo::AllReduceOpV2,
::mlir::vhlo::AllToAllOpV1,
::mlir::vhlo::AllToAllOpV2,
::mlir::vhlo::AndOpV1,
::mlir::vhlo::Atan2OpV1,
::mlir::vhlo::BatchNormGradOpV1,
::mlir::vhlo::BatchNormInferenceOpV1,
::mlir::vhlo::BatchNormTrainingOpV1,
::mlir::vhlo::BitcastConvertOpV1,
::mlir::vhlo::BroadcastInDimOpV1,
::mlir::vhlo::BroadcastOpV1,
::mlir::vhlo::CallOpV1,
::mlir::vhlo::CaseOpV1,
::mlir::vhlo::CbrtOpV1,
::mlir::vhlo::CeilOpV1,
::mlir::vhlo::CholeskyOpV1,
::mlir::vhlo::ClampOpV1,
::mlir::vhlo::ClzOpV1,
::mlir::vhlo::CollectiveBroadcastOpV1,
::mlir::vhlo::CollectivePermuteOpV1,
::mlir::vhlo::CompareOpV1,
::mlir::vhlo::ComplexOpV1,
::mlir::vhlo::CompositeOpV1,
::mlir::vhlo::ConcatenateOpV1,
::mlir::vhlo::ConstantOpV1,
::mlir::vhlo::ConvertOpV1,
::mlir::vhlo::ConvolutionOpV1,
::mlir::vhlo::CosineOpV1,
::mlir::vhlo::CreateTokenOpV1,
::mlir::vhlo::CrossReplicaSumOpV1,
::mlir::vhlo::CustomCallOpV1,
::mlir::vhlo::DivOpV1,
::mlir::vhlo::DotGeneralOpV1,
::mlir::vhlo::DotGeneralOpV2,
::mlir::vhlo::DotOpV1,
::mlir::vhlo::DynamicBroadcastInDimOpV1,
::mlir::vhlo::DynamicConvOpV1,
::mlir::vhlo::DynamicConvOpV2,
::mlir::vhlo::DynamicGatherOpV1,
::mlir::vhlo::DynamicGatherOpV2,
::mlir::vhlo::DynamicIotaOpV1,
::mlir::vhlo::DynamicPadOpV1,
::mlir::vhlo::DynamicReshapeOpV1,
::mlir::vhlo::DynamicSliceOpV1,
::mlir::vhlo::DynamicUpdateSliceOpV1,
::mlir::vhlo::EinsumOpV1,
::mlir::vhlo::ExpOpV1,
::mlir::vhlo::Expm1OpV1,
::mlir::vhlo::FftOpV1,
::mlir::vhlo::FloorOpV1,
::mlir::vhlo::FuncOpV1,
::mlir::vhlo::GatherOpV1,
::mlir::vhlo::GatherOpV2,
::mlir::vhlo::GetDimensionSizeOpV1,
::mlir::vhlo::GetTupleElementOpV1,
::mlir::vhlo::IfOpV1,
::mlir::vhlo::ImagOpV1,
::mlir::vhlo::InfeedOpV1,
::mlir::vhlo::IotaOpV1,
::mlir::vhlo::IsFiniteOpV1,
::mlir::vhlo::Log1pOpV1,
::mlir::vhlo::LogOpV1,
::mlir::vhlo::LogisticOpV1,
::mlir::vhlo::MapOpV1,
::mlir::vhlo::MaxOpV1,
::mlir::vhlo::MinOpV1,
::mlir::vhlo::MulOpV1,
::mlir::vhlo::NegOpV1,
::mlir::vhlo::NotOpV1,
::mlir::vhlo::OptimizationBarrierOpV1,
::mlir::vhlo::OrOpV1,
::mlir::vhlo::OutfeedOpV1,
::mlir::vhlo::PadOpV1,
::mlir::vhlo::PartitionIdOpV1,
::mlir::vhlo::PopulationCountOpV1,
::mlir::vhlo::PowOpV1,
::mlir::vhlo::RealDynamicSliceOpV1,
::mlir::vhlo::RealOpV1,
::mlir::vhlo::RecvOpV1,
::mlir::vhlo::ReduceOpV1,
::mlir::vhlo::ReducePrecisionOpV1,
::mlir::vhlo::ReduceScatterOpV1,
::mlir::vhlo::ReduceWindowOpV1,
::mlir::vhlo::RemOpV1,
::mlir::vhlo::ReplicaIdOpV1,
::mlir::vhlo::ReshapeOpV1,
::mlir::vhlo::ReturnOpV1,
::mlir::vhlo::ReverseOpV1,
::mlir::vhlo::RngBitGeneratorOpV1,
::mlir::vhlo::RngOpV1,
::mlir::vhlo::RoundNearestEvenOpV1,
::mlir::vhlo::RoundOpV1,
::mlir::vhlo::RsqrtOpV1,
::mlir::vhlo::ScatterOpV1,
::mlir::vhlo::ScatterOpV2,
::mlir::vhlo::SelectAndScatterOpV1,
::mlir::vhlo::SelectOpV1,
::mlir::vhlo::SendOpV1,
::mlir::vhlo::SetDimensionSizeOpV1,
::mlir::vhlo::ShiftLeftOpV1,
::mlir::vhlo::ShiftRightArithmeticOpV1,
::mlir::vhlo::ShiftRightLogicalOpV1,
::mlir::vhlo::SignOpV1,
::mlir::vhlo::SineOpV1,
::mlir::vhlo::SliceOpV1,
::mlir::vhlo::SortOpV1,
::mlir::vhlo::SqrtOpV1,
::mlir::vhlo::SubtractOpV1,
::mlir::vhlo::TanOpV1,
::mlir::vhlo::TanhOpV1,
::mlir::vhlo::TorchIndexSelectOpV1,
::mlir::vhlo::TransposeOpV1,
::mlir::vhlo::TriangularSolveOpV1,
::mlir::vhlo::TupleOpV1,
::mlir::vhlo::UnaryEinsumOpV1,
::mlir::vhlo::UniformDequantizeOpV1,
::mlir::vhlo::UniformQuantizeOpV1,
::mlir::vhlo::WhileOpV1,
::mlir::vhlo::XorOpV1
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace vhlo {

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_VhloOps1(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_VhloOps2(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of any type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_VhloOps1(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((true)))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: any attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_VhloOps1(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_VhloOps1(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_region_constraint_VhloOps1(
    ::mlir::Operation *op, ::mlir::Region &region, ::llvm::StringRef regionName,
    unsigned regionIndex) {
  if (!((true))) {
    return op->emitOpError("region #") << regionIndex
        << (regionName.empty() ? " " : " ('" + regionName + "') ")
        << "failed to verify constraint: any region";
  }
  return ::mlir::success();
}
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AbsOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AbsOpV1Adaptor::AbsOpV1Adaptor(AbsOpV1 op) : AbsOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AbsOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AbsOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void AbsOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AbsOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AbsOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AbsOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AbsOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version AbsOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AbsOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AddOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AddOpV1Adaptor::AddOpV1Adaptor(AddOpV1 op) : AddOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AddOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AddOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void AddOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AddOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AddOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AddOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version AddOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AddOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AfterAllOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> AfterAllOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
AfterAllOpV1Adaptor::AfterAllOpV1Adaptor(AfterAllOpV1 op) : AfterAllOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AfterAllOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AfterAllOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange AfterAllOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void AfterAllOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs) {
  odsState.addOperands(inputs);
  odsState.addTypes(result);
}

void AfterAllOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AfterAllOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AfterAllOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AfterAllOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version AfterAllOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AfterAllOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllGatherOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
AllGatherOpV1GenericAdaptorBase::AllGatherOpV1GenericAdaptorBase(AllGatherOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute AllGatherOpV1GenericAdaptorBase::getAllGatherDim() {
  auto attr = getAllGatherDimAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV1GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV1GenericAdaptorBase::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

} // namespace detail
AllGatherOpV1Adaptor::AllGatherOpV1Adaptor(AllGatherOpV1 op) : AllGatherOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AllGatherOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_all_gather_dim = getProperties().all_gather_dim; (void)tblgen_all_gather_dim;
  if (!tblgen_all_gather_dim) return emitError(loc, "'vhlo.all_gather_v1' op ""requires attribute 'all_gather_dim'");
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.all_gather_v1' op ""requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.all_gather_v1' op ""requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitError(loc, "'vhlo.all_gather_v1' op ""requires attribute 'use_global_device_ids'");

  if (tblgen_all_gather_dim && !((true)))
    return emitError(loc, "'vhlo.all_gather_v1' op ""attribute 'all_gather_dim' failed to satisfy constraint: any attribute");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.all_gather_v1' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.all_gather_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");

  if (tblgen_use_global_device_ids && !((true)))
    return emitError(loc, "'vhlo.all_gather_v1' op ""attribute 'use_global_device_ids' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult AllGatherOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.all_gather_dim;
       auto attr = dict.get("all_gather_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `all_gather_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.use_global_device_ids;
       auto attr = dict.get("use_global_device_ids");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `use_global_device_ids` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AllGatherOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.all_gather_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("all_gather_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.use_global_device_ids;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("use_global_device_ids",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AllGatherOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.all_gather_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.use_global_device_ids.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AllGatherOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "all_gather_dim")
      return prop.all_gather_dim;

    if (name == "channel_id")
      return prop.channel_id;

    if (name == "replica_groups")
      return prop.replica_groups;

    if (name == "use_global_device_ids")
      return prop.use_global_device_ids;
  return std::nullopt;
}

void AllGatherOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "all_gather_dim") {
       prop.all_gather_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.all_gather_dim)>>(value);
       return;
    }

    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }

    if (name == "use_global_device_ids") {
       prop.use_global_device_ids = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.use_global_device_ids)>>(value);
       return;
    }
}

void AllGatherOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.all_gather_dim) attrs.append("all_gather_dim", prop.all_gather_dim);

    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);

    if (prop.use_global_device_ids) attrs.append("use_global_device_ids", prop.use_global_device_ids);
}

::llvm::LogicalResult AllGatherOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAllGatherDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "all_gather_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUseGlobalDeviceIdsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "use_global_device_ids", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AllGatherOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.all_gather_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.use_global_device_ids)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AllGatherOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.all_gather_dim);
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.replica_groups);
  writer.writeAttribute(prop.use_global_device_ids);
}

::mlir::Attribute AllGatherOpV1::getAllGatherDim() {
  auto attr = getAllGatherDimAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV1::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV1::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

void AllGatherOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().all_gather_dim = all_gather_dim;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  odsState.addTypes(result);
}

void AllGatherOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().all_gather_dim = all_gather_dim;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllGatherOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AllGatherOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AllGatherOpV1::verifyInvariantsImpl() {
  auto tblgen_all_gather_dim = getProperties().all_gather_dim; (void)tblgen_all_gather_dim;
  if (!tblgen_all_gather_dim) return emitOpError("requires attribute 'all_gather_dim'");
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitOpError("requires attribute 'use_global_device_ids'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_all_gather_dim, "all_gather_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_use_global_device_ids, "use_global_device_ids")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AllGatherOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AllGatherOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version AllGatherOpV1::getMaxVersion() {
   return mlir::vhlo::Version(1, 4, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllGatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllGatherOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
AllGatherOpV2GenericAdaptorBase::AllGatherOpV2GenericAdaptorBase(AllGatherOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> AllGatherOpV2GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute AllGatherOpV2GenericAdaptorBase::getAllGatherDim() {
  auto attr = getAllGatherDimAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV2GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV2GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV2GenericAdaptorBase::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

} // namespace detail
AllGatherOpV2Adaptor::AllGatherOpV2Adaptor(AllGatherOpV2 op) : AllGatherOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AllGatherOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_all_gather_dim = getProperties().all_gather_dim; (void)tblgen_all_gather_dim;
  if (!tblgen_all_gather_dim) return emitError(loc, "'vhlo.all_gather_v2' op ""requires attribute 'all_gather_dim'");
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.all_gather_v2' op ""requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.all_gather_v2' op ""requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitError(loc, "'vhlo.all_gather_v2' op ""requires attribute 'use_global_device_ids'");

  if (tblgen_all_gather_dim && !((true)))
    return emitError(loc, "'vhlo.all_gather_v2' op ""attribute 'all_gather_dim' failed to satisfy constraint: any attribute");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.all_gather_v2' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.all_gather_v2' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");

  if (tblgen_use_global_device_ids && !((true)))
    return emitError(loc, "'vhlo.all_gather_v2' op ""attribute 'use_global_device_ids' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AllGatherOpV2::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange AllGatherOpV2::getOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AllGatherOpV2::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult AllGatherOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.all_gather_dim;
       auto attr = dict.get("all_gather_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `all_gather_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.use_global_device_ids;
       auto attr = dict.get("use_global_device_ids");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `use_global_device_ids` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AllGatherOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.all_gather_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("all_gather_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.use_global_device_ids;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("use_global_device_ids",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AllGatherOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.all_gather_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.use_global_device_ids.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AllGatherOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "all_gather_dim")
      return prop.all_gather_dim;

    if (name == "channel_id")
      return prop.channel_id;

    if (name == "replica_groups")
      return prop.replica_groups;

    if (name == "use_global_device_ids")
      return prop.use_global_device_ids;
  return std::nullopt;
}

void AllGatherOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "all_gather_dim") {
       prop.all_gather_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.all_gather_dim)>>(value);
       return;
    }

    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }

    if (name == "use_global_device_ids") {
       prop.use_global_device_ids = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.use_global_device_ids)>>(value);
       return;
    }
}

void AllGatherOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.all_gather_dim) attrs.append("all_gather_dim", prop.all_gather_dim);

    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);

    if (prop.use_global_device_ids) attrs.append("use_global_device_ids", prop.use_global_device_ids);
}

::llvm::LogicalResult AllGatherOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAllGatherDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "all_gather_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUseGlobalDeviceIdsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "use_global_device_ids", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AllGatherOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.all_gather_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.use_global_device_ids)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AllGatherOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.all_gather_dim);
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.replica_groups);
  writer.writeAttribute(prop.use_global_device_ids);
}

::mlir::Attribute AllGatherOpV2::getAllGatherDim() {
  auto attr = getAllGatherDimAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV2::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV2::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllGatherOpV2::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

void AllGatherOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange operands, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().all_gather_dim = all_gather_dim;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  odsState.addTypes(results);
}

void AllGatherOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AllGatherOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AllGatherOpV2::verifyInvariantsImpl() {
  auto tblgen_all_gather_dim = getProperties().all_gather_dim; (void)tblgen_all_gather_dim;
  if (!tblgen_all_gather_dim) return emitOpError("requires attribute 'all_gather_dim'");
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitOpError("requires attribute 'use_global_device_ids'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_all_gather_dim, "all_gather_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_use_global_device_ids, "use_global_device_ids")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AllGatherOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AllGatherOpV2::getMinVersion() {
  return mlir::vhlo::Version(1, 5, 0);
}
mlir::vhlo::Version AllGatherOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllGatherOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllReduceOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
AllReduceOpV1GenericAdaptorBase::AllReduceOpV1GenericAdaptorBase(AllReduceOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute AllReduceOpV1GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV1GenericAdaptorBase::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

} // namespace detail
AllReduceOpV1Adaptor::AllReduceOpV1Adaptor(AllReduceOpV1 op) : AllReduceOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AllReduceOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.all_reduce_v1' op ""requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.all_reduce_v1' op ""requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitError(loc, "'vhlo.all_reduce_v1' op ""requires attribute 'use_global_device_ids'");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.all_reduce_v1' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.all_reduce_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");

  if (tblgen_use_global_device_ids && !((true)))
    return emitError(loc, "'vhlo.all_reduce_v1' op ""attribute 'use_global_device_ids' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult AllReduceOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.use_global_device_ids;
       auto attr = dict.get("use_global_device_ids");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `use_global_device_ids` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AllReduceOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.use_global_device_ids;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("use_global_device_ids",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AllReduceOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.use_global_device_ids.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AllReduceOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "replica_groups")
      return prop.replica_groups;

    if (name == "use_global_device_ids")
      return prop.use_global_device_ids;
  return std::nullopt;
}

void AllReduceOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }

    if (name == "use_global_device_ids") {
       prop.use_global_device_ids = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.use_global_device_ids)>>(value);
       return;
    }
}

void AllReduceOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);

    if (prop.use_global_device_ids) attrs.append("use_global_device_ids", prop.use_global_device_ids);
}

::llvm::LogicalResult AllReduceOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUseGlobalDeviceIdsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "use_global_device_ids", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AllReduceOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.use_global_device_ids)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AllReduceOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.replica_groups);
  writer.writeAttribute(prop.use_global_device_ids);
}

::mlir::Attribute AllReduceOpV1::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV1::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

void AllReduceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  (void)odsState.addRegion();
  odsState.addTypes(result);
}

void AllReduceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllReduceOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AllReduceOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AllReduceOpV1::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitOpError("requires attribute 'use_global_device_ids'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_use_global_device_ids, "use_global_device_ids")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "computation", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult AllReduceOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AllReduceOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version AllReduceOpV1::getMaxVersion() {
   return mlir::vhlo::Version(1, 4, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllReduceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllReduceOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
AllReduceOpV2GenericAdaptorBase::AllReduceOpV2GenericAdaptorBase(AllReduceOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> AllReduceOpV2GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute AllReduceOpV2GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV2GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV2GenericAdaptorBase::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

} // namespace detail
AllReduceOpV2Adaptor::AllReduceOpV2Adaptor(AllReduceOpV2 op) : AllReduceOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AllReduceOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.all_reduce_v2' op ""requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.all_reduce_v2' op ""requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitError(loc, "'vhlo.all_reduce_v2' op ""requires attribute 'use_global_device_ids'");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.all_reduce_v2' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.all_reduce_v2' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");

  if (tblgen_use_global_device_ids && !((true)))
    return emitError(loc, "'vhlo.all_reduce_v2' op ""attribute 'use_global_device_ids' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AllReduceOpV2::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange AllReduceOpV2::getOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AllReduceOpV2::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult AllReduceOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.use_global_device_ids;
       auto attr = dict.get("use_global_device_ids");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `use_global_device_ids` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AllReduceOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.use_global_device_ids;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("use_global_device_ids",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AllReduceOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.use_global_device_ids.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AllReduceOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "replica_groups")
      return prop.replica_groups;

    if (name == "use_global_device_ids")
      return prop.use_global_device_ids;
  return std::nullopt;
}

void AllReduceOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }

    if (name == "use_global_device_ids") {
       prop.use_global_device_ids = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.use_global_device_ids)>>(value);
       return;
    }
}

void AllReduceOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);

    if (prop.use_global_device_ids) attrs.append("use_global_device_ids", prop.use_global_device_ids);
}

::llvm::LogicalResult AllReduceOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUseGlobalDeviceIdsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "use_global_device_ids", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AllReduceOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.use_global_device_ids)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AllReduceOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.replica_groups);
  writer.writeAttribute(prop.use_global_device_ids);
}

::mlir::Attribute AllReduceOpV2::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV2::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute AllReduceOpV2::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

void AllReduceOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange operands, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void AllReduceOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AllReduceOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AllReduceOpV2::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitOpError("requires attribute 'use_global_device_ids'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_use_global_device_ids, "use_global_device_ids")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "computation", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult AllReduceOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AllReduceOpV2::getMinVersion() {
  return mlir::vhlo::Version(1, 5, 0);
}
mlir::vhlo::Version AllReduceOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllReduceOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllToAllOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
AllToAllOpV1GenericAdaptorBase::AllToAllOpV1GenericAdaptorBase(AllToAllOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute AllToAllOpV1GenericAdaptorBase::getSplitDimension() {
  auto attr = getSplitDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1GenericAdaptorBase::getConcatDimension() {
  auto attr = getConcatDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1GenericAdaptorBase::getSplitCount() {
  auto attr = getSplitCountAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

} // namespace detail
AllToAllOpV1Adaptor::AllToAllOpV1Adaptor(AllToAllOpV1 op) : AllToAllOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AllToAllOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.all_to_all_v1' op ""requires attribute 'channel_id'");
  auto tblgen_concat_dimension = getProperties().concat_dimension; (void)tblgen_concat_dimension;
  if (!tblgen_concat_dimension) return emitError(loc, "'vhlo.all_to_all_v1' op ""requires attribute 'concat_dimension'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.all_to_all_v1' op ""requires attribute 'replica_groups'");
  auto tblgen_split_count = getProperties().split_count; (void)tblgen_split_count;
  if (!tblgen_split_count) return emitError(loc, "'vhlo.all_to_all_v1' op ""requires attribute 'split_count'");
  auto tblgen_split_dimension = getProperties().split_dimension; (void)tblgen_split_dimension;
  if (!tblgen_split_dimension) return emitError(loc, "'vhlo.all_to_all_v1' op ""requires attribute 'split_dimension'");

  if (tblgen_split_dimension && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v1' op ""attribute 'split_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_concat_dimension && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v1' op ""attribute 'concat_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_split_count && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v1' op ""attribute 'split_count' failed to satisfy constraint: any attribute");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v1' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult AllToAllOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.concat_dimension;
       auto attr = dict.get("concat_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `concat_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.split_count;
       auto attr = dict.get("split_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `split_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.split_dimension;
       auto attr = dict.get("split_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `split_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AllToAllOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.concat_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("concat_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.split_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("split_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.split_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("split_dimension",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AllToAllOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.concat_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.split_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.split_dimension.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AllToAllOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "concat_dimension")
      return prop.concat_dimension;

    if (name == "replica_groups")
      return prop.replica_groups;

    if (name == "split_count")
      return prop.split_count;

    if (name == "split_dimension")
      return prop.split_dimension;
  return std::nullopt;
}

void AllToAllOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "concat_dimension") {
       prop.concat_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.concat_dimension)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }

    if (name == "split_count") {
       prop.split_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.split_count)>>(value);
       return;
    }

    if (name == "split_dimension") {
       prop.split_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.split_dimension)>>(value);
       return;
    }
}

void AllToAllOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.concat_dimension) attrs.append("concat_dimension", prop.concat_dimension);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);

    if (prop.split_count) attrs.append("split_count", prop.split_count);

    if (prop.split_dimension) attrs.append("split_dimension", prop.split_dimension);
}

::llvm::LogicalResult AllToAllOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getConcatDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "concat_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSplitCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "split_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSplitDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "split_dimension", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AllToAllOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.concat_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.split_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.split_dimension)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AllToAllOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.concat_dimension);
  writer.writeAttribute(prop.replica_groups);
  writer.writeAttribute(prop.split_count);
  writer.writeAttribute(prop.split_dimension);
}

::mlir::Attribute AllToAllOpV1::getSplitDimension() {
  auto attr = getSplitDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1::getConcatDimension() {
  auto attr = getConcatDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1::getSplitCount() {
  auto attr = getSplitCountAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

void AllToAllOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().split_dimension = split_dimension;
  odsState.getOrAddProperties<Properties>().concat_dimension = concat_dimension;
  odsState.getOrAddProperties<Properties>().split_count = split_count;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.addTypes(result);
}

void AllToAllOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().split_dimension = split_dimension;
  odsState.getOrAddProperties<Properties>().concat_dimension = concat_dimension;
  odsState.getOrAddProperties<Properties>().split_count = split_count;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllToAllOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AllToAllOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AllToAllOpV1::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_concat_dimension = getProperties().concat_dimension; (void)tblgen_concat_dimension;
  if (!tblgen_concat_dimension) return emitOpError("requires attribute 'concat_dimension'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");
  auto tblgen_split_count = getProperties().split_count; (void)tblgen_split_count;
  if (!tblgen_split_count) return emitOpError("requires attribute 'split_count'");
  auto tblgen_split_dimension = getProperties().split_dimension; (void)tblgen_split_dimension;
  if (!tblgen_split_dimension) return emitOpError("requires attribute 'split_dimension'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_split_dimension, "split_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_concat_dimension, "concat_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_split_count, "split_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AllToAllOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AllToAllOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version AllToAllOpV1::getMaxVersion() {
   return mlir::vhlo::Version(1, 4, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllToAllOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllToAllOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
AllToAllOpV2GenericAdaptorBase::AllToAllOpV2GenericAdaptorBase(AllToAllOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> AllToAllOpV2GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute AllToAllOpV2GenericAdaptorBase::getSplitDimension() {
  auto attr = getSplitDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2GenericAdaptorBase::getConcatDimension() {
  auto attr = getConcatDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2GenericAdaptorBase::getSplitCount() {
  auto attr = getSplitCountAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

} // namespace detail
AllToAllOpV2Adaptor::AllToAllOpV2Adaptor(AllToAllOpV2 op) : AllToAllOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AllToAllOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.all_to_all_v2' op ""requires attribute 'channel_id'");
  auto tblgen_concat_dimension = getProperties().concat_dimension; (void)tblgen_concat_dimension;
  if (!tblgen_concat_dimension) return emitError(loc, "'vhlo.all_to_all_v2' op ""requires attribute 'concat_dimension'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.all_to_all_v2' op ""requires attribute 'replica_groups'");
  auto tblgen_split_count = getProperties().split_count; (void)tblgen_split_count;
  if (!tblgen_split_count) return emitError(loc, "'vhlo.all_to_all_v2' op ""requires attribute 'split_count'");
  auto tblgen_split_dimension = getProperties().split_dimension; (void)tblgen_split_dimension;
  if (!tblgen_split_dimension) return emitError(loc, "'vhlo.all_to_all_v2' op ""requires attribute 'split_dimension'");

  if (tblgen_split_dimension && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v2' op ""attribute 'split_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_concat_dimension && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v2' op ""attribute 'concat_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_split_count && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v2' op ""attribute 'split_count' failed to satisfy constraint: any attribute");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v2' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.all_to_all_v2' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AllToAllOpV2::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange AllToAllOpV2::getOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AllToAllOpV2::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult AllToAllOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.concat_dimension;
       auto attr = dict.get("concat_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `concat_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.split_count;
       auto attr = dict.get("split_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `split_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.split_dimension;
       auto attr = dict.get("split_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `split_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AllToAllOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.concat_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("concat_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.split_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("split_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.split_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("split_dimension",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AllToAllOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.concat_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.split_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.split_dimension.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AllToAllOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "concat_dimension")
      return prop.concat_dimension;

    if (name == "replica_groups")
      return prop.replica_groups;

    if (name == "split_count")
      return prop.split_count;

    if (name == "split_dimension")
      return prop.split_dimension;
  return std::nullopt;
}

void AllToAllOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "concat_dimension") {
       prop.concat_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.concat_dimension)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }

    if (name == "split_count") {
       prop.split_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.split_count)>>(value);
       return;
    }

    if (name == "split_dimension") {
       prop.split_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.split_dimension)>>(value);
       return;
    }
}

void AllToAllOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.concat_dimension) attrs.append("concat_dimension", prop.concat_dimension);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);

    if (prop.split_count) attrs.append("split_count", prop.split_count);

    if (prop.split_dimension) attrs.append("split_dimension", prop.split_dimension);
}

::llvm::LogicalResult AllToAllOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getConcatDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "concat_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSplitCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "split_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSplitDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "split_dimension", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AllToAllOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.concat_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.split_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.split_dimension)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AllToAllOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.concat_dimension);
  writer.writeAttribute(prop.replica_groups);
  writer.writeAttribute(prop.split_count);
  writer.writeAttribute(prop.split_dimension);
}

::mlir::Attribute AllToAllOpV2::getSplitDimension() {
  auto attr = getSplitDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2::getConcatDimension() {
  auto attr = getConcatDimensionAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2::getSplitCount() {
  auto attr = getSplitCountAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute AllToAllOpV2::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

void AllToAllOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange operands, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().split_dimension = split_dimension;
  odsState.getOrAddProperties<Properties>().concat_dimension = concat_dimension;
  odsState.getOrAddProperties<Properties>().split_count = split_count;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.addTypes(results);
}

void AllToAllOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AllToAllOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AllToAllOpV2::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_concat_dimension = getProperties().concat_dimension; (void)tblgen_concat_dimension;
  if (!tblgen_concat_dimension) return emitOpError("requires attribute 'concat_dimension'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");
  auto tblgen_split_count = getProperties().split_count; (void)tblgen_split_count;
  if (!tblgen_split_count) return emitOpError("requires attribute 'split_count'");
  auto tblgen_split_dimension = getProperties().split_dimension; (void)tblgen_split_dimension;
  if (!tblgen_split_dimension) return emitOpError("requires attribute 'split_dimension'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_split_dimension, "split_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_concat_dimension, "concat_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_split_count, "split_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AllToAllOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AllToAllOpV2::getMinVersion() {
  return mlir::vhlo::Version(1, 5, 0);
}
mlir::vhlo::Version AllToAllOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllToAllOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AndOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AndOpV1Adaptor::AndOpV1Adaptor(AndOpV1 op) : AndOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AndOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AndOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void AndOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AndOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AndOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AndOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version AndOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version AndOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::AndOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Atan2OpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
Atan2OpV1Adaptor::Atan2OpV1Adaptor(Atan2OpV1 op) : Atan2OpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult Atan2OpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void Atan2OpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void Atan2OpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Atan2OpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult Atan2OpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult Atan2OpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version Atan2OpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version Atan2OpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::Atan2OpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormGradOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
BatchNormGradOpV1GenericAdaptorBase::BatchNormGradOpV1GenericAdaptorBase(BatchNormGradOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute BatchNormGradOpV1GenericAdaptorBase::getEpsilon() {
  auto attr = getEpsilonAttr();
  return attr;
}

::mlir::Attribute BatchNormGradOpV1GenericAdaptorBase::getFeatureIndex() {
  auto attr = getFeatureIndexAttr();
  return attr;
}

} // namespace detail
BatchNormGradOpV1Adaptor::BatchNormGradOpV1Adaptor(BatchNormGradOpV1 op) : BatchNormGradOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BatchNormGradOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_epsilon = getProperties().epsilon; (void)tblgen_epsilon;
  if (!tblgen_epsilon) return emitError(loc, "'vhlo.batch_norm_grad_v1' op ""requires attribute 'epsilon'");
  auto tblgen_feature_index = getProperties().feature_index; (void)tblgen_feature_index;
  if (!tblgen_feature_index) return emitError(loc, "'vhlo.batch_norm_grad_v1' op ""requires attribute 'feature_index'");

  if (tblgen_epsilon && !((true)))
    return emitError(loc, "'vhlo.batch_norm_grad_v1' op ""attribute 'epsilon' failed to satisfy constraint: any attribute");

  if (tblgen_feature_index && !((true)))
    return emitError(loc, "'vhlo.batch_norm_grad_v1' op ""attribute 'feature_index' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

void BatchNormGradOpV1::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!resultGroup0.empty())
    setNameFn(*resultGroup0.begin(), "grad_operand");
  auto resultGroup1 = getODSResults(1);
  if (!resultGroup1.empty())
    setNameFn(*resultGroup1.begin(), "grad_scale");
  auto resultGroup2 = getODSResults(2);
  if (!resultGroup2.empty())
    setNameFn(*resultGroup2.begin(), "grad_offset");
}

::llvm::LogicalResult BatchNormGradOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.epsilon;
       auto attr = dict.get("epsilon");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `epsilon` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.feature_index;
       auto attr = dict.get("feature_index");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `feature_index` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute BatchNormGradOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.epsilon;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("epsilon",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.feature_index;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("feature_index",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code BatchNormGradOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.epsilon.getAsOpaquePointer()), 
    llvm::hash_value(prop.feature_index.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> BatchNormGradOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "epsilon")
      return prop.epsilon;

    if (name == "feature_index")
      return prop.feature_index;
  return std::nullopt;
}

void BatchNormGradOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "epsilon") {
       prop.epsilon = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.epsilon)>>(value);
       return;
    }

    if (name == "feature_index") {
       prop.feature_index = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.feature_index)>>(value);
       return;
    }
}

void BatchNormGradOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.epsilon) attrs.append("epsilon", prop.epsilon);

    if (prop.feature_index) attrs.append("feature_index", prop.feature_index);
}

::llvm::LogicalResult BatchNormGradOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getEpsilonAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "epsilon", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFeatureIndexAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "feature_index", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult BatchNormGradOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.epsilon)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.feature_index)))
    return ::mlir::failure();
  return ::mlir::success();
}

void BatchNormGradOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.epsilon);
  writer.writeAttribute(prop.feature_index);
}

::mlir::Attribute BatchNormGradOpV1::getEpsilon() {
  auto attr = getEpsilonAttr();
  return attr;
}

::mlir::Attribute BatchNormGradOpV1::getFeatureIndex() {
  auto attr = getFeatureIndexAttr();
  return attr;
}

void BatchNormGradOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type grad_operand, ::mlir::Type grad_scale, ::mlir::Type grad_offset, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Value grad_output, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index) {
  odsState.addOperands(operand);
  odsState.addOperands(scale);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addOperands(grad_output);
  odsState.getOrAddProperties<Properties>().epsilon = epsilon;
  odsState.getOrAddProperties<Properties>().feature_index = feature_index;
  odsState.addTypes(grad_operand);
  odsState.addTypes(grad_scale);
  odsState.addTypes(grad_offset);
}

void BatchNormGradOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Value grad_output, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index) {
  odsState.addOperands(operand);
  odsState.addOperands(scale);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addOperands(grad_output);
  odsState.getOrAddProperties<Properties>().epsilon = epsilon;
  odsState.getOrAddProperties<Properties>().feature_index = feature_index;
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchNormGradOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 3u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<BatchNormGradOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult BatchNormGradOpV1::verifyInvariantsImpl() {
  auto tblgen_epsilon = getProperties().epsilon; (void)tblgen_epsilon;
  if (!tblgen_epsilon) return emitOpError("requires attribute 'epsilon'");
  auto tblgen_feature_index = getProperties().feature_index; (void)tblgen_feature_index;
  if (!tblgen_feature_index) return emitOpError("requires attribute 'feature_index'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_epsilon, "epsilon")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_feature_index, "feature_index")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSResults(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSResults(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult BatchNormGradOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version BatchNormGradOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version BatchNormGradOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormGradOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormInferenceOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
BatchNormInferenceOpV1GenericAdaptorBase::BatchNormInferenceOpV1GenericAdaptorBase(BatchNormInferenceOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute BatchNormInferenceOpV1GenericAdaptorBase::getEpsilon() {
  auto attr = getEpsilonAttr();
  return attr;
}

::mlir::Attribute BatchNormInferenceOpV1GenericAdaptorBase::getFeatureIndex() {
  auto attr = getFeatureIndexAttr();
  return attr;
}

} // namespace detail
BatchNormInferenceOpV1Adaptor::BatchNormInferenceOpV1Adaptor(BatchNormInferenceOpV1 op) : BatchNormInferenceOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BatchNormInferenceOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_epsilon = getProperties().epsilon; (void)tblgen_epsilon;
  if (!tblgen_epsilon) return emitError(loc, "'vhlo.batch_norm_inference_v1' op ""requires attribute 'epsilon'");
  auto tblgen_feature_index = getProperties().feature_index; (void)tblgen_feature_index;
  if (!tblgen_feature_index) return emitError(loc, "'vhlo.batch_norm_inference_v1' op ""requires attribute 'feature_index'");

  if (tblgen_epsilon && !((true)))
    return emitError(loc, "'vhlo.batch_norm_inference_v1' op ""attribute 'epsilon' failed to satisfy constraint: any attribute");

  if (tblgen_feature_index && !((true)))
    return emitError(loc, "'vhlo.batch_norm_inference_v1' op ""attribute 'feature_index' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult BatchNormInferenceOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.epsilon;
       auto attr = dict.get("epsilon");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `epsilon` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.feature_index;
       auto attr = dict.get("feature_index");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `feature_index` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute BatchNormInferenceOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.epsilon;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("epsilon",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.feature_index;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("feature_index",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code BatchNormInferenceOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.epsilon.getAsOpaquePointer()), 
    llvm::hash_value(prop.feature_index.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> BatchNormInferenceOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "epsilon")
      return prop.epsilon;

    if (name == "feature_index")
      return prop.feature_index;
  return std::nullopt;
}

void BatchNormInferenceOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "epsilon") {
       prop.epsilon = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.epsilon)>>(value);
       return;
    }

    if (name == "feature_index") {
       prop.feature_index = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.feature_index)>>(value);
       return;
    }
}

void BatchNormInferenceOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.epsilon) attrs.append("epsilon", prop.epsilon);

    if (prop.feature_index) attrs.append("feature_index", prop.feature_index);
}

::llvm::LogicalResult BatchNormInferenceOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getEpsilonAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "epsilon", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFeatureIndexAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "feature_index", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult BatchNormInferenceOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.epsilon)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.feature_index)))
    return ::mlir::failure();
  return ::mlir::success();
}

void BatchNormInferenceOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.epsilon);
  writer.writeAttribute(prop.feature_index);
}

::mlir::Attribute BatchNormInferenceOpV1::getEpsilon() {
  auto attr = getEpsilonAttr();
  return attr;
}

::mlir::Attribute BatchNormInferenceOpV1::getFeatureIndex() {
  auto attr = getFeatureIndexAttr();
  return attr;
}

void BatchNormInferenceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index) {
  odsState.addOperands(operand);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.getOrAddProperties<Properties>().epsilon = epsilon;
  odsState.getOrAddProperties<Properties>().feature_index = feature_index;
  odsState.addTypes(result);
}

void BatchNormInferenceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index) {
  odsState.addOperands(operand);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.getOrAddProperties<Properties>().epsilon = epsilon;
  odsState.getOrAddProperties<Properties>().feature_index = feature_index;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchNormInferenceOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<BatchNormInferenceOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult BatchNormInferenceOpV1::verifyInvariantsImpl() {
  auto tblgen_epsilon = getProperties().epsilon; (void)tblgen_epsilon;
  if (!tblgen_epsilon) return emitOpError("requires attribute 'epsilon'");
  auto tblgen_feature_index = getProperties().feature_index; (void)tblgen_feature_index;
  if (!tblgen_feature_index) return emitOpError("requires attribute 'feature_index'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_epsilon, "epsilon")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_feature_index, "feature_index")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult BatchNormInferenceOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version BatchNormInferenceOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version BatchNormInferenceOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormInferenceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormTrainingOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
BatchNormTrainingOpV1GenericAdaptorBase::BatchNormTrainingOpV1GenericAdaptorBase(BatchNormTrainingOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute BatchNormTrainingOpV1GenericAdaptorBase::getEpsilon() {
  auto attr = getEpsilonAttr();
  return attr;
}

::mlir::Attribute BatchNormTrainingOpV1GenericAdaptorBase::getFeatureIndex() {
  auto attr = getFeatureIndexAttr();
  return attr;
}

} // namespace detail
BatchNormTrainingOpV1Adaptor::BatchNormTrainingOpV1Adaptor(BatchNormTrainingOpV1 op) : BatchNormTrainingOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BatchNormTrainingOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_epsilon = getProperties().epsilon; (void)tblgen_epsilon;
  if (!tblgen_epsilon) return emitError(loc, "'vhlo.batch_norm_training_v1' op ""requires attribute 'epsilon'");
  auto tblgen_feature_index = getProperties().feature_index; (void)tblgen_feature_index;
  if (!tblgen_feature_index) return emitError(loc, "'vhlo.batch_norm_training_v1' op ""requires attribute 'feature_index'");

  if (tblgen_epsilon && !((true)))
    return emitError(loc, "'vhlo.batch_norm_training_v1' op ""attribute 'epsilon' failed to satisfy constraint: any attribute");

  if (tblgen_feature_index && !((true)))
    return emitError(loc, "'vhlo.batch_norm_training_v1' op ""attribute 'feature_index' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

void BatchNormTrainingOpV1::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!resultGroup0.empty())
    setNameFn(*resultGroup0.begin(), "output");
  auto resultGroup1 = getODSResults(1);
  if (!resultGroup1.empty())
    setNameFn(*resultGroup1.begin(), "batch_mean");
  auto resultGroup2 = getODSResults(2);
  if (!resultGroup2.empty())
    setNameFn(*resultGroup2.begin(), "batch_var");
}

::llvm::LogicalResult BatchNormTrainingOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.epsilon;
       auto attr = dict.get("epsilon");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `epsilon` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.feature_index;
       auto attr = dict.get("feature_index");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `feature_index` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute BatchNormTrainingOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.epsilon;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("epsilon",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.feature_index;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("feature_index",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code BatchNormTrainingOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.epsilon.getAsOpaquePointer()), 
    llvm::hash_value(prop.feature_index.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> BatchNormTrainingOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "epsilon")
      return prop.epsilon;

    if (name == "feature_index")
      return prop.feature_index;
  return std::nullopt;
}

void BatchNormTrainingOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "epsilon") {
       prop.epsilon = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.epsilon)>>(value);
       return;
    }

    if (name == "feature_index") {
       prop.feature_index = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.feature_index)>>(value);
       return;
    }
}

void BatchNormTrainingOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.epsilon) attrs.append("epsilon", prop.epsilon);

    if (prop.feature_index) attrs.append("feature_index", prop.feature_index);
}

::llvm::LogicalResult BatchNormTrainingOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getEpsilonAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "epsilon", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFeatureIndexAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "feature_index", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult BatchNormTrainingOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.epsilon)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.feature_index)))
    return ::mlir::failure();
  return ::mlir::success();
}

void BatchNormTrainingOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.epsilon);
  writer.writeAttribute(prop.feature_index);
}

::mlir::Attribute BatchNormTrainingOpV1::getEpsilon() {
  auto attr = getEpsilonAttr();
  return attr;
}

::mlir::Attribute BatchNormTrainingOpV1::getFeatureIndex() {
  auto attr = getFeatureIndexAttr();
  return attr;
}

void BatchNormTrainingOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Type batch_mean, ::mlir::Type batch_var, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index) {
  odsState.addOperands(operand);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.getOrAddProperties<Properties>().epsilon = epsilon;
  odsState.getOrAddProperties<Properties>().feature_index = feature_index;
  odsState.addTypes(output);
  odsState.addTypes(batch_mean);
  odsState.addTypes(batch_var);
}

void BatchNormTrainingOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index) {
  odsState.addOperands(operand);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.getOrAddProperties<Properties>().epsilon = epsilon;
  odsState.getOrAddProperties<Properties>().feature_index = feature_index;
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchNormTrainingOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 3u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<BatchNormTrainingOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult BatchNormTrainingOpV1::verifyInvariantsImpl() {
  auto tblgen_epsilon = getProperties().epsilon; (void)tblgen_epsilon;
  if (!tblgen_epsilon) return emitOpError("requires attribute 'epsilon'");
  auto tblgen_feature_index = getProperties().feature_index; (void)tblgen_feature_index;
  if (!tblgen_feature_index) return emitOpError("requires attribute 'feature_index'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_epsilon, "epsilon")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_feature_index, "feature_index")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSResults(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSResults(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult BatchNormTrainingOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version BatchNormTrainingOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version BatchNormTrainingOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormTrainingOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BitcastConvertOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
BitcastConvertOpV1Adaptor::BitcastConvertOpV1Adaptor(BitcastConvertOpV1 op) : BitcastConvertOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BitcastConvertOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void BitcastConvertOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void BitcastConvertOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitcastConvertOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult BitcastConvertOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult BitcastConvertOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version BitcastConvertOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version BitcastConvertOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::BitcastConvertOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BroadcastInDimOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
BroadcastInDimOpV1GenericAdaptorBase::BroadcastInDimOpV1GenericAdaptorBase(BroadcastInDimOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute BroadcastInDimOpV1GenericAdaptorBase::getBroadcastDimensions() {
  auto attr = getBroadcastDimensionsAttr();
  return attr;
}

} // namespace detail
BroadcastInDimOpV1Adaptor::BroadcastInDimOpV1Adaptor(BroadcastInDimOpV1 op) : BroadcastInDimOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BroadcastInDimOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_broadcast_dimensions = getProperties().broadcast_dimensions; (void)tblgen_broadcast_dimensions;
  if (!tblgen_broadcast_dimensions) return emitError(loc, "'vhlo.broadcast_in_dim_v1' op ""requires attribute 'broadcast_dimensions'");

  if (tblgen_broadcast_dimensions && !((true)))
    return emitError(loc, "'vhlo.broadcast_in_dim_v1' op ""attribute 'broadcast_dimensions' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult BroadcastInDimOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.broadcast_dimensions;
       auto attr = dict.get("broadcast_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `broadcast_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute BroadcastInDimOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.broadcast_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("broadcast_dimensions",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code BroadcastInDimOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.broadcast_dimensions.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> BroadcastInDimOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "broadcast_dimensions")
      return prop.broadcast_dimensions;
  return std::nullopt;
}

void BroadcastInDimOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "broadcast_dimensions") {
       prop.broadcast_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.broadcast_dimensions)>>(value);
       return;
    }
}

void BroadcastInDimOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.broadcast_dimensions) attrs.append("broadcast_dimensions", prop.broadcast_dimensions);
}

::llvm::LogicalResult BroadcastInDimOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBroadcastDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "broadcast_dimensions", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult BroadcastInDimOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.broadcast_dimensions)))
    return ::mlir::failure();
  return ::mlir::success();
}

void BroadcastInDimOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.broadcast_dimensions);
}

::mlir::Attribute BroadcastInDimOpV1::getBroadcastDimensions() {
  auto attr = getBroadcastDimensionsAttr();
  return attr;
}

void BroadcastInDimOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute broadcast_dimensions) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().broadcast_dimensions = broadcast_dimensions;
  odsState.addTypes(result);
}

void BroadcastInDimOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute broadcast_dimensions) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().broadcast_dimensions = broadcast_dimensions;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BroadcastInDimOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<BroadcastInDimOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult BroadcastInDimOpV1::verifyInvariantsImpl() {
  auto tblgen_broadcast_dimensions = getProperties().broadcast_dimensions; (void)tblgen_broadcast_dimensions;
  if (!tblgen_broadcast_dimensions) return emitOpError("requires attribute 'broadcast_dimensions'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_broadcast_dimensions, "broadcast_dimensions")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult BroadcastInDimOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version BroadcastInDimOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version BroadcastInDimOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::BroadcastInDimOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BroadcastOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
BroadcastOpV1GenericAdaptorBase::BroadcastOpV1GenericAdaptorBase(BroadcastOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute BroadcastOpV1GenericAdaptorBase::getBroadcastSizes() {
  auto attr = getBroadcastSizesAttr();
  return attr;
}

} // namespace detail
BroadcastOpV1Adaptor::BroadcastOpV1Adaptor(BroadcastOpV1 op) : BroadcastOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult BroadcastOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_broadcast_sizes = getProperties().broadcast_sizes; (void)tblgen_broadcast_sizes;
  if (!tblgen_broadcast_sizes) return emitError(loc, "'vhlo.broadcast_v1' op ""requires attribute 'broadcast_sizes'");

  if (tblgen_broadcast_sizes && !((true)))
    return emitError(loc, "'vhlo.broadcast_v1' op ""attribute 'broadcast_sizes' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult BroadcastOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.broadcast_sizes;
       auto attr = dict.get("broadcast_sizes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `broadcast_sizes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute BroadcastOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.broadcast_sizes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("broadcast_sizes",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code BroadcastOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.broadcast_sizes.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> BroadcastOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "broadcast_sizes")
      return prop.broadcast_sizes;
  return std::nullopt;
}

void BroadcastOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "broadcast_sizes") {
       prop.broadcast_sizes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.broadcast_sizes)>>(value);
       return;
    }
}

void BroadcastOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.broadcast_sizes) attrs.append("broadcast_sizes", prop.broadcast_sizes);
}

::llvm::LogicalResult BroadcastOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBroadcastSizesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "broadcast_sizes", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult BroadcastOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.broadcast_sizes)))
    return ::mlir::failure();
  return ::mlir::success();
}

void BroadcastOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.broadcast_sizes);
}

::mlir::Attribute BroadcastOpV1::getBroadcastSizes() {
  auto attr = getBroadcastSizesAttr();
  return attr;
}

void BroadcastOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute broadcast_sizes) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().broadcast_sizes = broadcast_sizes;
  odsState.addTypes(result);
}

void BroadcastOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute broadcast_sizes) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().broadcast_sizes = broadcast_sizes;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BroadcastOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<BroadcastOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult BroadcastOpV1::verifyInvariantsImpl() {
  auto tblgen_broadcast_sizes = getProperties().broadcast_sizes; (void)tblgen_broadcast_sizes;
  if (!tblgen_broadcast_sizes) return emitOpError("requires attribute 'broadcast_sizes'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_broadcast_sizes, "broadcast_sizes")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult BroadcastOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version BroadcastOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version BroadcastOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::BroadcastOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CallOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CallOpV1GenericAdaptorBase::CallOpV1GenericAdaptorBase(CallOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CallOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute CallOpV1GenericAdaptorBase::getCallee() {
  auto attr = getCalleeAttr();
  return attr;
}

} // namespace detail
CallOpV1Adaptor::CallOpV1Adaptor(CallOpV1 op) : CallOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CallOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_callee = getProperties().callee; (void)tblgen_callee;
  if (!tblgen_callee) return emitError(loc, "'vhlo.call_v1' op ""requires attribute 'callee'");

  if (tblgen_callee && !((true)))
    return emitError(loc, "'vhlo.call_v1' op ""attribute 'callee' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CallOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange CallOpV1::getOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CallOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult CallOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.callee;
       auto attr = dict.get("callee");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `callee` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CallOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.callee;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("callee",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CallOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.callee.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CallOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "callee")
      return prop.callee;
  return std::nullopt;
}

void CallOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "callee") {
       prop.callee = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.callee)>>(value);
       return;
    }
}

void CallOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.callee) attrs.append("callee", prop.callee);
}

::llvm::LogicalResult CallOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCalleeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "callee", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CallOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.callee)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CallOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.callee);
}

::mlir::Attribute CallOpV1::getCallee() {
  auto attr = getCalleeAttr();
  return attr;
}

void CallOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Attribute callee, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.getOrAddProperties<Properties>().callee = callee;
  odsState.addTypes(results);
}

void CallOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CallOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CallOpV1::verifyInvariantsImpl() {
  auto tblgen_callee = getProperties().callee; (void)tblgen_callee;
  if (!tblgen_callee) return emitOpError("requires attribute 'callee'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_callee, "callee")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CallOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CallOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CallOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CallOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CaseOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
CaseOpV1Adaptor::CaseOpV1Adaptor(CaseOpV1 op) : CaseOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CaseOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CaseOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

void CaseOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value index, unsigned branchesCount) {
  odsState.addOperands(index);
  for (unsigned i = 0; i < branchesCount; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(results);
}

void CaseOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes, unsigned numRegions) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != numRegions; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult CaseOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : getBranches())
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "branches", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult CaseOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CaseOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CaseOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CaseOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CbrtOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
CbrtOpV1Adaptor::CbrtOpV1Adaptor(CbrtOpV1 op) : CbrtOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CbrtOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void CbrtOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void CbrtOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CbrtOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult CbrtOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CbrtOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CbrtOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CbrtOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CbrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CeilOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
CeilOpV1Adaptor::CeilOpV1Adaptor(CeilOpV1 op) : CeilOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CeilOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void CeilOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void CeilOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CeilOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult CeilOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CeilOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CeilOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CeilOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CeilOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CholeskyOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CholeskyOpV1GenericAdaptorBase::CholeskyOpV1GenericAdaptorBase(CholeskyOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute CholeskyOpV1GenericAdaptorBase::getLower() {
  auto attr = getLowerAttr();
  return attr;
}

} // namespace detail
CholeskyOpV1Adaptor::CholeskyOpV1Adaptor(CholeskyOpV1 op) : CholeskyOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CholeskyOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_lower = getProperties().lower; (void)tblgen_lower;
  if (!tblgen_lower) return emitError(loc, "'vhlo.cholesky_v1' op ""requires attribute 'lower'");

  if (tblgen_lower && !((true)))
    return emitError(loc, "'vhlo.cholesky_v1' op ""attribute 'lower' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult CholeskyOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.lower;
       auto attr = dict.get("lower");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lower` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CholeskyOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.lower;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lower",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CholeskyOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.lower.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CholeskyOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "lower")
      return prop.lower;
  return std::nullopt;
}

void CholeskyOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "lower") {
       prop.lower = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lower)>>(value);
       return;
    }
}

void CholeskyOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.lower) attrs.append("lower", prop.lower);
}

::llvm::LogicalResult CholeskyOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getLowerAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lower", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CholeskyOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.lower)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CholeskyOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.lower);
}

::mlir::Attribute CholeskyOpV1::getLower() {
  auto attr = getLowerAttr();
  return attr;
}

void CholeskyOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Attribute lower) {
  odsState.addOperands(a);
  odsState.getOrAddProperties<Properties>().lower = lower;
  odsState.addTypes(result);
}

void CholeskyOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Attribute lower) {
  odsState.addOperands(a);
  odsState.getOrAddProperties<Properties>().lower = lower;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CholeskyOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CholeskyOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CholeskyOpV1::verifyInvariantsImpl() {
  auto tblgen_lower = getProperties().lower; (void)tblgen_lower;
  if (!tblgen_lower) return emitOpError("requires attribute 'lower'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lower, "lower")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CholeskyOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CholeskyOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CholeskyOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CholeskyOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ClampOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ClampOpV1Adaptor::ClampOpV1Adaptor(ClampOpV1 op) : ClampOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ClampOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ClampOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value min, ::mlir::Value operand, ::mlir::Value max) {
  odsState.addOperands(min);
  odsState.addOperands(operand);
  odsState.addOperands(max);
  odsState.addTypes(result);
}

void ClampOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value min, ::mlir::Value operand, ::mlir::Value max) {
  odsState.addOperands(min);
  odsState.addOperands(operand);
  odsState.addOperands(max);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ClampOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ClampOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ClampOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ClampOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ClampOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ClampOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ClzOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ClzOpV1Adaptor::ClzOpV1Adaptor(ClzOpV1 op) : ClzOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ClzOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ClzOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ClzOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ClzOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ClzOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ClzOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ClzOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ClzOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ClzOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CollectiveBroadcastOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CollectiveBroadcastOpV1GenericAdaptorBase::CollectiveBroadcastOpV1GenericAdaptorBase(CollectiveBroadcastOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute CollectiveBroadcastOpV1GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute CollectiveBroadcastOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

} // namespace detail
CollectiveBroadcastOpV1Adaptor::CollectiveBroadcastOpV1Adaptor(CollectiveBroadcastOpV1 op) : CollectiveBroadcastOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CollectiveBroadcastOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.collective_broadcast_v1' op ""requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.collective_broadcast_v1' op ""requires attribute 'replica_groups'");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.collective_broadcast_v1' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.collective_broadcast_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult CollectiveBroadcastOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CollectiveBroadcastOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CollectiveBroadcastOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CollectiveBroadcastOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "replica_groups")
      return prop.replica_groups;
  return std::nullopt;
}

void CollectiveBroadcastOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }
}

void CollectiveBroadcastOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);
}

::llvm::LogicalResult CollectiveBroadcastOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CollectiveBroadcastOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CollectiveBroadcastOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.replica_groups);
}

::mlir::Attribute CollectiveBroadcastOpV1::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute CollectiveBroadcastOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

void CollectiveBroadcastOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.addTypes(result);
}

void CollectiveBroadcastOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveBroadcastOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CollectiveBroadcastOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CollectiveBroadcastOpV1::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CollectiveBroadcastOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CollectiveBroadcastOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 16, 0);
}
mlir::vhlo::Version CollectiveBroadcastOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CollectiveBroadcastOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CollectivePermuteOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CollectivePermuteOpV1GenericAdaptorBase::CollectivePermuteOpV1GenericAdaptorBase(CollectivePermuteOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute CollectivePermuteOpV1GenericAdaptorBase::getSourceTargetPairs() {
  auto attr = getSourceTargetPairsAttr();
  return attr;
}

::mlir::Attribute CollectivePermuteOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

} // namespace detail
CollectivePermuteOpV1Adaptor::CollectivePermuteOpV1Adaptor(CollectivePermuteOpV1 op) : CollectivePermuteOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CollectivePermuteOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.collective_permute_v1' op ""requires attribute 'channel_id'");
  auto tblgen_source_target_pairs = getProperties().source_target_pairs; (void)tblgen_source_target_pairs;
  if (!tblgen_source_target_pairs) return emitError(loc, "'vhlo.collective_permute_v1' op ""requires attribute 'source_target_pairs'");

  if (tblgen_source_target_pairs && !((true)))
    return emitError(loc, "'vhlo.collective_permute_v1' op ""attribute 'source_target_pairs' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.collective_permute_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult CollectivePermuteOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.source_target_pairs;
       auto attr = dict.get("source_target_pairs");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `source_target_pairs` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CollectivePermuteOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.source_target_pairs;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("source_target_pairs",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CollectivePermuteOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.source_target_pairs.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CollectivePermuteOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "source_target_pairs")
      return prop.source_target_pairs;
  return std::nullopt;
}

void CollectivePermuteOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "source_target_pairs") {
       prop.source_target_pairs = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.source_target_pairs)>>(value);
       return;
    }
}

void CollectivePermuteOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.source_target_pairs) attrs.append("source_target_pairs", prop.source_target_pairs);
}

::llvm::LogicalResult CollectivePermuteOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSourceTargetPairsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "source_target_pairs", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CollectivePermuteOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.source_target_pairs)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CollectivePermuteOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.source_target_pairs);
}

::mlir::Attribute CollectivePermuteOpV1::getSourceTargetPairs() {
  auto attr = getSourceTargetPairsAttr();
  return attr;
}

::mlir::Attribute CollectivePermuteOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

void CollectivePermuteOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute source_target_pairs, ::mlir::Attribute channel_id) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().source_target_pairs = source_target_pairs;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.addTypes(result);
}

void CollectivePermuteOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute source_target_pairs, ::mlir::Attribute channel_id) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().source_target_pairs = source_target_pairs;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectivePermuteOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CollectivePermuteOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CollectivePermuteOpV1::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_source_target_pairs = getProperties().source_target_pairs; (void)tblgen_source_target_pairs;
  if (!tblgen_source_target_pairs) return emitOpError("requires attribute 'source_target_pairs'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_source_target_pairs, "source_target_pairs")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CollectivePermuteOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CollectivePermuteOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CollectivePermuteOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CollectivePermuteOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CompareOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CompareOpV1GenericAdaptorBase::CompareOpV1GenericAdaptorBase(CompareOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute CompareOpV1GenericAdaptorBase::getComparisonDirection() {
  auto attr = getComparisonDirectionAttr();
  return attr;
}

::mlir::Attribute CompareOpV1GenericAdaptorBase::getCompareType() {
  auto attr = getCompareTypeAttr();
  return attr;
}

} // namespace detail
CompareOpV1Adaptor::CompareOpV1Adaptor(CompareOpV1 op) : CompareOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CompareOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_compare_type = getProperties().compare_type; (void)tblgen_compare_type;
  if (!tblgen_compare_type) return emitError(loc, "'vhlo.compare_v1' op ""requires attribute 'compare_type'");
  auto tblgen_comparison_direction = getProperties().comparison_direction; (void)tblgen_comparison_direction;
  if (!tblgen_comparison_direction) return emitError(loc, "'vhlo.compare_v1' op ""requires attribute 'comparison_direction'");

  if (tblgen_comparison_direction && !((true)))
    return emitError(loc, "'vhlo.compare_v1' op ""attribute 'comparison_direction' failed to satisfy constraint: any attribute");

  if (tblgen_compare_type && !((true)))
    return emitError(loc, "'vhlo.compare_v1' op ""attribute 'compare_type' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult CompareOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.compare_type;
       auto attr = dict.get("compare_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `compare_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.comparison_direction;
       auto attr = dict.get("comparison_direction");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `comparison_direction` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CompareOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.compare_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("compare_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.comparison_direction;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("comparison_direction",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CompareOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.compare_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.comparison_direction.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CompareOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "compare_type")
      return prop.compare_type;

    if (name == "comparison_direction")
      return prop.comparison_direction;
  return std::nullopt;
}

void CompareOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "compare_type") {
       prop.compare_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.compare_type)>>(value);
       return;
    }

    if (name == "comparison_direction") {
       prop.comparison_direction = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.comparison_direction)>>(value);
       return;
    }
}

void CompareOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.compare_type) attrs.append("compare_type", prop.compare_type);

    if (prop.comparison_direction) attrs.append("comparison_direction", prop.comparison_direction);
}

::llvm::LogicalResult CompareOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCompareTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "compare_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getComparisonDirectionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "comparison_direction", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CompareOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.compare_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.comparison_direction)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CompareOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.compare_type);
  writer.writeAttribute(prop.comparison_direction);
}

::mlir::Attribute CompareOpV1::getComparisonDirection() {
  auto attr = getComparisonDirectionAttr();
  return attr;
}

::mlir::Attribute CompareOpV1::getCompareType() {
  auto attr = getCompareTypeAttr();
  return attr;
}

void CompareOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute comparison_direction, ::mlir::Attribute compare_type) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().comparison_direction = comparison_direction;
  odsState.getOrAddProperties<Properties>().compare_type = compare_type;
  odsState.addTypes(result);
}

void CompareOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute comparison_direction, ::mlir::Attribute compare_type) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().comparison_direction = comparison_direction;
  odsState.getOrAddProperties<Properties>().compare_type = compare_type;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CompareOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CompareOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CompareOpV1::verifyInvariantsImpl() {
  auto tblgen_compare_type = getProperties().compare_type; (void)tblgen_compare_type;
  if (!tblgen_compare_type) return emitOpError("requires attribute 'compare_type'");
  auto tblgen_comparison_direction = getProperties().comparison_direction; (void)tblgen_comparison_direction;
  if (!tblgen_comparison_direction) return emitOpError("requires attribute 'comparison_direction'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_comparison_direction, "comparison_direction")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_compare_type, "compare_type")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CompareOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CompareOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CompareOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CompareOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ComplexOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ComplexOpV1Adaptor::ComplexOpV1Adaptor(ComplexOpV1 op) : ComplexOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ComplexOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ComplexOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void ComplexOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ComplexOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ComplexOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ComplexOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ComplexOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ComplexOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ComplexOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CompositeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CompositeOpV1GenericAdaptorBase::CompositeOpV1GenericAdaptorBase(CompositeOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CompositeOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute CompositeOpV1GenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr;
}

::mlir::Attribute CompositeOpV1GenericAdaptorBase::getCompositeAttributes() {
  auto attr = getCompositeAttributesAttr();
  return attr;
}

::mlir::Attribute CompositeOpV1GenericAdaptorBase::getDecomposition() {
  auto attr = getDecompositionAttr();
  return attr;
}

::mlir::Attribute CompositeOpV1GenericAdaptorBase::getVersion() {
  auto attr = getVersionAttr();
  return attr;
}

} // namespace detail
CompositeOpV1Adaptor::CompositeOpV1Adaptor(CompositeOpV1 op) : CompositeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CompositeOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_composite_attributes = getProperties().composite_attributes; (void)tblgen_composite_attributes;
  if (!tblgen_composite_attributes) return emitError(loc, "'vhlo.composite_v1' op ""requires attribute 'composite_attributes'");
  auto tblgen_decomposition = getProperties().decomposition; (void)tblgen_decomposition;
  if (!tblgen_decomposition) return emitError(loc, "'vhlo.composite_v1' op ""requires attribute 'decomposition'");
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  if (!tblgen_name) return emitError(loc, "'vhlo.composite_v1' op ""requires attribute 'name'");
  auto tblgen_version = getProperties().version; (void)tblgen_version;
  if (!tblgen_version) return emitError(loc, "'vhlo.composite_v1' op ""requires attribute 'version'");

  if (tblgen_name && !((true)))
    return emitError(loc, "'vhlo.composite_v1' op ""attribute 'name' failed to satisfy constraint: any attribute");

  if (tblgen_composite_attributes && !((true)))
    return emitError(loc, "'vhlo.composite_v1' op ""attribute 'composite_attributes' failed to satisfy constraint: any attribute");

  if (tblgen_decomposition && !((true)))
    return emitError(loc, "'vhlo.composite_v1' op ""attribute 'decomposition' failed to satisfy constraint: any attribute");

  if (tblgen_version && !((true)))
    return emitError(loc, "'vhlo.composite_v1' op ""attribute 'version' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CompositeOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange CompositeOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CompositeOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult CompositeOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.composite_attributes;
       auto attr = dict.get("composite_attributes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `composite_attributes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.decomposition;
       auto attr = dict.get("decomposition");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `decomposition` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.version;
       auto attr = dict.get("version");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `version` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CompositeOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.composite_attributes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("composite_attributes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.decomposition;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("decomposition",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.version;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("version",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CompositeOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.composite_attributes.getAsOpaquePointer()), 
    llvm::hash_value(prop.decomposition.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.version.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CompositeOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "composite_attributes")
      return prop.composite_attributes;

    if (name == "decomposition")
      return prop.decomposition;

    if (name == "name")
      return prop.name;

    if (name == "version")
      return prop.version;
  return std::nullopt;
}

void CompositeOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "composite_attributes") {
       prop.composite_attributes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.composite_attributes)>>(value);
       return;
    }

    if (name == "decomposition") {
       prop.decomposition = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.decomposition)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "version") {
       prop.version = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.version)>>(value);
       return;
    }
}

void CompositeOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.composite_attributes) attrs.append("composite_attributes", prop.composite_attributes);

    if (prop.decomposition) attrs.append("decomposition", prop.decomposition);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.version) attrs.append("version", prop.version);
}

::llvm::LogicalResult CompositeOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCompositeAttributesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "composite_attributes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDecompositionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "decomposition", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVersionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "version", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CompositeOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.composite_attributes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.decomposition)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.version)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CompositeOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.composite_attributes);
  writer.writeAttribute(prop.decomposition);
  writer.writeAttribute(prop.name);
  writer.writeAttribute(prop.version);
}

::mlir::Attribute CompositeOpV1::getName() {
  auto attr = getNameAttr();
  return attr;
}

::mlir::Attribute CompositeOpV1::getCompositeAttributes() {
  auto attr = getCompositeAttributesAttr();
  return attr;
}

::mlir::Attribute CompositeOpV1::getDecomposition() {
  auto attr = getDecompositionAttr();
  return attr;
}

::mlir::Attribute CompositeOpV1::getVersion() {
  auto attr = getVersionAttr();
  return attr;
}

void CompositeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute name, ::mlir::Attribute composite_attributes, ::mlir::Attribute decomposition, ::mlir::Attribute version) {
  odsState.addOperands(inputs);
  odsState.getOrAddProperties<Properties>().name = name;
  odsState.getOrAddProperties<Properties>().composite_attributes = composite_attributes;
  odsState.getOrAddProperties<Properties>().decomposition = decomposition;
  odsState.getOrAddProperties<Properties>().version = version;
  odsState.addTypes(results);
}

void CompositeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CompositeOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CompositeOpV1::verifyInvariantsImpl() {
  auto tblgen_composite_attributes = getProperties().composite_attributes; (void)tblgen_composite_attributes;
  if (!tblgen_composite_attributes) return emitOpError("requires attribute 'composite_attributes'");
  auto tblgen_decomposition = getProperties().decomposition; (void)tblgen_decomposition;
  if (!tblgen_decomposition) return emitOpError("requires attribute 'decomposition'");
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  if (!tblgen_name) return emitOpError("requires attribute 'name'");
  auto tblgen_version = getProperties().version; (void)tblgen_version;
  if (!tblgen_version) return emitOpError("requires attribute 'version'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_name, "name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_composite_attributes, "composite_attributes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_decomposition, "decomposition")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_version, "version")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CompositeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CompositeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 19, 0);
}
mlir::vhlo::Version CompositeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CompositeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConcatenateOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ConcatenateOpV1GenericAdaptorBase::ConcatenateOpV1GenericAdaptorBase(ConcatenateOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ConcatenateOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute ConcatenateOpV1GenericAdaptorBase::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

} // namespace detail
ConcatenateOpV1Adaptor::ConcatenateOpV1Adaptor(ConcatenateOpV1 op) : ConcatenateOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ConcatenateOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitError(loc, "'vhlo.concatenate_v1' op ""requires attribute 'dimension'");

  if (tblgen_dimension && !((true)))
    return emitError(loc, "'vhlo.concatenate_v1' op ""attribute 'dimension' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ConcatenateOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange ConcatenateOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::llvm::LogicalResult ConcatenateOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dimension;
       auto attr = dict.get("dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ConcatenateOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dimension",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ConcatenateOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dimension.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ConcatenateOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dimension")
      return prop.dimension;
  return std::nullopt;
}

void ConcatenateOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dimension") {
       prop.dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dimension)>>(value);
       return;
    }
}

void ConcatenateOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dimension) attrs.append("dimension", prop.dimension);
}

::llvm::LogicalResult ConcatenateOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dimension", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ConcatenateOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dimension)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConcatenateOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dimension);
}

::mlir::Attribute ConcatenateOpV1::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

void ConcatenateOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Attribute dimension) {
  odsState.addOperands(inputs);
  odsState.getOrAddProperties<Properties>().dimension = dimension;
  odsState.addTypes(result);
}

void ConcatenateOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Attribute dimension) {
  odsState.addOperands(inputs);
  odsState.getOrAddProperties<Properties>().dimension = dimension;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConcatenateOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ConcatenateOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ConcatenateOpV1::verifyInvariantsImpl() {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitOpError("requires attribute 'dimension'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dimension, "dimension")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ConcatenateOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ConcatenateOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ConcatenateOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConcatenateOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConstantOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ConstantOpV1GenericAdaptorBase::ConstantOpV1GenericAdaptorBase(ConstantOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute ConstantOpV1GenericAdaptorBase::getValue() {
  auto attr = getValueAttr();
  return attr;
}

} // namespace detail
ConstantOpV1Adaptor::ConstantOpV1Adaptor(ConstantOpV1 op) : ConstantOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ConstantOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_value = getProperties().value; (void)tblgen_value;
  if (!tblgen_value) return emitError(loc, "'vhlo.constant_v1' op ""requires attribute 'value'");

  if (tblgen_value && !((true)))
    return emitError(loc, "'vhlo.constant_v1' op ""attribute 'value' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ConstantOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.value;
       auto attr = dict.get("value");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `value` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ConstantOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.value;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("value",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ConstantOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.value.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ConstantOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "value")
      return prop.value;
  return std::nullopt;
}

void ConstantOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "value") {
       prop.value = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.value)>>(value);
       return;
    }
}

void ConstantOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.value) attrs.append("value", prop.value);
}

::llvm::LogicalResult ConstantOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getValueAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "value", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ConstantOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.value)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConstantOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.value);
}

::mlir::Attribute ConstantOpV1::getValue() {
  auto attr = getValueAttr();
  return attr;
}

void ConstantOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Attribute value) {
  odsState.getOrAddProperties<Properties>().value = value;
  odsState.addTypes(output);
}

void ConstantOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute value) {
  odsState.getOrAddProperties<Properties>().value = value;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstantOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ConstantOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ConstantOpV1::verifyInvariantsImpl() {
  auto tblgen_value = getProperties().value; (void)tblgen_value;
  if (!tblgen_value) return emitOpError("requires attribute 'value'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_value, "value")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ConstantOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ConstantOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ConstantOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConstantOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConvertOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ConvertOpV1Adaptor::ConvertOpV1Adaptor(ConvertOpV1 op) : ConvertOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ConvertOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ConvertOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ConvertOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConvertOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ConvertOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ConvertOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ConvertOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ConvertOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConvertOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConvolutionOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ConvolutionOpV1GenericAdaptorBase::ConvolutionOpV1GenericAdaptorBase(ConvolutionOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getLhsDilation() {
  auto attr = getLhsDilationAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getRhsDilation() {
  auto attr = getRhsDilationAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getWindowReversal() {
  auto attr = getWindowReversalAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getInputBatchDimension() {
  auto attr = getInputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getInputFeatureDimension() {
  auto attr = getInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getInputSpatialDimensions() {
  auto attr = getInputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getKernelInputFeatureDimension() {
  auto attr = getKernelInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getKernelOutputFeatureDimension() {
  auto attr = getKernelOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getKernelSpatialDimensions() {
  auto attr = getKernelSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getOutputBatchDimension() {
  auto attr = getOutputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getOutputFeatureDimension() {
  auto attr = getOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getOutputSpatialDimensions() {
  auto attr = getOutputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getFeatureGroupCount() {
  auto attr = getFeatureGroupCountAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getBatchGroupCount() {
  auto attr = getBatchGroupCountAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1GenericAdaptorBase::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

} // namespace detail
ConvolutionOpV1Adaptor::ConvolutionOpV1Adaptor(ConvolutionOpV1 op) : ConvolutionOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ConvolutionOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_batch_group_count = getProperties().batch_group_count; (void)tblgen_batch_group_count;
  if (!tblgen_batch_group_count) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'batch_group_count'");
  auto tblgen_feature_group_count = getProperties().feature_group_count; (void)tblgen_feature_group_count;
  if (!tblgen_feature_group_count) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'feature_group_count'");
  auto tblgen_input_batch_dimension = getProperties().input_batch_dimension; (void)tblgen_input_batch_dimension;
  if (!tblgen_input_batch_dimension) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'input_batch_dimension'");
  auto tblgen_input_feature_dimension = getProperties().input_feature_dimension; (void)tblgen_input_feature_dimension;
  if (!tblgen_input_feature_dimension) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'input_feature_dimension'");
  auto tblgen_input_spatial_dimensions = getProperties().input_spatial_dimensions; (void)tblgen_input_spatial_dimensions;
  if (!tblgen_input_spatial_dimensions) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'input_spatial_dimensions'");
  auto tblgen_kernel_input_feature_dimension = getProperties().kernel_input_feature_dimension; (void)tblgen_kernel_input_feature_dimension;
  if (!tblgen_kernel_input_feature_dimension) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'kernel_input_feature_dimension'");
  auto tblgen_kernel_output_feature_dimension = getProperties().kernel_output_feature_dimension; (void)tblgen_kernel_output_feature_dimension;
  if (!tblgen_kernel_output_feature_dimension) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'kernel_output_feature_dimension'");
  auto tblgen_kernel_spatial_dimensions = getProperties().kernel_spatial_dimensions; (void)tblgen_kernel_spatial_dimensions;
  if (!tblgen_kernel_spatial_dimensions) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'kernel_spatial_dimensions'");
  auto tblgen_lhs_dilation = getProperties().lhs_dilation; (void)tblgen_lhs_dilation;
  if (!tblgen_lhs_dilation) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'lhs_dilation'");
  auto tblgen_output_batch_dimension = getProperties().output_batch_dimension; (void)tblgen_output_batch_dimension;
  if (!tblgen_output_batch_dimension) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'output_batch_dimension'");
  auto tblgen_output_feature_dimension = getProperties().output_feature_dimension; (void)tblgen_output_feature_dimension;
  if (!tblgen_output_feature_dimension) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'output_feature_dimension'");
  auto tblgen_output_spatial_dimensions = getProperties().output_spatial_dimensions; (void)tblgen_output_spatial_dimensions;
  if (!tblgen_output_spatial_dimensions) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'output_spatial_dimensions'");
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'padding'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'precision_config'");
  auto tblgen_rhs_dilation = getProperties().rhs_dilation; (void)tblgen_rhs_dilation;
  if (!tblgen_rhs_dilation) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'rhs_dilation'");
  auto tblgen_window_reversal = getProperties().window_reversal; (void)tblgen_window_reversal;
  if (!tblgen_window_reversal) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'window_reversal'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitError(loc, "'vhlo.convolution_v1' op ""requires attribute 'window_strides'");

  if (tblgen_window_strides && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'window_strides' failed to satisfy constraint: any attribute");

  if (tblgen_padding && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'padding' failed to satisfy constraint: any attribute");

  if (tblgen_lhs_dilation && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'lhs_dilation' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_dilation && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'rhs_dilation' failed to satisfy constraint: any attribute");

  if (tblgen_window_reversal && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'window_reversal' failed to satisfy constraint: any attribute");

  if (tblgen_input_batch_dimension && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'input_batch_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_input_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'input_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_input_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'input_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_input_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'kernel_input_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_output_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'kernel_output_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'kernel_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_output_batch_dimension && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'output_batch_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_output_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'output_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_output_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'output_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_feature_group_count && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'feature_group_count' failed to satisfy constraint: any attribute");

  if (tblgen_batch_group_count && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'batch_group_count' failed to satisfy constraint: any attribute");

  if (tblgen_precision_config && !((true)))
    return emitError(loc, "'vhlo.convolution_v1' op ""attribute 'precision_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ConvolutionOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.batch_group_count;
       auto attr = dict.get("batch_group_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `batch_group_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.feature_group_count;
       auto attr = dict.get("feature_group_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `feature_group_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_batch_dimension;
       auto attr = dict.get("input_batch_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_batch_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_feature_dimension;
       auto attr = dict.get("input_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_spatial_dimensions;
       auto attr = dict.get("input_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_input_feature_dimension;
       auto attr = dict.get("kernel_input_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_input_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_output_feature_dimension;
       auto attr = dict.get("kernel_output_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_output_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_spatial_dimensions;
       auto attr = dict.get("kernel_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_dilation;
       auto attr = dict.get("lhs_dilation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_dilation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_batch_dimension;
       auto attr = dict.get("output_batch_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_batch_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_feature_dimension;
       auto attr = dict.get("output_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_spatial_dimensions;
       auto attr = dict.get("output_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.padding;
       auto attr = dict.get("padding");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `padding` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.precision_config;
       auto attr = dict.get("precision_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `precision_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_dilation;
       auto attr = dict.get("rhs_dilation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_dilation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_reversal;
       auto attr = dict.get("window_reversal");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_reversal` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_strides;
       auto attr = dict.get("window_strides");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_strides` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ConvolutionOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.batch_group_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("batch_group_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.feature_group_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("feature_group_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_batch_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_batch_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_input_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_input_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_output_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_output_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_dilation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_dilation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_batch_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_batch_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.padding;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("padding",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.precision_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("precision_config",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_dilation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_dilation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_reversal;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_reversal",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_strides;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_strides",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ConvolutionOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.batch_group_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.feature_group_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_batch_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_input_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_output_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_dilation.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_batch_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.padding.getAsOpaquePointer()), 
    llvm::hash_value(prop.precision_config.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_dilation.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_reversal.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_strides.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ConvolutionOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "batch_group_count")
      return prop.batch_group_count;

    if (name == "feature_group_count")
      return prop.feature_group_count;

    if (name == "input_batch_dimension")
      return prop.input_batch_dimension;

    if (name == "input_feature_dimension")
      return prop.input_feature_dimension;

    if (name == "input_spatial_dimensions")
      return prop.input_spatial_dimensions;

    if (name == "kernel_input_feature_dimension")
      return prop.kernel_input_feature_dimension;

    if (name == "kernel_output_feature_dimension")
      return prop.kernel_output_feature_dimension;

    if (name == "kernel_spatial_dimensions")
      return prop.kernel_spatial_dimensions;

    if (name == "lhs_dilation")
      return prop.lhs_dilation;

    if (name == "output_batch_dimension")
      return prop.output_batch_dimension;

    if (name == "output_feature_dimension")
      return prop.output_feature_dimension;

    if (name == "output_spatial_dimensions")
      return prop.output_spatial_dimensions;

    if (name == "padding")
      return prop.padding;

    if (name == "precision_config")
      return prop.precision_config;

    if (name == "rhs_dilation")
      return prop.rhs_dilation;

    if (name == "window_reversal")
      return prop.window_reversal;

    if (name == "window_strides")
      return prop.window_strides;
  return std::nullopt;
}

void ConvolutionOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "batch_group_count") {
       prop.batch_group_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.batch_group_count)>>(value);
       return;
    }

    if (name == "feature_group_count") {
       prop.feature_group_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.feature_group_count)>>(value);
       return;
    }

    if (name == "input_batch_dimension") {
       prop.input_batch_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_batch_dimension)>>(value);
       return;
    }

    if (name == "input_feature_dimension") {
       prop.input_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_feature_dimension)>>(value);
       return;
    }

    if (name == "input_spatial_dimensions") {
       prop.input_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_spatial_dimensions)>>(value);
       return;
    }

    if (name == "kernel_input_feature_dimension") {
       prop.kernel_input_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_input_feature_dimension)>>(value);
       return;
    }

    if (name == "kernel_output_feature_dimension") {
       prop.kernel_output_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_output_feature_dimension)>>(value);
       return;
    }

    if (name == "kernel_spatial_dimensions") {
       prop.kernel_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_spatial_dimensions)>>(value);
       return;
    }

    if (name == "lhs_dilation") {
       prop.lhs_dilation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_dilation)>>(value);
       return;
    }

    if (name == "output_batch_dimension") {
       prop.output_batch_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_batch_dimension)>>(value);
       return;
    }

    if (name == "output_feature_dimension") {
       prop.output_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_feature_dimension)>>(value);
       return;
    }

    if (name == "output_spatial_dimensions") {
       prop.output_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_spatial_dimensions)>>(value);
       return;
    }

    if (name == "padding") {
       prop.padding = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.padding)>>(value);
       return;
    }

    if (name == "precision_config") {
       prop.precision_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.precision_config)>>(value);
       return;
    }

    if (name == "rhs_dilation") {
       prop.rhs_dilation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_dilation)>>(value);
       return;
    }

    if (name == "window_reversal") {
       prop.window_reversal = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_reversal)>>(value);
       return;
    }

    if (name == "window_strides") {
       prop.window_strides = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_strides)>>(value);
       return;
    }
}

void ConvolutionOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.batch_group_count) attrs.append("batch_group_count", prop.batch_group_count);

    if (prop.feature_group_count) attrs.append("feature_group_count", prop.feature_group_count);

    if (prop.input_batch_dimension) attrs.append("input_batch_dimension", prop.input_batch_dimension);

    if (prop.input_feature_dimension) attrs.append("input_feature_dimension", prop.input_feature_dimension);

    if (prop.input_spatial_dimensions) attrs.append("input_spatial_dimensions", prop.input_spatial_dimensions);

    if (prop.kernel_input_feature_dimension) attrs.append("kernel_input_feature_dimension", prop.kernel_input_feature_dimension);

    if (prop.kernel_output_feature_dimension) attrs.append("kernel_output_feature_dimension", prop.kernel_output_feature_dimension);

    if (prop.kernel_spatial_dimensions) attrs.append("kernel_spatial_dimensions", prop.kernel_spatial_dimensions);

    if (prop.lhs_dilation) attrs.append("lhs_dilation", prop.lhs_dilation);

    if (prop.output_batch_dimension) attrs.append("output_batch_dimension", prop.output_batch_dimension);

    if (prop.output_feature_dimension) attrs.append("output_feature_dimension", prop.output_feature_dimension);

    if (prop.output_spatial_dimensions) attrs.append("output_spatial_dimensions", prop.output_spatial_dimensions);

    if (prop.padding) attrs.append("padding", prop.padding);

    if (prop.precision_config) attrs.append("precision_config", prop.precision_config);

    if (prop.rhs_dilation) attrs.append("rhs_dilation", prop.rhs_dilation);

    if (prop.window_reversal) attrs.append("window_reversal", prop.window_reversal);

    if (prop.window_strides) attrs.append("window_strides", prop.window_strides);
}

::llvm::LogicalResult ConvolutionOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBatchGroupCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "batch_group_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFeatureGroupCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "feature_group_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputBatchDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_batch_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelInputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_input_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelOutputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_output_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsDilationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_dilation", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputBatchDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_batch_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPaddingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "padding", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrecisionConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "precision_config", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsDilationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_dilation", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowReversalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_reversal", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowStridesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_strides", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ConvolutionOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.batch_group_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.feature_group_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_batch_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_input_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_output_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_dilation)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_batch_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.padding)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.precision_config)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_dilation)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_reversal)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_strides)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConvolutionOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.batch_group_count);
  writer.writeAttribute(prop.feature_group_count);
  writer.writeAttribute(prop.input_batch_dimension);
  writer.writeAttribute(prop.input_feature_dimension);
  writer.writeAttribute(prop.input_spatial_dimensions);
  writer.writeAttribute(prop.kernel_input_feature_dimension);
  writer.writeAttribute(prop.kernel_output_feature_dimension);
  writer.writeAttribute(prop.kernel_spatial_dimensions);
  writer.writeAttribute(prop.lhs_dilation);
  writer.writeAttribute(prop.output_batch_dimension);
  writer.writeAttribute(prop.output_feature_dimension);
  writer.writeAttribute(prop.output_spatial_dimensions);
  writer.writeAttribute(prop.padding);
  writer.writeAttribute(prop.precision_config);
  writer.writeAttribute(prop.rhs_dilation);
  writer.writeAttribute(prop.window_reversal);
  writer.writeAttribute(prop.window_strides);
}

::mlir::Attribute ConvolutionOpV1::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getLhsDilation() {
  auto attr = getLhsDilationAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getRhsDilation() {
  auto attr = getRhsDilationAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getWindowReversal() {
  auto attr = getWindowReversalAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getInputBatchDimension() {
  auto attr = getInputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getInputFeatureDimension() {
  auto attr = getInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getInputSpatialDimensions() {
  auto attr = getInputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getKernelInputFeatureDimension() {
  auto attr = getKernelInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getKernelOutputFeatureDimension() {
  auto attr = getKernelOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getKernelSpatialDimensions() {
  auto attr = getKernelSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getOutputBatchDimension() {
  auto attr = getOutputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getOutputFeatureDimension() {
  auto attr = getOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getOutputSpatialDimensions() {
  auto attr = getOutputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getFeatureGroupCount() {
  auto attr = getFeatureGroupCountAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getBatchGroupCount() {
  auto attr = getBatchGroupCountAttr();
  return attr;
}

::mlir::Attribute ConvolutionOpV1::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

void ConvolutionOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().padding = padding;
  odsState.getOrAddProperties<Properties>().lhs_dilation = lhs_dilation;
  odsState.getOrAddProperties<Properties>().rhs_dilation = rhs_dilation;
  odsState.getOrAddProperties<Properties>().window_reversal = window_reversal;
  odsState.getOrAddProperties<Properties>().input_batch_dimension = input_batch_dimension;
  odsState.getOrAddProperties<Properties>().input_feature_dimension = input_feature_dimension;
  odsState.getOrAddProperties<Properties>().input_spatial_dimensions = input_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().kernel_input_feature_dimension = kernel_input_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_output_feature_dimension = kernel_output_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_spatial_dimensions = kernel_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().output_batch_dimension = output_batch_dimension;
  odsState.getOrAddProperties<Properties>().output_feature_dimension = output_feature_dimension;
  odsState.getOrAddProperties<Properties>().output_spatial_dimensions = output_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().feature_group_count = feature_group_count;
  odsState.getOrAddProperties<Properties>().batch_group_count = batch_group_count;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  odsState.addTypes(result);
}

void ConvolutionOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().padding = padding;
  odsState.getOrAddProperties<Properties>().lhs_dilation = lhs_dilation;
  odsState.getOrAddProperties<Properties>().rhs_dilation = rhs_dilation;
  odsState.getOrAddProperties<Properties>().window_reversal = window_reversal;
  odsState.getOrAddProperties<Properties>().input_batch_dimension = input_batch_dimension;
  odsState.getOrAddProperties<Properties>().input_feature_dimension = input_feature_dimension;
  odsState.getOrAddProperties<Properties>().input_spatial_dimensions = input_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().kernel_input_feature_dimension = kernel_input_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_output_feature_dimension = kernel_output_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_spatial_dimensions = kernel_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().output_batch_dimension = output_batch_dimension;
  odsState.getOrAddProperties<Properties>().output_feature_dimension = output_feature_dimension;
  odsState.getOrAddProperties<Properties>().output_spatial_dimensions = output_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().feature_group_count = feature_group_count;
  odsState.getOrAddProperties<Properties>().batch_group_count = batch_group_count;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConvolutionOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ConvolutionOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ConvolutionOpV1::verifyInvariantsImpl() {
  auto tblgen_batch_group_count = getProperties().batch_group_count; (void)tblgen_batch_group_count;
  if (!tblgen_batch_group_count) return emitOpError("requires attribute 'batch_group_count'");
  auto tblgen_feature_group_count = getProperties().feature_group_count; (void)tblgen_feature_group_count;
  if (!tblgen_feature_group_count) return emitOpError("requires attribute 'feature_group_count'");
  auto tblgen_input_batch_dimension = getProperties().input_batch_dimension; (void)tblgen_input_batch_dimension;
  if (!tblgen_input_batch_dimension) return emitOpError("requires attribute 'input_batch_dimension'");
  auto tblgen_input_feature_dimension = getProperties().input_feature_dimension; (void)tblgen_input_feature_dimension;
  if (!tblgen_input_feature_dimension) return emitOpError("requires attribute 'input_feature_dimension'");
  auto tblgen_input_spatial_dimensions = getProperties().input_spatial_dimensions; (void)tblgen_input_spatial_dimensions;
  if (!tblgen_input_spatial_dimensions) return emitOpError("requires attribute 'input_spatial_dimensions'");
  auto tblgen_kernel_input_feature_dimension = getProperties().kernel_input_feature_dimension; (void)tblgen_kernel_input_feature_dimension;
  if (!tblgen_kernel_input_feature_dimension) return emitOpError("requires attribute 'kernel_input_feature_dimension'");
  auto tblgen_kernel_output_feature_dimension = getProperties().kernel_output_feature_dimension; (void)tblgen_kernel_output_feature_dimension;
  if (!tblgen_kernel_output_feature_dimension) return emitOpError("requires attribute 'kernel_output_feature_dimension'");
  auto tblgen_kernel_spatial_dimensions = getProperties().kernel_spatial_dimensions; (void)tblgen_kernel_spatial_dimensions;
  if (!tblgen_kernel_spatial_dimensions) return emitOpError("requires attribute 'kernel_spatial_dimensions'");
  auto tblgen_lhs_dilation = getProperties().lhs_dilation; (void)tblgen_lhs_dilation;
  if (!tblgen_lhs_dilation) return emitOpError("requires attribute 'lhs_dilation'");
  auto tblgen_output_batch_dimension = getProperties().output_batch_dimension; (void)tblgen_output_batch_dimension;
  if (!tblgen_output_batch_dimension) return emitOpError("requires attribute 'output_batch_dimension'");
  auto tblgen_output_feature_dimension = getProperties().output_feature_dimension; (void)tblgen_output_feature_dimension;
  if (!tblgen_output_feature_dimension) return emitOpError("requires attribute 'output_feature_dimension'");
  auto tblgen_output_spatial_dimensions = getProperties().output_spatial_dimensions; (void)tblgen_output_spatial_dimensions;
  if (!tblgen_output_spatial_dimensions) return emitOpError("requires attribute 'output_spatial_dimensions'");
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitOpError("requires attribute 'padding'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitOpError("requires attribute 'precision_config'");
  auto tblgen_rhs_dilation = getProperties().rhs_dilation; (void)tblgen_rhs_dilation;
  if (!tblgen_rhs_dilation) return emitOpError("requires attribute 'rhs_dilation'");
  auto tblgen_window_reversal = getProperties().window_reversal; (void)tblgen_window_reversal;
  if (!tblgen_window_reversal) return emitOpError("requires attribute 'window_reversal'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitOpError("requires attribute 'window_strides'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_strides, "window_strides")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_padding, "padding")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_dilation, "lhs_dilation")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_dilation, "rhs_dilation")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_reversal, "window_reversal")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_batch_dimension, "input_batch_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_feature_dimension, "input_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_spatial_dimensions, "input_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_input_feature_dimension, "kernel_input_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_output_feature_dimension, "kernel_output_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_spatial_dimensions, "kernel_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_batch_dimension, "output_batch_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_feature_dimension, "output_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_spatial_dimensions, "output_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_feature_group_count, "feature_group_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_batch_group_count, "batch_group_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_precision_config, "precision_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ConvolutionOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ConvolutionOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ConvolutionOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConvolutionOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CosineOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
CosineOpV1Adaptor::CosineOpV1Adaptor(CosineOpV1 op) : CosineOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CosineOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void CosineOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void CosineOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CosineOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult CosineOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CosineOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CosineOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CosineOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CosineOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CreateTokenOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
CreateTokenOpV1Adaptor::CreateTokenOpV1Adaptor(CreateTokenOpV1 op) : CreateTokenOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CreateTokenOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void CreateTokenOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output) {
  odsState.addTypes(output);
}

void CreateTokenOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateTokenOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult CreateTokenOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CreateTokenOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CreateTokenOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CreateTokenOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CreateTokenOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CrossReplicaSumOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CrossReplicaSumOpV1GenericAdaptorBase::CrossReplicaSumOpV1GenericAdaptorBase(CrossReplicaSumOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute CrossReplicaSumOpV1GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

} // namespace detail
CrossReplicaSumOpV1Adaptor::CrossReplicaSumOpV1Adaptor(CrossReplicaSumOpV1 op) : CrossReplicaSumOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CrossReplicaSumOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.cross-replica-sum_v1' op ""requires attribute 'replica_groups'");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.cross-replica-sum_v1' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult CrossReplicaSumOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CrossReplicaSumOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CrossReplicaSumOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CrossReplicaSumOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "replica_groups")
      return prop.replica_groups;
  return std::nullopt;
}

void CrossReplicaSumOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }
}

void CrossReplicaSumOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);
}

::llvm::LogicalResult CrossReplicaSumOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CrossReplicaSumOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CrossReplicaSumOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.replica_groups);
}

::mlir::Attribute CrossReplicaSumOpV1::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

void CrossReplicaSumOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.addTypes(result);
}

void CrossReplicaSumOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CrossReplicaSumOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CrossReplicaSumOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CrossReplicaSumOpV1::verifyInvariantsImpl() {
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CrossReplicaSumOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CrossReplicaSumOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CrossReplicaSumOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CrossReplicaSumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CustomCallOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
CustomCallOpV1GenericAdaptorBase::CustomCallOpV1GenericAdaptorBase(CustomCallOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CustomCallOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getCallTargetName() {
  auto attr = getCallTargetNameAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getHasSideEffect() {
  auto attr = getHasSideEffectAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getBackendConfig() {
  auto attr = getBackendConfigAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getApiVersion() {
  auto attr = getApiVersionAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getCalledComputations() {
  auto attr = getCalledComputationsAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getOperandLayouts() {
  auto attr = getOperandLayoutsAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getResultLayouts() {
  auto attr = getResultLayoutsAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1GenericAdaptorBase::getOutputOperandAliases() {
  auto attr = getOutputOperandAliasesAttr();
  return attr;
}

} // namespace detail
CustomCallOpV1Adaptor::CustomCallOpV1Adaptor(CustomCallOpV1 op) : CustomCallOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CustomCallOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_api_version = getProperties().api_version; (void)tblgen_api_version;
  if (!tblgen_api_version) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'api_version'");
  auto tblgen_backend_config = getProperties().backend_config; (void)tblgen_backend_config;
  if (!tblgen_backend_config) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'backend_config'");
  auto tblgen_call_target_name = getProperties().call_target_name; (void)tblgen_call_target_name;
  if (!tblgen_call_target_name) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'call_target_name'");
  auto tblgen_called_computations = getProperties().called_computations; (void)tblgen_called_computations;
  if (!tblgen_called_computations) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'called_computations'");
  auto tblgen_has_side_effect = getProperties().has_side_effect; (void)tblgen_has_side_effect;
  if (!tblgen_has_side_effect) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'has_side_effect'");
  auto tblgen_operand_layouts = getProperties().operand_layouts; (void)tblgen_operand_layouts;
  if (!tblgen_operand_layouts) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'operand_layouts'");
  auto tblgen_output_operand_aliases = getProperties().output_operand_aliases; (void)tblgen_output_operand_aliases;
  if (!tblgen_output_operand_aliases) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'output_operand_aliases'");
  auto tblgen_result_layouts = getProperties().result_layouts; (void)tblgen_result_layouts;
  if (!tblgen_result_layouts) return emitError(loc, "'vhlo.custom_call_v1' op ""requires attribute 'result_layouts'");

  if (tblgen_call_target_name && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'call_target_name' failed to satisfy constraint: any attribute");

  if (tblgen_has_side_effect && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'has_side_effect' failed to satisfy constraint: any attribute");

  if (tblgen_backend_config && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'backend_config' failed to satisfy constraint: any attribute");

  if (tblgen_api_version && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'api_version' failed to satisfy constraint: any attribute");

  if (tblgen_called_computations && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'called_computations' failed to satisfy constraint: any attribute");

  if (tblgen_operand_layouts && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'operand_layouts' failed to satisfy constraint: any attribute");

  if (tblgen_result_layouts && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'result_layouts' failed to satisfy constraint: any attribute");

  if (tblgen_output_operand_aliases && !((true)))
    return emitError(loc, "'vhlo.custom_call_v1' op ""attribute 'output_operand_aliases' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CustomCallOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange CustomCallOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CustomCallOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult CustomCallOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.api_version;
       auto attr = dict.get("api_version");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `api_version` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.backend_config;
       auto attr = dict.get("backend_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `backend_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.call_target_name;
       auto attr = dict.get("call_target_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `call_target_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.called_computations;
       auto attr = dict.get("called_computations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `called_computations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.has_side_effect;
       auto attr = dict.get("has_side_effect");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `has_side_effect` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.operand_layouts;
       auto attr = dict.get("operand_layouts");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `operand_layouts` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_operand_aliases;
       auto attr = dict.get("output_operand_aliases");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_operand_aliases` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.result_layouts;
       auto attr = dict.get("result_layouts");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `result_layouts` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute CustomCallOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.api_version;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("api_version",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.backend_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("backend_config",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.call_target_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("call_target_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.called_computations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("called_computations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.has_side_effect;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("has_side_effect",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operand_layouts;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("operand_layouts",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_operand_aliases;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_operand_aliases",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.result_layouts;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("result_layouts",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CustomCallOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.api_version.getAsOpaquePointer()), 
    llvm::hash_value(prop.backend_config.getAsOpaquePointer()), 
    llvm::hash_value(prop.call_target_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.called_computations.getAsOpaquePointer()), 
    llvm::hash_value(prop.has_side_effect.getAsOpaquePointer()), 
    llvm::hash_value(prop.operand_layouts.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_operand_aliases.getAsOpaquePointer()), 
    llvm::hash_value(prop.result_layouts.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> CustomCallOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "api_version")
      return prop.api_version;

    if (name == "backend_config")
      return prop.backend_config;

    if (name == "call_target_name")
      return prop.call_target_name;

    if (name == "called_computations")
      return prop.called_computations;

    if (name == "has_side_effect")
      return prop.has_side_effect;

    if (name == "operand_layouts")
      return prop.operand_layouts;

    if (name == "output_operand_aliases")
      return prop.output_operand_aliases;

    if (name == "result_layouts")
      return prop.result_layouts;
  return std::nullopt;
}

void CustomCallOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "api_version") {
       prop.api_version = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.api_version)>>(value);
       return;
    }

    if (name == "backend_config") {
       prop.backend_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.backend_config)>>(value);
       return;
    }

    if (name == "call_target_name") {
       prop.call_target_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.call_target_name)>>(value);
       return;
    }

    if (name == "called_computations") {
       prop.called_computations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.called_computations)>>(value);
       return;
    }

    if (name == "has_side_effect") {
       prop.has_side_effect = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.has_side_effect)>>(value);
       return;
    }

    if (name == "operand_layouts") {
       prop.operand_layouts = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.operand_layouts)>>(value);
       return;
    }

    if (name == "output_operand_aliases") {
       prop.output_operand_aliases = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_operand_aliases)>>(value);
       return;
    }

    if (name == "result_layouts") {
       prop.result_layouts = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.result_layouts)>>(value);
       return;
    }
}

void CustomCallOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.api_version) attrs.append("api_version", prop.api_version);

    if (prop.backend_config) attrs.append("backend_config", prop.backend_config);

    if (prop.call_target_name) attrs.append("call_target_name", prop.call_target_name);

    if (prop.called_computations) attrs.append("called_computations", prop.called_computations);

    if (prop.has_side_effect) attrs.append("has_side_effect", prop.has_side_effect);

    if (prop.operand_layouts) attrs.append("operand_layouts", prop.operand_layouts);

    if (prop.output_operand_aliases) attrs.append("output_operand_aliases", prop.output_operand_aliases);

    if (prop.result_layouts) attrs.append("result_layouts", prop.result_layouts);
}

::llvm::LogicalResult CustomCallOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getApiVersionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "api_version", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getBackendConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "backend_config", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCallTargetNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "call_target_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCalledComputationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "called_computations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getHasSideEffectAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "has_side_effect", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOperandLayoutsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "operand_layouts", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputOperandAliasesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_operand_aliases", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getResultLayoutsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "result_layouts", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CustomCallOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.api_version)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.backend_config)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.call_target_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.called_computations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.has_side_effect)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.operand_layouts)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_operand_aliases)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.result_layouts)))
    return ::mlir::failure();
  return ::mlir::success();
}

void CustomCallOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.api_version);
  writer.writeAttribute(prop.backend_config);
  writer.writeAttribute(prop.call_target_name);
  writer.writeAttribute(prop.called_computations);
  writer.writeAttribute(prop.has_side_effect);
  writer.writeAttribute(prop.operand_layouts);
  writer.writeAttribute(prop.output_operand_aliases);
  writer.writeAttribute(prop.result_layouts);
}

::mlir::Attribute CustomCallOpV1::getCallTargetName() {
  auto attr = getCallTargetNameAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1::getHasSideEffect() {
  auto attr = getHasSideEffectAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1::getBackendConfig() {
  auto attr = getBackendConfigAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1::getApiVersion() {
  auto attr = getApiVersionAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1::getCalledComputations() {
  auto attr = getCalledComputationsAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1::getOperandLayouts() {
  auto attr = getOperandLayoutsAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1::getResultLayouts() {
  auto attr = getResultLayoutsAttr();
  return attr;
}

::mlir::Attribute CustomCallOpV1::getOutputOperandAliases() {
  auto attr = getOutputOperandAliasesAttr();
  return attr;
}

void CustomCallOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute call_target_name, ::mlir::Attribute has_side_effect, ::mlir::Attribute backend_config, ::mlir::Attribute api_version, ::mlir::Attribute called_computations, ::mlir::Attribute operand_layouts, ::mlir::Attribute result_layouts, ::mlir::Attribute output_operand_aliases) {
  odsState.addOperands(inputs);
  odsState.getOrAddProperties<Properties>().call_target_name = call_target_name;
  odsState.getOrAddProperties<Properties>().has_side_effect = has_side_effect;
  odsState.getOrAddProperties<Properties>().backend_config = backend_config;
  odsState.getOrAddProperties<Properties>().api_version = api_version;
  odsState.getOrAddProperties<Properties>().called_computations = called_computations;
  odsState.getOrAddProperties<Properties>().operand_layouts = operand_layouts;
  odsState.getOrAddProperties<Properties>().result_layouts = result_layouts;
  odsState.getOrAddProperties<Properties>().output_operand_aliases = output_operand_aliases;
  odsState.addTypes(results);
}

void CustomCallOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CustomCallOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult CustomCallOpV1::verifyInvariantsImpl() {
  auto tblgen_api_version = getProperties().api_version; (void)tblgen_api_version;
  if (!tblgen_api_version) return emitOpError("requires attribute 'api_version'");
  auto tblgen_backend_config = getProperties().backend_config; (void)tblgen_backend_config;
  if (!tblgen_backend_config) return emitOpError("requires attribute 'backend_config'");
  auto tblgen_call_target_name = getProperties().call_target_name; (void)tblgen_call_target_name;
  if (!tblgen_call_target_name) return emitOpError("requires attribute 'call_target_name'");
  auto tblgen_called_computations = getProperties().called_computations; (void)tblgen_called_computations;
  if (!tblgen_called_computations) return emitOpError("requires attribute 'called_computations'");
  auto tblgen_has_side_effect = getProperties().has_side_effect; (void)tblgen_has_side_effect;
  if (!tblgen_has_side_effect) return emitOpError("requires attribute 'has_side_effect'");
  auto tblgen_operand_layouts = getProperties().operand_layouts; (void)tblgen_operand_layouts;
  if (!tblgen_operand_layouts) return emitOpError("requires attribute 'operand_layouts'");
  auto tblgen_output_operand_aliases = getProperties().output_operand_aliases; (void)tblgen_output_operand_aliases;
  if (!tblgen_output_operand_aliases) return emitOpError("requires attribute 'output_operand_aliases'");
  auto tblgen_result_layouts = getProperties().result_layouts; (void)tblgen_result_layouts;
  if (!tblgen_result_layouts) return emitOpError("requires attribute 'result_layouts'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_call_target_name, "call_target_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_has_side_effect, "has_side_effect")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_backend_config, "backend_config")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_api_version, "api_version")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_called_computations, "called_computations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_operand_layouts, "operand_layouts")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_result_layouts, "result_layouts")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_operand_aliases, "output_operand_aliases")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CustomCallOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version CustomCallOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version CustomCallOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::CustomCallOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DivOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
DivOpV1Adaptor::DivOpV1Adaptor(DivOpV1 op) : DivOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DivOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void DivOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void DivOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DivOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult DivOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DivOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DivOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DivOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DivOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotGeneralOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DotGeneralOpV1GenericAdaptorBase::DotGeneralOpV1GenericAdaptorBase(DotGeneralOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DotGeneralOpV1GenericAdaptorBase::getLhsBatchingDimensions() {
  auto attr = getLhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1GenericAdaptorBase::getRhsBatchingDimensions() {
  auto attr = getRhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1GenericAdaptorBase::getLhsContractingDimensions() {
  auto attr = getLhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1GenericAdaptorBase::getRhsContractingDimensions() {
  auto attr = getRhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1GenericAdaptorBase::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

} // namespace detail
DotGeneralOpV1Adaptor::DotGeneralOpV1Adaptor(DotGeneralOpV1 op) : DotGeneralOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DotGeneralOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_lhs_batching_dimensions = getProperties().lhs_batching_dimensions; (void)tblgen_lhs_batching_dimensions;
  if (!tblgen_lhs_batching_dimensions) return emitError(loc, "'vhlo.dot_general_v1' op ""requires attribute 'lhs_batching_dimensions'");
  auto tblgen_lhs_contracting_dimensions = getProperties().lhs_contracting_dimensions; (void)tblgen_lhs_contracting_dimensions;
  if (!tblgen_lhs_contracting_dimensions) return emitError(loc, "'vhlo.dot_general_v1' op ""requires attribute 'lhs_contracting_dimensions'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitError(loc, "'vhlo.dot_general_v1' op ""requires attribute 'precision_config'");
  auto tblgen_rhs_batching_dimensions = getProperties().rhs_batching_dimensions; (void)tblgen_rhs_batching_dimensions;
  if (!tblgen_rhs_batching_dimensions) return emitError(loc, "'vhlo.dot_general_v1' op ""requires attribute 'rhs_batching_dimensions'");
  auto tblgen_rhs_contracting_dimensions = getProperties().rhs_contracting_dimensions; (void)tblgen_rhs_contracting_dimensions;
  if (!tblgen_rhs_contracting_dimensions) return emitError(loc, "'vhlo.dot_general_v1' op ""requires attribute 'rhs_contracting_dimensions'");

  if (tblgen_lhs_batching_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v1' op ""attribute 'lhs_batching_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_batching_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v1' op ""attribute 'rhs_batching_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_lhs_contracting_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v1' op ""attribute 'lhs_contracting_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_contracting_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v1' op ""attribute 'rhs_contracting_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_precision_config && !((true)))
    return emitError(loc, "'vhlo.dot_general_v1' op ""attribute 'precision_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DotGeneralOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.lhs_batching_dimensions;
       auto attr = dict.get("lhs_batching_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_batching_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_contracting_dimensions;
       auto attr = dict.get("lhs_contracting_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_contracting_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.precision_config;
       auto attr = dict.get("precision_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `precision_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_batching_dimensions;
       auto attr = dict.get("rhs_batching_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_batching_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_contracting_dimensions;
       auto attr = dict.get("rhs_contracting_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_contracting_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DotGeneralOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.lhs_batching_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_batching_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_contracting_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_contracting_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.precision_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("precision_config",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_batching_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_batching_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_contracting_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_contracting_dimensions",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DotGeneralOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.lhs_batching_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_contracting_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.precision_config.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_batching_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_contracting_dimensions.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DotGeneralOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "lhs_batching_dimensions")
      return prop.lhs_batching_dimensions;

    if (name == "lhs_contracting_dimensions")
      return prop.lhs_contracting_dimensions;

    if (name == "precision_config")
      return prop.precision_config;

    if (name == "rhs_batching_dimensions")
      return prop.rhs_batching_dimensions;

    if (name == "rhs_contracting_dimensions")
      return prop.rhs_contracting_dimensions;
  return std::nullopt;
}

void DotGeneralOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "lhs_batching_dimensions") {
       prop.lhs_batching_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_batching_dimensions)>>(value);
       return;
    }

    if (name == "lhs_contracting_dimensions") {
       prop.lhs_contracting_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_contracting_dimensions)>>(value);
       return;
    }

    if (name == "precision_config") {
       prop.precision_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.precision_config)>>(value);
       return;
    }

    if (name == "rhs_batching_dimensions") {
       prop.rhs_batching_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_batching_dimensions)>>(value);
       return;
    }

    if (name == "rhs_contracting_dimensions") {
       prop.rhs_contracting_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_contracting_dimensions)>>(value);
       return;
    }
}

void DotGeneralOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.lhs_batching_dimensions) attrs.append("lhs_batching_dimensions", prop.lhs_batching_dimensions);

    if (prop.lhs_contracting_dimensions) attrs.append("lhs_contracting_dimensions", prop.lhs_contracting_dimensions);

    if (prop.precision_config) attrs.append("precision_config", prop.precision_config);

    if (prop.rhs_batching_dimensions) attrs.append("rhs_batching_dimensions", prop.rhs_batching_dimensions);

    if (prop.rhs_contracting_dimensions) attrs.append("rhs_contracting_dimensions", prop.rhs_contracting_dimensions);
}

::llvm::LogicalResult DotGeneralOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getLhsBatchingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_batching_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsContractingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_contracting_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrecisionConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "precision_config", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsBatchingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_batching_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsContractingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_contracting_dimensions", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DotGeneralOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.lhs_batching_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_contracting_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.precision_config)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_batching_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_contracting_dimensions)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DotGeneralOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.lhs_batching_dimensions);
  writer.writeAttribute(prop.lhs_contracting_dimensions);
  writer.writeAttribute(prop.precision_config);
  writer.writeAttribute(prop.rhs_batching_dimensions);
  writer.writeAttribute(prop.rhs_contracting_dimensions);
}

::mlir::Attribute DotGeneralOpV1::getLhsBatchingDimensions() {
  auto attr = getLhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1::getRhsBatchingDimensions() {
  auto attr = getRhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1::getLhsContractingDimensions() {
  auto attr = getLhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1::getRhsContractingDimensions() {
  auto attr = getRhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV1::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

void DotGeneralOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().lhs_batching_dimensions = lhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_batching_dimensions = rhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().lhs_contracting_dimensions = lhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_contracting_dimensions = rhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  odsState.addTypes(result);
}

void DotGeneralOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().lhs_batching_dimensions = lhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_batching_dimensions = rhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().lhs_contracting_dimensions = lhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_contracting_dimensions = rhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DotGeneralOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DotGeneralOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DotGeneralOpV1::verifyInvariantsImpl() {
  auto tblgen_lhs_batching_dimensions = getProperties().lhs_batching_dimensions; (void)tblgen_lhs_batching_dimensions;
  if (!tblgen_lhs_batching_dimensions) return emitOpError("requires attribute 'lhs_batching_dimensions'");
  auto tblgen_lhs_contracting_dimensions = getProperties().lhs_contracting_dimensions; (void)tblgen_lhs_contracting_dimensions;
  if (!tblgen_lhs_contracting_dimensions) return emitOpError("requires attribute 'lhs_contracting_dimensions'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitOpError("requires attribute 'precision_config'");
  auto tblgen_rhs_batching_dimensions = getProperties().rhs_batching_dimensions; (void)tblgen_rhs_batching_dimensions;
  if (!tblgen_rhs_batching_dimensions) return emitOpError("requires attribute 'rhs_batching_dimensions'");
  auto tblgen_rhs_contracting_dimensions = getProperties().rhs_contracting_dimensions; (void)tblgen_rhs_contracting_dimensions;
  if (!tblgen_rhs_contracting_dimensions) return emitOpError("requires attribute 'rhs_contracting_dimensions'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_batching_dimensions, "lhs_batching_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_batching_dimensions, "rhs_batching_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_contracting_dimensions, "lhs_contracting_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_contracting_dimensions, "rhs_contracting_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_precision_config, "precision_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DotGeneralOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DotGeneralOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DotGeneralOpV1::getMaxVersion() {
   return mlir::vhlo::Version(1, 5, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotGeneralOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotGeneralOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DotGeneralOpV2GenericAdaptorBase::DotGeneralOpV2GenericAdaptorBase(DotGeneralOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getLhsBatchingDimensions() {
  auto attr = getLhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getRhsBatchingDimensions() {
  auto attr = getRhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getLhsContractingDimensions() {
  auto attr = getLhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getRhsContractingDimensions() {
  auto attr = getRhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getLhsPrecisionType() {
  auto attr = getLhsPrecisionTypeAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getRhsPrecisionType() {
  auto attr = getRhsPrecisionTypeAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getAccumulationType() {
  auto attr = getAccumulationTypeAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getLhsComponentCount() {
  auto attr = getLhsComponentCountAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getRhsComponentCount() {
  auto attr = getRhsComponentCountAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getNumPrimitiveOperations() {
  auto attr = getNumPrimitiveOperationsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2GenericAdaptorBase::getAllowImpreciseAccumulation() {
  auto attr = getAllowImpreciseAccumulationAttr();
  return attr;
}

} // namespace detail
DotGeneralOpV2Adaptor::DotGeneralOpV2Adaptor(DotGeneralOpV2 op) : DotGeneralOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DotGeneralOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_accumulation_type = getProperties().accumulation_type; (void)tblgen_accumulation_type;
  if (!tblgen_accumulation_type) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'accumulation_type'");
  auto tblgen_allow_imprecise_accumulation = getProperties().allow_imprecise_accumulation; (void)tblgen_allow_imprecise_accumulation;
  if (!tblgen_allow_imprecise_accumulation) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'allow_imprecise_accumulation'");
  auto tblgen_lhs_batching_dimensions = getProperties().lhs_batching_dimensions; (void)tblgen_lhs_batching_dimensions;
  if (!tblgen_lhs_batching_dimensions) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'lhs_batching_dimensions'");
  auto tblgen_lhs_component_count = getProperties().lhs_component_count; (void)tblgen_lhs_component_count;
  if (!tblgen_lhs_component_count) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'lhs_component_count'");
  auto tblgen_lhs_contracting_dimensions = getProperties().lhs_contracting_dimensions; (void)tblgen_lhs_contracting_dimensions;
  if (!tblgen_lhs_contracting_dimensions) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'lhs_contracting_dimensions'");
  auto tblgen_lhs_precision_type = getProperties().lhs_precision_type; (void)tblgen_lhs_precision_type;
  if (!tblgen_lhs_precision_type) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'lhs_precision_type'");
  auto tblgen_num_primitive_operations = getProperties().num_primitive_operations; (void)tblgen_num_primitive_operations;
  if (!tblgen_num_primitive_operations) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'num_primitive_operations'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'precision_config'");
  auto tblgen_rhs_batching_dimensions = getProperties().rhs_batching_dimensions; (void)tblgen_rhs_batching_dimensions;
  if (!tblgen_rhs_batching_dimensions) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'rhs_batching_dimensions'");
  auto tblgen_rhs_component_count = getProperties().rhs_component_count; (void)tblgen_rhs_component_count;
  if (!tblgen_rhs_component_count) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'rhs_component_count'");
  auto tblgen_rhs_contracting_dimensions = getProperties().rhs_contracting_dimensions; (void)tblgen_rhs_contracting_dimensions;
  if (!tblgen_rhs_contracting_dimensions) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'rhs_contracting_dimensions'");
  auto tblgen_rhs_precision_type = getProperties().rhs_precision_type; (void)tblgen_rhs_precision_type;
  if (!tblgen_rhs_precision_type) return emitError(loc, "'vhlo.dot_general_v2' op ""requires attribute 'rhs_precision_type'");

  if (tblgen_lhs_batching_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'lhs_batching_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_batching_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'rhs_batching_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_lhs_contracting_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'lhs_contracting_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_contracting_dimensions && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'rhs_contracting_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_precision_config && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'precision_config' failed to satisfy constraint: any attribute");

  if (tblgen_lhs_precision_type && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'lhs_precision_type' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_precision_type && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'rhs_precision_type' failed to satisfy constraint: any attribute");

  if (tblgen_accumulation_type && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'accumulation_type' failed to satisfy constraint: any attribute");

  if (tblgen_lhs_component_count && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'lhs_component_count' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_component_count && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'rhs_component_count' failed to satisfy constraint: any attribute");

  if (tblgen_num_primitive_operations && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'num_primitive_operations' failed to satisfy constraint: any attribute");

  if (tblgen_allow_imprecise_accumulation && !((true)))
    return emitError(loc, "'vhlo.dot_general_v2' op ""attribute 'allow_imprecise_accumulation' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DotGeneralOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.accumulation_type;
       auto attr = dict.get("accumulation_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `accumulation_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.allow_imprecise_accumulation;
       auto attr = dict.get("allow_imprecise_accumulation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `allow_imprecise_accumulation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_batching_dimensions;
       auto attr = dict.get("lhs_batching_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_batching_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_component_count;
       auto attr = dict.get("lhs_component_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_component_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_contracting_dimensions;
       auto attr = dict.get("lhs_contracting_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_contracting_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_precision_type;
       auto attr = dict.get("lhs_precision_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_precision_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.num_primitive_operations;
       auto attr = dict.get("num_primitive_operations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `num_primitive_operations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.precision_config;
       auto attr = dict.get("precision_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `precision_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_batching_dimensions;
       auto attr = dict.get("rhs_batching_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_batching_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_component_count;
       auto attr = dict.get("rhs_component_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_component_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_contracting_dimensions;
       auto attr = dict.get("rhs_contracting_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_contracting_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_precision_type;
       auto attr = dict.get("rhs_precision_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_precision_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DotGeneralOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.accumulation_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("accumulation_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.allow_imprecise_accumulation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("allow_imprecise_accumulation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_batching_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_batching_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_component_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_component_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_contracting_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_contracting_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_precision_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_precision_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.num_primitive_operations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("num_primitive_operations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.precision_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("precision_config",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_batching_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_batching_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_component_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_component_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_contracting_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_contracting_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_precision_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_precision_type",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DotGeneralOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.accumulation_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.allow_imprecise_accumulation.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_batching_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_component_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_contracting_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_precision_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.num_primitive_operations.getAsOpaquePointer()), 
    llvm::hash_value(prop.precision_config.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_batching_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_component_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_contracting_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_precision_type.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DotGeneralOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "accumulation_type")
      return prop.accumulation_type;

    if (name == "allow_imprecise_accumulation")
      return prop.allow_imprecise_accumulation;

    if (name == "lhs_batching_dimensions")
      return prop.lhs_batching_dimensions;

    if (name == "lhs_component_count")
      return prop.lhs_component_count;

    if (name == "lhs_contracting_dimensions")
      return prop.lhs_contracting_dimensions;

    if (name == "lhs_precision_type")
      return prop.lhs_precision_type;

    if (name == "num_primitive_operations")
      return prop.num_primitive_operations;

    if (name == "precision_config")
      return prop.precision_config;

    if (name == "rhs_batching_dimensions")
      return prop.rhs_batching_dimensions;

    if (name == "rhs_component_count")
      return prop.rhs_component_count;

    if (name == "rhs_contracting_dimensions")
      return prop.rhs_contracting_dimensions;

    if (name == "rhs_precision_type")
      return prop.rhs_precision_type;
  return std::nullopt;
}

void DotGeneralOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "accumulation_type") {
       prop.accumulation_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.accumulation_type)>>(value);
       return;
    }

    if (name == "allow_imprecise_accumulation") {
       prop.allow_imprecise_accumulation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.allow_imprecise_accumulation)>>(value);
       return;
    }

    if (name == "lhs_batching_dimensions") {
       prop.lhs_batching_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_batching_dimensions)>>(value);
       return;
    }

    if (name == "lhs_component_count") {
       prop.lhs_component_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_component_count)>>(value);
       return;
    }

    if (name == "lhs_contracting_dimensions") {
       prop.lhs_contracting_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_contracting_dimensions)>>(value);
       return;
    }

    if (name == "lhs_precision_type") {
       prop.lhs_precision_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_precision_type)>>(value);
       return;
    }

    if (name == "num_primitive_operations") {
       prop.num_primitive_operations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.num_primitive_operations)>>(value);
       return;
    }

    if (name == "precision_config") {
       prop.precision_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.precision_config)>>(value);
       return;
    }

    if (name == "rhs_batching_dimensions") {
       prop.rhs_batching_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_batching_dimensions)>>(value);
       return;
    }

    if (name == "rhs_component_count") {
       prop.rhs_component_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_component_count)>>(value);
       return;
    }

    if (name == "rhs_contracting_dimensions") {
       prop.rhs_contracting_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_contracting_dimensions)>>(value);
       return;
    }

    if (name == "rhs_precision_type") {
       prop.rhs_precision_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_precision_type)>>(value);
       return;
    }
}

void DotGeneralOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.accumulation_type) attrs.append("accumulation_type", prop.accumulation_type);

    if (prop.allow_imprecise_accumulation) attrs.append("allow_imprecise_accumulation", prop.allow_imprecise_accumulation);

    if (prop.lhs_batching_dimensions) attrs.append("lhs_batching_dimensions", prop.lhs_batching_dimensions);

    if (prop.lhs_component_count) attrs.append("lhs_component_count", prop.lhs_component_count);

    if (prop.lhs_contracting_dimensions) attrs.append("lhs_contracting_dimensions", prop.lhs_contracting_dimensions);

    if (prop.lhs_precision_type) attrs.append("lhs_precision_type", prop.lhs_precision_type);

    if (prop.num_primitive_operations) attrs.append("num_primitive_operations", prop.num_primitive_operations);

    if (prop.precision_config) attrs.append("precision_config", prop.precision_config);

    if (prop.rhs_batching_dimensions) attrs.append("rhs_batching_dimensions", prop.rhs_batching_dimensions);

    if (prop.rhs_component_count) attrs.append("rhs_component_count", prop.rhs_component_count);

    if (prop.rhs_contracting_dimensions) attrs.append("rhs_contracting_dimensions", prop.rhs_contracting_dimensions);

    if (prop.rhs_precision_type) attrs.append("rhs_precision_type", prop.rhs_precision_type);
}

::llvm::LogicalResult DotGeneralOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAccumulationTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "accumulation_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAllowImpreciseAccumulationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "allow_imprecise_accumulation", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsBatchingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_batching_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsComponentCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_component_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsContractingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_contracting_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsPrecisionTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_precision_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNumPrimitiveOperationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "num_primitive_operations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrecisionConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "precision_config", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsBatchingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_batching_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsComponentCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_component_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsContractingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_contracting_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsPrecisionTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_precision_type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DotGeneralOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.accumulation_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.allow_imprecise_accumulation)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_batching_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_component_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_contracting_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_precision_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.num_primitive_operations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.precision_config)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_batching_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_component_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_contracting_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_precision_type)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DotGeneralOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.accumulation_type);
  writer.writeAttribute(prop.allow_imprecise_accumulation);
  writer.writeAttribute(prop.lhs_batching_dimensions);
  writer.writeAttribute(prop.lhs_component_count);
  writer.writeAttribute(prop.lhs_contracting_dimensions);
  writer.writeAttribute(prop.lhs_precision_type);
  writer.writeAttribute(prop.num_primitive_operations);
  writer.writeAttribute(prop.precision_config);
  writer.writeAttribute(prop.rhs_batching_dimensions);
  writer.writeAttribute(prop.rhs_component_count);
  writer.writeAttribute(prop.rhs_contracting_dimensions);
  writer.writeAttribute(prop.rhs_precision_type);
}

::mlir::Attribute DotGeneralOpV2::getLhsBatchingDimensions() {
  auto attr = getLhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getRhsBatchingDimensions() {
  auto attr = getRhsBatchingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getLhsContractingDimensions() {
  auto attr = getLhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getRhsContractingDimensions() {
  auto attr = getRhsContractingDimensionsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getLhsPrecisionType() {
  auto attr = getLhsPrecisionTypeAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getRhsPrecisionType() {
  auto attr = getRhsPrecisionTypeAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getAccumulationType() {
  auto attr = getAccumulationTypeAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getLhsComponentCount() {
  auto attr = getLhsComponentCountAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getRhsComponentCount() {
  auto attr = getRhsComponentCountAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getNumPrimitiveOperations() {
  auto attr = getNumPrimitiveOperationsAttr();
  return attr;
}

::mlir::Attribute DotGeneralOpV2::getAllowImpreciseAccumulation() {
  auto attr = getAllowImpreciseAccumulationAttr();
  return attr;
}

void DotGeneralOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config, ::mlir::Attribute lhs_precision_type, ::mlir::Attribute rhs_precision_type, ::mlir::Attribute accumulation_type, ::mlir::Attribute lhs_component_count, ::mlir::Attribute rhs_component_count, ::mlir::Attribute num_primitive_operations, ::mlir::Attribute allow_imprecise_accumulation) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().lhs_batching_dimensions = lhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_batching_dimensions = rhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().lhs_contracting_dimensions = lhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_contracting_dimensions = rhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  odsState.getOrAddProperties<Properties>().lhs_precision_type = lhs_precision_type;
  odsState.getOrAddProperties<Properties>().rhs_precision_type = rhs_precision_type;
  odsState.getOrAddProperties<Properties>().accumulation_type = accumulation_type;
  odsState.getOrAddProperties<Properties>().lhs_component_count = lhs_component_count;
  odsState.getOrAddProperties<Properties>().rhs_component_count = rhs_component_count;
  odsState.getOrAddProperties<Properties>().num_primitive_operations = num_primitive_operations;
  odsState.getOrAddProperties<Properties>().allow_imprecise_accumulation = allow_imprecise_accumulation;
  odsState.addTypes(result);
}

void DotGeneralOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config, ::mlir::Attribute lhs_precision_type, ::mlir::Attribute rhs_precision_type, ::mlir::Attribute accumulation_type, ::mlir::Attribute lhs_component_count, ::mlir::Attribute rhs_component_count, ::mlir::Attribute num_primitive_operations, ::mlir::Attribute allow_imprecise_accumulation) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().lhs_batching_dimensions = lhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_batching_dimensions = rhs_batching_dimensions;
  odsState.getOrAddProperties<Properties>().lhs_contracting_dimensions = lhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().rhs_contracting_dimensions = rhs_contracting_dimensions;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  odsState.getOrAddProperties<Properties>().lhs_precision_type = lhs_precision_type;
  odsState.getOrAddProperties<Properties>().rhs_precision_type = rhs_precision_type;
  odsState.getOrAddProperties<Properties>().accumulation_type = accumulation_type;
  odsState.getOrAddProperties<Properties>().lhs_component_count = lhs_component_count;
  odsState.getOrAddProperties<Properties>().rhs_component_count = rhs_component_count;
  odsState.getOrAddProperties<Properties>().num_primitive_operations = num_primitive_operations;
  odsState.getOrAddProperties<Properties>().allow_imprecise_accumulation = allow_imprecise_accumulation;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DotGeneralOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DotGeneralOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DotGeneralOpV2::verifyInvariantsImpl() {
  auto tblgen_accumulation_type = getProperties().accumulation_type; (void)tblgen_accumulation_type;
  if (!tblgen_accumulation_type) return emitOpError("requires attribute 'accumulation_type'");
  auto tblgen_allow_imprecise_accumulation = getProperties().allow_imprecise_accumulation; (void)tblgen_allow_imprecise_accumulation;
  if (!tblgen_allow_imprecise_accumulation) return emitOpError("requires attribute 'allow_imprecise_accumulation'");
  auto tblgen_lhs_batching_dimensions = getProperties().lhs_batching_dimensions; (void)tblgen_lhs_batching_dimensions;
  if (!tblgen_lhs_batching_dimensions) return emitOpError("requires attribute 'lhs_batching_dimensions'");
  auto tblgen_lhs_component_count = getProperties().lhs_component_count; (void)tblgen_lhs_component_count;
  if (!tblgen_lhs_component_count) return emitOpError("requires attribute 'lhs_component_count'");
  auto tblgen_lhs_contracting_dimensions = getProperties().lhs_contracting_dimensions; (void)tblgen_lhs_contracting_dimensions;
  if (!tblgen_lhs_contracting_dimensions) return emitOpError("requires attribute 'lhs_contracting_dimensions'");
  auto tblgen_lhs_precision_type = getProperties().lhs_precision_type; (void)tblgen_lhs_precision_type;
  if (!tblgen_lhs_precision_type) return emitOpError("requires attribute 'lhs_precision_type'");
  auto tblgen_num_primitive_operations = getProperties().num_primitive_operations; (void)tblgen_num_primitive_operations;
  if (!tblgen_num_primitive_operations) return emitOpError("requires attribute 'num_primitive_operations'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitOpError("requires attribute 'precision_config'");
  auto tblgen_rhs_batching_dimensions = getProperties().rhs_batching_dimensions; (void)tblgen_rhs_batching_dimensions;
  if (!tblgen_rhs_batching_dimensions) return emitOpError("requires attribute 'rhs_batching_dimensions'");
  auto tblgen_rhs_component_count = getProperties().rhs_component_count; (void)tblgen_rhs_component_count;
  if (!tblgen_rhs_component_count) return emitOpError("requires attribute 'rhs_component_count'");
  auto tblgen_rhs_contracting_dimensions = getProperties().rhs_contracting_dimensions; (void)tblgen_rhs_contracting_dimensions;
  if (!tblgen_rhs_contracting_dimensions) return emitOpError("requires attribute 'rhs_contracting_dimensions'");
  auto tblgen_rhs_precision_type = getProperties().rhs_precision_type; (void)tblgen_rhs_precision_type;
  if (!tblgen_rhs_precision_type) return emitOpError("requires attribute 'rhs_precision_type'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_batching_dimensions, "lhs_batching_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_batching_dimensions, "rhs_batching_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_contracting_dimensions, "lhs_contracting_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_contracting_dimensions, "rhs_contracting_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_precision_config, "precision_config")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_precision_type, "lhs_precision_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_precision_type, "rhs_precision_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_accumulation_type, "accumulation_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_component_count, "lhs_component_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_component_count, "rhs_component_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_num_primitive_operations, "num_primitive_operations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_allow_imprecise_accumulation, "allow_imprecise_accumulation")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DotGeneralOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DotGeneralOpV2::getMinVersion() {
  return mlir::vhlo::Version(1, 6, 0);
}
mlir::vhlo::Version DotGeneralOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotGeneralOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DotOpV1GenericAdaptorBase::DotOpV1GenericAdaptorBase(DotOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DotOpV1GenericAdaptorBase::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

} // namespace detail
DotOpV1Adaptor::DotOpV1Adaptor(DotOpV1 op) : DotOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DotOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitError(loc, "'vhlo.dot_v1' op ""requires attribute 'precision_config'");

  if (tblgen_precision_config && !((true)))
    return emitError(loc, "'vhlo.dot_v1' op ""attribute 'precision_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DotOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.precision_config;
       auto attr = dict.get("precision_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `precision_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DotOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.precision_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("precision_config",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DotOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.precision_config.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DotOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "precision_config")
      return prop.precision_config;
  return std::nullopt;
}

void DotOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "precision_config") {
       prop.precision_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.precision_config)>>(value);
       return;
    }
}

void DotOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.precision_config) attrs.append("precision_config", prop.precision_config);
}

::llvm::LogicalResult DotOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getPrecisionConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "precision_config", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DotOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.precision_config)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DotOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.precision_config);
}

::mlir::Attribute DotOpV1::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

void DotOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  odsState.addTypes(result);
}

void DotOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DotOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DotOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DotOpV1::verifyInvariantsImpl() {
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitOpError("requires attribute 'precision_config'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_precision_config, "precision_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DotOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DotOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DotOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicBroadcastInDimOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DynamicBroadcastInDimOpV1GenericAdaptorBase::DynamicBroadcastInDimOpV1GenericAdaptorBase(DynamicBroadcastInDimOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DynamicBroadcastInDimOpV1GenericAdaptorBase::getBroadcastDimensions() {
  auto attr = getBroadcastDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicBroadcastInDimOpV1GenericAdaptorBase::getKnownExpandingDimensions() {
  auto attr = getKnownExpandingDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicBroadcastInDimOpV1GenericAdaptorBase::getKnownNonexpandingDimensions() {
  auto attr = getKnownNonexpandingDimensionsAttr();
  return attr;
}

} // namespace detail
DynamicBroadcastInDimOpV1Adaptor::DynamicBroadcastInDimOpV1Adaptor(DynamicBroadcastInDimOpV1 op) : DynamicBroadcastInDimOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicBroadcastInDimOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_broadcast_dimensions = getProperties().broadcast_dimensions; (void)tblgen_broadcast_dimensions;
  if (!tblgen_broadcast_dimensions) return emitError(loc, "'vhlo.dynamic_broadcast_in_dim_v1' op ""requires attribute 'broadcast_dimensions'");
  auto tblgen_known_expanding_dimensions = getProperties().known_expanding_dimensions; (void)tblgen_known_expanding_dimensions;
  if (!tblgen_known_expanding_dimensions) return emitError(loc, "'vhlo.dynamic_broadcast_in_dim_v1' op ""requires attribute 'known_expanding_dimensions'");
  auto tblgen_known_nonexpanding_dimensions = getProperties().known_nonexpanding_dimensions; (void)tblgen_known_nonexpanding_dimensions;
  if (!tblgen_known_nonexpanding_dimensions) return emitError(loc, "'vhlo.dynamic_broadcast_in_dim_v1' op ""requires attribute 'known_nonexpanding_dimensions'");

  if (tblgen_broadcast_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_broadcast_in_dim_v1' op ""attribute 'broadcast_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_known_expanding_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_broadcast_in_dim_v1' op ""attribute 'known_expanding_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_known_nonexpanding_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_broadcast_in_dim_v1' op ""attribute 'known_nonexpanding_dimensions' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DynamicBroadcastInDimOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.broadcast_dimensions;
       auto attr = dict.get("broadcast_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `broadcast_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.known_expanding_dimensions;
       auto attr = dict.get("known_expanding_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `known_expanding_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.known_nonexpanding_dimensions;
       auto attr = dict.get("known_nonexpanding_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `known_nonexpanding_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DynamicBroadcastInDimOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.broadcast_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("broadcast_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.known_expanding_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("known_expanding_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.known_nonexpanding_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("known_nonexpanding_dimensions",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DynamicBroadcastInDimOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.broadcast_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.known_expanding_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.known_nonexpanding_dimensions.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DynamicBroadcastInDimOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "broadcast_dimensions")
      return prop.broadcast_dimensions;

    if (name == "known_expanding_dimensions")
      return prop.known_expanding_dimensions;

    if (name == "known_nonexpanding_dimensions")
      return prop.known_nonexpanding_dimensions;
  return std::nullopt;
}

void DynamicBroadcastInDimOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "broadcast_dimensions") {
       prop.broadcast_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.broadcast_dimensions)>>(value);
       return;
    }

    if (name == "known_expanding_dimensions") {
       prop.known_expanding_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.known_expanding_dimensions)>>(value);
       return;
    }

    if (name == "known_nonexpanding_dimensions") {
       prop.known_nonexpanding_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.known_nonexpanding_dimensions)>>(value);
       return;
    }
}

void DynamicBroadcastInDimOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.broadcast_dimensions) attrs.append("broadcast_dimensions", prop.broadcast_dimensions);

    if (prop.known_expanding_dimensions) attrs.append("known_expanding_dimensions", prop.known_expanding_dimensions);

    if (prop.known_nonexpanding_dimensions) attrs.append("known_nonexpanding_dimensions", prop.known_nonexpanding_dimensions);
}

::llvm::LogicalResult DynamicBroadcastInDimOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBroadcastDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "broadcast_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKnownExpandingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "known_expanding_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKnownNonexpandingDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "known_nonexpanding_dimensions", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DynamicBroadcastInDimOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.broadcast_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.known_expanding_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.known_nonexpanding_dimensions)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DynamicBroadcastInDimOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.broadcast_dimensions);
  writer.writeAttribute(prop.known_expanding_dimensions);
  writer.writeAttribute(prop.known_nonexpanding_dimensions);
}

::mlir::Attribute DynamicBroadcastInDimOpV1::getBroadcastDimensions() {
  auto attr = getBroadcastDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicBroadcastInDimOpV1::getKnownExpandingDimensions() {
  auto attr = getKnownExpandingDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicBroadcastInDimOpV1::getKnownNonexpandingDimensions() {
  auto attr = getKnownNonexpandingDimensionsAttr();
  return attr;
}

void DynamicBroadcastInDimOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value output_dimensions, ::mlir::Attribute broadcast_dimensions, ::mlir::Attribute known_expanding_dimensions, ::mlir::Attribute known_nonexpanding_dimensions) {
  odsState.addOperands(operand);
  odsState.addOperands(output_dimensions);
  odsState.getOrAddProperties<Properties>().broadcast_dimensions = broadcast_dimensions;
  odsState.getOrAddProperties<Properties>().known_expanding_dimensions = known_expanding_dimensions;
  odsState.getOrAddProperties<Properties>().known_nonexpanding_dimensions = known_nonexpanding_dimensions;
  odsState.addTypes(result);
}

void DynamicBroadcastInDimOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value output_dimensions, ::mlir::Attribute broadcast_dimensions, ::mlir::Attribute known_expanding_dimensions, ::mlir::Attribute known_nonexpanding_dimensions) {
  odsState.addOperands(operand);
  odsState.addOperands(output_dimensions);
  odsState.getOrAddProperties<Properties>().broadcast_dimensions = broadcast_dimensions;
  odsState.getOrAddProperties<Properties>().known_expanding_dimensions = known_expanding_dimensions;
  odsState.getOrAddProperties<Properties>().known_nonexpanding_dimensions = known_nonexpanding_dimensions;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicBroadcastInDimOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DynamicBroadcastInDimOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DynamicBroadcastInDimOpV1::verifyInvariantsImpl() {
  auto tblgen_broadcast_dimensions = getProperties().broadcast_dimensions; (void)tblgen_broadcast_dimensions;
  if (!tblgen_broadcast_dimensions) return emitOpError("requires attribute 'broadcast_dimensions'");
  auto tblgen_known_expanding_dimensions = getProperties().known_expanding_dimensions; (void)tblgen_known_expanding_dimensions;
  if (!tblgen_known_expanding_dimensions) return emitOpError("requires attribute 'known_expanding_dimensions'");
  auto tblgen_known_nonexpanding_dimensions = getProperties().known_nonexpanding_dimensions; (void)tblgen_known_nonexpanding_dimensions;
  if (!tblgen_known_nonexpanding_dimensions) return emitOpError("requires attribute 'known_nonexpanding_dimensions'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_broadcast_dimensions, "broadcast_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_known_expanding_dimensions, "known_expanding_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_known_nonexpanding_dimensions, "known_nonexpanding_dimensions")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicBroadcastInDimOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicBroadcastInDimOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicBroadcastInDimOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicBroadcastInDimOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicConvOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DynamicConvOpV1GenericAdaptorBase::DynamicConvOpV1GenericAdaptorBase(DynamicConvOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getLhsDilation() {
  auto attr = getLhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getRhsDilation() {
  auto attr = getRhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getWindowReversal() {
  auto attr = getWindowReversalAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getInputBatchDimension() {
  auto attr = getInputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getInputFeatureDimension() {
  auto attr = getInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getInputSpatialDimensions() {
  auto attr = getInputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getKernelInputFeatureDimension() {
  auto attr = getKernelInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getKernelOutputFeatureDimension() {
  auto attr = getKernelOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getKernelSpatialDimensions() {
  auto attr = getKernelSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getOutputBatchDimension() {
  auto attr = getOutputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getOutputFeatureDimension() {
  auto attr = getOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getOutputSpatialDimensions() {
  auto attr = getOutputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getFeatureGroupCount() {
  auto attr = getFeatureGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getBatchGroupCount() {
  auto attr = getBatchGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1GenericAdaptorBase::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

} // namespace detail
DynamicConvOpV1Adaptor::DynamicConvOpV1Adaptor(DynamicConvOpV1 op) : DynamicConvOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicConvOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_batch_group_count = getProperties().batch_group_count; (void)tblgen_batch_group_count;
  if (!tblgen_batch_group_count) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'batch_group_count'");
  auto tblgen_feature_group_count = getProperties().feature_group_count; (void)tblgen_feature_group_count;
  if (!tblgen_feature_group_count) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'feature_group_count'");
  auto tblgen_input_batch_dimension = getProperties().input_batch_dimension; (void)tblgen_input_batch_dimension;
  if (!tblgen_input_batch_dimension) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'input_batch_dimension'");
  auto tblgen_input_feature_dimension = getProperties().input_feature_dimension; (void)tblgen_input_feature_dimension;
  if (!tblgen_input_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'input_feature_dimension'");
  auto tblgen_input_spatial_dimensions = getProperties().input_spatial_dimensions; (void)tblgen_input_spatial_dimensions;
  if (!tblgen_input_spatial_dimensions) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'input_spatial_dimensions'");
  auto tblgen_kernel_input_feature_dimension = getProperties().kernel_input_feature_dimension; (void)tblgen_kernel_input_feature_dimension;
  if (!tblgen_kernel_input_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'kernel_input_feature_dimension'");
  auto tblgen_kernel_output_feature_dimension = getProperties().kernel_output_feature_dimension; (void)tblgen_kernel_output_feature_dimension;
  if (!tblgen_kernel_output_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'kernel_output_feature_dimension'");
  auto tblgen_kernel_spatial_dimensions = getProperties().kernel_spatial_dimensions; (void)tblgen_kernel_spatial_dimensions;
  if (!tblgen_kernel_spatial_dimensions) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'kernel_spatial_dimensions'");
  auto tblgen_lhs_dilation = getProperties().lhs_dilation; (void)tblgen_lhs_dilation;
  if (!tblgen_lhs_dilation) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'lhs_dilation'");
  auto tblgen_output_batch_dimension = getProperties().output_batch_dimension; (void)tblgen_output_batch_dimension;
  if (!tblgen_output_batch_dimension) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'output_batch_dimension'");
  auto tblgen_output_feature_dimension = getProperties().output_feature_dimension; (void)tblgen_output_feature_dimension;
  if (!tblgen_output_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'output_feature_dimension'");
  auto tblgen_output_spatial_dimensions = getProperties().output_spatial_dimensions; (void)tblgen_output_spatial_dimensions;
  if (!tblgen_output_spatial_dimensions) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'output_spatial_dimensions'");
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'padding'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'precision_config'");
  auto tblgen_rhs_dilation = getProperties().rhs_dilation; (void)tblgen_rhs_dilation;
  if (!tblgen_rhs_dilation) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'rhs_dilation'");
  auto tblgen_window_reversal = getProperties().window_reversal; (void)tblgen_window_reversal;
  if (!tblgen_window_reversal) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'window_reversal'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitError(loc, "'vhlo.dynamic_conv_v1' op ""requires attribute 'window_strides'");

  if (tblgen_window_strides && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'window_strides' failed to satisfy constraint: any attribute");

  if (tblgen_padding && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'padding' failed to satisfy constraint: any attribute");

  if (tblgen_lhs_dilation && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'lhs_dilation' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_dilation && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'rhs_dilation' failed to satisfy constraint: any attribute");

  if (tblgen_window_reversal && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'window_reversal' failed to satisfy constraint: any attribute");

  if (tblgen_input_batch_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'input_batch_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_input_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'input_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_input_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'input_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_input_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'kernel_input_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_output_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'kernel_output_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'kernel_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_output_batch_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'output_batch_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_output_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'output_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_output_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'output_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_feature_group_count && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'feature_group_count' failed to satisfy constraint: any attribute");

  if (tblgen_batch_group_count && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'batch_group_count' failed to satisfy constraint: any attribute");

  if (tblgen_precision_config && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v1' op ""attribute 'precision_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DynamicConvOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.batch_group_count;
       auto attr = dict.get("batch_group_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `batch_group_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.feature_group_count;
       auto attr = dict.get("feature_group_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `feature_group_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_batch_dimension;
       auto attr = dict.get("input_batch_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_batch_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_feature_dimension;
       auto attr = dict.get("input_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_spatial_dimensions;
       auto attr = dict.get("input_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_input_feature_dimension;
       auto attr = dict.get("kernel_input_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_input_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_output_feature_dimension;
       auto attr = dict.get("kernel_output_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_output_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_spatial_dimensions;
       auto attr = dict.get("kernel_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_dilation;
       auto attr = dict.get("lhs_dilation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_dilation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_batch_dimension;
       auto attr = dict.get("output_batch_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_batch_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_feature_dimension;
       auto attr = dict.get("output_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_spatial_dimensions;
       auto attr = dict.get("output_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.padding;
       auto attr = dict.get("padding");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `padding` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.precision_config;
       auto attr = dict.get("precision_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `precision_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_dilation;
       auto attr = dict.get("rhs_dilation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_dilation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_reversal;
       auto attr = dict.get("window_reversal");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_reversal` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_strides;
       auto attr = dict.get("window_strides");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_strides` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DynamicConvOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.batch_group_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("batch_group_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.feature_group_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("feature_group_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_batch_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_batch_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_input_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_input_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_output_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_output_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_dilation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_dilation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_batch_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_batch_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.padding;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("padding",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.precision_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("precision_config",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_dilation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_dilation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_reversal;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_reversal",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_strides;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_strides",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DynamicConvOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.batch_group_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.feature_group_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_batch_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_input_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_output_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_dilation.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_batch_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.padding.getAsOpaquePointer()), 
    llvm::hash_value(prop.precision_config.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_dilation.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_reversal.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_strides.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DynamicConvOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "batch_group_count")
      return prop.batch_group_count;

    if (name == "feature_group_count")
      return prop.feature_group_count;

    if (name == "input_batch_dimension")
      return prop.input_batch_dimension;

    if (name == "input_feature_dimension")
      return prop.input_feature_dimension;

    if (name == "input_spatial_dimensions")
      return prop.input_spatial_dimensions;

    if (name == "kernel_input_feature_dimension")
      return prop.kernel_input_feature_dimension;

    if (name == "kernel_output_feature_dimension")
      return prop.kernel_output_feature_dimension;

    if (name == "kernel_spatial_dimensions")
      return prop.kernel_spatial_dimensions;

    if (name == "lhs_dilation")
      return prop.lhs_dilation;

    if (name == "output_batch_dimension")
      return prop.output_batch_dimension;

    if (name == "output_feature_dimension")
      return prop.output_feature_dimension;

    if (name == "output_spatial_dimensions")
      return prop.output_spatial_dimensions;

    if (name == "padding")
      return prop.padding;

    if (name == "precision_config")
      return prop.precision_config;

    if (name == "rhs_dilation")
      return prop.rhs_dilation;

    if (name == "window_reversal")
      return prop.window_reversal;

    if (name == "window_strides")
      return prop.window_strides;
  return std::nullopt;
}

void DynamicConvOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "batch_group_count") {
       prop.batch_group_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.batch_group_count)>>(value);
       return;
    }

    if (name == "feature_group_count") {
       prop.feature_group_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.feature_group_count)>>(value);
       return;
    }

    if (name == "input_batch_dimension") {
       prop.input_batch_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_batch_dimension)>>(value);
       return;
    }

    if (name == "input_feature_dimension") {
       prop.input_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_feature_dimension)>>(value);
       return;
    }

    if (name == "input_spatial_dimensions") {
       prop.input_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_spatial_dimensions)>>(value);
       return;
    }

    if (name == "kernel_input_feature_dimension") {
       prop.kernel_input_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_input_feature_dimension)>>(value);
       return;
    }

    if (name == "kernel_output_feature_dimension") {
       prop.kernel_output_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_output_feature_dimension)>>(value);
       return;
    }

    if (name == "kernel_spatial_dimensions") {
       prop.kernel_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_spatial_dimensions)>>(value);
       return;
    }

    if (name == "lhs_dilation") {
       prop.lhs_dilation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_dilation)>>(value);
       return;
    }

    if (name == "output_batch_dimension") {
       prop.output_batch_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_batch_dimension)>>(value);
       return;
    }

    if (name == "output_feature_dimension") {
       prop.output_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_feature_dimension)>>(value);
       return;
    }

    if (name == "output_spatial_dimensions") {
       prop.output_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_spatial_dimensions)>>(value);
       return;
    }

    if (name == "padding") {
       prop.padding = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.padding)>>(value);
       return;
    }

    if (name == "precision_config") {
       prop.precision_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.precision_config)>>(value);
       return;
    }

    if (name == "rhs_dilation") {
       prop.rhs_dilation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_dilation)>>(value);
       return;
    }

    if (name == "window_reversal") {
       prop.window_reversal = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_reversal)>>(value);
       return;
    }

    if (name == "window_strides") {
       prop.window_strides = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_strides)>>(value);
       return;
    }
}

void DynamicConvOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.batch_group_count) attrs.append("batch_group_count", prop.batch_group_count);

    if (prop.feature_group_count) attrs.append("feature_group_count", prop.feature_group_count);

    if (prop.input_batch_dimension) attrs.append("input_batch_dimension", prop.input_batch_dimension);

    if (prop.input_feature_dimension) attrs.append("input_feature_dimension", prop.input_feature_dimension);

    if (prop.input_spatial_dimensions) attrs.append("input_spatial_dimensions", prop.input_spatial_dimensions);

    if (prop.kernel_input_feature_dimension) attrs.append("kernel_input_feature_dimension", prop.kernel_input_feature_dimension);

    if (prop.kernel_output_feature_dimension) attrs.append("kernel_output_feature_dimension", prop.kernel_output_feature_dimension);

    if (prop.kernel_spatial_dimensions) attrs.append("kernel_spatial_dimensions", prop.kernel_spatial_dimensions);

    if (prop.lhs_dilation) attrs.append("lhs_dilation", prop.lhs_dilation);

    if (prop.output_batch_dimension) attrs.append("output_batch_dimension", prop.output_batch_dimension);

    if (prop.output_feature_dimension) attrs.append("output_feature_dimension", prop.output_feature_dimension);

    if (prop.output_spatial_dimensions) attrs.append("output_spatial_dimensions", prop.output_spatial_dimensions);

    if (prop.padding) attrs.append("padding", prop.padding);

    if (prop.precision_config) attrs.append("precision_config", prop.precision_config);

    if (prop.rhs_dilation) attrs.append("rhs_dilation", prop.rhs_dilation);

    if (prop.window_reversal) attrs.append("window_reversal", prop.window_reversal);

    if (prop.window_strides) attrs.append("window_strides", prop.window_strides);
}

::llvm::LogicalResult DynamicConvOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBatchGroupCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "batch_group_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFeatureGroupCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "feature_group_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputBatchDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_batch_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelInputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_input_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelOutputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_output_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsDilationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_dilation", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputBatchDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_batch_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPaddingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "padding", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrecisionConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "precision_config", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsDilationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_dilation", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowReversalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_reversal", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowStridesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_strides", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DynamicConvOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.batch_group_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.feature_group_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_batch_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_input_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_output_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_dilation)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_batch_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.padding)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.precision_config)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_dilation)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_reversal)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_strides)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DynamicConvOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.batch_group_count);
  writer.writeAttribute(prop.feature_group_count);
  writer.writeAttribute(prop.input_batch_dimension);
  writer.writeAttribute(prop.input_feature_dimension);
  writer.writeAttribute(prop.input_spatial_dimensions);
  writer.writeAttribute(prop.kernel_input_feature_dimension);
  writer.writeAttribute(prop.kernel_output_feature_dimension);
  writer.writeAttribute(prop.kernel_spatial_dimensions);
  writer.writeAttribute(prop.lhs_dilation);
  writer.writeAttribute(prop.output_batch_dimension);
  writer.writeAttribute(prop.output_feature_dimension);
  writer.writeAttribute(prop.output_spatial_dimensions);
  writer.writeAttribute(prop.padding);
  writer.writeAttribute(prop.precision_config);
  writer.writeAttribute(prop.rhs_dilation);
  writer.writeAttribute(prop.window_reversal);
  writer.writeAttribute(prop.window_strides);
}

::mlir::Attribute DynamicConvOpV1::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getLhsDilation() {
  auto attr = getLhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getRhsDilation() {
  auto attr = getRhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getWindowReversal() {
  auto attr = getWindowReversalAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getInputBatchDimension() {
  auto attr = getInputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getInputFeatureDimension() {
  auto attr = getInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getInputSpatialDimensions() {
  auto attr = getInputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getKernelInputFeatureDimension() {
  auto attr = getKernelInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getKernelOutputFeatureDimension() {
  auto attr = getKernelOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getKernelSpatialDimensions() {
  auto attr = getKernelSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getOutputBatchDimension() {
  auto attr = getOutputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getOutputFeatureDimension() {
  auto attr = getOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getOutputSpatialDimensions() {
  auto attr = getOutputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getFeatureGroupCount() {
  auto attr = getFeatureGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getBatchGroupCount() {
  auto attr = getBatchGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV1::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

void DynamicConvOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value d_padding, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(d_padding);
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().padding = padding;
  odsState.getOrAddProperties<Properties>().lhs_dilation = lhs_dilation;
  odsState.getOrAddProperties<Properties>().rhs_dilation = rhs_dilation;
  odsState.getOrAddProperties<Properties>().window_reversal = window_reversal;
  odsState.getOrAddProperties<Properties>().input_batch_dimension = input_batch_dimension;
  odsState.getOrAddProperties<Properties>().input_feature_dimension = input_feature_dimension;
  odsState.getOrAddProperties<Properties>().input_spatial_dimensions = input_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().kernel_input_feature_dimension = kernel_input_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_output_feature_dimension = kernel_output_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_spatial_dimensions = kernel_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().output_batch_dimension = output_batch_dimension;
  odsState.getOrAddProperties<Properties>().output_feature_dimension = output_feature_dimension;
  odsState.getOrAddProperties<Properties>().output_spatial_dimensions = output_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().feature_group_count = feature_group_count;
  odsState.getOrAddProperties<Properties>().batch_group_count = batch_group_count;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  odsState.addTypes(result);
}

void DynamicConvOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value d_padding, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(d_padding);
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().padding = padding;
  odsState.getOrAddProperties<Properties>().lhs_dilation = lhs_dilation;
  odsState.getOrAddProperties<Properties>().rhs_dilation = rhs_dilation;
  odsState.getOrAddProperties<Properties>().window_reversal = window_reversal;
  odsState.getOrAddProperties<Properties>().input_batch_dimension = input_batch_dimension;
  odsState.getOrAddProperties<Properties>().input_feature_dimension = input_feature_dimension;
  odsState.getOrAddProperties<Properties>().input_spatial_dimensions = input_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().kernel_input_feature_dimension = kernel_input_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_output_feature_dimension = kernel_output_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_spatial_dimensions = kernel_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().output_batch_dimension = output_batch_dimension;
  odsState.getOrAddProperties<Properties>().output_feature_dimension = output_feature_dimension;
  odsState.getOrAddProperties<Properties>().output_spatial_dimensions = output_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().feature_group_count = feature_group_count;
  odsState.getOrAddProperties<Properties>().batch_group_count = batch_group_count;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicConvOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DynamicConvOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DynamicConvOpV1::verifyInvariantsImpl() {
  auto tblgen_batch_group_count = getProperties().batch_group_count; (void)tblgen_batch_group_count;
  if (!tblgen_batch_group_count) return emitOpError("requires attribute 'batch_group_count'");
  auto tblgen_feature_group_count = getProperties().feature_group_count; (void)tblgen_feature_group_count;
  if (!tblgen_feature_group_count) return emitOpError("requires attribute 'feature_group_count'");
  auto tblgen_input_batch_dimension = getProperties().input_batch_dimension; (void)tblgen_input_batch_dimension;
  if (!tblgen_input_batch_dimension) return emitOpError("requires attribute 'input_batch_dimension'");
  auto tblgen_input_feature_dimension = getProperties().input_feature_dimension; (void)tblgen_input_feature_dimension;
  if (!tblgen_input_feature_dimension) return emitOpError("requires attribute 'input_feature_dimension'");
  auto tblgen_input_spatial_dimensions = getProperties().input_spatial_dimensions; (void)tblgen_input_spatial_dimensions;
  if (!tblgen_input_spatial_dimensions) return emitOpError("requires attribute 'input_spatial_dimensions'");
  auto tblgen_kernel_input_feature_dimension = getProperties().kernel_input_feature_dimension; (void)tblgen_kernel_input_feature_dimension;
  if (!tblgen_kernel_input_feature_dimension) return emitOpError("requires attribute 'kernel_input_feature_dimension'");
  auto tblgen_kernel_output_feature_dimension = getProperties().kernel_output_feature_dimension; (void)tblgen_kernel_output_feature_dimension;
  if (!tblgen_kernel_output_feature_dimension) return emitOpError("requires attribute 'kernel_output_feature_dimension'");
  auto tblgen_kernel_spatial_dimensions = getProperties().kernel_spatial_dimensions; (void)tblgen_kernel_spatial_dimensions;
  if (!tblgen_kernel_spatial_dimensions) return emitOpError("requires attribute 'kernel_spatial_dimensions'");
  auto tblgen_lhs_dilation = getProperties().lhs_dilation; (void)tblgen_lhs_dilation;
  if (!tblgen_lhs_dilation) return emitOpError("requires attribute 'lhs_dilation'");
  auto tblgen_output_batch_dimension = getProperties().output_batch_dimension; (void)tblgen_output_batch_dimension;
  if (!tblgen_output_batch_dimension) return emitOpError("requires attribute 'output_batch_dimension'");
  auto tblgen_output_feature_dimension = getProperties().output_feature_dimension; (void)tblgen_output_feature_dimension;
  if (!tblgen_output_feature_dimension) return emitOpError("requires attribute 'output_feature_dimension'");
  auto tblgen_output_spatial_dimensions = getProperties().output_spatial_dimensions; (void)tblgen_output_spatial_dimensions;
  if (!tblgen_output_spatial_dimensions) return emitOpError("requires attribute 'output_spatial_dimensions'");
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitOpError("requires attribute 'padding'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitOpError("requires attribute 'precision_config'");
  auto tblgen_rhs_dilation = getProperties().rhs_dilation; (void)tblgen_rhs_dilation;
  if (!tblgen_rhs_dilation) return emitOpError("requires attribute 'rhs_dilation'");
  auto tblgen_window_reversal = getProperties().window_reversal; (void)tblgen_window_reversal;
  if (!tblgen_window_reversal) return emitOpError("requires attribute 'window_reversal'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitOpError("requires attribute 'window_strides'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_strides, "window_strides")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_padding, "padding")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_dilation, "lhs_dilation")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_dilation, "rhs_dilation")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_reversal, "window_reversal")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_batch_dimension, "input_batch_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_feature_dimension, "input_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_spatial_dimensions, "input_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_input_feature_dimension, "kernel_input_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_output_feature_dimension, "kernel_output_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_spatial_dimensions, "kernel_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_batch_dimension, "output_batch_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_feature_dimension, "output_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_spatial_dimensions, "output_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_feature_group_count, "feature_group_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_batch_group_count, "batch_group_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_precision_config, "precision_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicConvOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicConvOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicConvOpV1::getMaxVersion() {
   return mlir::vhlo::Version(0, 19, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicConvOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicConvOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DynamicConvOpV2GenericAdaptorBase::DynamicConvOpV2GenericAdaptorBase(DynamicConvOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getLhsDilation() {
  auto attr = getLhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getRhsDilation() {
  auto attr = getRhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getWindowReversal() {
  auto attr = getWindowReversalAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getInputBatchDimension() {
  auto attr = getInputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getInputFeatureDimension() {
  auto attr = getInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getInputSpatialDimensions() {
  auto attr = getInputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getKernelInputFeatureDimension() {
  auto attr = getKernelInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getKernelOutputFeatureDimension() {
  auto attr = getKernelOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getKernelSpatialDimensions() {
  auto attr = getKernelSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getOutputBatchDimension() {
  auto attr = getOutputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getOutputFeatureDimension() {
  auto attr = getOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getOutputSpatialDimensions() {
  auto attr = getOutputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getFeatureGroupCount() {
  auto attr = getFeatureGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getBatchGroupCount() {
  auto attr = getBatchGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2GenericAdaptorBase::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

} // namespace detail
DynamicConvOpV2Adaptor::DynamicConvOpV2Adaptor(DynamicConvOpV2 op) : DynamicConvOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicConvOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_batch_group_count = getProperties().batch_group_count; (void)tblgen_batch_group_count;
  if (!tblgen_batch_group_count) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'batch_group_count'");
  auto tblgen_feature_group_count = getProperties().feature_group_count; (void)tblgen_feature_group_count;
  if (!tblgen_feature_group_count) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'feature_group_count'");
  auto tblgen_input_batch_dimension = getProperties().input_batch_dimension; (void)tblgen_input_batch_dimension;
  if (!tblgen_input_batch_dimension) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'input_batch_dimension'");
  auto tblgen_input_feature_dimension = getProperties().input_feature_dimension; (void)tblgen_input_feature_dimension;
  if (!tblgen_input_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'input_feature_dimension'");
  auto tblgen_input_spatial_dimensions = getProperties().input_spatial_dimensions; (void)tblgen_input_spatial_dimensions;
  if (!tblgen_input_spatial_dimensions) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'input_spatial_dimensions'");
  auto tblgen_kernel_input_feature_dimension = getProperties().kernel_input_feature_dimension; (void)tblgen_kernel_input_feature_dimension;
  if (!tblgen_kernel_input_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'kernel_input_feature_dimension'");
  auto tblgen_kernel_output_feature_dimension = getProperties().kernel_output_feature_dimension; (void)tblgen_kernel_output_feature_dimension;
  if (!tblgen_kernel_output_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'kernel_output_feature_dimension'");
  auto tblgen_kernel_spatial_dimensions = getProperties().kernel_spatial_dimensions; (void)tblgen_kernel_spatial_dimensions;
  if (!tblgen_kernel_spatial_dimensions) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'kernel_spatial_dimensions'");
  auto tblgen_lhs_dilation = getProperties().lhs_dilation; (void)tblgen_lhs_dilation;
  if (!tblgen_lhs_dilation) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'lhs_dilation'");
  auto tblgen_output_batch_dimension = getProperties().output_batch_dimension; (void)tblgen_output_batch_dimension;
  if (!tblgen_output_batch_dimension) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'output_batch_dimension'");
  auto tblgen_output_feature_dimension = getProperties().output_feature_dimension; (void)tblgen_output_feature_dimension;
  if (!tblgen_output_feature_dimension) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'output_feature_dimension'");
  auto tblgen_output_spatial_dimensions = getProperties().output_spatial_dimensions; (void)tblgen_output_spatial_dimensions;
  if (!tblgen_output_spatial_dimensions) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'output_spatial_dimensions'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'precision_config'");
  auto tblgen_rhs_dilation = getProperties().rhs_dilation; (void)tblgen_rhs_dilation;
  if (!tblgen_rhs_dilation) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'rhs_dilation'");
  auto tblgen_window_reversal = getProperties().window_reversal; (void)tblgen_window_reversal;
  if (!tblgen_window_reversal) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'window_reversal'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitError(loc, "'vhlo.dynamic_conv_v2' op ""requires attribute 'window_strides'");

  if (tblgen_window_strides && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'window_strides' failed to satisfy constraint: any attribute");

  if (tblgen_lhs_dilation && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'lhs_dilation' failed to satisfy constraint: any attribute");

  if (tblgen_rhs_dilation && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'rhs_dilation' failed to satisfy constraint: any attribute");

  if (tblgen_window_reversal && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'window_reversal' failed to satisfy constraint: any attribute");

  if (tblgen_input_batch_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'input_batch_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_input_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'input_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_input_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'input_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_input_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'kernel_input_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_output_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'kernel_output_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_kernel_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'kernel_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_output_batch_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'output_batch_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_output_feature_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'output_feature_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_output_spatial_dimensions && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'output_spatial_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_feature_group_count && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'feature_group_count' failed to satisfy constraint: any attribute");

  if (tblgen_batch_group_count && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'batch_group_count' failed to satisfy constraint: any attribute");

  if (tblgen_precision_config && !((true)))
    return emitError(loc, "'vhlo.dynamic_conv_v2' op ""attribute 'precision_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DynamicConvOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.batch_group_count;
       auto attr = dict.get("batch_group_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `batch_group_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.feature_group_count;
       auto attr = dict.get("feature_group_count");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `feature_group_count` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_batch_dimension;
       auto attr = dict.get("input_batch_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_batch_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_feature_dimension;
       auto attr = dict.get("input_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_spatial_dimensions;
       auto attr = dict.get("input_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_input_feature_dimension;
       auto attr = dict.get("kernel_input_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_input_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_output_feature_dimension;
       auto attr = dict.get("kernel_output_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_output_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.kernel_spatial_dimensions;
       auto attr = dict.get("kernel_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `kernel_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lhs_dilation;
       auto attr = dict.get("lhs_dilation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lhs_dilation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_batch_dimension;
       auto attr = dict.get("output_batch_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_batch_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_feature_dimension;
       auto attr = dict.get("output_feature_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_feature_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.output_spatial_dimensions;
       auto attr = dict.get("output_spatial_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `output_spatial_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.precision_config;
       auto attr = dict.get("precision_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `precision_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.rhs_dilation;
       auto attr = dict.get("rhs_dilation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rhs_dilation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_reversal;
       auto attr = dict.get("window_reversal");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_reversal` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_strides;
       auto attr = dict.get("window_strides");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_strides` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DynamicConvOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.batch_group_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("batch_group_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.feature_group_count;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("feature_group_count",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_batch_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_batch_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_input_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_input_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_output_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_output_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.kernel_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("kernel_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lhs_dilation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lhs_dilation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_batch_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_batch_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_feature_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_feature_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.output_spatial_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("output_spatial_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.precision_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("precision_config",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.rhs_dilation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rhs_dilation",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_reversal;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_reversal",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_strides;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_strides",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DynamicConvOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.batch_group_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.feature_group_count.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_batch_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_input_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_output_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.kernel_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.lhs_dilation.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_batch_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_feature_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.output_spatial_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.precision_config.getAsOpaquePointer()), 
    llvm::hash_value(prop.rhs_dilation.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_reversal.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_strides.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DynamicConvOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "batch_group_count")
      return prop.batch_group_count;

    if (name == "feature_group_count")
      return prop.feature_group_count;

    if (name == "input_batch_dimension")
      return prop.input_batch_dimension;

    if (name == "input_feature_dimension")
      return prop.input_feature_dimension;

    if (name == "input_spatial_dimensions")
      return prop.input_spatial_dimensions;

    if (name == "kernel_input_feature_dimension")
      return prop.kernel_input_feature_dimension;

    if (name == "kernel_output_feature_dimension")
      return prop.kernel_output_feature_dimension;

    if (name == "kernel_spatial_dimensions")
      return prop.kernel_spatial_dimensions;

    if (name == "lhs_dilation")
      return prop.lhs_dilation;

    if (name == "output_batch_dimension")
      return prop.output_batch_dimension;

    if (name == "output_feature_dimension")
      return prop.output_feature_dimension;

    if (name == "output_spatial_dimensions")
      return prop.output_spatial_dimensions;

    if (name == "precision_config")
      return prop.precision_config;

    if (name == "rhs_dilation")
      return prop.rhs_dilation;

    if (name == "window_reversal")
      return prop.window_reversal;

    if (name == "window_strides")
      return prop.window_strides;
  return std::nullopt;
}

void DynamicConvOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "batch_group_count") {
       prop.batch_group_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.batch_group_count)>>(value);
       return;
    }

    if (name == "feature_group_count") {
       prop.feature_group_count = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.feature_group_count)>>(value);
       return;
    }

    if (name == "input_batch_dimension") {
       prop.input_batch_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_batch_dimension)>>(value);
       return;
    }

    if (name == "input_feature_dimension") {
       prop.input_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_feature_dimension)>>(value);
       return;
    }

    if (name == "input_spatial_dimensions") {
       prop.input_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_spatial_dimensions)>>(value);
       return;
    }

    if (name == "kernel_input_feature_dimension") {
       prop.kernel_input_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_input_feature_dimension)>>(value);
       return;
    }

    if (name == "kernel_output_feature_dimension") {
       prop.kernel_output_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_output_feature_dimension)>>(value);
       return;
    }

    if (name == "kernel_spatial_dimensions") {
       prop.kernel_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.kernel_spatial_dimensions)>>(value);
       return;
    }

    if (name == "lhs_dilation") {
       prop.lhs_dilation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lhs_dilation)>>(value);
       return;
    }

    if (name == "output_batch_dimension") {
       prop.output_batch_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_batch_dimension)>>(value);
       return;
    }

    if (name == "output_feature_dimension") {
       prop.output_feature_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_feature_dimension)>>(value);
       return;
    }

    if (name == "output_spatial_dimensions") {
       prop.output_spatial_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.output_spatial_dimensions)>>(value);
       return;
    }

    if (name == "precision_config") {
       prop.precision_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.precision_config)>>(value);
       return;
    }

    if (name == "rhs_dilation") {
       prop.rhs_dilation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rhs_dilation)>>(value);
       return;
    }

    if (name == "window_reversal") {
       prop.window_reversal = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_reversal)>>(value);
       return;
    }

    if (name == "window_strides") {
       prop.window_strides = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_strides)>>(value);
       return;
    }
}

void DynamicConvOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.batch_group_count) attrs.append("batch_group_count", prop.batch_group_count);

    if (prop.feature_group_count) attrs.append("feature_group_count", prop.feature_group_count);

    if (prop.input_batch_dimension) attrs.append("input_batch_dimension", prop.input_batch_dimension);

    if (prop.input_feature_dimension) attrs.append("input_feature_dimension", prop.input_feature_dimension);

    if (prop.input_spatial_dimensions) attrs.append("input_spatial_dimensions", prop.input_spatial_dimensions);

    if (prop.kernel_input_feature_dimension) attrs.append("kernel_input_feature_dimension", prop.kernel_input_feature_dimension);

    if (prop.kernel_output_feature_dimension) attrs.append("kernel_output_feature_dimension", prop.kernel_output_feature_dimension);

    if (prop.kernel_spatial_dimensions) attrs.append("kernel_spatial_dimensions", prop.kernel_spatial_dimensions);

    if (prop.lhs_dilation) attrs.append("lhs_dilation", prop.lhs_dilation);

    if (prop.output_batch_dimension) attrs.append("output_batch_dimension", prop.output_batch_dimension);

    if (prop.output_feature_dimension) attrs.append("output_feature_dimension", prop.output_feature_dimension);

    if (prop.output_spatial_dimensions) attrs.append("output_spatial_dimensions", prop.output_spatial_dimensions);

    if (prop.precision_config) attrs.append("precision_config", prop.precision_config);

    if (prop.rhs_dilation) attrs.append("rhs_dilation", prop.rhs_dilation);

    if (prop.window_reversal) attrs.append("window_reversal", prop.window_reversal);

    if (prop.window_strides) attrs.append("window_strides", prop.window_strides);
}

::llvm::LogicalResult DynamicConvOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBatchGroupCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "batch_group_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFeatureGroupCountAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "feature_group_count", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputBatchDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_batch_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelInputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_input_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelOutputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_output_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getKernelSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "kernel_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLhsDilationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lhs_dilation", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputBatchDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_batch_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputFeatureDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_feature_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOutputSpatialDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "output_spatial_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrecisionConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "precision_config", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getRhsDilationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rhs_dilation", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowReversalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_reversal", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowStridesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_strides", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DynamicConvOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.batch_group_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.feature_group_count)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_batch_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_input_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_output_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.kernel_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lhs_dilation)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_batch_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_feature_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.output_spatial_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.precision_config)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.rhs_dilation)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_reversal)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_strides)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DynamicConvOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.batch_group_count);
  writer.writeAttribute(prop.feature_group_count);
  writer.writeAttribute(prop.input_batch_dimension);
  writer.writeAttribute(prop.input_feature_dimension);
  writer.writeAttribute(prop.input_spatial_dimensions);
  writer.writeAttribute(prop.kernel_input_feature_dimension);
  writer.writeAttribute(prop.kernel_output_feature_dimension);
  writer.writeAttribute(prop.kernel_spatial_dimensions);
  writer.writeAttribute(prop.lhs_dilation);
  writer.writeAttribute(prop.output_batch_dimension);
  writer.writeAttribute(prop.output_feature_dimension);
  writer.writeAttribute(prop.output_spatial_dimensions);
  writer.writeAttribute(prop.precision_config);
  writer.writeAttribute(prop.rhs_dilation);
  writer.writeAttribute(prop.window_reversal);
  writer.writeAttribute(prop.window_strides);
}

::mlir::Attribute DynamicConvOpV2::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getLhsDilation() {
  auto attr = getLhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getRhsDilation() {
  auto attr = getRhsDilationAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getWindowReversal() {
  auto attr = getWindowReversalAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getInputBatchDimension() {
  auto attr = getInputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getInputFeatureDimension() {
  auto attr = getInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getInputSpatialDimensions() {
  auto attr = getInputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getKernelInputFeatureDimension() {
  auto attr = getKernelInputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getKernelOutputFeatureDimension() {
  auto attr = getKernelOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getKernelSpatialDimensions() {
  auto attr = getKernelSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getOutputBatchDimension() {
  auto attr = getOutputBatchDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getOutputFeatureDimension() {
  auto attr = getOutputFeatureDimensionAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getOutputSpatialDimensions() {
  auto attr = getOutputSpatialDimensionsAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getFeatureGroupCount() {
  auto attr = getFeatureGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getBatchGroupCount() {
  auto attr = getBatchGroupCountAttr();
  return attr;
}

::mlir::Attribute DynamicConvOpV2::getPrecisionConfig() {
  auto attr = getPrecisionConfigAttr();
  return attr;
}

void DynamicConvOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value padding, ::mlir::Attribute window_strides, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(padding);
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().lhs_dilation = lhs_dilation;
  odsState.getOrAddProperties<Properties>().rhs_dilation = rhs_dilation;
  odsState.getOrAddProperties<Properties>().window_reversal = window_reversal;
  odsState.getOrAddProperties<Properties>().input_batch_dimension = input_batch_dimension;
  odsState.getOrAddProperties<Properties>().input_feature_dimension = input_feature_dimension;
  odsState.getOrAddProperties<Properties>().input_spatial_dimensions = input_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().kernel_input_feature_dimension = kernel_input_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_output_feature_dimension = kernel_output_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_spatial_dimensions = kernel_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().output_batch_dimension = output_batch_dimension;
  odsState.getOrAddProperties<Properties>().output_feature_dimension = output_feature_dimension;
  odsState.getOrAddProperties<Properties>().output_spatial_dimensions = output_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().feature_group_count = feature_group_count;
  odsState.getOrAddProperties<Properties>().batch_group_count = batch_group_count;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  odsState.addTypes(result);
}

void DynamicConvOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value padding, ::mlir::Attribute window_strides, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(padding);
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().lhs_dilation = lhs_dilation;
  odsState.getOrAddProperties<Properties>().rhs_dilation = rhs_dilation;
  odsState.getOrAddProperties<Properties>().window_reversal = window_reversal;
  odsState.getOrAddProperties<Properties>().input_batch_dimension = input_batch_dimension;
  odsState.getOrAddProperties<Properties>().input_feature_dimension = input_feature_dimension;
  odsState.getOrAddProperties<Properties>().input_spatial_dimensions = input_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().kernel_input_feature_dimension = kernel_input_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_output_feature_dimension = kernel_output_feature_dimension;
  odsState.getOrAddProperties<Properties>().kernel_spatial_dimensions = kernel_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().output_batch_dimension = output_batch_dimension;
  odsState.getOrAddProperties<Properties>().output_feature_dimension = output_feature_dimension;
  odsState.getOrAddProperties<Properties>().output_spatial_dimensions = output_spatial_dimensions;
  odsState.getOrAddProperties<Properties>().feature_group_count = feature_group_count;
  odsState.getOrAddProperties<Properties>().batch_group_count = batch_group_count;
  odsState.getOrAddProperties<Properties>().precision_config = precision_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicConvOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DynamicConvOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DynamicConvOpV2::verifyInvariantsImpl() {
  auto tblgen_batch_group_count = getProperties().batch_group_count; (void)tblgen_batch_group_count;
  if (!tblgen_batch_group_count) return emitOpError("requires attribute 'batch_group_count'");
  auto tblgen_feature_group_count = getProperties().feature_group_count; (void)tblgen_feature_group_count;
  if (!tblgen_feature_group_count) return emitOpError("requires attribute 'feature_group_count'");
  auto tblgen_input_batch_dimension = getProperties().input_batch_dimension; (void)tblgen_input_batch_dimension;
  if (!tblgen_input_batch_dimension) return emitOpError("requires attribute 'input_batch_dimension'");
  auto tblgen_input_feature_dimension = getProperties().input_feature_dimension; (void)tblgen_input_feature_dimension;
  if (!tblgen_input_feature_dimension) return emitOpError("requires attribute 'input_feature_dimension'");
  auto tblgen_input_spatial_dimensions = getProperties().input_spatial_dimensions; (void)tblgen_input_spatial_dimensions;
  if (!tblgen_input_spatial_dimensions) return emitOpError("requires attribute 'input_spatial_dimensions'");
  auto tblgen_kernel_input_feature_dimension = getProperties().kernel_input_feature_dimension; (void)tblgen_kernel_input_feature_dimension;
  if (!tblgen_kernel_input_feature_dimension) return emitOpError("requires attribute 'kernel_input_feature_dimension'");
  auto tblgen_kernel_output_feature_dimension = getProperties().kernel_output_feature_dimension; (void)tblgen_kernel_output_feature_dimension;
  if (!tblgen_kernel_output_feature_dimension) return emitOpError("requires attribute 'kernel_output_feature_dimension'");
  auto tblgen_kernel_spatial_dimensions = getProperties().kernel_spatial_dimensions; (void)tblgen_kernel_spatial_dimensions;
  if (!tblgen_kernel_spatial_dimensions) return emitOpError("requires attribute 'kernel_spatial_dimensions'");
  auto tblgen_lhs_dilation = getProperties().lhs_dilation; (void)tblgen_lhs_dilation;
  if (!tblgen_lhs_dilation) return emitOpError("requires attribute 'lhs_dilation'");
  auto tblgen_output_batch_dimension = getProperties().output_batch_dimension; (void)tblgen_output_batch_dimension;
  if (!tblgen_output_batch_dimension) return emitOpError("requires attribute 'output_batch_dimension'");
  auto tblgen_output_feature_dimension = getProperties().output_feature_dimension; (void)tblgen_output_feature_dimension;
  if (!tblgen_output_feature_dimension) return emitOpError("requires attribute 'output_feature_dimension'");
  auto tblgen_output_spatial_dimensions = getProperties().output_spatial_dimensions; (void)tblgen_output_spatial_dimensions;
  if (!tblgen_output_spatial_dimensions) return emitOpError("requires attribute 'output_spatial_dimensions'");
  auto tblgen_precision_config = getProperties().precision_config; (void)tblgen_precision_config;
  if (!tblgen_precision_config) return emitOpError("requires attribute 'precision_config'");
  auto tblgen_rhs_dilation = getProperties().rhs_dilation; (void)tblgen_rhs_dilation;
  if (!tblgen_rhs_dilation) return emitOpError("requires attribute 'rhs_dilation'");
  auto tblgen_window_reversal = getProperties().window_reversal; (void)tblgen_window_reversal;
  if (!tblgen_window_reversal) return emitOpError("requires attribute 'window_reversal'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitOpError("requires attribute 'window_strides'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_strides, "window_strides")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lhs_dilation, "lhs_dilation")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rhs_dilation, "rhs_dilation")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_reversal, "window_reversal")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_batch_dimension, "input_batch_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_feature_dimension, "input_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_spatial_dimensions, "input_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_input_feature_dimension, "kernel_input_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_output_feature_dimension, "kernel_output_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_kernel_spatial_dimensions, "kernel_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_batch_dimension, "output_batch_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_feature_dimension, "output_feature_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_output_spatial_dimensions, "output_spatial_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_feature_group_count, "feature_group_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_batch_group_count, "batch_group_count")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_precision_config, "precision_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicConvOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicConvOpV2::getMinVersion() {
  return mlir::vhlo::Version(0, 20, 0);
}
mlir::vhlo::Version DynamicConvOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicConvOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicGatherOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DynamicGatherOpV1GenericAdaptorBase::DynamicGatherOpV1GenericAdaptorBase(DynamicGatherOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DynamicGatherOpV1GenericAdaptorBase::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1GenericAdaptorBase::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1GenericAdaptorBase::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1GenericAdaptorBase::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1GenericAdaptorBase::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

} // namespace detail
DynamicGatherOpV1Adaptor::DynamicGatherOpV1Adaptor(DynamicGatherOpV1 op) : DynamicGatherOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicGatherOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitError(loc, "'vhlo.dynamic_gather_v1' op ""requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitError(loc, "'vhlo.dynamic_gather_v1' op ""requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitError(loc, "'vhlo.dynamic_gather_v1' op ""requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitError(loc, "'vhlo.dynamic_gather_v1' op ""requires attribute 'offset_dims'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitError(loc, "'vhlo.dynamic_gather_v1' op ""requires attribute 'start_index_map'");

  if (tblgen_offset_dims && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v1' op ""attribute 'offset_dims' failed to satisfy constraint: any attribute");

  if (tblgen_collapsed_slice_dims && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v1' op ""attribute 'collapsed_slice_dims' failed to satisfy constraint: any attribute");

  if (tblgen_start_index_map && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v1' op ""attribute 'start_index_map' failed to satisfy constraint: any attribute");

  if (tblgen_index_vector_dim && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v1' op ""attribute 'index_vector_dim' failed to satisfy constraint: any attribute");

  if (tblgen_indices_are_sorted && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v1' op ""attribute 'indices_are_sorted' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DynamicGatherOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.collapsed_slice_dims;
       auto attr = dict.get("collapsed_slice_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `collapsed_slice_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.index_vector_dim;
       auto attr = dict.get("index_vector_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `index_vector_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.indices_are_sorted;
       auto attr = dict.get("indices_are_sorted");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `indices_are_sorted` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.offset_dims;
       auto attr = dict.get("offset_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `offset_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.start_index_map;
       auto attr = dict.get("start_index_map");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `start_index_map` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DynamicGatherOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.collapsed_slice_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("collapsed_slice_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.index_vector_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("index_vector_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.indices_are_sorted;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("indices_are_sorted",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.offset_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("offset_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.start_index_map;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("start_index_map",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DynamicGatherOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.collapsed_slice_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.index_vector_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.indices_are_sorted.getAsOpaquePointer()), 
    llvm::hash_value(prop.offset_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.start_index_map.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DynamicGatherOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "collapsed_slice_dims")
      return prop.collapsed_slice_dims;

    if (name == "index_vector_dim")
      return prop.index_vector_dim;

    if (name == "indices_are_sorted")
      return prop.indices_are_sorted;

    if (name == "offset_dims")
      return prop.offset_dims;

    if (name == "start_index_map")
      return prop.start_index_map;
  return std::nullopt;
}

void DynamicGatherOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "collapsed_slice_dims") {
       prop.collapsed_slice_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.collapsed_slice_dims)>>(value);
       return;
    }

    if (name == "index_vector_dim") {
       prop.index_vector_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.index_vector_dim)>>(value);
       return;
    }

    if (name == "indices_are_sorted") {
       prop.indices_are_sorted = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.indices_are_sorted)>>(value);
       return;
    }

    if (name == "offset_dims") {
       prop.offset_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.offset_dims)>>(value);
       return;
    }

    if (name == "start_index_map") {
       prop.start_index_map = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.start_index_map)>>(value);
       return;
    }
}

void DynamicGatherOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.collapsed_slice_dims) attrs.append("collapsed_slice_dims", prop.collapsed_slice_dims);

    if (prop.index_vector_dim) attrs.append("index_vector_dim", prop.index_vector_dim);

    if (prop.indices_are_sorted) attrs.append("indices_are_sorted", prop.indices_are_sorted);

    if (prop.offset_dims) attrs.append("offset_dims", prop.offset_dims);

    if (prop.start_index_map) attrs.append("start_index_map", prop.start_index_map);
}

::llvm::LogicalResult DynamicGatherOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCollapsedSliceDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "collapsed_slice_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndexVectorDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "index_vector_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndicesAreSortedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "indices_are_sorted", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOffsetDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "offset_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStartIndexMapAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "start_index_map", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DynamicGatherOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.collapsed_slice_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.index_vector_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.indices_are_sorted)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.offset_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.start_index_map)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DynamicGatherOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.collapsed_slice_dims);
  writer.writeAttribute(prop.index_vector_dim);
  writer.writeAttribute(prop.indices_are_sorted);
  writer.writeAttribute(prop.offset_dims);
  writer.writeAttribute(prop.start_index_map);
}

::mlir::Attribute DynamicGatherOpV1::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV1::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

void DynamicGatherOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  odsState.addTypes(result);
}

void DynamicGatherOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicGatherOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DynamicGatherOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DynamicGatherOpV1::verifyInvariantsImpl() {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitOpError("requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitOpError("requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitOpError("requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitOpError("requires attribute 'offset_dims'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitOpError("requires attribute 'start_index_map'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_offset_dims, "offset_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_collapsed_slice_dims, "collapsed_slice_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_start_index_map, "start_index_map")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_index_vector_dim, "index_vector_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_indices_are_sorted, "indices_are_sorted")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicGatherOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicGatherOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicGatherOpV1::getMaxVersion() {
   return mlir::vhlo::Version(1, 0, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicGatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicGatherOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DynamicGatherOpV2GenericAdaptorBase::DynamicGatherOpV2GenericAdaptorBase(DynamicGatherOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DynamicGatherOpV2GenericAdaptorBase::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2GenericAdaptorBase::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2GenericAdaptorBase::getOperandBatchingDims() {
  auto attr = getOperandBatchingDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2GenericAdaptorBase::getStartIndicesBatchingDims() {
  auto attr = getStartIndicesBatchingDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2GenericAdaptorBase::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2GenericAdaptorBase::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2GenericAdaptorBase::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

} // namespace detail
DynamicGatherOpV2Adaptor::DynamicGatherOpV2Adaptor(DynamicGatherOpV2 op) : DynamicGatherOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicGatherOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitError(loc, "'vhlo.dynamic_gather_v2' op ""requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitError(loc, "'vhlo.dynamic_gather_v2' op ""requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitError(loc, "'vhlo.dynamic_gather_v2' op ""requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitError(loc, "'vhlo.dynamic_gather_v2' op ""requires attribute 'offset_dims'");
  auto tblgen_operand_batching_dims = getProperties().operand_batching_dims; (void)tblgen_operand_batching_dims;
  if (!tblgen_operand_batching_dims) return emitError(loc, "'vhlo.dynamic_gather_v2' op ""requires attribute 'operand_batching_dims'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitError(loc, "'vhlo.dynamic_gather_v2' op ""requires attribute 'start_index_map'");
  auto tblgen_start_indices_batching_dims = getProperties().start_indices_batching_dims; (void)tblgen_start_indices_batching_dims;
  if (!tblgen_start_indices_batching_dims) return emitError(loc, "'vhlo.dynamic_gather_v2' op ""requires attribute 'start_indices_batching_dims'");

  if (tblgen_offset_dims && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v2' op ""attribute 'offset_dims' failed to satisfy constraint: any attribute");

  if (tblgen_collapsed_slice_dims && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v2' op ""attribute 'collapsed_slice_dims' failed to satisfy constraint: any attribute");

  if (tblgen_operand_batching_dims && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v2' op ""attribute 'operand_batching_dims' failed to satisfy constraint: any attribute");

  if (tblgen_start_indices_batching_dims && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v2' op ""attribute 'start_indices_batching_dims' failed to satisfy constraint: any attribute");

  if (tblgen_start_index_map && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v2' op ""attribute 'start_index_map' failed to satisfy constraint: any attribute");

  if (tblgen_index_vector_dim && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v2' op ""attribute 'index_vector_dim' failed to satisfy constraint: any attribute");

  if (tblgen_indices_are_sorted && !((true)))
    return emitError(loc, "'vhlo.dynamic_gather_v2' op ""attribute 'indices_are_sorted' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DynamicGatherOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.collapsed_slice_dims;
       auto attr = dict.get("collapsed_slice_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `collapsed_slice_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.index_vector_dim;
       auto attr = dict.get("index_vector_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `index_vector_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.indices_are_sorted;
       auto attr = dict.get("indices_are_sorted");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `indices_are_sorted` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.offset_dims;
       auto attr = dict.get("offset_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `offset_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.operand_batching_dims;
       auto attr = dict.get("operand_batching_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `operand_batching_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.start_index_map;
       auto attr = dict.get("start_index_map");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `start_index_map` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.start_indices_batching_dims;
       auto attr = dict.get("start_indices_batching_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `start_indices_batching_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DynamicGatherOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.collapsed_slice_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("collapsed_slice_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.index_vector_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("index_vector_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.indices_are_sorted;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("indices_are_sorted",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.offset_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("offset_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operand_batching_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("operand_batching_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.start_index_map;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("start_index_map",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.start_indices_batching_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("start_indices_batching_dims",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DynamicGatherOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.collapsed_slice_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.index_vector_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.indices_are_sorted.getAsOpaquePointer()), 
    llvm::hash_value(prop.offset_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.operand_batching_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.start_index_map.getAsOpaquePointer()), 
    llvm::hash_value(prop.start_indices_batching_dims.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DynamicGatherOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "collapsed_slice_dims")
      return prop.collapsed_slice_dims;

    if (name == "index_vector_dim")
      return prop.index_vector_dim;

    if (name == "indices_are_sorted")
      return prop.indices_are_sorted;

    if (name == "offset_dims")
      return prop.offset_dims;

    if (name == "operand_batching_dims")
      return prop.operand_batching_dims;

    if (name == "start_index_map")
      return prop.start_index_map;

    if (name == "start_indices_batching_dims")
      return prop.start_indices_batching_dims;
  return std::nullopt;
}

void DynamicGatherOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "collapsed_slice_dims") {
       prop.collapsed_slice_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.collapsed_slice_dims)>>(value);
       return;
    }

    if (name == "index_vector_dim") {
       prop.index_vector_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.index_vector_dim)>>(value);
       return;
    }

    if (name == "indices_are_sorted") {
       prop.indices_are_sorted = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.indices_are_sorted)>>(value);
       return;
    }

    if (name == "offset_dims") {
       prop.offset_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.offset_dims)>>(value);
       return;
    }

    if (name == "operand_batching_dims") {
       prop.operand_batching_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.operand_batching_dims)>>(value);
       return;
    }

    if (name == "start_index_map") {
       prop.start_index_map = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.start_index_map)>>(value);
       return;
    }

    if (name == "start_indices_batching_dims") {
       prop.start_indices_batching_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.start_indices_batching_dims)>>(value);
       return;
    }
}

void DynamicGatherOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.collapsed_slice_dims) attrs.append("collapsed_slice_dims", prop.collapsed_slice_dims);

    if (prop.index_vector_dim) attrs.append("index_vector_dim", prop.index_vector_dim);

    if (prop.indices_are_sorted) attrs.append("indices_are_sorted", prop.indices_are_sorted);

    if (prop.offset_dims) attrs.append("offset_dims", prop.offset_dims);

    if (prop.operand_batching_dims) attrs.append("operand_batching_dims", prop.operand_batching_dims);

    if (prop.start_index_map) attrs.append("start_index_map", prop.start_index_map);

    if (prop.start_indices_batching_dims) attrs.append("start_indices_batching_dims", prop.start_indices_batching_dims);
}

::llvm::LogicalResult DynamicGatherOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCollapsedSliceDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "collapsed_slice_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndexVectorDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "index_vector_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndicesAreSortedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "indices_are_sorted", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOffsetDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "offset_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOperandBatchingDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "operand_batching_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStartIndexMapAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "start_index_map", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStartIndicesBatchingDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "start_indices_batching_dims", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DynamicGatherOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.collapsed_slice_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.index_vector_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.indices_are_sorted)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.offset_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.operand_batching_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.start_index_map)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.start_indices_batching_dims)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DynamicGatherOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.collapsed_slice_dims);
  writer.writeAttribute(prop.index_vector_dim);
  writer.writeAttribute(prop.indices_are_sorted);
  writer.writeAttribute(prop.offset_dims);
  writer.writeAttribute(prop.operand_batching_dims);
  writer.writeAttribute(prop.start_index_map);
  writer.writeAttribute(prop.start_indices_batching_dims);
}

::mlir::Attribute DynamicGatherOpV2::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2::getOperandBatchingDims() {
  auto attr = getOperandBatchingDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2::getStartIndicesBatchingDims() {
  auto attr = getStartIndicesBatchingDimsAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute DynamicGatherOpV2::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

void DynamicGatherOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().operand_batching_dims = operand_batching_dims;
  odsState.getOrAddProperties<Properties>().start_indices_batching_dims = start_indices_batching_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  odsState.addTypes(result);
}

void DynamicGatherOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().operand_batching_dims = operand_batching_dims;
  odsState.getOrAddProperties<Properties>().start_indices_batching_dims = start_indices_batching_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicGatherOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DynamicGatherOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DynamicGatherOpV2::verifyInvariantsImpl() {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitOpError("requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitOpError("requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitOpError("requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitOpError("requires attribute 'offset_dims'");
  auto tblgen_operand_batching_dims = getProperties().operand_batching_dims; (void)tblgen_operand_batching_dims;
  if (!tblgen_operand_batching_dims) return emitOpError("requires attribute 'operand_batching_dims'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitOpError("requires attribute 'start_index_map'");
  auto tblgen_start_indices_batching_dims = getProperties().start_indices_batching_dims; (void)tblgen_start_indices_batching_dims;
  if (!tblgen_start_indices_batching_dims) return emitOpError("requires attribute 'start_indices_batching_dims'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_offset_dims, "offset_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_collapsed_slice_dims, "collapsed_slice_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_operand_batching_dims, "operand_batching_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_start_indices_batching_dims, "start_indices_batching_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_start_index_map, "start_index_map")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_index_vector_dim, "index_vector_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_indices_are_sorted, "indices_are_sorted")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicGatherOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicGatherOpV2::getMinVersion() {
  return mlir::vhlo::Version(1, 1, 0);
}
mlir::vhlo::Version DynamicGatherOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicGatherOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicIotaOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DynamicIotaOpV1GenericAdaptorBase::DynamicIotaOpV1GenericAdaptorBase(DynamicIotaOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute DynamicIotaOpV1GenericAdaptorBase::getIotaDimension() {
  auto attr = getIotaDimensionAttr();
  return attr;
}

} // namespace detail
DynamicIotaOpV1Adaptor::DynamicIotaOpV1Adaptor(DynamicIotaOpV1 op) : DynamicIotaOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicIotaOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_iota_dimension = getProperties().iota_dimension; (void)tblgen_iota_dimension;
  if (!tblgen_iota_dimension) return emitError(loc, "'vhlo.dynamic_iota_v1' op ""requires attribute 'iota_dimension'");

  if (tblgen_iota_dimension && !((true)))
    return emitError(loc, "'vhlo.dynamic_iota_v1' op ""attribute 'iota_dimension' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult DynamicIotaOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.iota_dimension;
       auto attr = dict.get("iota_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `iota_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DynamicIotaOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.iota_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("iota_dimension",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DynamicIotaOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.iota_dimension.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DynamicIotaOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "iota_dimension")
      return prop.iota_dimension;
  return std::nullopt;
}

void DynamicIotaOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "iota_dimension") {
       prop.iota_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.iota_dimension)>>(value);
       return;
    }
}

void DynamicIotaOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.iota_dimension) attrs.append("iota_dimension", prop.iota_dimension);
}

::llvm::LogicalResult DynamicIotaOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getIotaDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "iota_dimension", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DynamicIotaOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.iota_dimension)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DynamicIotaOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.iota_dimension);
}

::mlir::Attribute DynamicIotaOpV1::getIotaDimension() {
  auto attr = getIotaDimensionAttr();
  return attr;
}

void DynamicIotaOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value output_shape, ::mlir::Attribute iota_dimension) {
  odsState.addOperands(output_shape);
  odsState.getOrAddProperties<Properties>().iota_dimension = iota_dimension;
  odsState.addTypes(result);
}

void DynamicIotaOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value output_shape, ::mlir::Attribute iota_dimension) {
  odsState.addOperands(output_shape);
  odsState.getOrAddProperties<Properties>().iota_dimension = iota_dimension;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicIotaOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DynamicIotaOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DynamicIotaOpV1::verifyInvariantsImpl() {
  auto tblgen_iota_dimension = getProperties().iota_dimension; (void)tblgen_iota_dimension;
  if (!tblgen_iota_dimension) return emitOpError("requires attribute 'iota_dimension'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_iota_dimension, "iota_dimension")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicIotaOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicIotaOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicIotaOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicIotaOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicPadOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
DynamicPadOpV1Adaptor::DynamicPadOpV1Adaptor(DynamicPadOpV1 op) : DynamicPadOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicPadOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void DynamicPadOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Value edge_padding_low, ::mlir::Value edge_padding_high, ::mlir::Value interior_padding) {
  odsState.addOperands(operand);
  odsState.addOperands(padding_value);
  odsState.addOperands(edge_padding_low);
  odsState.addOperands(edge_padding_high);
  odsState.addOperands(interior_padding);
  odsState.addTypes(result);
}

void DynamicPadOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Value edge_padding_low, ::mlir::Value edge_padding_high, ::mlir::Value interior_padding) {
  odsState.addOperands(operand);
  odsState.addOperands(padding_value);
  odsState.addOperands(edge_padding_low);
  odsState.addOperands(edge_padding_high);
  odsState.addOperands(interior_padding);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicPadOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult DynamicPadOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicPadOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicPadOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicPadOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicPadOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicReshapeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
DynamicReshapeOpV1Adaptor::DynamicReshapeOpV1Adaptor(DynamicReshapeOpV1 op) : DynamicReshapeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicReshapeOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void DynamicReshapeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value output_shape) {
  odsState.addOperands(operand);
  odsState.addOperands(output_shape);
  odsState.addTypes(result);
}

void DynamicReshapeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value output_shape) {
  odsState.addOperands(operand);
  odsState.addOperands(output_shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicReshapeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult DynamicReshapeOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicReshapeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicReshapeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicReshapeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicReshapeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicSliceOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
DynamicSliceOpV1GenericAdaptorBase::DynamicSliceOpV1GenericAdaptorBase(DynamicSliceOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DynamicSliceOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute DynamicSliceOpV1GenericAdaptorBase::getSliceSizes() {
  auto attr = getSliceSizesAttr();
  return attr;
}

} // namespace detail
DynamicSliceOpV1Adaptor::DynamicSliceOpV1Adaptor(DynamicSliceOpV1 op) : DynamicSliceOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicSliceOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_slice_sizes = getProperties().slice_sizes; (void)tblgen_slice_sizes;
  if (!tblgen_slice_sizes) return emitError(loc, "'vhlo.dynamic_slice_v1' op ""requires attribute 'slice_sizes'");

  if (tblgen_slice_sizes && !((true)))
    return emitError(loc, "'vhlo.dynamic_slice_v1' op ""attribute 'slice_sizes' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DynamicSliceOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange DynamicSliceOpV1::getStartIndicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::llvm::LogicalResult DynamicSliceOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.slice_sizes;
       auto attr = dict.get("slice_sizes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `slice_sizes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute DynamicSliceOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.slice_sizes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("slice_sizes",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DynamicSliceOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.slice_sizes.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> DynamicSliceOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "slice_sizes")
      return prop.slice_sizes;
  return std::nullopt;
}

void DynamicSliceOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "slice_sizes") {
       prop.slice_sizes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.slice_sizes)>>(value);
       return;
    }
}

void DynamicSliceOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.slice_sizes) attrs.append("slice_sizes", prop.slice_sizes);
}

::llvm::LogicalResult DynamicSliceOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getSliceSizesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "slice_sizes", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DynamicSliceOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.slice_sizes)))
    return ::mlir::failure();
  return ::mlir::success();
}

void DynamicSliceOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.slice_sizes);
}

::mlir::Attribute DynamicSliceOpV1::getSliceSizes() {
  auto attr = getSliceSizesAttr();
  return attr;
}

void DynamicSliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::ValueRange start_indices, ::mlir::Attribute slice_sizes) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.getOrAddProperties<Properties>().slice_sizes = slice_sizes;
  odsState.addTypes(result);
}

void DynamicSliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::ValueRange start_indices, ::mlir::Attribute slice_sizes) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.getOrAddProperties<Properties>().slice_sizes = slice_sizes;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicSliceOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DynamicSliceOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DynamicSliceOpV1::verifyInvariantsImpl() {
  auto tblgen_slice_sizes = getProperties().slice_sizes; (void)tblgen_slice_sizes;
  if (!tblgen_slice_sizes) return emitOpError("requires attribute 'slice_sizes'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_slice_sizes, "slice_sizes")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicSliceOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicSliceOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicSliceOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicUpdateSliceOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> DynamicUpdateSliceOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
DynamicUpdateSliceOpV1Adaptor::DynamicUpdateSliceOpV1Adaptor(DynamicUpdateSliceOpV1 op) : DynamicUpdateSliceOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DynamicUpdateSliceOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DynamicUpdateSliceOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange DynamicUpdateSliceOpV1::getStartIndicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void DynamicUpdateSliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value update, ::mlir::ValueRange start_indices) {
  odsState.addOperands(operand);
  odsState.addOperands(update);
  odsState.addOperands(start_indices);
  odsState.addTypes(result);
}

void DynamicUpdateSliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value update, ::mlir::ValueRange start_indices) {
  odsState.addOperands(operand);
  odsState.addOperands(update);
  odsState.addOperands(start_indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicUpdateSliceOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult DynamicUpdateSliceOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DynamicUpdateSliceOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version DynamicUpdateSliceOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version DynamicUpdateSliceOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicUpdateSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::EinsumOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
EinsumOpV1GenericAdaptorBase::EinsumOpV1GenericAdaptorBase(EinsumOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute EinsumOpV1GenericAdaptorBase::getEinsumConfig() {
  auto attr = getEinsumConfigAttr();
  return attr;
}

} // namespace detail
EinsumOpV1Adaptor::EinsumOpV1Adaptor(EinsumOpV1 op) : EinsumOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult EinsumOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_einsum_config = getProperties().einsum_config; (void)tblgen_einsum_config;
  if (!tblgen_einsum_config) return emitError(loc, "'vhlo.einsum_v1' op ""requires attribute 'einsum_config'");

  if (tblgen_einsum_config && !((true)))
    return emitError(loc, "'vhlo.einsum_v1' op ""attribute 'einsum_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult EinsumOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.einsum_config;
       auto attr = dict.get("einsum_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `einsum_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute EinsumOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.einsum_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("einsum_config",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code EinsumOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.einsum_config.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> EinsumOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "einsum_config")
      return prop.einsum_config;
  return std::nullopt;
}

void EinsumOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "einsum_config") {
       prop.einsum_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.einsum_config)>>(value);
       return;
    }
}

void EinsumOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.einsum_config) attrs.append("einsum_config", prop.einsum_config);
}

::llvm::LogicalResult EinsumOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getEinsumConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "einsum_config", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult EinsumOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.einsum_config)))
    return ::mlir::failure();
  return ::mlir::success();
}

void EinsumOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.einsum_config);
}

::mlir::Attribute EinsumOpV1::getEinsumConfig() {
  auto attr = getEinsumConfigAttr();
  return attr;
}

void EinsumOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute einsum_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().einsum_config = einsum_config;
  odsState.addTypes(result);
}

void EinsumOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute einsum_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.getOrAddProperties<Properties>().einsum_config = einsum_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EinsumOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<EinsumOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult EinsumOpV1::verifyInvariantsImpl() {
  auto tblgen_einsum_config = getProperties().einsum_config; (void)tblgen_einsum_config;
  if (!tblgen_einsum_config) return emitOpError("requires attribute 'einsum_config'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_einsum_config, "einsum_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult EinsumOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version EinsumOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version EinsumOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::EinsumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ExpOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ExpOpV1Adaptor::ExpOpV1Adaptor(ExpOpV1 op) : ExpOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ExpOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ExpOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ExpOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExpOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ExpOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ExpOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ExpOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ExpOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ExpOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Expm1OpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
Expm1OpV1Adaptor::Expm1OpV1Adaptor(Expm1OpV1 op) : Expm1OpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult Expm1OpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void Expm1OpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void Expm1OpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Expm1OpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult Expm1OpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult Expm1OpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version Expm1OpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version Expm1OpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::Expm1OpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FftOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
FftOpV1GenericAdaptorBase::FftOpV1GenericAdaptorBase(FftOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute FftOpV1GenericAdaptorBase::getFftType() {
  auto attr = getFftTypeAttr();
  return attr;
}

::mlir::Attribute FftOpV1GenericAdaptorBase::getFftLength() {
  auto attr = getFftLengthAttr();
  return attr;
}

} // namespace detail
FftOpV1Adaptor::FftOpV1Adaptor(FftOpV1 op) : FftOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FftOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_fft_length = getProperties().fft_length; (void)tblgen_fft_length;
  if (!tblgen_fft_length) return emitError(loc, "'vhlo.fft_v1' op ""requires attribute 'fft_length'");
  auto tblgen_fft_type = getProperties().fft_type; (void)tblgen_fft_type;
  if (!tblgen_fft_type) return emitError(loc, "'vhlo.fft_v1' op ""requires attribute 'fft_type'");

  if (tblgen_fft_type && !((true)))
    return emitError(loc, "'vhlo.fft_v1' op ""attribute 'fft_type' failed to satisfy constraint: any attribute");

  if (tblgen_fft_length && !((true)))
    return emitError(loc, "'vhlo.fft_v1' op ""attribute 'fft_length' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult FftOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.fft_length;
       auto attr = dict.get("fft_length");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fft_length` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.fft_type;
       auto attr = dict.get("fft_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `fft_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FftOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.fft_length;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fft_length",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.fft_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("fft_type",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FftOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.fft_length.getAsOpaquePointer()), 
    llvm::hash_value(prop.fft_type.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FftOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "fft_length")
      return prop.fft_length;

    if (name == "fft_type")
      return prop.fft_type;
  return std::nullopt;
}

void FftOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "fft_length") {
       prop.fft_length = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fft_length)>>(value);
       return;
    }

    if (name == "fft_type") {
       prop.fft_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.fft_type)>>(value);
       return;
    }
}

void FftOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.fft_length) attrs.append("fft_length", prop.fft_length);

    if (prop.fft_type) attrs.append("fft_type", prop.fft_type);
}

::llvm::LogicalResult FftOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getFftLengthAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "fft_length", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFftTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "fft_type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FftOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.fft_length)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.fft_type)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FftOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.fft_length);
  writer.writeAttribute(prop.fft_type);
}

::mlir::Attribute FftOpV1::getFftType() {
  auto attr = getFftTypeAttr();
  return attr;
}

::mlir::Attribute FftOpV1::getFftLength() {
  auto attr = getFftLengthAttr();
  return attr;
}

void FftOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute fft_type, ::mlir::Attribute fft_length) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().fft_type = fft_type;
  odsState.getOrAddProperties<Properties>().fft_length = fft_length;
  odsState.addTypes(result);
}

void FftOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute fft_type, ::mlir::Attribute fft_length) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().fft_type = fft_type;
  odsState.getOrAddProperties<Properties>().fft_length = fft_length;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FftOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FftOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult FftOpV1::verifyInvariantsImpl() {
  auto tblgen_fft_length = getProperties().fft_length; (void)tblgen_fft_length;
  if (!tblgen_fft_length) return emitOpError("requires attribute 'fft_length'");
  auto tblgen_fft_type = getProperties().fft_type; (void)tblgen_fft_type;
  if (!tblgen_fft_type) return emitOpError("requires attribute 'fft_type'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_fft_type, "fft_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_fft_length, "fft_length")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FftOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version FftOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version FftOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::FftOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FloorOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
FloorOpV1Adaptor::FloorOpV1Adaptor(FloorOpV1 op) : FloorOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FloorOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void FloorOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void FloorOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FloorOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult FloorOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FloorOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version FloorOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version FloorOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::FloorOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FuncOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
FuncOpV1GenericAdaptorBase::FuncOpV1GenericAdaptorBase(FuncOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute FuncOpV1GenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr;
}

::mlir::Attribute FuncOpV1GenericAdaptorBase::getFunctionType() {
  auto attr = getFunctionTypeAttr();
  return attr;
}

::mlir::Attribute FuncOpV1GenericAdaptorBase::getSymVisibility() {
  auto attr = getSymVisibilityAttr();
  return attr;
}

::mlir::Attribute FuncOpV1GenericAdaptorBase::getArgAttrs() {
  auto attr = getArgAttrsAttr();
  return attr;
}

::mlir::Attribute FuncOpV1GenericAdaptorBase::getResAttrs() {
  auto attr = getResAttrsAttr();
  return attr;
}

} // namespace detail
FuncOpV1Adaptor::FuncOpV1Adaptor(FuncOpV1 op) : FuncOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FuncOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_arg_attrs = getProperties().arg_attrs; (void)tblgen_arg_attrs;
  if (!tblgen_arg_attrs) return emitError(loc, "'vhlo.func_v1' op ""requires attribute 'arg_attrs'");
  auto tblgen_function_type = getProperties().function_type; (void)tblgen_function_type;
  if (!tblgen_function_type) return emitError(loc, "'vhlo.func_v1' op ""requires attribute 'function_type'");
  auto tblgen_res_attrs = getProperties().res_attrs; (void)tblgen_res_attrs;
  if (!tblgen_res_attrs) return emitError(loc, "'vhlo.func_v1' op ""requires attribute 'res_attrs'");
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'vhlo.func_v1' op ""requires attribute 'sym_name'");
  auto tblgen_sym_visibility = getProperties().sym_visibility; (void)tblgen_sym_visibility;
  if (!tblgen_sym_visibility) return emitError(loc, "'vhlo.func_v1' op ""requires attribute 'sym_visibility'");

  if (tblgen_sym_name && !((true)))
    return emitError(loc, "'vhlo.func_v1' op ""attribute 'sym_name' failed to satisfy constraint: any attribute");

  if (tblgen_function_type && !((true)))
    return emitError(loc, "'vhlo.func_v1' op ""attribute 'function_type' failed to satisfy constraint: any attribute");

  if (tblgen_sym_visibility && !((true)))
    return emitError(loc, "'vhlo.func_v1' op ""attribute 'sym_visibility' failed to satisfy constraint: any attribute");

  if (tblgen_arg_attrs && !((true)))
    return emitError(loc, "'vhlo.func_v1' op ""attribute 'arg_attrs' failed to satisfy constraint: any attribute");

  if (tblgen_res_attrs && !((true)))
    return emitError(loc, "'vhlo.func_v1' op ""attribute 'res_attrs' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult FuncOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.arg_attrs;
       auto attr = dict.get("arg_attrs");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `arg_attrs` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.function_type;
       auto attr = dict.get("function_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `function_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.res_attrs;
       auto attr = dict.get("res_attrs");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `res_attrs` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_visibility;
       auto attr = dict.get("sym_visibility");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_visibility` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FuncOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.arg_attrs;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("arg_attrs",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.function_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("function_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.res_attrs;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("res_attrs",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_visibility;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_visibility",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FuncOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.arg_attrs.getAsOpaquePointer()), 
    llvm::hash_value(prop.function_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.res_attrs.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_visibility.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FuncOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "arg_attrs")
      return prop.arg_attrs;

    if (name == "function_type")
      return prop.function_type;

    if (name == "res_attrs")
      return prop.res_attrs;

    if (name == "sym_name")
      return prop.sym_name;

    if (name == "sym_visibility")
      return prop.sym_visibility;
  return std::nullopt;
}

void FuncOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "arg_attrs") {
       prop.arg_attrs = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.arg_attrs)>>(value);
       return;
    }

    if (name == "function_type") {
       prop.function_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.function_type)>>(value);
       return;
    }

    if (name == "res_attrs") {
       prop.res_attrs = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.res_attrs)>>(value);
       return;
    }

    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }

    if (name == "sym_visibility") {
       prop.sym_visibility = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_visibility)>>(value);
       return;
    }
}

void FuncOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.arg_attrs) attrs.append("arg_attrs", prop.arg_attrs);

    if (prop.function_type) attrs.append("function_type", prop.function_type);

    if (prop.res_attrs) attrs.append("res_attrs", prop.res_attrs);

    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);

    if (prop.sym_visibility) attrs.append("sym_visibility", prop.sym_visibility);
}

::llvm::LogicalResult FuncOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getArgAttrsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "arg_attrs", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFunctionTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "function_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getResAttrsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "res_attrs", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymVisibilityAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "sym_visibility", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FuncOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.arg_attrs)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.function_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.res_attrs)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.sym_visibility)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FuncOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.arg_attrs);
  writer.writeAttribute(prop.function_type);
  writer.writeAttribute(prop.res_attrs);
  writer.writeAttribute(prop.sym_name);
  writer.writeAttribute(prop.sym_visibility);
}

::mlir::Attribute FuncOpV1::getSymName() {
  auto attr = getSymNameAttr();
  return attr;
}

::mlir::Attribute FuncOpV1::getFunctionType() {
  auto attr = getFunctionTypeAttr();
  return attr;
}

::mlir::Attribute FuncOpV1::getSymVisibility() {
  auto attr = getSymVisibilityAttr();
  return attr;
}

::mlir::Attribute FuncOpV1::getArgAttrs() {
  auto attr = getArgAttrsAttr();
  return attr;
}

::mlir::Attribute FuncOpV1::getResAttrs() {
  auto attr = getResAttrsAttr();
  return attr;
}

void FuncOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Attribute sym_name, ::mlir::Attribute function_type, ::mlir::Attribute sym_visibility, ::mlir::Attribute arg_attrs, ::mlir::Attribute res_attrs) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().function_type = function_type;
  odsState.getOrAddProperties<Properties>().sym_visibility = sym_visibility;
  odsState.getOrAddProperties<Properties>().arg_attrs = arg_attrs;
  odsState.getOrAddProperties<Properties>().res_attrs = res_attrs;
  (void)odsState.addRegion();
}

void FuncOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute sym_name, ::mlir::Attribute function_type, ::mlir::Attribute sym_visibility, ::mlir::Attribute arg_attrs, ::mlir::Attribute res_attrs) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().function_type = function_type;
  odsState.getOrAddProperties<Properties>().sym_visibility = sym_visibility;
  odsState.getOrAddProperties<Properties>().arg_attrs = arg_attrs;
  odsState.getOrAddProperties<Properties>().res_attrs = res_attrs;
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FuncOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FuncOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult FuncOpV1::verifyInvariantsImpl() {
  auto tblgen_arg_attrs = getProperties().arg_attrs; (void)tblgen_arg_attrs;
  if (!tblgen_arg_attrs) return emitOpError("requires attribute 'arg_attrs'");
  auto tblgen_function_type = getProperties().function_type; (void)tblgen_function_type;
  if (!tblgen_function_type) return emitOpError("requires attribute 'function_type'");
  auto tblgen_res_attrs = getProperties().res_attrs; (void)tblgen_res_attrs;
  if (!tblgen_res_attrs) return emitOpError("requires attribute 'res_attrs'");
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");
  auto tblgen_sym_visibility = getProperties().sym_visibility; (void)tblgen_sym_visibility;
  if (!tblgen_sym_visibility) return emitOpError("requires attribute 'sym_visibility'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_function_type, "function_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_sym_visibility, "sym_visibility")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_arg_attrs, "arg_attrs")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_res_attrs, "res_attrs")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult FuncOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FuncOpV1::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Attribute sym_nameAttr;
  std::unique_ptr<::mlir::Region> bodyRegion = std::make_unique<::mlir::Region>();
  ::mlir::Attribute function_typeAttr;
  {
    auto odsResult = parseFunctionBody(parser, sym_nameAttr, *bodyRegion, function_typeAttr);
    if (odsResult) return ::mlir::failure();
    result.getOrAddProperties<FuncOpV1::Properties>().sym_name = sym_nameAttr;
    result.getOrAddProperties<FuncOpV1::Properties>().function_type = function_typeAttr;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(bodyRegion));
  return ::mlir::success();
}

void FuncOpV1::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  printFunctionBody(_odsPrinter, *this, getSymNameAttr(), getBody(), getFunctionTypeAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  elidedAttrs.push_back("function_type");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

mlir::vhlo::Version FuncOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version FuncOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::FuncOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GatherOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
GatherOpV1GenericAdaptorBase::GatherOpV1GenericAdaptorBase(GatherOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute GatherOpV1GenericAdaptorBase::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV1GenericAdaptorBase::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV1GenericAdaptorBase::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute GatherOpV1GenericAdaptorBase::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute GatherOpV1GenericAdaptorBase::getSliceSizes() {
  auto attr = getSliceSizesAttr();
  return attr;
}

::mlir::Attribute GatherOpV1GenericAdaptorBase::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

} // namespace detail
GatherOpV1Adaptor::GatherOpV1Adaptor(GatherOpV1 op) : GatherOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GatherOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitError(loc, "'vhlo.gather_v1' op ""requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitError(loc, "'vhlo.gather_v1' op ""requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitError(loc, "'vhlo.gather_v1' op ""requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitError(loc, "'vhlo.gather_v1' op ""requires attribute 'offset_dims'");
  auto tblgen_slice_sizes = getProperties().slice_sizes; (void)tblgen_slice_sizes;
  if (!tblgen_slice_sizes) return emitError(loc, "'vhlo.gather_v1' op ""requires attribute 'slice_sizes'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitError(loc, "'vhlo.gather_v1' op ""requires attribute 'start_index_map'");

  if (tblgen_offset_dims && !((true)))
    return emitError(loc, "'vhlo.gather_v1' op ""attribute 'offset_dims' failed to satisfy constraint: any attribute");

  if (tblgen_collapsed_slice_dims && !((true)))
    return emitError(loc, "'vhlo.gather_v1' op ""attribute 'collapsed_slice_dims' failed to satisfy constraint: any attribute");

  if (tblgen_start_index_map && !((true)))
    return emitError(loc, "'vhlo.gather_v1' op ""attribute 'start_index_map' failed to satisfy constraint: any attribute");

  if (tblgen_index_vector_dim && !((true)))
    return emitError(loc, "'vhlo.gather_v1' op ""attribute 'index_vector_dim' failed to satisfy constraint: any attribute");

  if (tblgen_slice_sizes && !((true)))
    return emitError(loc, "'vhlo.gather_v1' op ""attribute 'slice_sizes' failed to satisfy constraint: any attribute");

  if (tblgen_indices_are_sorted && !((true)))
    return emitError(loc, "'vhlo.gather_v1' op ""attribute 'indices_are_sorted' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GatherOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.collapsed_slice_dims;
       auto attr = dict.get("collapsed_slice_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `collapsed_slice_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.index_vector_dim;
       auto attr = dict.get("index_vector_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `index_vector_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.indices_are_sorted;
       auto attr = dict.get("indices_are_sorted");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `indices_are_sorted` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.offset_dims;
       auto attr = dict.get("offset_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `offset_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.slice_sizes;
       auto attr = dict.get("slice_sizes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `slice_sizes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.start_index_map;
       auto attr = dict.get("start_index_map");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `start_index_map` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GatherOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.collapsed_slice_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("collapsed_slice_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.index_vector_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("index_vector_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.indices_are_sorted;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("indices_are_sorted",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.offset_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("offset_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.slice_sizes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("slice_sizes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.start_index_map;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("start_index_map",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GatherOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.collapsed_slice_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.index_vector_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.indices_are_sorted.getAsOpaquePointer()), 
    llvm::hash_value(prop.offset_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.slice_sizes.getAsOpaquePointer()), 
    llvm::hash_value(prop.start_index_map.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GatherOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "collapsed_slice_dims")
      return prop.collapsed_slice_dims;

    if (name == "index_vector_dim")
      return prop.index_vector_dim;

    if (name == "indices_are_sorted")
      return prop.indices_are_sorted;

    if (name == "offset_dims")
      return prop.offset_dims;

    if (name == "slice_sizes")
      return prop.slice_sizes;

    if (name == "start_index_map")
      return prop.start_index_map;
  return std::nullopt;
}

void GatherOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "collapsed_slice_dims") {
       prop.collapsed_slice_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.collapsed_slice_dims)>>(value);
       return;
    }

    if (name == "index_vector_dim") {
       prop.index_vector_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.index_vector_dim)>>(value);
       return;
    }

    if (name == "indices_are_sorted") {
       prop.indices_are_sorted = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.indices_are_sorted)>>(value);
       return;
    }

    if (name == "offset_dims") {
       prop.offset_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.offset_dims)>>(value);
       return;
    }

    if (name == "slice_sizes") {
       prop.slice_sizes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.slice_sizes)>>(value);
       return;
    }

    if (name == "start_index_map") {
       prop.start_index_map = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.start_index_map)>>(value);
       return;
    }
}

void GatherOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.collapsed_slice_dims) attrs.append("collapsed_slice_dims", prop.collapsed_slice_dims);

    if (prop.index_vector_dim) attrs.append("index_vector_dim", prop.index_vector_dim);

    if (prop.indices_are_sorted) attrs.append("indices_are_sorted", prop.indices_are_sorted);

    if (prop.offset_dims) attrs.append("offset_dims", prop.offset_dims);

    if (prop.slice_sizes) attrs.append("slice_sizes", prop.slice_sizes);

    if (prop.start_index_map) attrs.append("start_index_map", prop.start_index_map);
}

::llvm::LogicalResult GatherOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCollapsedSliceDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "collapsed_slice_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndexVectorDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "index_vector_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndicesAreSortedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "indices_are_sorted", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOffsetDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "offset_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSliceSizesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "slice_sizes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStartIndexMapAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "start_index_map", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GatherOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.collapsed_slice_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.index_vector_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.indices_are_sorted)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.offset_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.slice_sizes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.start_index_map)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GatherOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.collapsed_slice_dims);
  writer.writeAttribute(prop.index_vector_dim);
  writer.writeAttribute(prop.indices_are_sorted);
  writer.writeAttribute(prop.offset_dims);
  writer.writeAttribute(prop.slice_sizes);
  writer.writeAttribute(prop.start_index_map);
}

::mlir::Attribute GatherOpV1::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV1::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV1::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute GatherOpV1::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute GatherOpV1::getSliceSizes() {
  auto attr = getSliceSizesAttr();
  return attr;
}

::mlir::Attribute GatherOpV1::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

void GatherOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().slice_sizes = slice_sizes;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  odsState.addTypes(result);
}

void GatherOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().slice_sizes = slice_sizes;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GatherOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GatherOpV1::verifyInvariantsImpl() {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitOpError("requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitOpError("requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitOpError("requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitOpError("requires attribute 'offset_dims'");
  auto tblgen_slice_sizes = getProperties().slice_sizes; (void)tblgen_slice_sizes;
  if (!tblgen_slice_sizes) return emitOpError("requires attribute 'slice_sizes'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitOpError("requires attribute 'start_index_map'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_offset_dims, "offset_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_collapsed_slice_dims, "collapsed_slice_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_start_index_map, "start_index_map")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_index_vector_dim, "index_vector_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_slice_sizes, "slice_sizes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_indices_are_sorted, "indices_are_sorted")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult GatherOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version GatherOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version GatherOpV1::getMaxVersion() {
   return mlir::vhlo::Version(1, 0, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::GatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GatherOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
GatherOpV2GenericAdaptorBase::GatherOpV2GenericAdaptorBase(GatherOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getOperandBatchingDims() {
  auto attr = getOperandBatchingDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getStartIndicesBatchingDims() {
  auto attr = getStartIndicesBatchingDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getSliceSizes() {
  auto attr = getSliceSizesAttr();
  return attr;
}

::mlir::Attribute GatherOpV2GenericAdaptorBase::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

} // namespace detail
GatherOpV2Adaptor::GatherOpV2Adaptor(GatherOpV2 op) : GatherOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GatherOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'offset_dims'");
  auto tblgen_operand_batching_dims = getProperties().operand_batching_dims; (void)tblgen_operand_batching_dims;
  if (!tblgen_operand_batching_dims) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'operand_batching_dims'");
  auto tblgen_slice_sizes = getProperties().slice_sizes; (void)tblgen_slice_sizes;
  if (!tblgen_slice_sizes) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'slice_sizes'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'start_index_map'");
  auto tblgen_start_indices_batching_dims = getProperties().start_indices_batching_dims; (void)tblgen_start_indices_batching_dims;
  if (!tblgen_start_indices_batching_dims) return emitError(loc, "'vhlo.gather_v2' op ""requires attribute 'start_indices_batching_dims'");

  if (tblgen_offset_dims && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'offset_dims' failed to satisfy constraint: any attribute");

  if (tblgen_collapsed_slice_dims && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'collapsed_slice_dims' failed to satisfy constraint: any attribute");

  if (tblgen_operand_batching_dims && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'operand_batching_dims' failed to satisfy constraint: any attribute");

  if (tblgen_start_indices_batching_dims && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'start_indices_batching_dims' failed to satisfy constraint: any attribute");

  if (tblgen_start_index_map && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'start_index_map' failed to satisfy constraint: any attribute");

  if (tblgen_index_vector_dim && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'index_vector_dim' failed to satisfy constraint: any attribute");

  if (tblgen_slice_sizes && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'slice_sizes' failed to satisfy constraint: any attribute");

  if (tblgen_indices_are_sorted && !((true)))
    return emitError(loc, "'vhlo.gather_v2' op ""attribute 'indices_are_sorted' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GatherOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.collapsed_slice_dims;
       auto attr = dict.get("collapsed_slice_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `collapsed_slice_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.index_vector_dim;
       auto attr = dict.get("index_vector_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `index_vector_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.indices_are_sorted;
       auto attr = dict.get("indices_are_sorted");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `indices_are_sorted` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.offset_dims;
       auto attr = dict.get("offset_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `offset_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.operand_batching_dims;
       auto attr = dict.get("operand_batching_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `operand_batching_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.slice_sizes;
       auto attr = dict.get("slice_sizes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `slice_sizes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.start_index_map;
       auto attr = dict.get("start_index_map");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `start_index_map` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.start_indices_batching_dims;
       auto attr = dict.get("start_indices_batching_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `start_indices_batching_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GatherOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.collapsed_slice_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("collapsed_slice_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.index_vector_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("index_vector_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.indices_are_sorted;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("indices_are_sorted",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.offset_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("offset_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operand_batching_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("operand_batching_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.slice_sizes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("slice_sizes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.start_index_map;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("start_index_map",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.start_indices_batching_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("start_indices_batching_dims",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GatherOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.collapsed_slice_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.index_vector_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.indices_are_sorted.getAsOpaquePointer()), 
    llvm::hash_value(prop.offset_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.operand_batching_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.slice_sizes.getAsOpaquePointer()), 
    llvm::hash_value(prop.start_index_map.getAsOpaquePointer()), 
    llvm::hash_value(prop.start_indices_batching_dims.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GatherOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "collapsed_slice_dims")
      return prop.collapsed_slice_dims;

    if (name == "index_vector_dim")
      return prop.index_vector_dim;

    if (name == "indices_are_sorted")
      return prop.indices_are_sorted;

    if (name == "offset_dims")
      return prop.offset_dims;

    if (name == "operand_batching_dims")
      return prop.operand_batching_dims;

    if (name == "slice_sizes")
      return prop.slice_sizes;

    if (name == "start_index_map")
      return prop.start_index_map;

    if (name == "start_indices_batching_dims")
      return prop.start_indices_batching_dims;
  return std::nullopt;
}

void GatherOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "collapsed_slice_dims") {
       prop.collapsed_slice_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.collapsed_slice_dims)>>(value);
       return;
    }

    if (name == "index_vector_dim") {
       prop.index_vector_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.index_vector_dim)>>(value);
       return;
    }

    if (name == "indices_are_sorted") {
       prop.indices_are_sorted = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.indices_are_sorted)>>(value);
       return;
    }

    if (name == "offset_dims") {
       prop.offset_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.offset_dims)>>(value);
       return;
    }

    if (name == "operand_batching_dims") {
       prop.operand_batching_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.operand_batching_dims)>>(value);
       return;
    }

    if (name == "slice_sizes") {
       prop.slice_sizes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.slice_sizes)>>(value);
       return;
    }

    if (name == "start_index_map") {
       prop.start_index_map = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.start_index_map)>>(value);
       return;
    }

    if (name == "start_indices_batching_dims") {
       prop.start_indices_batching_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.start_indices_batching_dims)>>(value);
       return;
    }
}

void GatherOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.collapsed_slice_dims) attrs.append("collapsed_slice_dims", prop.collapsed_slice_dims);

    if (prop.index_vector_dim) attrs.append("index_vector_dim", prop.index_vector_dim);

    if (prop.indices_are_sorted) attrs.append("indices_are_sorted", prop.indices_are_sorted);

    if (prop.offset_dims) attrs.append("offset_dims", prop.offset_dims);

    if (prop.operand_batching_dims) attrs.append("operand_batching_dims", prop.operand_batching_dims);

    if (prop.slice_sizes) attrs.append("slice_sizes", prop.slice_sizes);

    if (prop.start_index_map) attrs.append("start_index_map", prop.start_index_map);

    if (prop.start_indices_batching_dims) attrs.append("start_indices_batching_dims", prop.start_indices_batching_dims);
}

::llvm::LogicalResult GatherOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getCollapsedSliceDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "collapsed_slice_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndexVectorDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "index_vector_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndicesAreSortedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "indices_are_sorted", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOffsetDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "offset_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getOperandBatchingDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "operand_batching_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSliceSizesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "slice_sizes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStartIndexMapAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "start_index_map", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStartIndicesBatchingDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "start_indices_batching_dims", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GatherOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.collapsed_slice_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.index_vector_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.indices_are_sorted)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.offset_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.operand_batching_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.slice_sizes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.start_index_map)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.start_indices_batching_dims)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GatherOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.collapsed_slice_dims);
  writer.writeAttribute(prop.index_vector_dim);
  writer.writeAttribute(prop.indices_are_sorted);
  writer.writeAttribute(prop.offset_dims);
  writer.writeAttribute(prop.operand_batching_dims);
  writer.writeAttribute(prop.slice_sizes);
  writer.writeAttribute(prop.start_index_map);
  writer.writeAttribute(prop.start_indices_batching_dims);
}

::mlir::Attribute GatherOpV2::getOffsetDims() {
  auto attr = getOffsetDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2::getCollapsedSliceDims() {
  auto attr = getCollapsedSliceDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2::getOperandBatchingDims() {
  auto attr = getOperandBatchingDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2::getStartIndicesBatchingDims() {
  auto attr = getStartIndicesBatchingDimsAttr();
  return attr;
}

::mlir::Attribute GatherOpV2::getStartIndexMap() {
  auto attr = getStartIndexMapAttr();
  return attr;
}

::mlir::Attribute GatherOpV2::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute GatherOpV2::getSliceSizes() {
  auto attr = getSliceSizesAttr();
  return attr;
}

::mlir::Attribute GatherOpV2::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

void GatherOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().operand_batching_dims = operand_batching_dims;
  odsState.getOrAddProperties<Properties>().start_indices_batching_dims = start_indices_batching_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().slice_sizes = slice_sizes;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  odsState.addTypes(result);
}

void GatherOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.getOrAddProperties<Properties>().offset_dims = offset_dims;
  odsState.getOrAddProperties<Properties>().collapsed_slice_dims = collapsed_slice_dims;
  odsState.getOrAddProperties<Properties>().operand_batching_dims = operand_batching_dims;
  odsState.getOrAddProperties<Properties>().start_indices_batching_dims = start_indices_batching_dims;
  odsState.getOrAddProperties<Properties>().start_index_map = start_index_map;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().slice_sizes = slice_sizes;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GatherOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GatherOpV2::verifyInvariantsImpl() {
  auto tblgen_collapsed_slice_dims = getProperties().collapsed_slice_dims; (void)tblgen_collapsed_slice_dims;
  if (!tblgen_collapsed_slice_dims) return emitOpError("requires attribute 'collapsed_slice_dims'");
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitOpError("requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitOpError("requires attribute 'indices_are_sorted'");
  auto tblgen_offset_dims = getProperties().offset_dims; (void)tblgen_offset_dims;
  if (!tblgen_offset_dims) return emitOpError("requires attribute 'offset_dims'");
  auto tblgen_operand_batching_dims = getProperties().operand_batching_dims; (void)tblgen_operand_batching_dims;
  if (!tblgen_operand_batching_dims) return emitOpError("requires attribute 'operand_batching_dims'");
  auto tblgen_slice_sizes = getProperties().slice_sizes; (void)tblgen_slice_sizes;
  if (!tblgen_slice_sizes) return emitOpError("requires attribute 'slice_sizes'");
  auto tblgen_start_index_map = getProperties().start_index_map; (void)tblgen_start_index_map;
  if (!tblgen_start_index_map) return emitOpError("requires attribute 'start_index_map'");
  auto tblgen_start_indices_batching_dims = getProperties().start_indices_batching_dims; (void)tblgen_start_indices_batching_dims;
  if (!tblgen_start_indices_batching_dims) return emitOpError("requires attribute 'start_indices_batching_dims'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_offset_dims, "offset_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_collapsed_slice_dims, "collapsed_slice_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_operand_batching_dims, "operand_batching_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_start_indices_batching_dims, "start_indices_batching_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_start_index_map, "start_index_map")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_index_vector_dim, "index_vector_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_slice_sizes, "slice_sizes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_indices_are_sorted, "indices_are_sorted")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult GatherOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version GatherOpV2::getMinVersion() {
  return mlir::vhlo::Version(1, 1, 0);
}
mlir::vhlo::Version GatherOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::GatherOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GetDimensionSizeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
GetDimensionSizeOpV1GenericAdaptorBase::GetDimensionSizeOpV1GenericAdaptorBase(GetDimensionSizeOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute GetDimensionSizeOpV1GenericAdaptorBase::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

} // namespace detail
GetDimensionSizeOpV1Adaptor::GetDimensionSizeOpV1Adaptor(GetDimensionSizeOpV1 op) : GetDimensionSizeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GetDimensionSizeOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitError(loc, "'vhlo.get_dimension_size_v1' op ""requires attribute 'dimension'");

  if (tblgen_dimension && !((true)))
    return emitError(loc, "'vhlo.get_dimension_size_v1' op ""attribute 'dimension' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GetDimensionSizeOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dimension;
       auto attr = dict.get("dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GetDimensionSizeOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dimension",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GetDimensionSizeOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dimension.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GetDimensionSizeOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dimension")
      return prop.dimension;
  return std::nullopt;
}

void GetDimensionSizeOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dimension") {
       prop.dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dimension)>>(value);
       return;
    }
}

void GetDimensionSizeOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dimension) attrs.append("dimension", prop.dimension);
}

::llvm::LogicalResult GetDimensionSizeOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dimension", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GetDimensionSizeOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dimension)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetDimensionSizeOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dimension);
}

::mlir::Attribute GetDimensionSizeOpV1::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

void GetDimensionSizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute dimension) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().dimension = dimension;
  odsState.addTypes(result);
}

void GetDimensionSizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute dimension) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().dimension = dimension;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetDimensionSizeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GetDimensionSizeOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GetDimensionSizeOpV1::verifyInvariantsImpl() {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitOpError("requires attribute 'dimension'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dimension, "dimension")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult GetDimensionSizeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version GetDimensionSizeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version GetDimensionSizeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::GetDimensionSizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GetTupleElementOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
GetTupleElementOpV1GenericAdaptorBase::GetTupleElementOpV1GenericAdaptorBase(GetTupleElementOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute GetTupleElementOpV1GenericAdaptorBase::getIndex() {
  auto attr = getIndexAttr();
  return attr;
}

} // namespace detail
GetTupleElementOpV1Adaptor::GetTupleElementOpV1Adaptor(GetTupleElementOpV1 op) : GetTupleElementOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GetTupleElementOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_index = getProperties().index; (void)tblgen_index;
  if (!tblgen_index) return emitError(loc, "'vhlo.get_tuple_element_v1' op ""requires attribute 'index'");

  if (tblgen_index && !((true)))
    return emitError(loc, "'vhlo.get_tuple_element_v1' op ""attribute 'index' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GetTupleElementOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.index;
       auto attr = dict.get("index");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `index` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GetTupleElementOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.index;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("index",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GetTupleElementOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.index.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GetTupleElementOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "index")
      return prop.index;
  return std::nullopt;
}

void GetTupleElementOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "index") {
       prop.index = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.index)>>(value);
       return;
    }
}

void GetTupleElementOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.index) attrs.append("index", prop.index);
}

::llvm::LogicalResult GetTupleElementOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getIndexAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "index", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GetTupleElementOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.index)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetTupleElementOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.index);
}

::mlir::Attribute GetTupleElementOpV1::getIndex() {
  auto attr = getIndexAttr();
  return attr;
}

void GetTupleElementOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute index) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().index = index;
  odsState.addTypes(result);
}

void GetTupleElementOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute index) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().index = index;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetTupleElementOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GetTupleElementOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GetTupleElementOpV1::verifyInvariantsImpl() {
  auto tblgen_index = getProperties().index; (void)tblgen_index;
  if (!tblgen_index) return emitOpError("requires attribute 'index'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_index, "index")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult GetTupleElementOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version GetTupleElementOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version GetTupleElementOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::GetTupleElementOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IfOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
IfOpV1Adaptor::IfOpV1Adaptor(IfOpV1 op) : IfOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult IfOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> IfOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

void IfOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value pred) {
  odsState.addOperands(pred);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void IfOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult IfOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "true_branch", index++)))
        return ::mlir::failure();

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(1)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "false_branch", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult IfOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version IfOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version IfOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::IfOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ImagOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ImagOpV1Adaptor::ImagOpV1Adaptor(ImagOpV1 op) : ImagOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ImagOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ImagOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ImagOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ImagOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ImagOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ImagOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ImagOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ImagOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ImagOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::InfeedOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
InfeedOpV1GenericAdaptorBase::InfeedOpV1GenericAdaptorBase(InfeedOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute InfeedOpV1GenericAdaptorBase::getInfeedConfig() {
  auto attr = getInfeedConfigAttr();
  return attr;
}

::mlir::Attribute InfeedOpV1GenericAdaptorBase::getLayout() {
  auto attr = getLayoutAttr();
  return attr;
}

} // namespace detail
InfeedOpV1Adaptor::InfeedOpV1Adaptor(InfeedOpV1 op) : InfeedOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult InfeedOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_infeed_config = getProperties().infeed_config; (void)tblgen_infeed_config;
  if (!tblgen_infeed_config) return emitError(loc, "'vhlo.infeed_v1' op ""requires attribute 'infeed_config'");
  auto tblgen_layout = getProperties().layout; (void)tblgen_layout;
  if (!tblgen_layout) return emitError(loc, "'vhlo.infeed_v1' op ""requires attribute 'layout'");

  if (tblgen_infeed_config && !((true)))
    return emitError(loc, "'vhlo.infeed_v1' op ""attribute 'infeed_config' failed to satisfy constraint: any attribute");

  if (tblgen_layout && !((true)))
    return emitError(loc, "'vhlo.infeed_v1' op ""attribute 'layout' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> InfeedOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult InfeedOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.infeed_config;
       auto attr = dict.get("infeed_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `infeed_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.layout;
       auto attr = dict.get("layout");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `layout` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute InfeedOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.infeed_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("infeed_config",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.layout;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("layout",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code InfeedOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.infeed_config.getAsOpaquePointer()), 
    llvm::hash_value(prop.layout.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> InfeedOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "infeed_config")
      return prop.infeed_config;

    if (name == "layout")
      return prop.layout;
  return std::nullopt;
}

void InfeedOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "infeed_config") {
       prop.infeed_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.infeed_config)>>(value);
       return;
    }

    if (name == "layout") {
       prop.layout = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.layout)>>(value);
       return;
    }
}

void InfeedOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.infeed_config) attrs.append("infeed_config", prop.infeed_config);

    if (prop.layout) attrs.append("layout", prop.layout);
}

::llvm::LogicalResult InfeedOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getInfeedConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "infeed_config", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLayoutAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "layout", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult InfeedOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.infeed_config)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.layout)))
    return ::mlir::failure();
  return ::mlir::success();
}

void InfeedOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.infeed_config);
  writer.writeAttribute(prop.layout);
}

::mlir::Attribute InfeedOpV1::getInfeedConfig() {
  auto attr = getInfeedConfigAttr();
  return attr;
}

::mlir::Attribute InfeedOpV1::getLayout() {
  auto attr = getLayoutAttr();
  return attr;
}

void InfeedOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value token, ::mlir::Attribute infeed_config, ::mlir::Attribute layout) {
  odsState.addOperands(token);
  odsState.getOrAddProperties<Properties>().infeed_config = infeed_config;
  odsState.getOrAddProperties<Properties>().layout = layout;
  odsState.addTypes(results);
}

void InfeedOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<InfeedOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult InfeedOpV1::verifyInvariantsImpl() {
  auto tblgen_infeed_config = getProperties().infeed_config; (void)tblgen_infeed_config;
  if (!tblgen_infeed_config) return emitOpError("requires attribute 'infeed_config'");
  auto tblgen_layout = getProperties().layout; (void)tblgen_layout;
  if (!tblgen_layout) return emitOpError("requires attribute 'layout'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_infeed_config, "infeed_config")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_layout, "layout")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult InfeedOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version InfeedOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version InfeedOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::InfeedOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IotaOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
IotaOpV1GenericAdaptorBase::IotaOpV1GenericAdaptorBase(IotaOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute IotaOpV1GenericAdaptorBase::getIotaDimension() {
  auto attr = getIotaDimensionAttr();
  return attr;
}

} // namespace detail
IotaOpV1Adaptor::IotaOpV1Adaptor(IotaOpV1 op) : IotaOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult IotaOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_iota_dimension = getProperties().iota_dimension; (void)tblgen_iota_dimension;
  if (!tblgen_iota_dimension) return emitError(loc, "'vhlo.iota_v1' op ""requires attribute 'iota_dimension'");

  if (tblgen_iota_dimension && !((true)))
    return emitError(loc, "'vhlo.iota_v1' op ""attribute 'iota_dimension' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult IotaOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.iota_dimension;
       auto attr = dict.get("iota_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `iota_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute IotaOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.iota_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("iota_dimension",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code IotaOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.iota_dimension.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> IotaOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "iota_dimension")
      return prop.iota_dimension;
  return std::nullopt;
}

void IotaOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "iota_dimension") {
       prop.iota_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.iota_dimension)>>(value);
       return;
    }
}

void IotaOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.iota_dimension) attrs.append("iota_dimension", prop.iota_dimension);
}

::llvm::LogicalResult IotaOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getIotaDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "iota_dimension", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult IotaOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.iota_dimension)))
    return ::mlir::failure();
  return ::mlir::success();
}

void IotaOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.iota_dimension);
}

::mlir::Attribute IotaOpV1::getIotaDimension() {
  auto attr = getIotaDimensionAttr();
  return attr;
}

void IotaOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Attribute iota_dimension) {
  odsState.getOrAddProperties<Properties>().iota_dimension = iota_dimension;
  odsState.addTypes(output);
}

void IotaOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute iota_dimension) {
  odsState.getOrAddProperties<Properties>().iota_dimension = iota_dimension;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IotaOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<IotaOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult IotaOpV1::verifyInvariantsImpl() {
  auto tblgen_iota_dimension = getProperties().iota_dimension; (void)tblgen_iota_dimension;
  if (!tblgen_iota_dimension) return emitOpError("requires attribute 'iota_dimension'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_iota_dimension, "iota_dimension")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult IotaOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version IotaOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version IotaOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::IotaOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IsFiniteOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
IsFiniteOpV1Adaptor::IsFiniteOpV1Adaptor(IsFiniteOpV1 op) : IsFiniteOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult IsFiniteOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void IsFiniteOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void IsFiniteOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IsFiniteOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult IsFiniteOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult IsFiniteOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version IsFiniteOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version IsFiniteOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::IsFiniteOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Log1pOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
Log1pOpV1Adaptor::Log1pOpV1Adaptor(Log1pOpV1 op) : Log1pOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult Log1pOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void Log1pOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void Log1pOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Log1pOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult Log1pOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult Log1pOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version Log1pOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version Log1pOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::Log1pOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::LogOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
LogOpV1Adaptor::LogOpV1Adaptor(LogOpV1 op) : LogOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LogOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void LogOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void LogOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult LogOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult LogOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version LogOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version LogOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::LogOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::LogisticOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
LogisticOpV1Adaptor::LogisticOpV1Adaptor(LogisticOpV1 op) : LogisticOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LogisticOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void LogisticOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void LogisticOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogisticOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult LogisticOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult LogisticOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version LogisticOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version LogisticOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::LogisticOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MapOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
MapOpV1GenericAdaptorBase::MapOpV1GenericAdaptorBase(MapOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> MapOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute MapOpV1GenericAdaptorBase::getDimensions() {
  auto attr = getDimensionsAttr();
  return attr;
}

} // namespace detail
MapOpV1Adaptor::MapOpV1Adaptor(MapOpV1 op) : MapOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult MapOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_dimensions = getProperties().dimensions; (void)tblgen_dimensions;
  if (!tblgen_dimensions) return emitError(loc, "'vhlo.map_v1' op ""requires attribute 'dimensions'");

  if (tblgen_dimensions && !((true)))
    return emitError(loc, "'vhlo.map_v1' op ""attribute 'dimensions' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> MapOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange MapOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::llvm::LogicalResult MapOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dimensions;
       auto attr = dict.get("dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute MapOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dimensions",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code MapOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dimensions.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> MapOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dimensions")
      return prop.dimensions;
  return std::nullopt;
}

void MapOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dimensions") {
       prop.dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dimensions)>>(value);
       return;
    }
}

void MapOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dimensions) attrs.append("dimensions", prop.dimensions);
}

::llvm::LogicalResult MapOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dimensions", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult MapOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dimensions)))
    return ::mlir::failure();
  return ::mlir::success();
}

void MapOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dimensions);
}

::mlir::Attribute MapOpV1::getDimensions() {
  auto attr = getDimensionsAttr();
  return attr;
}

void MapOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Attribute dimensions) {
  odsState.addOperands(inputs);
  odsState.getOrAddProperties<Properties>().dimensions = dimensions;
  (void)odsState.addRegion();
  odsState.addTypes(result);
}

void MapOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Attribute dimensions) {
  odsState.addOperands(inputs);
  odsState.getOrAddProperties<Properties>().dimensions = dimensions;
  (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MapOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<MapOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult MapOpV1::verifyInvariantsImpl() {
  auto tblgen_dimensions = getProperties().dimensions; (void)tblgen_dimensions;
  if (!tblgen_dimensions) return emitOpError("requires attribute 'dimensions'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dimensions, "dimensions")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "computation", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult MapOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version MapOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version MapOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::MapOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MaxOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
MaxOpV1Adaptor::MaxOpV1Adaptor(MaxOpV1 op) : MaxOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult MaxOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void MaxOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MaxOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult MaxOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult MaxOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version MaxOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version MaxOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::MaxOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MinOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
MinOpV1Adaptor::MinOpV1Adaptor(MinOpV1 op) : MinOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult MinOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void MinOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MinOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MinOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult MinOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult MinOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version MinOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version MinOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::MinOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MulOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
MulOpV1Adaptor::MulOpV1Adaptor(MulOpV1 op) : MulOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult MulOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void MulOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MulOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult MulOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult MulOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version MulOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version MulOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::MulOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::NegOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
NegOpV1Adaptor::NegOpV1Adaptor(NegOpV1 op) : NegOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult NegOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void NegOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void NegOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NegOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult NegOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult NegOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version NegOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version NegOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::NegOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::NotOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
NotOpV1Adaptor::NotOpV1Adaptor(NotOpV1 op) : NotOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult NotOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void NotOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void NotOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NotOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult NotOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult NotOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version NotOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version NotOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::NotOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OptimizationBarrierOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> OptimizationBarrierOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
OptimizationBarrierOpV1Adaptor::OptimizationBarrierOpV1Adaptor(OptimizationBarrierOpV1 op) : OptimizationBarrierOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult OptimizationBarrierOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OptimizationBarrierOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange OptimizationBarrierOpV1::getOperandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OptimizationBarrierOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

void OptimizationBarrierOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult OptimizationBarrierOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult OptimizationBarrierOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version OptimizationBarrierOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version OptimizationBarrierOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::OptimizationBarrierOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OrOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
OrOpV1Adaptor::OrOpV1Adaptor(OrOpV1 op) : OrOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult OrOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void OrOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void OrOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OrOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult OrOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult OrOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version OrOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version OrOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::OrOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OutfeedOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
OutfeedOpV1GenericAdaptorBase::OutfeedOpV1GenericAdaptorBase(OutfeedOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> OutfeedOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute OutfeedOpV1GenericAdaptorBase::getOutfeedConfig() {
  auto attr = getOutfeedConfigAttr();
  return attr;
}

} // namespace detail
OutfeedOpV1Adaptor::OutfeedOpV1Adaptor(OutfeedOpV1 op) : OutfeedOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult OutfeedOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_outfeed_config = getProperties().outfeed_config; (void)tblgen_outfeed_config;
  if (!tblgen_outfeed_config) return emitError(loc, "'vhlo.outfeed_v1' op ""requires attribute 'outfeed_config'");

  if (tblgen_outfeed_config && !((true)))
    return emitError(loc, "'vhlo.outfeed_v1' op ""attribute 'outfeed_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OutfeedOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange OutfeedOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::llvm::LogicalResult OutfeedOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.outfeed_config;
       auto attr = dict.get("outfeed_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `outfeed_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute OutfeedOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.outfeed_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("outfeed_config",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code OutfeedOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.outfeed_config.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> OutfeedOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "outfeed_config")
      return prop.outfeed_config;
  return std::nullopt;
}

void OutfeedOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "outfeed_config") {
       prop.outfeed_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.outfeed_config)>>(value);
       return;
    }
}

void OutfeedOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.outfeed_config) attrs.append("outfeed_config", prop.outfeed_config);
}

::llvm::LogicalResult OutfeedOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getOutfeedConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "outfeed_config", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult OutfeedOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.outfeed_config)))
    return ::mlir::failure();
  return ::mlir::success();
}

void OutfeedOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.outfeed_config);
}

::mlir::Attribute OutfeedOpV1::getOutfeedConfig() {
  auto attr = getOutfeedConfigAttr();
  return attr;
}

void OutfeedOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute outfeed_config) {
  odsState.addOperands(inputs);
  odsState.addOperands(token);
  odsState.getOrAddProperties<Properties>().outfeed_config = outfeed_config;
  odsState.addTypes(result);
}

void OutfeedOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute outfeed_config) {
  odsState.addOperands(inputs);
  odsState.addOperands(token);
  odsState.getOrAddProperties<Properties>().outfeed_config = outfeed_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OutfeedOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<OutfeedOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult OutfeedOpV1::verifyInvariantsImpl() {
  auto tblgen_outfeed_config = getProperties().outfeed_config; (void)tblgen_outfeed_config;
  if (!tblgen_outfeed_config) return emitOpError("requires attribute 'outfeed_config'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_outfeed_config, "outfeed_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult OutfeedOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version OutfeedOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version OutfeedOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::OutfeedOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PadOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
PadOpV1GenericAdaptorBase::PadOpV1GenericAdaptorBase(PadOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute PadOpV1GenericAdaptorBase::getEdgePaddingLow() {
  auto attr = getEdgePaddingLowAttr();
  return attr;
}

::mlir::Attribute PadOpV1GenericAdaptorBase::getEdgePaddingHigh() {
  auto attr = getEdgePaddingHighAttr();
  return attr;
}

::mlir::Attribute PadOpV1GenericAdaptorBase::getInteriorPadding() {
  auto attr = getInteriorPaddingAttr();
  return attr;
}

} // namespace detail
PadOpV1Adaptor::PadOpV1Adaptor(PadOpV1 op) : PadOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PadOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_edge_padding_high = getProperties().edge_padding_high; (void)tblgen_edge_padding_high;
  if (!tblgen_edge_padding_high) return emitError(loc, "'vhlo.pad_v1' op ""requires attribute 'edge_padding_high'");
  auto tblgen_edge_padding_low = getProperties().edge_padding_low; (void)tblgen_edge_padding_low;
  if (!tblgen_edge_padding_low) return emitError(loc, "'vhlo.pad_v1' op ""requires attribute 'edge_padding_low'");
  auto tblgen_interior_padding = getProperties().interior_padding; (void)tblgen_interior_padding;
  if (!tblgen_interior_padding) return emitError(loc, "'vhlo.pad_v1' op ""requires attribute 'interior_padding'");

  if (tblgen_edge_padding_low && !((true)))
    return emitError(loc, "'vhlo.pad_v1' op ""attribute 'edge_padding_low' failed to satisfy constraint: any attribute");

  if (tblgen_edge_padding_high && !((true)))
    return emitError(loc, "'vhlo.pad_v1' op ""attribute 'edge_padding_high' failed to satisfy constraint: any attribute");

  if (tblgen_interior_padding && !((true)))
    return emitError(loc, "'vhlo.pad_v1' op ""attribute 'interior_padding' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult PadOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.edge_padding_high;
       auto attr = dict.get("edge_padding_high");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `edge_padding_high` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.edge_padding_low;
       auto attr = dict.get("edge_padding_low");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `edge_padding_low` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.interior_padding;
       auto attr = dict.get("interior_padding");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `interior_padding` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute PadOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.edge_padding_high;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("edge_padding_high",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.edge_padding_low;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("edge_padding_low",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.interior_padding;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("interior_padding",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code PadOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.edge_padding_high.getAsOpaquePointer()), 
    llvm::hash_value(prop.edge_padding_low.getAsOpaquePointer()), 
    llvm::hash_value(prop.interior_padding.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> PadOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "edge_padding_high")
      return prop.edge_padding_high;

    if (name == "edge_padding_low")
      return prop.edge_padding_low;

    if (name == "interior_padding")
      return prop.interior_padding;
  return std::nullopt;
}

void PadOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "edge_padding_high") {
       prop.edge_padding_high = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.edge_padding_high)>>(value);
       return;
    }

    if (name == "edge_padding_low") {
       prop.edge_padding_low = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.edge_padding_low)>>(value);
       return;
    }

    if (name == "interior_padding") {
       prop.interior_padding = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.interior_padding)>>(value);
       return;
    }
}

void PadOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.edge_padding_high) attrs.append("edge_padding_high", prop.edge_padding_high);

    if (prop.edge_padding_low) attrs.append("edge_padding_low", prop.edge_padding_low);

    if (prop.interior_padding) attrs.append("interior_padding", prop.interior_padding);
}

::llvm::LogicalResult PadOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getEdgePaddingHighAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "edge_padding_high", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getEdgePaddingLowAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "edge_padding_low", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInteriorPaddingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "interior_padding", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult PadOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.edge_padding_high)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.edge_padding_low)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.interior_padding)))
    return ::mlir::failure();
  return ::mlir::success();
}

void PadOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.edge_padding_high);
  writer.writeAttribute(prop.edge_padding_low);
  writer.writeAttribute(prop.interior_padding);
}

::mlir::Attribute PadOpV1::getEdgePaddingLow() {
  auto attr = getEdgePaddingLowAttr();
  return attr;
}

::mlir::Attribute PadOpV1::getEdgePaddingHigh() {
  auto attr = getEdgePaddingHighAttr();
  return attr;
}

::mlir::Attribute PadOpV1::getInteriorPadding() {
  auto attr = getInteriorPaddingAttr();
  return attr;
}

void PadOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Attribute edge_padding_low, ::mlir::Attribute edge_padding_high, ::mlir::Attribute interior_padding) {
  odsState.addOperands(operand);
  odsState.addOperands(padding_value);
  odsState.getOrAddProperties<Properties>().edge_padding_low = edge_padding_low;
  odsState.getOrAddProperties<Properties>().edge_padding_high = edge_padding_high;
  odsState.getOrAddProperties<Properties>().interior_padding = interior_padding;
  odsState.addTypes(result);
}

void PadOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Attribute edge_padding_low, ::mlir::Attribute edge_padding_high, ::mlir::Attribute interior_padding) {
  odsState.addOperands(operand);
  odsState.addOperands(padding_value);
  odsState.getOrAddProperties<Properties>().edge_padding_low = edge_padding_low;
  odsState.getOrAddProperties<Properties>().edge_padding_high = edge_padding_high;
  odsState.getOrAddProperties<Properties>().interior_padding = interior_padding;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PadOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<PadOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult PadOpV1::verifyInvariantsImpl() {
  auto tblgen_edge_padding_high = getProperties().edge_padding_high; (void)tblgen_edge_padding_high;
  if (!tblgen_edge_padding_high) return emitOpError("requires attribute 'edge_padding_high'");
  auto tblgen_edge_padding_low = getProperties().edge_padding_low; (void)tblgen_edge_padding_low;
  if (!tblgen_edge_padding_low) return emitOpError("requires attribute 'edge_padding_low'");
  auto tblgen_interior_padding = getProperties().interior_padding; (void)tblgen_interior_padding;
  if (!tblgen_interior_padding) return emitOpError("requires attribute 'interior_padding'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_edge_padding_low, "edge_padding_low")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_edge_padding_high, "edge_padding_high")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_interior_padding, "interior_padding")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PadOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version PadOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version PadOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::PadOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PartitionIdOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
PartitionIdOpV1Adaptor::PartitionIdOpV1Adaptor(PartitionIdOpV1 op) : PartitionIdOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PartitionIdOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void PartitionIdOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result) {
  odsState.addTypes(result);
}

void PartitionIdOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PartitionIdOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult PartitionIdOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PartitionIdOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version PartitionIdOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version PartitionIdOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::PartitionIdOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PopulationCountOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
PopulationCountOpV1Adaptor::PopulationCountOpV1Adaptor(PopulationCountOpV1 op) : PopulationCountOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PopulationCountOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void PopulationCountOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void PopulationCountOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PopulationCountOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult PopulationCountOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PopulationCountOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version PopulationCountOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version PopulationCountOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::PopulationCountOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PowOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
PowOpV1Adaptor::PowOpV1Adaptor(PowOpV1 op) : PowOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PowOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void PowOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void PowOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PowOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult PowOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PowOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version PowOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version PowOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::PowOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RealDynamicSliceOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
RealDynamicSliceOpV1Adaptor::RealDynamicSliceOpV1Adaptor(RealDynamicSliceOpV1 op) : RealDynamicSliceOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RealDynamicSliceOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void RealDynamicSliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value limit_indices, ::mlir::Value strides) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(limit_indices);
  odsState.addOperands(strides);
  odsState.addTypes(result);
}

void RealDynamicSliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value limit_indices, ::mlir::Value strides) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(limit_indices);
  odsState.addOperands(strides);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RealDynamicSliceOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult RealDynamicSliceOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RealDynamicSliceOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RealDynamicSliceOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RealDynamicSliceOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RealDynamicSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RealOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
RealOpV1Adaptor::RealOpV1Adaptor(RealOpV1 op) : RealOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RealOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void RealOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void RealOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RealOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult RealOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RealOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RealOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RealOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RealOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RecvOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
RecvOpV1GenericAdaptorBase::RecvOpV1GenericAdaptorBase(RecvOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute RecvOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute RecvOpV1GenericAdaptorBase::getChannelType() {
  auto attr = getChannelTypeAttr();
  return attr;
}

::mlir::Attribute RecvOpV1GenericAdaptorBase::getIsHostTransfer() {
  auto attr = getIsHostTransferAttr();
  return attr;
}

} // namespace detail
RecvOpV1Adaptor::RecvOpV1Adaptor(RecvOpV1 op) : RecvOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RecvOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.recv_v1' op ""requires attribute 'channel_id'");
  auto tblgen_channel_type = getProperties().channel_type; (void)tblgen_channel_type;
  if (!tblgen_channel_type) return emitError(loc, "'vhlo.recv_v1' op ""requires attribute 'channel_type'");
  auto tblgen_is_host_transfer = getProperties().is_host_transfer; (void)tblgen_is_host_transfer;
  if (!tblgen_is_host_transfer) return emitError(loc, "'vhlo.recv_v1' op ""requires attribute 'is_host_transfer'");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.recv_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");

  if (tblgen_channel_type && !((true)))
    return emitError(loc, "'vhlo.recv_v1' op ""attribute 'channel_type' failed to satisfy constraint: any attribute");

  if (tblgen_is_host_transfer && !((true)))
    return emitError(loc, "'vhlo.recv_v1' op ""attribute 'is_host_transfer' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> RecvOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult RecvOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.channel_type;
       auto attr = dict.get("channel_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.is_host_transfer;
       auto attr = dict.get("is_host_transfer");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `is_host_transfer` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute RecvOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.channel_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.is_host_transfer;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("is_host_transfer",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code RecvOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.channel_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.is_host_transfer.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> RecvOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "channel_type")
      return prop.channel_type;

    if (name == "is_host_transfer")
      return prop.is_host_transfer;
  return std::nullopt;
}

void RecvOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "channel_type") {
       prop.channel_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_type)>>(value);
       return;
    }

    if (name == "is_host_transfer") {
       prop.is_host_transfer = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.is_host_transfer)>>(value);
       return;
    }
}

void RecvOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.channel_type) attrs.append("channel_type", prop.channel_type);

    if (prop.is_host_transfer) attrs.append("is_host_transfer", prop.is_host_transfer);
}

::llvm::LogicalResult RecvOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getChannelTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIsHostTransferAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "is_host_transfer", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult RecvOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.channel_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.is_host_transfer)))
    return ::mlir::failure();
  return ::mlir::success();
}

void RecvOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.channel_type);
  writer.writeAttribute(prop.is_host_transfer);
}

::mlir::Attribute RecvOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute RecvOpV1::getChannelType() {
  auto attr = getChannelTypeAttr();
  return attr;
}

::mlir::Attribute RecvOpV1::getIsHostTransfer() {
  auto attr = getIsHostTransferAttr();
  return attr;
}

void RecvOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer) {
  odsState.addOperands(token);
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().channel_type = channel_type;
  odsState.getOrAddProperties<Properties>().is_host_transfer = is_host_transfer;
  odsState.addTypes(results);
}

void RecvOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<RecvOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult RecvOpV1::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_channel_type = getProperties().channel_type; (void)tblgen_channel_type;
  if (!tblgen_channel_type) return emitOpError("requires attribute 'channel_type'");
  auto tblgen_is_host_transfer = getProperties().is_host_transfer; (void)tblgen_is_host_transfer;
  if (!tblgen_is_host_transfer) return emitOpError("requires attribute 'is_host_transfer'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_type, "channel_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_is_host_transfer, "is_host_transfer")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RecvOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RecvOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RecvOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RecvOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ReduceOpV1GenericAdaptorBase::ReduceOpV1GenericAdaptorBase(ReduceOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ReduceOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute ReduceOpV1GenericAdaptorBase::getDimensions() {
  auto attr = getDimensionsAttr();
  return attr;
}

} // namespace detail
ReduceOpV1Adaptor::ReduceOpV1Adaptor(ReduceOpV1 op) : ReduceOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReduceOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_dimensions = getProperties().dimensions; (void)tblgen_dimensions;
  if (!tblgen_dimensions) return emitError(loc, "'vhlo.reduce_v1' op ""requires attribute 'dimensions'");

  if (tblgen_dimensions && !((true)))
    return emitError(loc, "'vhlo.reduce_v1' op ""attribute 'dimensions' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReduceOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange ReduceOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ReduceOpV1::getInitValuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ReduceOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult ReduceOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dimensions;
       auto attr = dict.get("dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ReduceOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dimensions",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ReduceOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dimensions.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ReduceOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dimensions")
      return prop.dimensions;
  return std::nullopt;
}

void ReduceOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dimensions") {
       prop.dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dimensions)>>(value);
       return;
    }
}

void ReduceOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dimensions) attrs.append("dimensions", prop.dimensions);
}

::llvm::LogicalResult ReduceOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dimensions", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ReduceOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dimensions)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReduceOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dimensions);
}

::mlir::Attribute ReduceOpV1::getDimensions() {
  auto attr = getDimensionsAttr();
  return attr;
}

void ReduceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::ValueRange init_values, ::mlir::Attribute dimensions) {
  odsState.addOperands(inputs);
  odsState.addOperands(init_values);
  odsState.getOrAddProperties<Properties>().dimensions = dimensions;
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void ReduceOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ReduceOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ReduceOpV1::verifyInvariantsImpl() {
  auto tblgen_dimensions = getProperties().dimensions; (void)tblgen_dimensions;
  if (!tblgen_dimensions) return emitOpError("requires attribute 'dimensions'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dimensions, "dimensions")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReduceOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReduceOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReduceOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReducePrecisionOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ReducePrecisionOpV1GenericAdaptorBase::ReducePrecisionOpV1GenericAdaptorBase(ReducePrecisionOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute ReducePrecisionOpV1GenericAdaptorBase::getExponentBits() {
  auto attr = getExponentBitsAttr();
  return attr;
}

::mlir::Attribute ReducePrecisionOpV1GenericAdaptorBase::getMantissaBits() {
  auto attr = getMantissaBitsAttr();
  return attr;
}

} // namespace detail
ReducePrecisionOpV1Adaptor::ReducePrecisionOpV1Adaptor(ReducePrecisionOpV1 op) : ReducePrecisionOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReducePrecisionOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_exponent_bits = getProperties().exponent_bits; (void)tblgen_exponent_bits;
  if (!tblgen_exponent_bits) return emitError(loc, "'vhlo.reduce_precision_v1' op ""requires attribute 'exponent_bits'");
  auto tblgen_mantissa_bits = getProperties().mantissa_bits; (void)tblgen_mantissa_bits;
  if (!tblgen_mantissa_bits) return emitError(loc, "'vhlo.reduce_precision_v1' op ""requires attribute 'mantissa_bits'");

  if (tblgen_exponent_bits && !((true)))
    return emitError(loc, "'vhlo.reduce_precision_v1' op ""attribute 'exponent_bits' failed to satisfy constraint: any attribute");

  if (tblgen_mantissa_bits && !((true)))
    return emitError(loc, "'vhlo.reduce_precision_v1' op ""attribute 'mantissa_bits' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ReducePrecisionOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.exponent_bits;
       auto attr = dict.get("exponent_bits");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `exponent_bits` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.mantissa_bits;
       auto attr = dict.get("mantissa_bits");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `mantissa_bits` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ReducePrecisionOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.exponent_bits;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("exponent_bits",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.mantissa_bits;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("mantissa_bits",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ReducePrecisionOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.exponent_bits.getAsOpaquePointer()), 
    llvm::hash_value(prop.mantissa_bits.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ReducePrecisionOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "exponent_bits")
      return prop.exponent_bits;

    if (name == "mantissa_bits")
      return prop.mantissa_bits;
  return std::nullopt;
}

void ReducePrecisionOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "exponent_bits") {
       prop.exponent_bits = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.exponent_bits)>>(value);
       return;
    }

    if (name == "mantissa_bits") {
       prop.mantissa_bits = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.mantissa_bits)>>(value);
       return;
    }
}

void ReducePrecisionOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.exponent_bits) attrs.append("exponent_bits", prop.exponent_bits);

    if (prop.mantissa_bits) attrs.append("mantissa_bits", prop.mantissa_bits);
}

::llvm::LogicalResult ReducePrecisionOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getExponentBitsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "exponent_bits", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getMantissaBitsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "mantissa_bits", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ReducePrecisionOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.exponent_bits)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.mantissa_bits)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReducePrecisionOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.exponent_bits);
  writer.writeAttribute(prop.mantissa_bits);
}

::mlir::Attribute ReducePrecisionOpV1::getExponentBits() {
  auto attr = getExponentBitsAttr();
  return attr;
}

::mlir::Attribute ReducePrecisionOpV1::getMantissaBits() {
  auto attr = getMantissaBitsAttr();
  return attr;
}

void ReducePrecisionOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Attribute exponent_bits, ::mlir::Attribute mantissa_bits) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().exponent_bits = exponent_bits;
  odsState.getOrAddProperties<Properties>().mantissa_bits = mantissa_bits;
  odsState.addTypes(output);
}

void ReducePrecisionOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute exponent_bits, ::mlir::Attribute mantissa_bits) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().exponent_bits = exponent_bits;
  odsState.getOrAddProperties<Properties>().mantissa_bits = mantissa_bits;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReducePrecisionOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ReducePrecisionOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ReducePrecisionOpV1::verifyInvariantsImpl() {
  auto tblgen_exponent_bits = getProperties().exponent_bits; (void)tblgen_exponent_bits;
  if (!tblgen_exponent_bits) return emitOpError("requires attribute 'exponent_bits'");
  auto tblgen_mantissa_bits = getProperties().mantissa_bits; (void)tblgen_mantissa_bits;
  if (!tblgen_mantissa_bits) return emitOpError("requires attribute 'mantissa_bits'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_exponent_bits, "exponent_bits")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_mantissa_bits, "mantissa_bits")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReducePrecisionOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReducePrecisionOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReducePrecisionOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReducePrecisionOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceScatterOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ReduceScatterOpV1GenericAdaptorBase::ReduceScatterOpV1GenericAdaptorBase(ReduceScatterOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute ReduceScatterOpV1GenericAdaptorBase::getScatterDimension() {
  auto attr = getScatterDimensionAttr();
  return attr;
}

::mlir::Attribute ReduceScatterOpV1GenericAdaptorBase::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute ReduceScatterOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute ReduceScatterOpV1GenericAdaptorBase::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

} // namespace detail
ReduceScatterOpV1Adaptor::ReduceScatterOpV1Adaptor(ReduceScatterOpV1 op) : ReduceScatterOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReduceScatterOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.reduce_scatter_v1' op ""requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitError(loc, "'vhlo.reduce_scatter_v1' op ""requires attribute 'replica_groups'");
  auto tblgen_scatter_dimension = getProperties().scatter_dimension; (void)tblgen_scatter_dimension;
  if (!tblgen_scatter_dimension) return emitError(loc, "'vhlo.reduce_scatter_v1' op ""requires attribute 'scatter_dimension'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitError(loc, "'vhlo.reduce_scatter_v1' op ""requires attribute 'use_global_device_ids'");

  if (tblgen_scatter_dimension && !((true)))
    return emitError(loc, "'vhlo.reduce_scatter_v1' op ""attribute 'scatter_dimension' failed to satisfy constraint: any attribute");

  if (tblgen_replica_groups && !((true)))
    return emitError(loc, "'vhlo.reduce_scatter_v1' op ""attribute 'replica_groups' failed to satisfy constraint: any attribute");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.reduce_scatter_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");

  if (tblgen_use_global_device_ids && !((true)))
    return emitError(loc, "'vhlo.reduce_scatter_v1' op ""attribute 'use_global_device_ids' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ReduceScatterOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.replica_groups;
       auto attr = dict.get("replica_groups");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `replica_groups` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.scatter_dimension;
       auto attr = dict.get("scatter_dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `scatter_dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.use_global_device_ids;
       auto attr = dict.get("use_global_device_ids");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `use_global_device_ids` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ReduceScatterOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.replica_groups;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("replica_groups",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.scatter_dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("scatter_dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.use_global_device_ids;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("use_global_device_ids",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ReduceScatterOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.replica_groups.getAsOpaquePointer()), 
    llvm::hash_value(prop.scatter_dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.use_global_device_ids.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ReduceScatterOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "replica_groups")
      return prop.replica_groups;

    if (name == "scatter_dimension")
      return prop.scatter_dimension;

    if (name == "use_global_device_ids")
      return prop.use_global_device_ids;
  return std::nullopt;
}

void ReduceScatterOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "replica_groups") {
       prop.replica_groups = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.replica_groups)>>(value);
       return;
    }

    if (name == "scatter_dimension") {
       prop.scatter_dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.scatter_dimension)>>(value);
       return;
    }

    if (name == "use_global_device_ids") {
       prop.use_global_device_ids = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.use_global_device_ids)>>(value);
       return;
    }
}

void ReduceScatterOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.replica_groups) attrs.append("replica_groups", prop.replica_groups);

    if (prop.scatter_dimension) attrs.append("scatter_dimension", prop.scatter_dimension);

    if (prop.use_global_device_ids) attrs.append("use_global_device_ids", prop.use_global_device_ids);
}

::llvm::LogicalResult ReduceScatterOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReplicaGroupsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "replica_groups", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getScatterDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "scatter_dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUseGlobalDeviceIdsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "use_global_device_ids", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ReduceScatterOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.replica_groups)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.scatter_dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.use_global_device_ids)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReduceScatterOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.replica_groups);
  writer.writeAttribute(prop.scatter_dimension);
  writer.writeAttribute(prop.use_global_device_ids);
}

::mlir::Attribute ReduceScatterOpV1::getScatterDimension() {
  auto attr = getScatterDimensionAttr();
  return attr;
}

::mlir::Attribute ReduceScatterOpV1::getReplicaGroups() {
  auto attr = getReplicaGroupsAttr();
  return attr;
}

::mlir::Attribute ReduceScatterOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute ReduceScatterOpV1::getUseGlobalDeviceIds() {
  auto attr = getUseGlobalDeviceIdsAttr();
  return attr;
}

void ReduceScatterOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute scatter_dimension, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().scatter_dimension = scatter_dimension;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  (void)odsState.addRegion();
  odsState.addTypes(result);
}

void ReduceScatterOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute scatter_dimension, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().scatter_dimension = scatter_dimension;
  odsState.getOrAddProperties<Properties>().replica_groups = replica_groups;
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().use_global_device_ids = use_global_device_ids;
  (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReduceScatterOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ReduceScatterOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ReduceScatterOpV1::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_replica_groups = getProperties().replica_groups; (void)tblgen_replica_groups;
  if (!tblgen_replica_groups) return emitOpError("requires attribute 'replica_groups'");
  auto tblgen_scatter_dimension = getProperties().scatter_dimension; (void)tblgen_scatter_dimension;
  if (!tblgen_scatter_dimension) return emitOpError("requires attribute 'scatter_dimension'");
  auto tblgen_use_global_device_ids = getProperties().use_global_device_ids; (void)tblgen_use_global_device_ids;
  if (!tblgen_use_global_device_ids) return emitOpError("requires attribute 'use_global_device_ids'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_scatter_dimension, "scatter_dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_replica_groups, "replica_groups")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_use_global_device_ids, "use_global_device_ids")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "computation", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReduceScatterOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReduceScatterOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReduceScatterOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceWindowOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ReduceWindowOpV1GenericAdaptorBase::ReduceWindowOpV1GenericAdaptorBase(ReduceWindowOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ReduceWindowOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute ReduceWindowOpV1GenericAdaptorBase::getWindowDimensions() {
  auto attr = getWindowDimensionsAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1GenericAdaptorBase::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1GenericAdaptorBase::getBaseDilations() {
  auto attr = getBaseDilationsAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1GenericAdaptorBase::getWindowDilations() {
  auto attr = getWindowDilationsAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1GenericAdaptorBase::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

} // namespace detail
ReduceWindowOpV1Adaptor::ReduceWindowOpV1Adaptor(ReduceWindowOpV1 op) : ReduceWindowOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReduceWindowOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_base_dilations = getProperties().base_dilations; (void)tblgen_base_dilations;
  if (!tblgen_base_dilations) return emitError(loc, "'vhlo.reduce_window_v1' op ""requires attribute 'base_dilations'");
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitError(loc, "'vhlo.reduce_window_v1' op ""requires attribute 'padding'");
  auto tblgen_window_dilations = getProperties().window_dilations; (void)tblgen_window_dilations;
  if (!tblgen_window_dilations) return emitError(loc, "'vhlo.reduce_window_v1' op ""requires attribute 'window_dilations'");
  auto tblgen_window_dimensions = getProperties().window_dimensions; (void)tblgen_window_dimensions;
  if (!tblgen_window_dimensions) return emitError(loc, "'vhlo.reduce_window_v1' op ""requires attribute 'window_dimensions'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitError(loc, "'vhlo.reduce_window_v1' op ""requires attribute 'window_strides'");

  if (tblgen_window_dimensions && !((true)))
    return emitError(loc, "'vhlo.reduce_window_v1' op ""attribute 'window_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_window_strides && !((true)))
    return emitError(loc, "'vhlo.reduce_window_v1' op ""attribute 'window_strides' failed to satisfy constraint: any attribute");

  if (tblgen_base_dilations && !((true)))
    return emitError(loc, "'vhlo.reduce_window_v1' op ""attribute 'base_dilations' failed to satisfy constraint: any attribute");

  if (tblgen_window_dilations && !((true)))
    return emitError(loc, "'vhlo.reduce_window_v1' op ""attribute 'window_dilations' failed to satisfy constraint: any attribute");

  if (tblgen_padding && !((true)))
    return emitError(loc, "'vhlo.reduce_window_v1' op ""attribute 'padding' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReduceWindowOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange ReduceWindowOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ReduceWindowOpV1::getInitValuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ReduceWindowOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult ReduceWindowOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.base_dilations;
       auto attr = dict.get("base_dilations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `base_dilations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.padding;
       auto attr = dict.get("padding");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `padding` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_dilations;
       auto attr = dict.get("window_dilations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_dilations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_dimensions;
       auto attr = dict.get("window_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_strides;
       auto attr = dict.get("window_strides");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_strides` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ReduceWindowOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.base_dilations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("base_dilations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.padding;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("padding",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_dilations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_dilations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_strides;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_strides",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ReduceWindowOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.base_dilations.getAsOpaquePointer()), 
    llvm::hash_value(prop.padding.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_dilations.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_strides.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ReduceWindowOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "base_dilations")
      return prop.base_dilations;

    if (name == "padding")
      return prop.padding;

    if (name == "window_dilations")
      return prop.window_dilations;

    if (name == "window_dimensions")
      return prop.window_dimensions;

    if (name == "window_strides")
      return prop.window_strides;
  return std::nullopt;
}

void ReduceWindowOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "base_dilations") {
       prop.base_dilations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.base_dilations)>>(value);
       return;
    }

    if (name == "padding") {
       prop.padding = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.padding)>>(value);
       return;
    }

    if (name == "window_dilations") {
       prop.window_dilations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_dilations)>>(value);
       return;
    }

    if (name == "window_dimensions") {
       prop.window_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_dimensions)>>(value);
       return;
    }

    if (name == "window_strides") {
       prop.window_strides = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_strides)>>(value);
       return;
    }
}

void ReduceWindowOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.base_dilations) attrs.append("base_dilations", prop.base_dilations);

    if (prop.padding) attrs.append("padding", prop.padding);

    if (prop.window_dilations) attrs.append("window_dilations", prop.window_dilations);

    if (prop.window_dimensions) attrs.append("window_dimensions", prop.window_dimensions);

    if (prop.window_strides) attrs.append("window_strides", prop.window_strides);
}

::llvm::LogicalResult ReduceWindowOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBaseDilationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "base_dilations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPaddingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "padding", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowDilationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_dilations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowStridesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_strides", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ReduceWindowOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.base_dilations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.padding)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_dilations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_strides)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReduceWindowOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.base_dilations);
  writer.writeAttribute(prop.padding);
  writer.writeAttribute(prop.window_dilations);
  writer.writeAttribute(prop.window_dimensions);
  writer.writeAttribute(prop.window_strides);
}

::mlir::Attribute ReduceWindowOpV1::getWindowDimensions() {
  auto attr = getWindowDimensionsAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1::getBaseDilations() {
  auto attr = getBaseDilationsAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1::getWindowDilations() {
  auto attr = getWindowDilationsAttr();
  return attr;
}

::mlir::Attribute ReduceWindowOpV1::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

void ReduceWindowOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::ValueRange init_values, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute base_dilations, ::mlir::Attribute window_dilations, ::mlir::Attribute padding) {
  odsState.addOperands(inputs);
  odsState.addOperands(init_values);
  odsState.getOrAddProperties<Properties>().window_dimensions = window_dimensions;
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().base_dilations = base_dilations;
  odsState.getOrAddProperties<Properties>().window_dilations = window_dilations;
  odsState.getOrAddProperties<Properties>().padding = padding;
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void ReduceWindowOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ReduceWindowOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ReduceWindowOpV1::verifyInvariantsImpl() {
  auto tblgen_base_dilations = getProperties().base_dilations; (void)tblgen_base_dilations;
  if (!tblgen_base_dilations) return emitOpError("requires attribute 'base_dilations'");
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitOpError("requires attribute 'padding'");
  auto tblgen_window_dilations = getProperties().window_dilations; (void)tblgen_window_dilations;
  if (!tblgen_window_dilations) return emitOpError("requires attribute 'window_dilations'");
  auto tblgen_window_dimensions = getProperties().window_dimensions; (void)tblgen_window_dimensions;
  if (!tblgen_window_dimensions) return emitOpError("requires attribute 'window_dimensions'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitOpError("requires attribute 'window_strides'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_dimensions, "window_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_strides, "window_strides")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_base_dilations, "base_dilations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_dilations, "window_dilations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_padding, "padding")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReduceWindowOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReduceWindowOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReduceWindowOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceWindowOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RemOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
RemOpV1Adaptor::RemOpV1Adaptor(RemOpV1 op) : RemOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RemOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void RemOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void RemOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RemOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult RemOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RemOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RemOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RemOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RemOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReplicaIdOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ReplicaIdOpV1Adaptor::ReplicaIdOpV1Adaptor(ReplicaIdOpV1 op) : ReplicaIdOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReplicaIdOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ReplicaIdOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result) {
  odsState.addTypes(result);
}

void ReplicaIdOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReplicaIdOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ReplicaIdOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReplicaIdOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReplicaIdOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReplicaIdOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReplicaIdOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReshapeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ReshapeOpV1Adaptor::ReshapeOpV1Adaptor(ReshapeOpV1 op) : ReshapeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReshapeOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ReshapeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ReshapeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReshapeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ReshapeOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReshapeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReshapeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReshapeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReshapeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReturnOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> ReturnOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
ReturnOpV1Adaptor::ReturnOpV1Adaptor(ReturnOpV1 op) : ReturnOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReturnOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReturnOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange ReturnOpV1::getResultsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void ReturnOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange results) {
  odsState.addOperands(results);
}

void ReturnOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ReturnOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReturnOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReturnOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReturnOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReturnOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReverseOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ReverseOpV1GenericAdaptorBase::ReverseOpV1GenericAdaptorBase(ReverseOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute ReverseOpV1GenericAdaptorBase::getDimensions() {
  auto attr = getDimensionsAttr();
  return attr;
}

} // namespace detail
ReverseOpV1Adaptor::ReverseOpV1Adaptor(ReverseOpV1 op) : ReverseOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReverseOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_dimensions = getProperties().dimensions; (void)tblgen_dimensions;
  if (!tblgen_dimensions) return emitError(loc, "'vhlo.reverse_v1' op ""requires attribute 'dimensions'");

  if (tblgen_dimensions && !((true)))
    return emitError(loc, "'vhlo.reverse_v1' op ""attribute 'dimensions' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult ReverseOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dimensions;
       auto attr = dict.get("dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ReverseOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dimensions",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ReverseOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dimensions.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ReverseOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dimensions")
      return prop.dimensions;
  return std::nullopt;
}

void ReverseOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dimensions") {
       prop.dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dimensions)>>(value);
       return;
    }
}

void ReverseOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dimensions) attrs.append("dimensions", prop.dimensions);
}

::llvm::LogicalResult ReverseOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dimensions", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ReverseOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dimensions)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReverseOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dimensions);
}

::mlir::Attribute ReverseOpV1::getDimensions() {
  auto attr = getDimensionsAttr();
  return attr;
}

void ReverseOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute dimensions) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().dimensions = dimensions;
  odsState.addTypes(result);
}

void ReverseOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute dimensions) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().dimensions = dimensions;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReverseOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ReverseOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ReverseOpV1::verifyInvariantsImpl() {
  auto tblgen_dimensions = getProperties().dimensions; (void)tblgen_dimensions;
  if (!tblgen_dimensions) return emitOpError("requires attribute 'dimensions'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dimensions, "dimensions")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReverseOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ReverseOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ReverseOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReverseOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RngBitGeneratorOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
RngBitGeneratorOpV1GenericAdaptorBase::RngBitGeneratorOpV1GenericAdaptorBase(RngBitGeneratorOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute RngBitGeneratorOpV1GenericAdaptorBase::getRngAlgorithm() {
  auto attr = getRngAlgorithmAttr();
  return attr;
}

} // namespace detail
RngBitGeneratorOpV1Adaptor::RngBitGeneratorOpV1Adaptor(RngBitGeneratorOpV1 op) : RngBitGeneratorOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RngBitGeneratorOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_rng_algorithm = getProperties().rng_algorithm; (void)tblgen_rng_algorithm;
  if (!tblgen_rng_algorithm) return emitError(loc, "'vhlo.rng_bit_generator_v1' op ""requires attribute 'rng_algorithm'");

  if (tblgen_rng_algorithm && !((true)))
    return emitError(loc, "'vhlo.rng_bit_generator_v1' op ""attribute 'rng_algorithm' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

void RngBitGeneratorOpV1::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!resultGroup0.empty())
    setNameFn(*resultGroup0.begin(), "output_state");
  auto resultGroup1 = getODSResults(1);
  if (!resultGroup1.empty())
    setNameFn(*resultGroup1.begin(), "output");
}

::llvm::LogicalResult RngBitGeneratorOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.rng_algorithm;
       auto attr = dict.get("rng_algorithm");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rng_algorithm` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute RngBitGeneratorOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.rng_algorithm;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rng_algorithm",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code RngBitGeneratorOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.rng_algorithm.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> RngBitGeneratorOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "rng_algorithm")
      return prop.rng_algorithm;
  return std::nullopt;
}

void RngBitGeneratorOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "rng_algorithm") {
       prop.rng_algorithm = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rng_algorithm)>>(value);
       return;
    }
}

void RngBitGeneratorOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.rng_algorithm) attrs.append("rng_algorithm", prop.rng_algorithm);
}

::llvm::LogicalResult RngBitGeneratorOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getRngAlgorithmAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rng_algorithm", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult RngBitGeneratorOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.rng_algorithm)))
    return ::mlir::failure();
  return ::mlir::success();
}

void RngBitGeneratorOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.rng_algorithm);
}

::mlir::Attribute RngBitGeneratorOpV1::getRngAlgorithm() {
  auto attr = getRngAlgorithmAttr();
  return attr;
}

void RngBitGeneratorOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_state, ::mlir::Type output, ::mlir::Attribute rng_algorithm, ::mlir::Value initial_state) {
  odsState.addOperands(initial_state);
  odsState.getOrAddProperties<Properties>().rng_algorithm = rng_algorithm;
  odsState.addTypes(output_state);
  odsState.addTypes(output);
}

void RngBitGeneratorOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute rng_algorithm, ::mlir::Value initial_state) {
  odsState.addOperands(initial_state);
  odsState.getOrAddProperties<Properties>().rng_algorithm = rng_algorithm;
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RngBitGeneratorOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<RngBitGeneratorOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult RngBitGeneratorOpV1::verifyInvariantsImpl() {
  auto tblgen_rng_algorithm = getProperties().rng_algorithm; (void)tblgen_rng_algorithm;
  if (!tblgen_rng_algorithm) return emitOpError("requires attribute 'rng_algorithm'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rng_algorithm, "rng_algorithm")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSResults(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RngBitGeneratorOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RngBitGeneratorOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RngBitGeneratorOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RngBitGeneratorOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RngOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
RngOpV1GenericAdaptorBase::RngOpV1GenericAdaptorBase(RngOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute RngOpV1GenericAdaptorBase::getRngDistribution() {
  auto attr = getRngDistributionAttr();
  return attr;
}

} // namespace detail
RngOpV1Adaptor::RngOpV1Adaptor(RngOpV1 op) : RngOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RngOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_rng_distribution = getProperties().rng_distribution; (void)tblgen_rng_distribution;
  if (!tblgen_rng_distribution) return emitError(loc, "'vhlo.rng_v1' op ""requires attribute 'rng_distribution'");

  if (tblgen_rng_distribution && !((true)))
    return emitError(loc, "'vhlo.rng_v1' op ""attribute 'rng_distribution' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult RngOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.rng_distribution;
       auto attr = dict.get("rng_distribution");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `rng_distribution` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute RngOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.rng_distribution;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("rng_distribution",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code RngOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.rng_distribution.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> RngOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "rng_distribution")
      return prop.rng_distribution;
  return std::nullopt;
}

void RngOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "rng_distribution") {
       prop.rng_distribution = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.rng_distribution)>>(value);
       return;
    }
}

void RngOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.rng_distribution) attrs.append("rng_distribution", prop.rng_distribution);
}

::llvm::LogicalResult RngOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getRngDistributionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "rng_distribution", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult RngOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.rng_distribution)))
    return ::mlir::failure();
  return ::mlir::success();
}

void RngOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.rng_distribution);
}

::mlir::Attribute RngOpV1::getRngDistribution() {
  auto attr = getRngDistributionAttr();
  return attr;
}

void RngOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Value b, ::mlir::Value shape, ::mlir::Attribute rng_distribution) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addOperands(shape);
  odsState.getOrAddProperties<Properties>().rng_distribution = rng_distribution;
  odsState.addTypes(result);
}

void RngOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Value shape, ::mlir::Attribute rng_distribution) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addOperands(shape);
  odsState.getOrAddProperties<Properties>().rng_distribution = rng_distribution;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RngOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<RngOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult RngOpV1::verifyInvariantsImpl() {
  auto tblgen_rng_distribution = getProperties().rng_distribution; (void)tblgen_rng_distribution;
  if (!tblgen_rng_distribution) return emitOpError("requires attribute 'rng_distribution'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_rng_distribution, "rng_distribution")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RngOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RngOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RngOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RngOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RoundNearestEvenOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
RoundNearestEvenOpV1Adaptor::RoundNearestEvenOpV1Adaptor(RoundNearestEvenOpV1 op) : RoundNearestEvenOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RoundNearestEvenOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void RoundNearestEvenOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void RoundNearestEvenOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RoundNearestEvenOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult RoundNearestEvenOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RoundNearestEvenOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RoundNearestEvenOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RoundNearestEvenOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RoundNearestEvenOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RoundOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
RoundOpV1Adaptor::RoundOpV1Adaptor(RoundOpV1 op) : RoundOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RoundOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void RoundOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void RoundOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RoundOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult RoundOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RoundOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RoundOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RoundOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RoundOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RsqrtOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
RsqrtOpV1Adaptor::RsqrtOpV1Adaptor(RsqrtOpV1 op) : RsqrtOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RsqrtOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void RsqrtOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void RsqrtOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RsqrtOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult RsqrtOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult RsqrtOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version RsqrtOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version RsqrtOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::RsqrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ScatterOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ScatterOpV1GenericAdaptorBase::ScatterOpV1GenericAdaptorBase(ScatterOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ScatterOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 1) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute ScatterOpV1GenericAdaptorBase::getUpdateWindowDims() {
  auto attr = getUpdateWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1GenericAdaptorBase::getInsertedWindowDims() {
  auto attr = getInsertedWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1GenericAdaptorBase::getScatterDimsToOperandDims() {
  auto attr = getScatterDimsToOperandDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1GenericAdaptorBase::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1GenericAdaptorBase::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1GenericAdaptorBase::getUniqueIndices() {
  auto attr = getUniqueIndicesAttr();
  return attr;
}

} // namespace detail
ScatterOpV1Adaptor::ScatterOpV1Adaptor(ScatterOpV1 op) : ScatterOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ScatterOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitError(loc, "'vhlo.scatter_v1' op ""requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitError(loc, "'vhlo.scatter_v1' op ""requires attribute 'indices_are_sorted'");
  auto tblgen_inserted_window_dims = getProperties().inserted_window_dims; (void)tblgen_inserted_window_dims;
  if (!tblgen_inserted_window_dims) return emitError(loc, "'vhlo.scatter_v1' op ""requires attribute 'inserted_window_dims'");
  auto tblgen_scatter_dims_to_operand_dims = getProperties().scatter_dims_to_operand_dims; (void)tblgen_scatter_dims_to_operand_dims;
  if (!tblgen_scatter_dims_to_operand_dims) return emitError(loc, "'vhlo.scatter_v1' op ""requires attribute 'scatter_dims_to_operand_dims'");
  auto tblgen_unique_indices = getProperties().unique_indices; (void)tblgen_unique_indices;
  if (!tblgen_unique_indices) return emitError(loc, "'vhlo.scatter_v1' op ""requires attribute 'unique_indices'");
  auto tblgen_update_window_dims = getProperties().update_window_dims; (void)tblgen_update_window_dims;
  if (!tblgen_update_window_dims) return emitError(loc, "'vhlo.scatter_v1' op ""requires attribute 'update_window_dims'");

  if (tblgen_update_window_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v1' op ""attribute 'update_window_dims' failed to satisfy constraint: any attribute");

  if (tblgen_inserted_window_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v1' op ""attribute 'inserted_window_dims' failed to satisfy constraint: any attribute");

  if (tblgen_scatter_dims_to_operand_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v1' op ""attribute 'scatter_dims_to_operand_dims' failed to satisfy constraint: any attribute");

  if (tblgen_index_vector_dim && !((true)))
    return emitError(loc, "'vhlo.scatter_v1' op ""attribute 'index_vector_dim' failed to satisfy constraint: any attribute");

  if (tblgen_indices_are_sorted && !((true)))
    return emitError(loc, "'vhlo.scatter_v1' op ""attribute 'indices_are_sorted' failed to satisfy constraint: any attribute");

  if (tblgen_unique_indices && !((true)))
    return emitError(loc, "'vhlo.scatter_v1' op ""attribute 'unique_indices' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ScatterOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange ScatterOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ScatterOpV1::getUpdatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ScatterOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult ScatterOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.index_vector_dim;
       auto attr = dict.get("index_vector_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `index_vector_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.indices_are_sorted;
       auto attr = dict.get("indices_are_sorted");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `indices_are_sorted` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.inserted_window_dims;
       auto attr = dict.get("inserted_window_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `inserted_window_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.scatter_dims_to_operand_dims;
       auto attr = dict.get("scatter_dims_to_operand_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `scatter_dims_to_operand_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.unique_indices;
       auto attr = dict.get("unique_indices");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `unique_indices` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.update_window_dims;
       auto attr = dict.get("update_window_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `update_window_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ScatterOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.index_vector_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("index_vector_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.indices_are_sorted;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("indices_are_sorted",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.inserted_window_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("inserted_window_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.scatter_dims_to_operand_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("scatter_dims_to_operand_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.unique_indices;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("unique_indices",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.update_window_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("update_window_dims",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ScatterOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.index_vector_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.indices_are_sorted.getAsOpaquePointer()), 
    llvm::hash_value(prop.inserted_window_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.scatter_dims_to_operand_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.unique_indices.getAsOpaquePointer()), 
    llvm::hash_value(prop.update_window_dims.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ScatterOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "index_vector_dim")
      return prop.index_vector_dim;

    if (name == "indices_are_sorted")
      return prop.indices_are_sorted;

    if (name == "inserted_window_dims")
      return prop.inserted_window_dims;

    if (name == "scatter_dims_to_operand_dims")
      return prop.scatter_dims_to_operand_dims;

    if (name == "unique_indices")
      return prop.unique_indices;

    if (name == "update_window_dims")
      return prop.update_window_dims;
  return std::nullopt;
}

void ScatterOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "index_vector_dim") {
       prop.index_vector_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.index_vector_dim)>>(value);
       return;
    }

    if (name == "indices_are_sorted") {
       prop.indices_are_sorted = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.indices_are_sorted)>>(value);
       return;
    }

    if (name == "inserted_window_dims") {
       prop.inserted_window_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.inserted_window_dims)>>(value);
       return;
    }

    if (name == "scatter_dims_to_operand_dims") {
       prop.scatter_dims_to_operand_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.scatter_dims_to_operand_dims)>>(value);
       return;
    }

    if (name == "unique_indices") {
       prop.unique_indices = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.unique_indices)>>(value);
       return;
    }

    if (name == "update_window_dims") {
       prop.update_window_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.update_window_dims)>>(value);
       return;
    }
}

void ScatterOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.index_vector_dim) attrs.append("index_vector_dim", prop.index_vector_dim);

    if (prop.indices_are_sorted) attrs.append("indices_are_sorted", prop.indices_are_sorted);

    if (prop.inserted_window_dims) attrs.append("inserted_window_dims", prop.inserted_window_dims);

    if (prop.scatter_dims_to_operand_dims) attrs.append("scatter_dims_to_operand_dims", prop.scatter_dims_to_operand_dims);

    if (prop.unique_indices) attrs.append("unique_indices", prop.unique_indices);

    if (prop.update_window_dims) attrs.append("update_window_dims", prop.update_window_dims);
}

::llvm::LogicalResult ScatterOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getIndexVectorDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "index_vector_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndicesAreSortedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "indices_are_sorted", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInsertedWindowDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "inserted_window_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getScatterDimsToOperandDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "scatter_dims_to_operand_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUniqueIndicesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "unique_indices", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUpdateWindowDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "update_window_dims", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ScatterOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.index_vector_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.indices_are_sorted)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.inserted_window_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.scatter_dims_to_operand_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.unique_indices)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.update_window_dims)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ScatterOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.index_vector_dim);
  writer.writeAttribute(prop.indices_are_sorted);
  writer.writeAttribute(prop.inserted_window_dims);
  writer.writeAttribute(prop.scatter_dims_to_operand_dims);
  writer.writeAttribute(prop.unique_indices);
  writer.writeAttribute(prop.update_window_dims);
}

::mlir::Attribute ScatterOpV1::getUpdateWindowDims() {
  auto attr = getUpdateWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1::getInsertedWindowDims() {
  auto attr = getInsertedWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1::getScatterDimsToOperandDims() {
  auto attr = getScatterDimsToOperandDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

::mlir::Attribute ScatterOpV1::getUniqueIndices() {
  auto attr = getUniqueIndicesAttr();
  return attr;
}

void ScatterOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Value scatter_indices, ::mlir::ValueRange updates, ::mlir::Attribute update_window_dims, ::mlir::Attribute inserted_window_dims, ::mlir::Attribute scatter_dims_to_operand_dims, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted, ::mlir::Attribute unique_indices) {
  odsState.addOperands(inputs);
  odsState.addOperands(scatter_indices);
  odsState.addOperands(updates);
  odsState.getOrAddProperties<Properties>().update_window_dims = update_window_dims;
  odsState.getOrAddProperties<Properties>().inserted_window_dims = inserted_window_dims;
  odsState.getOrAddProperties<Properties>().scatter_dims_to_operand_dims = scatter_dims_to_operand_dims;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  odsState.getOrAddProperties<Properties>().unique_indices = unique_indices;
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void ScatterOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ScatterOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ScatterOpV1::verifyInvariantsImpl() {
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitOpError("requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitOpError("requires attribute 'indices_are_sorted'");
  auto tblgen_inserted_window_dims = getProperties().inserted_window_dims; (void)tblgen_inserted_window_dims;
  if (!tblgen_inserted_window_dims) return emitOpError("requires attribute 'inserted_window_dims'");
  auto tblgen_scatter_dims_to_operand_dims = getProperties().scatter_dims_to_operand_dims; (void)tblgen_scatter_dims_to_operand_dims;
  if (!tblgen_scatter_dims_to_operand_dims) return emitOpError("requires attribute 'scatter_dims_to_operand_dims'");
  auto tblgen_unique_indices = getProperties().unique_indices; (void)tblgen_unique_indices;
  if (!tblgen_unique_indices) return emitOpError("requires attribute 'unique_indices'");
  auto tblgen_update_window_dims = getProperties().update_window_dims; (void)tblgen_update_window_dims;
  if (!tblgen_update_window_dims) return emitOpError("requires attribute 'update_window_dims'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_update_window_dims, "update_window_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_inserted_window_dims, "inserted_window_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_scatter_dims_to_operand_dims, "scatter_dims_to_operand_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_index_vector_dim, "index_vector_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_indices_are_sorted, "indices_are_sorted")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_unique_indices, "unique_indices")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "update_computation", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ScatterOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ScatterOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ScatterOpV1::getMaxVersion() {
   return mlir::vhlo::Version(1, 0, 0); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ScatterOpV2 definitions
//===----------------------------------------------------------------------===//

namespace detail {
ScatterOpV2GenericAdaptorBase::ScatterOpV2GenericAdaptorBase(ScatterOpV2 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ScatterOpV2GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 1) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getUpdateWindowDims() {
  auto attr = getUpdateWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getInsertedWindowDims() {
  auto attr = getInsertedWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getInputBatchingDims() {
  auto attr = getInputBatchingDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getScatterIndicesBatchingDims() {
  auto attr = getScatterIndicesBatchingDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getScatterDimsToOperandDims() {
  auto attr = getScatterDimsToOperandDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2GenericAdaptorBase::getUniqueIndices() {
  auto attr = getUniqueIndicesAttr();
  return attr;
}

} // namespace detail
ScatterOpV2Adaptor::ScatterOpV2Adaptor(ScatterOpV2 op) : ScatterOpV2GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ScatterOpV2Adaptor::verify(::mlir::Location loc) {
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'indices_are_sorted'");
  auto tblgen_input_batching_dims = getProperties().input_batching_dims; (void)tblgen_input_batching_dims;
  if (!tblgen_input_batching_dims) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'input_batching_dims'");
  auto tblgen_inserted_window_dims = getProperties().inserted_window_dims; (void)tblgen_inserted_window_dims;
  if (!tblgen_inserted_window_dims) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'inserted_window_dims'");
  auto tblgen_scatter_dims_to_operand_dims = getProperties().scatter_dims_to_operand_dims; (void)tblgen_scatter_dims_to_operand_dims;
  if (!tblgen_scatter_dims_to_operand_dims) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'scatter_dims_to_operand_dims'");
  auto tblgen_scatter_indices_batching_dims = getProperties().scatter_indices_batching_dims; (void)tblgen_scatter_indices_batching_dims;
  if (!tblgen_scatter_indices_batching_dims) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'scatter_indices_batching_dims'");
  auto tblgen_unique_indices = getProperties().unique_indices; (void)tblgen_unique_indices;
  if (!tblgen_unique_indices) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'unique_indices'");
  auto tblgen_update_window_dims = getProperties().update_window_dims; (void)tblgen_update_window_dims;
  if (!tblgen_update_window_dims) return emitError(loc, "'vhlo.scatter_v2' op ""requires attribute 'update_window_dims'");

  if (tblgen_update_window_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'update_window_dims' failed to satisfy constraint: any attribute");

  if (tblgen_inserted_window_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'inserted_window_dims' failed to satisfy constraint: any attribute");

  if (tblgen_input_batching_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'input_batching_dims' failed to satisfy constraint: any attribute");

  if (tblgen_scatter_indices_batching_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'scatter_indices_batching_dims' failed to satisfy constraint: any attribute");

  if (tblgen_scatter_dims_to_operand_dims && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'scatter_dims_to_operand_dims' failed to satisfy constraint: any attribute");

  if (tblgen_index_vector_dim && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'index_vector_dim' failed to satisfy constraint: any attribute");

  if (tblgen_indices_are_sorted && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'indices_are_sorted' failed to satisfy constraint: any attribute");

  if (tblgen_unique_indices && !((true)))
    return emitError(loc, "'vhlo.scatter_v2' op ""attribute 'unique_indices' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ScatterOpV2::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange ScatterOpV2::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ScatterOpV2::getUpdatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ScatterOpV2::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult ScatterOpV2::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.index_vector_dim;
       auto attr = dict.get("index_vector_dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `index_vector_dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.indices_are_sorted;
       auto attr = dict.get("indices_are_sorted");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `indices_are_sorted` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.input_batching_dims;
       auto attr = dict.get("input_batching_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `input_batching_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.inserted_window_dims;
       auto attr = dict.get("inserted_window_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `inserted_window_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.scatter_dims_to_operand_dims;
       auto attr = dict.get("scatter_dims_to_operand_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `scatter_dims_to_operand_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.scatter_indices_batching_dims;
       auto attr = dict.get("scatter_indices_batching_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `scatter_indices_batching_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.unique_indices;
       auto attr = dict.get("unique_indices");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `unique_indices` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.update_window_dims;
       auto attr = dict.get("update_window_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `update_window_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ScatterOpV2::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.index_vector_dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("index_vector_dim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.indices_are_sorted;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("indices_are_sorted",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.input_batching_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("input_batching_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.inserted_window_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("inserted_window_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.scatter_dims_to_operand_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("scatter_dims_to_operand_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.scatter_indices_batching_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("scatter_indices_batching_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.unique_indices;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("unique_indices",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.update_window_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("update_window_dims",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ScatterOpV2::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.index_vector_dim.getAsOpaquePointer()), 
    llvm::hash_value(prop.indices_are_sorted.getAsOpaquePointer()), 
    llvm::hash_value(prop.input_batching_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.inserted_window_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.scatter_dims_to_operand_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.scatter_indices_batching_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.unique_indices.getAsOpaquePointer()), 
    llvm::hash_value(prop.update_window_dims.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ScatterOpV2::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "index_vector_dim")
      return prop.index_vector_dim;

    if (name == "indices_are_sorted")
      return prop.indices_are_sorted;

    if (name == "input_batching_dims")
      return prop.input_batching_dims;

    if (name == "inserted_window_dims")
      return prop.inserted_window_dims;

    if (name == "scatter_dims_to_operand_dims")
      return prop.scatter_dims_to_operand_dims;

    if (name == "scatter_indices_batching_dims")
      return prop.scatter_indices_batching_dims;

    if (name == "unique_indices")
      return prop.unique_indices;

    if (name == "update_window_dims")
      return prop.update_window_dims;
  return std::nullopt;
}

void ScatterOpV2::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "index_vector_dim") {
       prop.index_vector_dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.index_vector_dim)>>(value);
       return;
    }

    if (name == "indices_are_sorted") {
       prop.indices_are_sorted = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.indices_are_sorted)>>(value);
       return;
    }

    if (name == "input_batching_dims") {
       prop.input_batching_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.input_batching_dims)>>(value);
       return;
    }

    if (name == "inserted_window_dims") {
       prop.inserted_window_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.inserted_window_dims)>>(value);
       return;
    }

    if (name == "scatter_dims_to_operand_dims") {
       prop.scatter_dims_to_operand_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.scatter_dims_to_operand_dims)>>(value);
       return;
    }

    if (name == "scatter_indices_batching_dims") {
       prop.scatter_indices_batching_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.scatter_indices_batching_dims)>>(value);
       return;
    }

    if (name == "unique_indices") {
       prop.unique_indices = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.unique_indices)>>(value);
       return;
    }

    if (name == "update_window_dims") {
       prop.update_window_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.update_window_dims)>>(value);
       return;
    }
}

void ScatterOpV2::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.index_vector_dim) attrs.append("index_vector_dim", prop.index_vector_dim);

    if (prop.indices_are_sorted) attrs.append("indices_are_sorted", prop.indices_are_sorted);

    if (prop.input_batching_dims) attrs.append("input_batching_dims", prop.input_batching_dims);

    if (prop.inserted_window_dims) attrs.append("inserted_window_dims", prop.inserted_window_dims);

    if (prop.scatter_dims_to_operand_dims) attrs.append("scatter_dims_to_operand_dims", prop.scatter_dims_to_operand_dims);

    if (prop.scatter_indices_batching_dims) attrs.append("scatter_indices_batching_dims", prop.scatter_indices_batching_dims);

    if (prop.unique_indices) attrs.append("unique_indices", prop.unique_indices);

    if (prop.update_window_dims) attrs.append("update_window_dims", prop.update_window_dims);
}

::llvm::LogicalResult ScatterOpV2::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getIndexVectorDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "index_vector_dim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndicesAreSortedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "indices_are_sorted", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInputBatchingDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "input_batching_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInsertedWindowDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "inserted_window_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getScatterDimsToOperandDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "scatter_dims_to_operand_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getScatterIndicesBatchingDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "scatter_indices_batching_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUniqueIndicesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "unique_indices", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUpdateWindowDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "update_window_dims", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ScatterOpV2::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.index_vector_dim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.indices_are_sorted)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.input_batching_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.inserted_window_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.scatter_dims_to_operand_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.scatter_indices_batching_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.unique_indices)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.update_window_dims)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ScatterOpV2::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.index_vector_dim);
  writer.writeAttribute(prop.indices_are_sorted);
  writer.writeAttribute(prop.input_batching_dims);
  writer.writeAttribute(prop.inserted_window_dims);
  writer.writeAttribute(prop.scatter_dims_to_operand_dims);
  writer.writeAttribute(prop.scatter_indices_batching_dims);
  writer.writeAttribute(prop.unique_indices);
  writer.writeAttribute(prop.update_window_dims);
}

::mlir::Attribute ScatterOpV2::getUpdateWindowDims() {
  auto attr = getUpdateWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2::getInsertedWindowDims() {
  auto attr = getInsertedWindowDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2::getInputBatchingDims() {
  auto attr = getInputBatchingDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2::getScatterIndicesBatchingDims() {
  auto attr = getScatterIndicesBatchingDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2::getScatterDimsToOperandDims() {
  auto attr = getScatterDimsToOperandDimsAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2::getIndexVectorDim() {
  auto attr = getIndexVectorDimAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2::getIndicesAreSorted() {
  auto attr = getIndicesAreSortedAttr();
  return attr;
}

::mlir::Attribute ScatterOpV2::getUniqueIndices() {
  auto attr = getUniqueIndicesAttr();
  return attr;
}

void ScatterOpV2::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Value scatter_indices, ::mlir::ValueRange updates, ::mlir::Attribute update_window_dims, ::mlir::Attribute inserted_window_dims, ::mlir::Attribute input_batching_dims, ::mlir::Attribute scatter_indices_batching_dims, ::mlir::Attribute scatter_dims_to_operand_dims, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted, ::mlir::Attribute unique_indices) {
  odsState.addOperands(inputs);
  odsState.addOperands(scatter_indices);
  odsState.addOperands(updates);
  odsState.getOrAddProperties<Properties>().update_window_dims = update_window_dims;
  odsState.getOrAddProperties<Properties>().inserted_window_dims = inserted_window_dims;
  odsState.getOrAddProperties<Properties>().input_batching_dims = input_batching_dims;
  odsState.getOrAddProperties<Properties>().scatter_indices_batching_dims = scatter_indices_batching_dims;
  odsState.getOrAddProperties<Properties>().scatter_dims_to_operand_dims = scatter_dims_to_operand_dims;
  odsState.getOrAddProperties<Properties>().index_vector_dim = index_vector_dim;
  odsState.getOrAddProperties<Properties>().indices_are_sorted = indices_are_sorted;
  odsState.getOrAddProperties<Properties>().unique_indices = unique_indices;
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void ScatterOpV2::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ScatterOpV2::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ScatterOpV2::verifyInvariantsImpl() {
  auto tblgen_index_vector_dim = getProperties().index_vector_dim; (void)tblgen_index_vector_dim;
  if (!tblgen_index_vector_dim) return emitOpError("requires attribute 'index_vector_dim'");
  auto tblgen_indices_are_sorted = getProperties().indices_are_sorted; (void)tblgen_indices_are_sorted;
  if (!tblgen_indices_are_sorted) return emitOpError("requires attribute 'indices_are_sorted'");
  auto tblgen_input_batching_dims = getProperties().input_batching_dims; (void)tblgen_input_batching_dims;
  if (!tblgen_input_batching_dims) return emitOpError("requires attribute 'input_batching_dims'");
  auto tblgen_inserted_window_dims = getProperties().inserted_window_dims; (void)tblgen_inserted_window_dims;
  if (!tblgen_inserted_window_dims) return emitOpError("requires attribute 'inserted_window_dims'");
  auto tblgen_scatter_dims_to_operand_dims = getProperties().scatter_dims_to_operand_dims; (void)tblgen_scatter_dims_to_operand_dims;
  if (!tblgen_scatter_dims_to_operand_dims) return emitOpError("requires attribute 'scatter_dims_to_operand_dims'");
  auto tblgen_scatter_indices_batching_dims = getProperties().scatter_indices_batching_dims; (void)tblgen_scatter_indices_batching_dims;
  if (!tblgen_scatter_indices_batching_dims) return emitOpError("requires attribute 'scatter_indices_batching_dims'");
  auto tblgen_unique_indices = getProperties().unique_indices; (void)tblgen_unique_indices;
  if (!tblgen_unique_indices) return emitOpError("requires attribute 'unique_indices'");
  auto tblgen_update_window_dims = getProperties().update_window_dims; (void)tblgen_update_window_dims;
  if (!tblgen_update_window_dims) return emitOpError("requires attribute 'update_window_dims'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_update_window_dims, "update_window_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_inserted_window_dims, "inserted_window_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_input_batching_dims, "input_batching_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_scatter_indices_batching_dims, "scatter_indices_batching_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_scatter_dims_to_operand_dims, "scatter_dims_to_operand_dims")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_index_vector_dim, "index_vector_dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_indices_are_sorted, "indices_are_sorted")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_unique_indices, "unique_indices")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "update_computation", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ScatterOpV2::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ScatterOpV2::getMinVersion() {
  return mlir::vhlo::Version(1, 1, 0);
}
mlir::vhlo::Version ScatterOpV2::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ScatterOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SelectAndScatterOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
SelectAndScatterOpV1GenericAdaptorBase::SelectAndScatterOpV1GenericAdaptorBase(SelectAndScatterOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute SelectAndScatterOpV1GenericAdaptorBase::getWindowDimensions() {
  auto attr = getWindowDimensionsAttr();
  return attr;
}

::mlir::Attribute SelectAndScatterOpV1GenericAdaptorBase::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute SelectAndScatterOpV1GenericAdaptorBase::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

} // namespace detail
SelectAndScatterOpV1Adaptor::SelectAndScatterOpV1Adaptor(SelectAndScatterOpV1 op) : SelectAndScatterOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SelectAndScatterOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitError(loc, "'vhlo.select_and_scatter_v1' op ""requires attribute 'padding'");
  auto tblgen_window_dimensions = getProperties().window_dimensions; (void)tblgen_window_dimensions;
  if (!tblgen_window_dimensions) return emitError(loc, "'vhlo.select_and_scatter_v1' op ""requires attribute 'window_dimensions'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitError(loc, "'vhlo.select_and_scatter_v1' op ""requires attribute 'window_strides'");

  if (tblgen_window_dimensions && !((true)))
    return emitError(loc, "'vhlo.select_and_scatter_v1' op ""attribute 'window_dimensions' failed to satisfy constraint: any attribute");

  if (tblgen_window_strides && !((true)))
    return emitError(loc, "'vhlo.select_and_scatter_v1' op ""attribute 'window_strides' failed to satisfy constraint: any attribute");

  if (tblgen_padding && !((true)))
    return emitError(loc, "'vhlo.select_and_scatter_v1' op ""attribute 'padding' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult SelectAndScatterOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.padding;
       auto attr = dict.get("padding");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `padding` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_dimensions;
       auto attr = dict.get("window_dimensions");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_dimensions` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.window_strides;
       auto attr = dict.get("window_strides");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `window_strides` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute SelectAndScatterOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.padding;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("padding",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_dimensions;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_dimensions",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.window_strides;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("window_strides",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SelectAndScatterOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.padding.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_dimensions.getAsOpaquePointer()), 
    llvm::hash_value(prop.window_strides.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> SelectAndScatterOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "padding")
      return prop.padding;

    if (name == "window_dimensions")
      return prop.window_dimensions;

    if (name == "window_strides")
      return prop.window_strides;
  return std::nullopt;
}

void SelectAndScatterOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "padding") {
       prop.padding = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.padding)>>(value);
       return;
    }

    if (name == "window_dimensions") {
       prop.window_dimensions = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_dimensions)>>(value);
       return;
    }

    if (name == "window_strides") {
       prop.window_strides = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.window_strides)>>(value);
       return;
    }
}

void SelectAndScatterOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.padding) attrs.append("padding", prop.padding);

    if (prop.window_dimensions) attrs.append("window_dimensions", prop.window_dimensions);

    if (prop.window_strides) attrs.append("window_strides", prop.window_strides);
}

::llvm::LogicalResult SelectAndScatterOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getPaddingAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "padding", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowDimensionsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_dimensions", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWindowStridesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "window_strides", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SelectAndScatterOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.padding)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_dimensions)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.window_strides)))
    return ::mlir::failure();
  return ::mlir::success();
}

void SelectAndScatterOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.padding);
  writer.writeAttribute(prop.window_dimensions);
  writer.writeAttribute(prop.window_strides);
}

::mlir::Attribute SelectAndScatterOpV1::getWindowDimensions() {
  auto attr = getWindowDimensionsAttr();
  return attr;
}

::mlir::Attribute SelectAndScatterOpV1::getWindowStrides() {
  auto attr = getWindowStridesAttr();
  return attr;
}

::mlir::Attribute SelectAndScatterOpV1::getPadding() {
  auto attr = getPaddingAttr();
  return attr;
}

void SelectAndScatterOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value source, ::mlir::Value init_value, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute padding) {
  odsState.addOperands(operand);
  odsState.addOperands(source);
  odsState.addOperands(init_value);
  odsState.getOrAddProperties<Properties>().window_dimensions = window_dimensions;
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().padding = padding;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  odsState.addTypes(result);
}

void SelectAndScatterOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value source, ::mlir::Value init_value, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute padding) {
  odsState.addOperands(operand);
  odsState.addOperands(source);
  odsState.addOperands(init_value);
  odsState.getOrAddProperties<Properties>().window_dimensions = window_dimensions;
  odsState.getOrAddProperties<Properties>().window_strides = window_strides;
  odsState.getOrAddProperties<Properties>().padding = padding;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectAndScatterOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SelectAndScatterOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SelectAndScatterOpV1::verifyInvariantsImpl() {
  auto tblgen_padding = getProperties().padding; (void)tblgen_padding;
  if (!tblgen_padding) return emitOpError("requires attribute 'padding'");
  auto tblgen_window_dimensions = getProperties().window_dimensions; (void)tblgen_window_dimensions;
  if (!tblgen_window_dimensions) return emitOpError("requires attribute 'window_dimensions'");
  auto tblgen_window_strides = getProperties().window_strides; (void)tblgen_window_strides;
  if (!tblgen_window_strides) return emitOpError("requires attribute 'window_strides'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_dimensions, "window_dimensions")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_window_strides, "window_strides")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_padding, "padding")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "select", index++)))
        return ::mlir::failure();

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(1)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "scatter", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult SelectAndScatterOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SelectAndScatterOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SelectAndScatterOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SelectAndScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SelectOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SelectOpV1Adaptor::SelectOpV1Adaptor(SelectOpV1 op) : SelectOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SelectOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SelectOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pred, ::mlir::Value on_true, ::mlir::Value on_false) {
  odsState.addOperands(pred);
  odsState.addOperands(on_true);
  odsState.addOperands(on_false);
  odsState.addTypes(result);
}

void SelectOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pred, ::mlir::Value on_true, ::mlir::Value on_false) {
  odsState.addOperands(pred);
  odsState.addOperands(on_true);
  odsState.addOperands(on_false);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult SelectOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SelectOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SelectOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SelectOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SelectOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SendOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
SendOpV1GenericAdaptorBase::SendOpV1GenericAdaptorBase(SendOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> SendOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute SendOpV1GenericAdaptorBase::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute SendOpV1GenericAdaptorBase::getChannelType() {
  auto attr = getChannelTypeAttr();
  return attr;
}

::mlir::Attribute SendOpV1GenericAdaptorBase::getIsHostTransfer() {
  auto attr = getIsHostTransferAttr();
  return attr;
}

} // namespace detail
SendOpV1Adaptor::SendOpV1Adaptor(SendOpV1 op) : SendOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SendOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitError(loc, "'vhlo.send_v1' op ""requires attribute 'channel_id'");
  auto tblgen_channel_type = getProperties().channel_type; (void)tblgen_channel_type;
  if (!tblgen_channel_type) return emitError(loc, "'vhlo.send_v1' op ""requires attribute 'channel_type'");
  auto tblgen_is_host_transfer = getProperties().is_host_transfer; (void)tblgen_is_host_transfer;
  if (!tblgen_is_host_transfer) return emitError(loc, "'vhlo.send_v1' op ""requires attribute 'is_host_transfer'");

  if (tblgen_channel_id && !((true)))
    return emitError(loc, "'vhlo.send_v1' op ""attribute 'channel_id' failed to satisfy constraint: any attribute");

  if (tblgen_channel_type && !((true)))
    return emitError(loc, "'vhlo.send_v1' op ""attribute 'channel_type' failed to satisfy constraint: any attribute");

  if (tblgen_is_host_transfer && !((true)))
    return emitError(loc, "'vhlo.send_v1' op ""attribute 'is_host_transfer' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SendOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange SendOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::llvm::LogicalResult SendOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.channel_id;
       auto attr = dict.get("channel_id");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_id` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.channel_type;
       auto attr = dict.get("channel_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `channel_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.is_host_transfer;
       auto attr = dict.get("is_host_transfer");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `is_host_transfer` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute SendOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.channel_id;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_id",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.channel_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("channel_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.is_host_transfer;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("is_host_transfer",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SendOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.channel_id.getAsOpaquePointer()), 
    llvm::hash_value(prop.channel_type.getAsOpaquePointer()), 
    llvm::hash_value(prop.is_host_transfer.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> SendOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "channel_id")
      return prop.channel_id;

    if (name == "channel_type")
      return prop.channel_type;

    if (name == "is_host_transfer")
      return prop.is_host_transfer;
  return std::nullopt;
}

void SendOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "channel_id") {
       prop.channel_id = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_id)>>(value);
       return;
    }

    if (name == "channel_type") {
       prop.channel_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.channel_type)>>(value);
       return;
    }

    if (name == "is_host_transfer") {
       prop.is_host_transfer = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.is_host_transfer)>>(value);
       return;
    }
}

void SendOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.channel_id) attrs.append("channel_id", prop.channel_id);

    if (prop.channel_type) attrs.append("channel_type", prop.channel_type);

    if (prop.is_host_transfer) attrs.append("is_host_transfer", prop.is_host_transfer);
}

::llvm::LogicalResult SendOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getChannelIdAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_id", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getChannelTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "channel_type", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIsHostTransferAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "is_host_transfer", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SendOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.channel_id)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.channel_type)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.is_host_transfer)))
    return ::mlir::failure();
  return ::mlir::success();
}

void SendOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.channel_id);
  writer.writeAttribute(prop.channel_type);
  writer.writeAttribute(prop.is_host_transfer);
}

::mlir::Attribute SendOpV1::getChannelId() {
  auto attr = getChannelIdAttr();
  return attr;
}

::mlir::Attribute SendOpV1::getChannelType() {
  auto attr = getChannelTypeAttr();
  return attr;
}

::mlir::Attribute SendOpV1::getIsHostTransfer() {
  auto attr = getIsHostTransferAttr();
  return attr;
}

void SendOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer) {
  odsState.addOperands(inputs);
  odsState.addOperands(token);
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().channel_type = channel_type;
  odsState.getOrAddProperties<Properties>().is_host_transfer = is_host_transfer;
  odsState.addTypes(result);
}

void SendOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer) {
  odsState.addOperands(inputs);
  odsState.addOperands(token);
  odsState.getOrAddProperties<Properties>().channel_id = channel_id;
  odsState.getOrAddProperties<Properties>().channel_type = channel_type;
  odsState.getOrAddProperties<Properties>().is_host_transfer = is_host_transfer;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SendOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SendOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SendOpV1::verifyInvariantsImpl() {
  auto tblgen_channel_id = getProperties().channel_id; (void)tblgen_channel_id;
  if (!tblgen_channel_id) return emitOpError("requires attribute 'channel_id'");
  auto tblgen_channel_type = getProperties().channel_type; (void)tblgen_channel_type;
  if (!tblgen_channel_type) return emitOpError("requires attribute 'channel_type'");
  auto tblgen_is_host_transfer = getProperties().is_host_transfer; (void)tblgen_is_host_transfer;
  if (!tblgen_is_host_transfer) return emitOpError("requires attribute 'is_host_transfer'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_id, "channel_id")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_channel_type, "channel_type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_is_host_transfer, "is_host_transfer")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SendOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SendOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SendOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SendOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SetDimensionSizeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
SetDimensionSizeOpV1GenericAdaptorBase::SetDimensionSizeOpV1GenericAdaptorBase(SetDimensionSizeOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute SetDimensionSizeOpV1GenericAdaptorBase::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

} // namespace detail
SetDimensionSizeOpV1Adaptor::SetDimensionSizeOpV1Adaptor(SetDimensionSizeOpV1 op) : SetDimensionSizeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SetDimensionSizeOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitError(loc, "'vhlo.set_dimension_size_v1' op ""requires attribute 'dimension'");

  if (tblgen_dimension && !((true)))
    return emitError(loc, "'vhlo.set_dimension_size_v1' op ""attribute 'dimension' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult SetDimensionSizeOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dimension;
       auto attr = dict.get("dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute SetDimensionSizeOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dimension",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SetDimensionSizeOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dimension.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> SetDimensionSizeOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dimension")
      return prop.dimension;
  return std::nullopt;
}

void SetDimensionSizeOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dimension") {
       prop.dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dimension)>>(value);
       return;
    }
}

void SetDimensionSizeOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dimension) attrs.append("dimension", prop.dimension);
}

::llvm::LogicalResult SetDimensionSizeOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dimension", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SetDimensionSizeOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dimension)))
    return ::mlir::failure();
  return ::mlir::success();
}

void SetDimensionSizeOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dimension);
}

::mlir::Attribute SetDimensionSizeOpV1::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

void SetDimensionSizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value size, ::mlir::Attribute dimension) {
  odsState.addOperands(operand);
  odsState.addOperands(size);
  odsState.getOrAddProperties<Properties>().dimension = dimension;
  odsState.addTypes(result);
}

void SetDimensionSizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value size, ::mlir::Attribute dimension) {
  odsState.addOperands(operand);
  odsState.addOperands(size);
  odsState.getOrAddProperties<Properties>().dimension = dimension;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SetDimensionSizeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SetDimensionSizeOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SetDimensionSizeOpV1::verifyInvariantsImpl() {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitOpError("requires attribute 'dimension'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dimension, "dimension")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SetDimensionSizeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SetDimensionSizeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SetDimensionSizeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SetDimensionSizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftLeftOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ShiftLeftOpV1Adaptor::ShiftLeftOpV1Adaptor(ShiftLeftOpV1 op) : ShiftLeftOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ShiftLeftOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ShiftLeftOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void ShiftLeftOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShiftLeftOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ShiftLeftOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ShiftLeftOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ShiftLeftOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ShiftLeftOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftLeftOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftRightArithmeticOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ShiftRightArithmeticOpV1Adaptor::ShiftRightArithmeticOpV1Adaptor(ShiftRightArithmeticOpV1 op) : ShiftRightArithmeticOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ShiftRightArithmeticOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ShiftRightArithmeticOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void ShiftRightArithmeticOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShiftRightArithmeticOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ShiftRightArithmeticOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ShiftRightArithmeticOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ShiftRightArithmeticOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ShiftRightArithmeticOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftRightArithmeticOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftRightLogicalOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
ShiftRightLogicalOpV1Adaptor::ShiftRightLogicalOpV1Adaptor(ShiftRightLogicalOpV1 op) : ShiftRightLogicalOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ShiftRightLogicalOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ShiftRightLogicalOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void ShiftRightLogicalOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShiftRightLogicalOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult ShiftRightLogicalOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ShiftRightLogicalOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version ShiftRightLogicalOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version ShiftRightLogicalOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftRightLogicalOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SignOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SignOpV1Adaptor::SignOpV1Adaptor(SignOpV1 op) : SignOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SignOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SignOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void SignOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SignOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult SignOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SignOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SignOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SignOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SignOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SineOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SineOpV1Adaptor::SineOpV1Adaptor(SineOpV1 op) : SineOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SineOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SineOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void SineOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SineOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult SineOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SineOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SineOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SineOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SineOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SliceOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
SliceOpV1GenericAdaptorBase::SliceOpV1GenericAdaptorBase(SliceOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute SliceOpV1GenericAdaptorBase::getStartIndices() {
  auto attr = getStartIndicesAttr();
  return attr;
}

::mlir::Attribute SliceOpV1GenericAdaptorBase::getLimitIndices() {
  auto attr = getLimitIndicesAttr();
  return attr;
}

::mlir::Attribute SliceOpV1GenericAdaptorBase::getStrides() {
  auto attr = getStridesAttr();
  return attr;
}

} // namespace detail
SliceOpV1Adaptor::SliceOpV1Adaptor(SliceOpV1 op) : SliceOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SliceOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_limit_indices = getProperties().limit_indices; (void)tblgen_limit_indices;
  if (!tblgen_limit_indices) return emitError(loc, "'vhlo.slice_v1' op ""requires attribute 'limit_indices'");
  auto tblgen_start_indices = getProperties().start_indices; (void)tblgen_start_indices;
  if (!tblgen_start_indices) return emitError(loc, "'vhlo.slice_v1' op ""requires attribute 'start_indices'");
  auto tblgen_strides = getProperties().strides; (void)tblgen_strides;
  if (!tblgen_strides) return emitError(loc, "'vhlo.slice_v1' op ""requires attribute 'strides'");

  if (tblgen_start_indices && !((true)))
    return emitError(loc, "'vhlo.slice_v1' op ""attribute 'start_indices' failed to satisfy constraint: any attribute");

  if (tblgen_limit_indices && !((true)))
    return emitError(loc, "'vhlo.slice_v1' op ""attribute 'limit_indices' failed to satisfy constraint: any attribute");

  if (tblgen_strides && !((true)))
    return emitError(loc, "'vhlo.slice_v1' op ""attribute 'strides' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult SliceOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.limit_indices;
       auto attr = dict.get("limit_indices");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `limit_indices` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.start_indices;
       auto attr = dict.get("start_indices");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `start_indices` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.strides;
       auto attr = dict.get("strides");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `strides` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute SliceOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.limit_indices;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("limit_indices",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.start_indices;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("start_indices",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.strides;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("strides",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SliceOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.limit_indices.getAsOpaquePointer()), 
    llvm::hash_value(prop.start_indices.getAsOpaquePointer()), 
    llvm::hash_value(prop.strides.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> SliceOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "limit_indices")
      return prop.limit_indices;

    if (name == "start_indices")
      return prop.start_indices;

    if (name == "strides")
      return prop.strides;
  return std::nullopt;
}

void SliceOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "limit_indices") {
       prop.limit_indices = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.limit_indices)>>(value);
       return;
    }

    if (name == "start_indices") {
       prop.start_indices = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.start_indices)>>(value);
       return;
    }

    if (name == "strides") {
       prop.strides = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.strides)>>(value);
       return;
    }
}

void SliceOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.limit_indices) attrs.append("limit_indices", prop.limit_indices);

    if (prop.start_indices) attrs.append("start_indices", prop.start_indices);

    if (prop.strides) attrs.append("strides", prop.strides);
}

::llvm::LogicalResult SliceOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getLimitIndicesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "limit_indices", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStartIndicesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "start_indices", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStridesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "strides", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SliceOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.limit_indices)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.start_indices)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.strides)))
    return ::mlir::failure();
  return ::mlir::success();
}

void SliceOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.limit_indices);
  writer.writeAttribute(prop.start_indices);
  writer.writeAttribute(prop.strides);
}

::mlir::Attribute SliceOpV1::getStartIndices() {
  auto attr = getStartIndicesAttr();
  return attr;
}

::mlir::Attribute SliceOpV1::getLimitIndices() {
  auto attr = getLimitIndicesAttr();
  return attr;
}

::mlir::Attribute SliceOpV1::getStrides() {
  auto attr = getStridesAttr();
  return attr;
}

void SliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute start_indices, ::mlir::Attribute limit_indices, ::mlir::Attribute strides) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().start_indices = start_indices;
  odsState.getOrAddProperties<Properties>().limit_indices = limit_indices;
  odsState.getOrAddProperties<Properties>().strides = strides;
  odsState.addTypes(result);
}

void SliceOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute start_indices, ::mlir::Attribute limit_indices, ::mlir::Attribute strides) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().start_indices = start_indices;
  odsState.getOrAddProperties<Properties>().limit_indices = limit_indices;
  odsState.getOrAddProperties<Properties>().strides = strides;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SliceOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SliceOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SliceOpV1::verifyInvariantsImpl() {
  auto tblgen_limit_indices = getProperties().limit_indices; (void)tblgen_limit_indices;
  if (!tblgen_limit_indices) return emitOpError("requires attribute 'limit_indices'");
  auto tblgen_start_indices = getProperties().start_indices; (void)tblgen_start_indices;
  if (!tblgen_start_indices) return emitOpError("requires attribute 'start_indices'");
  auto tblgen_strides = getProperties().strides; (void)tblgen_strides;
  if (!tblgen_strides) return emitOpError("requires attribute 'strides'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_start_indices, "start_indices")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_limit_indices, "limit_indices")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_strides, "strides")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SliceOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SliceOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SliceOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SortOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
SortOpV1GenericAdaptorBase::SortOpV1GenericAdaptorBase(SortOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> SortOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Attribute SortOpV1GenericAdaptorBase::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

::mlir::Attribute SortOpV1GenericAdaptorBase::getIsStable() {
  auto attr = getIsStableAttr();
  return attr;
}

} // namespace detail
SortOpV1Adaptor::SortOpV1Adaptor(SortOpV1 op) : SortOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SortOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitError(loc, "'vhlo.sort_v1' op ""requires attribute 'dimension'");
  auto tblgen_is_stable = getProperties().is_stable; (void)tblgen_is_stable;
  if (!tblgen_is_stable) return emitError(loc, "'vhlo.sort_v1' op ""requires attribute 'is_stable'");

  if (tblgen_dimension && !((true)))
    return emitError(loc, "'vhlo.sort_v1' op ""attribute 'dimension' failed to satisfy constraint: any attribute");

  if (tblgen_is_stable && !((true)))
    return emitError(loc, "'vhlo.sort_v1' op ""attribute 'is_stable' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SortOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange SortOpV1::getInputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SortOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult SortOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.dimension;
       auto attr = dict.get("dimension");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dimension` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.is_stable;
       auto attr = dict.get("is_stable");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `is_stable` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute SortOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.dimension;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dimension",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.is_stable;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("is_stable",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SortOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.dimension.getAsOpaquePointer()), 
    llvm::hash_value(prop.is_stable.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> SortOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "dimension")
      return prop.dimension;

    if (name == "is_stable")
      return prop.is_stable;
  return std::nullopt;
}

void SortOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "dimension") {
       prop.dimension = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dimension)>>(value);
       return;
    }

    if (name == "is_stable") {
       prop.is_stable = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.is_stable)>>(value);
       return;
    }
}

void SortOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.dimension) attrs.append("dimension", prop.dimension);

    if (prop.is_stable) attrs.append("is_stable", prop.is_stable);
}

::llvm::LogicalResult SortOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDimensionAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dimension", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIsStableAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "is_stable", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SortOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.dimension)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.is_stable)))
    return ::mlir::failure();
  return ::mlir::success();
}

void SortOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.dimension);
  writer.writeAttribute(prop.is_stable);
}

::mlir::Attribute SortOpV1::getDimension() {
  auto attr = getDimensionAttr();
  return attr;
}

::mlir::Attribute SortOpV1::getIsStable() {
  auto attr = getIsStableAttr();
  return attr;
}

void SortOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute dimension, ::mlir::Attribute is_stable) {
  odsState.addOperands(inputs);
  odsState.getOrAddProperties<Properties>().dimension = dimension;
  odsState.getOrAddProperties<Properties>().is_stable = is_stable;
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void SortOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SortOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SortOpV1::verifyInvariantsImpl() {
  auto tblgen_dimension = getProperties().dimension; (void)tblgen_dimension;
  if (!tblgen_dimension) return emitOpError("requires attribute 'dimension'");
  auto tblgen_is_stable = getProperties().is_stable; (void)tblgen_is_stable;
  if (!tblgen_is_stable) return emitOpError("requires attribute 'is_stable'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dimension, "dimension")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_is_stable, "is_stable")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "comparator", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult SortOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SortOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SortOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SortOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SqrtOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SqrtOpV1Adaptor::SqrtOpV1Adaptor(SqrtOpV1 op) : SqrtOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SqrtOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SqrtOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void SqrtOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SqrtOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult SqrtOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SqrtOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SqrtOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SqrtOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SqrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SubtractOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
SubtractOpV1Adaptor::SubtractOpV1Adaptor(SubtractOpV1 op) : SubtractOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SubtractOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SubtractOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void SubtractOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubtractOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult SubtractOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SubtractOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version SubtractOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version SubtractOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::SubtractOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TanOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
TanOpV1Adaptor::TanOpV1Adaptor(TanOpV1 op) : TanOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TanOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void TanOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void TanOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TanOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult TanOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult TanOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version TanOpV1::getMinVersion() {
  return mlir::vhlo::Version(1, 4, 0);
}
mlir::vhlo::Version TanOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::TanOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TanhOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
TanhOpV1Adaptor::TanhOpV1Adaptor(TanhOpV1 op) : TanhOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TanhOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void TanhOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void TanhOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TanhOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult TanhOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult TanhOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version TanhOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version TanhOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::TanhOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TorchIndexSelectOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
TorchIndexSelectOpV1GenericAdaptorBase::TorchIndexSelectOpV1GenericAdaptorBase(TorchIndexSelectOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute TorchIndexSelectOpV1GenericAdaptorBase::getDim() {
  auto attr = getDimAttr();
  return attr;
}

::mlir::Attribute TorchIndexSelectOpV1GenericAdaptorBase::getBatchDims() {
  auto attr = getBatchDimsAttr();
  return attr;
}

} // namespace detail
TorchIndexSelectOpV1Adaptor::TorchIndexSelectOpV1Adaptor(TorchIndexSelectOpV1 op) : TorchIndexSelectOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TorchIndexSelectOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_batch_dims = getProperties().batch_dims; (void)tblgen_batch_dims;
  if (!tblgen_batch_dims) return emitError(loc, "'vhlo.torch_index_select_v1' op ""requires attribute 'batch_dims'");
  auto tblgen_dim = getProperties().dim; (void)tblgen_dim;
  if (!tblgen_dim) return emitError(loc, "'vhlo.torch_index_select_v1' op ""requires attribute 'dim'");

  if (tblgen_dim && !((true)))
    return emitError(loc, "'vhlo.torch_index_select_v1' op ""attribute 'dim' failed to satisfy constraint: any attribute");

  if (tblgen_batch_dims && !((true)))
    return emitError(loc, "'vhlo.torch_index_select_v1' op ""attribute 'batch_dims' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult TorchIndexSelectOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.batch_dims;
       auto attr = dict.get("batch_dims");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `batch_dims` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dim;
       auto attr = dict.get("dim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute TorchIndexSelectOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.batch_dims;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("batch_dims",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dim",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code TorchIndexSelectOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.batch_dims.getAsOpaquePointer()), 
    llvm::hash_value(prop.dim.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> TorchIndexSelectOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "batch_dims")
      return prop.batch_dims;

    if (name == "dim")
      return prop.dim;
  return std::nullopt;
}

void TorchIndexSelectOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "batch_dims") {
       prop.batch_dims = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.batch_dims)>>(value);
       return;
    }

    if (name == "dim") {
       prop.dim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dim)>>(value);
       return;
    }
}

void TorchIndexSelectOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.batch_dims) attrs.append("batch_dims", prop.batch_dims);

    if (prop.dim) attrs.append("dim", prop.dim);
}

::llvm::LogicalResult TorchIndexSelectOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBatchDimsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "batch_dims", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "dim", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult TorchIndexSelectOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.batch_dims)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.dim)))
    return ::mlir::failure();
  return ::mlir::success();
}

void TorchIndexSelectOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.batch_dims);
  writer.writeAttribute(prop.dim);
}

::mlir::Attribute TorchIndexSelectOpV1::getDim() {
  auto attr = getDimAttr();
  return attr;
}

::mlir::Attribute TorchIndexSelectOpV1::getBatchDims() {
  auto attr = getBatchDimsAttr();
  return attr;
}

void TorchIndexSelectOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value index, ::mlir::Attribute dim, ::mlir::Attribute batch_dims) {
  odsState.addOperands(operand);
  odsState.addOperands(index);
  odsState.getOrAddProperties<Properties>().dim = dim;
  odsState.getOrAddProperties<Properties>().batch_dims = batch_dims;
  odsState.addTypes(result);
}

void TorchIndexSelectOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value index, ::mlir::Attribute dim, ::mlir::Attribute batch_dims) {
  odsState.addOperands(operand);
  odsState.addOperands(index);
  odsState.getOrAddProperties<Properties>().dim = dim;
  odsState.getOrAddProperties<Properties>().batch_dims = batch_dims;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TorchIndexSelectOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<TorchIndexSelectOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult TorchIndexSelectOpV1::verifyInvariantsImpl() {
  auto tblgen_batch_dims = getProperties().batch_dims; (void)tblgen_batch_dims;
  if (!tblgen_batch_dims) return emitOpError("requires attribute 'batch_dims'");
  auto tblgen_dim = getProperties().dim; (void)tblgen_dim;
  if (!tblgen_dim) return emitOpError("requires attribute 'dim'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_dim, "dim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_batch_dims, "batch_dims")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult TorchIndexSelectOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version TorchIndexSelectOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version TorchIndexSelectOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::TorchIndexSelectOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TransposeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
TransposeOpV1GenericAdaptorBase::TransposeOpV1GenericAdaptorBase(TransposeOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute TransposeOpV1GenericAdaptorBase::getPermutation() {
  auto attr = getPermutationAttr();
  return attr;
}

} // namespace detail
TransposeOpV1Adaptor::TransposeOpV1Adaptor(TransposeOpV1 op) : TransposeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TransposeOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_permutation = getProperties().permutation; (void)tblgen_permutation;
  if (!tblgen_permutation) return emitError(loc, "'vhlo.transpose_v1' op ""requires attribute 'permutation'");

  if (tblgen_permutation && !((true)))
    return emitError(loc, "'vhlo.transpose_v1' op ""attribute 'permutation' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult TransposeOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.permutation;
       auto attr = dict.get("permutation");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `permutation` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute TransposeOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.permutation;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("permutation",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code TransposeOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.permutation.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> TransposeOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "permutation")
      return prop.permutation;
  return std::nullopt;
}

void TransposeOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "permutation") {
       prop.permutation = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.permutation)>>(value);
       return;
    }
}

void TransposeOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.permutation) attrs.append("permutation", prop.permutation);
}

::llvm::LogicalResult TransposeOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getPermutationAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "permutation", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult TransposeOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.permutation)))
    return ::mlir::failure();
  return ::mlir::success();
}

void TransposeOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.permutation);
}

::mlir::Attribute TransposeOpV1::getPermutation() {
  auto attr = getPermutationAttr();
  return attr;
}

void TransposeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute permutation) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().permutation = permutation;
  odsState.addTypes(result);
}

void TransposeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute permutation) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().permutation = permutation;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TransposeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<TransposeOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult TransposeOpV1::verifyInvariantsImpl() {
  auto tblgen_permutation = getProperties().permutation; (void)tblgen_permutation;
  if (!tblgen_permutation) return emitOpError("requires attribute 'permutation'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_permutation, "permutation")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult TransposeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version TransposeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version TransposeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::TransposeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TriangularSolveOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
TriangularSolveOpV1GenericAdaptorBase::TriangularSolveOpV1GenericAdaptorBase(TriangularSolveOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute TriangularSolveOpV1GenericAdaptorBase::getLeftSide() {
  auto attr = getLeftSideAttr();
  return attr;
}

::mlir::Attribute TriangularSolveOpV1GenericAdaptorBase::getLower() {
  auto attr = getLowerAttr();
  return attr;
}

::mlir::Attribute TriangularSolveOpV1GenericAdaptorBase::getUnitDiagonal() {
  auto attr = getUnitDiagonalAttr();
  return attr;
}

::mlir::Attribute TriangularSolveOpV1GenericAdaptorBase::getTransposeA() {
  auto attr = getTransposeAAttr();
  return attr;
}

} // namespace detail
TriangularSolveOpV1Adaptor::TriangularSolveOpV1Adaptor(TriangularSolveOpV1 op) : TriangularSolveOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TriangularSolveOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_left_side = getProperties().left_side; (void)tblgen_left_side;
  if (!tblgen_left_side) return emitError(loc, "'vhlo.triangular_solve_v1' op ""requires attribute 'left_side'");
  auto tblgen_lower = getProperties().lower; (void)tblgen_lower;
  if (!tblgen_lower) return emitError(loc, "'vhlo.triangular_solve_v1' op ""requires attribute 'lower'");
  auto tblgen_transpose_a = getProperties().transpose_a; (void)tblgen_transpose_a;
  if (!tblgen_transpose_a) return emitError(loc, "'vhlo.triangular_solve_v1' op ""requires attribute 'transpose_a'");
  auto tblgen_unit_diagonal = getProperties().unit_diagonal; (void)tblgen_unit_diagonal;
  if (!tblgen_unit_diagonal) return emitError(loc, "'vhlo.triangular_solve_v1' op ""requires attribute 'unit_diagonal'");

  if (tblgen_left_side && !((true)))
    return emitError(loc, "'vhlo.triangular_solve_v1' op ""attribute 'left_side' failed to satisfy constraint: any attribute");

  if (tblgen_lower && !((true)))
    return emitError(loc, "'vhlo.triangular_solve_v1' op ""attribute 'lower' failed to satisfy constraint: any attribute");

  if (tblgen_unit_diagonal && !((true)))
    return emitError(loc, "'vhlo.triangular_solve_v1' op ""attribute 'unit_diagonal' failed to satisfy constraint: any attribute");

  if (tblgen_transpose_a && !((true)))
    return emitError(loc, "'vhlo.triangular_solve_v1' op ""attribute 'transpose_a' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult TriangularSolveOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.left_side;
       auto attr = dict.get("left_side");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `left_side` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.lower;
       auto attr = dict.get("lower");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `lower` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.transpose_a;
       auto attr = dict.get("transpose_a");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `transpose_a` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.unit_diagonal;
       auto attr = dict.get("unit_diagonal");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `unit_diagonal` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute TriangularSolveOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.left_side;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("left_side",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.lower;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("lower",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.transpose_a;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("transpose_a",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.unit_diagonal;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("unit_diagonal",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code TriangularSolveOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.left_side.getAsOpaquePointer()), 
    llvm::hash_value(prop.lower.getAsOpaquePointer()), 
    llvm::hash_value(prop.transpose_a.getAsOpaquePointer()), 
    llvm::hash_value(prop.unit_diagonal.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> TriangularSolveOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "left_side")
      return prop.left_side;

    if (name == "lower")
      return prop.lower;

    if (name == "transpose_a")
      return prop.transpose_a;

    if (name == "unit_diagonal")
      return prop.unit_diagonal;
  return std::nullopt;
}

void TriangularSolveOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "left_side") {
       prop.left_side = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.left_side)>>(value);
       return;
    }

    if (name == "lower") {
       prop.lower = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.lower)>>(value);
       return;
    }

    if (name == "transpose_a") {
       prop.transpose_a = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.transpose_a)>>(value);
       return;
    }

    if (name == "unit_diagonal") {
       prop.unit_diagonal = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.unit_diagonal)>>(value);
       return;
    }
}

void TriangularSolveOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.left_side) attrs.append("left_side", prop.left_side);

    if (prop.lower) attrs.append("lower", prop.lower);

    if (prop.transpose_a) attrs.append("transpose_a", prop.transpose_a);

    if (prop.unit_diagonal) attrs.append("unit_diagonal", prop.unit_diagonal);
}

::llvm::LogicalResult TriangularSolveOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getLeftSideAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "left_side", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getLowerAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "lower", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTransposeAAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "transpose_a", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getUnitDiagonalAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "unit_diagonal", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult TriangularSolveOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.left_side)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.lower)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.transpose_a)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.unit_diagonal)))
    return ::mlir::failure();
  return ::mlir::success();
}

void TriangularSolveOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.left_side);
  writer.writeAttribute(prop.lower);
  writer.writeAttribute(prop.transpose_a);
  writer.writeAttribute(prop.unit_diagonal);
}

::mlir::Attribute TriangularSolveOpV1::getLeftSide() {
  auto attr = getLeftSideAttr();
  return attr;
}

::mlir::Attribute TriangularSolveOpV1::getLower() {
  auto attr = getLowerAttr();
  return attr;
}

::mlir::Attribute TriangularSolveOpV1::getUnitDiagonal() {
  auto attr = getUnitDiagonalAttr();
  return attr;
}

::mlir::Attribute TriangularSolveOpV1::getTransposeA() {
  auto attr = getTransposeAAttr();
  return attr;
}

void TriangularSolveOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Value b, ::mlir::Attribute left_side, ::mlir::Attribute lower, ::mlir::Attribute unit_diagonal, ::mlir::Attribute transpose_a) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.getOrAddProperties<Properties>().left_side = left_side;
  odsState.getOrAddProperties<Properties>().lower = lower;
  odsState.getOrAddProperties<Properties>().unit_diagonal = unit_diagonal;
  odsState.getOrAddProperties<Properties>().transpose_a = transpose_a;
  odsState.addTypes(result);
}

void TriangularSolveOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Attribute left_side, ::mlir::Attribute lower, ::mlir::Attribute unit_diagonal, ::mlir::Attribute transpose_a) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.getOrAddProperties<Properties>().left_side = left_side;
  odsState.getOrAddProperties<Properties>().lower = lower;
  odsState.getOrAddProperties<Properties>().unit_diagonal = unit_diagonal;
  odsState.getOrAddProperties<Properties>().transpose_a = transpose_a;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TriangularSolveOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<TriangularSolveOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult TriangularSolveOpV1::verifyInvariantsImpl() {
  auto tblgen_left_side = getProperties().left_side; (void)tblgen_left_side;
  if (!tblgen_left_side) return emitOpError("requires attribute 'left_side'");
  auto tblgen_lower = getProperties().lower; (void)tblgen_lower;
  if (!tblgen_lower) return emitOpError("requires attribute 'lower'");
  auto tblgen_transpose_a = getProperties().transpose_a; (void)tblgen_transpose_a;
  if (!tblgen_transpose_a) return emitOpError("requires attribute 'transpose_a'");
  auto tblgen_unit_diagonal = getProperties().unit_diagonal; (void)tblgen_unit_diagonal;
  if (!tblgen_unit_diagonal) return emitOpError("requires attribute 'unit_diagonal'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_left_side, "left_side")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_lower, "lower")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_unit_diagonal, "unit_diagonal")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_transpose_a, "transpose_a")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult TriangularSolveOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version TriangularSolveOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version TriangularSolveOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::TriangularSolveOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TupleOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> TupleOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
TupleOpV1Adaptor::TupleOpV1Adaptor(TupleOpV1 op) : TupleOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TupleOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> TupleOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange TupleOpV1::getValMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void TupleOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange val) {
  odsState.addOperands(val);
  odsState.addTypes(result);
}

void TupleOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult TupleOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult TupleOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version TupleOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version TupleOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::TupleOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UnaryEinsumOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
UnaryEinsumOpV1GenericAdaptorBase::UnaryEinsumOpV1GenericAdaptorBase(UnaryEinsumOpV1 op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Attribute UnaryEinsumOpV1GenericAdaptorBase::getEinsumConfig() {
  auto attr = getEinsumConfigAttr();
  return attr;
}

} // namespace detail
UnaryEinsumOpV1Adaptor::UnaryEinsumOpV1Adaptor(UnaryEinsumOpV1 op) : UnaryEinsumOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UnaryEinsumOpV1Adaptor::verify(::mlir::Location loc) {
  auto tblgen_einsum_config = getProperties().einsum_config; (void)tblgen_einsum_config;
  if (!tblgen_einsum_config) return emitError(loc, "'vhlo.unary_einsum_v1' op ""requires attribute 'einsum_config'");

  if (tblgen_einsum_config && !((true)))
    return emitError(loc, "'vhlo.unary_einsum_v1' op ""attribute 'einsum_config' failed to satisfy constraint: any attribute");
  return ::mlir::success();
}

::llvm::LogicalResult UnaryEinsumOpV1::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.einsum_config;
       auto attr = dict.get("einsum_config");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `einsum_config` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute UnaryEinsumOpV1::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.einsum_config;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("einsum_config",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code UnaryEinsumOpV1::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.einsum_config.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> UnaryEinsumOpV1::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "einsum_config")
      return prop.einsum_config;
  return std::nullopt;
}

void UnaryEinsumOpV1::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "einsum_config") {
       prop.einsum_config = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.einsum_config)>>(value);
       return;
    }
}

void UnaryEinsumOpV1::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.einsum_config) attrs.append("einsum_config", prop.einsum_config);
}

::llvm::LogicalResult UnaryEinsumOpV1::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getEinsumConfigAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(attr, "einsum_config", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult UnaryEinsumOpV1::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.einsum_config)))
    return ::mlir::failure();
  return ::mlir::success();
}

void UnaryEinsumOpV1::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.einsum_config);
}

::mlir::Attribute UnaryEinsumOpV1::getEinsumConfig() {
  auto attr = getEinsumConfigAttr();
  return attr;
}

void UnaryEinsumOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute einsum_config) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().einsum_config = einsum_config;
  odsState.addTypes(result);
}

void UnaryEinsumOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute einsum_config) {
  odsState.addOperands(operand);
  odsState.getOrAddProperties<Properties>().einsum_config = einsum_config;
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnaryEinsumOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<UnaryEinsumOpV1::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult UnaryEinsumOpV1::verifyInvariantsImpl() {
  auto tblgen_einsum_config = getProperties().einsum_config; (void)tblgen_einsum_config;
  if (!tblgen_einsum_config) return emitOpError("requires attribute 'einsum_config'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_VhloOps1(*this, tblgen_einsum_config, "einsum_config")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UnaryEinsumOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version UnaryEinsumOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version UnaryEinsumOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::UnaryEinsumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UniformDequantizeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
UniformDequantizeOpV1Adaptor::UniformDequantizeOpV1Adaptor(UniformDequantizeOpV1 op) : UniformDequantizeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UniformDequantizeOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void UniformDequantizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void UniformDequantizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UniformDequantizeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult UniformDequantizeOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UniformDequantizeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version UniformDequantizeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version UniformDequantizeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::UniformDequantizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UniformQuantizeOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
UniformQuantizeOpV1Adaptor::UniformQuantizeOpV1Adaptor(UniformQuantizeOpV1 op) : UniformQuantizeOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UniformQuantizeOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void UniformQuantizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void UniformQuantizeOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UniformQuantizeOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult UniformQuantizeOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UniformQuantizeOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version UniformQuantizeOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version UniformQuantizeOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::UniformQuantizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::WhileOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> WhileOpV1GenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
WhileOpV1Adaptor::WhileOpV1Adaptor(WhileOpV1 op) : WhileOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult WhileOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> WhileOpV1::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange WhileOpV1::getOperandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> WhileOpV1::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

void WhileOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult WhileOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "cond", index++)))
        return ::mlir::failure();

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(1)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_VhloOps1(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult WhileOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version WhileOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version WhileOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::WhileOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::XorOpV1 definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
XorOpV1Adaptor::XorOpV1Adaptor(XorOpV1 op) : XorOpV1GenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult XorOpV1Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void XorOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void XorOpV1::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XorOpV1::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult XorOpV1::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_VhloOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult XorOpV1::verifyInvariants() {
  return verifyInvariantsImpl();
}

mlir::vhlo::Version XorOpV1::getMinVersion() {
  return mlir::vhlo::Version(0, 9, 0);
}
mlir::vhlo::Version XorOpV1::getMaxVersion() {
   return mlir::vhlo::Version::getCurrentVersion(); 
}
} // namespace vhlo
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::vhlo::XorOpV1)


#endif  // GET_OP_CLASSES

