/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Declarations                                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: VhloOps.td                                                           *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

namespace mlir {
namespace vhlo {
class AbsOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AddOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AfterAllOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllGatherOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllGatherOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllReduceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllReduceOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllToAllOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllToAllOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AndOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class Atan2OpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BatchNormGradOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BatchNormInferenceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BatchNormTrainingOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BitcastConvertOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BroadcastInDimOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BroadcastOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CallOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CaseOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CbrtOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CeilOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CholeskyOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ClampOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ClzOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CollectiveBroadcastOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CollectivePermuteOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CompareOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ComplexOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CompositeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConcatenateOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConstantOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConvertOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConvolutionOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CosineOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CreateTokenOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CrossReplicaSumOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CustomCallOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DivOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DotGeneralOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DotGeneralOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DotOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicBroadcastInDimOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicConvOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicConvOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicGatherOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicGatherOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicIotaOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicPadOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicReshapeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicSliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicUpdateSliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class EinsumOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ExpOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class Expm1OpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class FftOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class FloorOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class FuncOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class GatherOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class GatherOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class GetDimensionSizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class GetTupleElementOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class IfOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ImagOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class InfeedOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class IotaOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class IsFiniteOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class Log1pOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class LogOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class LogisticOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MapOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MaxOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MinOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MulOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class NegOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class NotOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class OptimizationBarrierOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class OrOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class OutfeedOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PadOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PartitionIdOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PopulationCountOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PowOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RealDynamicSliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RealOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RecvOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReduceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReducePrecisionOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReduceScatterOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReduceWindowOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RemOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReplicaIdOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReshapeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReturnOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReverseOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RngBitGeneratorOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RngOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RoundNearestEvenOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RoundOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RsqrtOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ScatterOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ScatterOpV2;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SelectAndScatterOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SelectOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SendOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SetDimensionSizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ShiftLeftOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ShiftRightArithmeticOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ShiftRightLogicalOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SignOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SineOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SortOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SqrtOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SubtractOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TanOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TanhOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TorchIndexSelectOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TransposeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TriangularSolveOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TupleOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class UnaryEinsumOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class UniformDequantizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class UniformQuantizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class WhileOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class XorOpV1;
} // namespace vhlo
} // namespace mlir
#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AbsOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AbsOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AbsOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.abs_v1", odsAttrs.getContext());
  }

  AbsOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class AbsOpV1GenericAdaptor : public detail::AbsOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AbsOpV1GenericAdaptorBase;
public:
  AbsOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AbsOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AbsOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AbsOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AbsOpV1>>>
  AbsOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AbsOpV1Adaptor : public AbsOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AbsOpV1GenericAdaptor::AbsOpV1GenericAdaptor;
  AbsOpV1Adaptor(AbsOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AbsOpV1 : public ::mlir::Op<AbsOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AbsOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AbsOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.abs_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AbsOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AddOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AddOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AddOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.add_v1", odsAttrs.getContext());
  }

  AddOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class AddOpV1GenericAdaptor : public detail::AddOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AddOpV1GenericAdaptorBase;
public:
  AddOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AddOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AddOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AddOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AddOpV1>>>
  AddOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AddOpV1Adaptor : public AddOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AddOpV1GenericAdaptor::AddOpV1GenericAdaptor;
  AddOpV1Adaptor(AddOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AddOpV1 : public ::mlir::Op<AddOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AddOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AddOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.add_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AddOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AfterAllOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AfterAllOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AfterAllOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.after_all_v1", odsAttrs.getContext());
  }

  AfterAllOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class AfterAllOpV1GenericAdaptor : public detail::AfterAllOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AfterAllOpV1GenericAdaptorBase;
public:
  AfterAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AfterAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AfterAllOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AfterAllOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AfterAllOpV1>>>
  AfterAllOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AfterAllOpV1Adaptor : public AfterAllOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AfterAllOpV1GenericAdaptor::AfterAllOpV1GenericAdaptor;
  AfterAllOpV1Adaptor(AfterAllOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AfterAllOpV1 : public ::mlir::Op<AfterAllOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AfterAllOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AfterAllOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.after_all_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AfterAllOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllGatherOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllGatherOpV1GenericAdaptorBase {
public:
  struct Properties {
    using all_gather_dimTy = ::mlir::Attribute;
    all_gather_dimTy all_gather_dim;

    auto getAllGatherDim() {
      auto &propStorage = this->all_gather_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setAllGatherDim(const ::mlir::Attribute &propValue) {
      this->all_gather_dim = propValue;
    }
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    using use_global_device_idsTy = ::mlir::Attribute;
    use_global_device_idsTy use_global_device_ids;

    auto getUseGlobalDeviceIds() {
      auto &propStorage = this->use_global_device_ids;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUseGlobalDeviceIds(const ::mlir::Attribute &propValue) {
      this->use_global_device_ids = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.all_gather_dim == this->all_gather_dim &&
        rhs.channel_id == this->channel_id &&
        rhs.replica_groups == this->replica_groups &&
        rhs.use_global_device_ids == this->use_global_device_ids &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllGatherOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.all_gather_v1", odsAttrs.getContext());
  }

  AllGatherOpV1GenericAdaptorBase(AllGatherOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getAllGatherDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().all_gather_dim);
    return attr;
  }

  ::mlir::Attribute getAllGatherDim();
  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
    return attr;
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
};
} // namespace detail
template <typename RangeT>
class AllGatherOpV1GenericAdaptor : public detail::AllGatherOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllGatherOpV1GenericAdaptorBase;
public:
  AllGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllGatherOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AllGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AllGatherOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AllGatherOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AllGatherOpV1>>>
  AllGatherOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllGatherOpV1Adaptor : public AllGatherOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AllGatherOpV1GenericAdaptor::AllGatherOpV1GenericAdaptor;
  AllGatherOpV1Adaptor(AllGatherOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AllGatherOpV1 : public ::mlir::Op<AllGatherOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllGatherOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllGatherOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("all_gather_dim"), ::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAllGatherDimAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAllGatherDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_gather_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getAllGatherDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().all_gather_dim);
  }

  ::mlir::Attribute getAllGatherDim();
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  void setAllGatherDimAttr(::mlir::Attribute attr) {
    getProperties().all_gather_dim = attr;
  }

  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr) {
    getProperties().use_global_device_ids = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllGatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllGatherOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllGatherOpV2GenericAdaptorBase {
public:
  struct Properties {
    using all_gather_dimTy = ::mlir::Attribute;
    all_gather_dimTy all_gather_dim;

    auto getAllGatherDim() {
      auto &propStorage = this->all_gather_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setAllGatherDim(const ::mlir::Attribute &propValue) {
      this->all_gather_dim = propValue;
    }
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    using use_global_device_idsTy = ::mlir::Attribute;
    use_global_device_idsTy use_global_device_ids;

    auto getUseGlobalDeviceIds() {
      auto &propStorage = this->use_global_device_ids;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUseGlobalDeviceIds(const ::mlir::Attribute &propValue) {
      this->use_global_device_ids = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.all_gather_dim == this->all_gather_dim &&
        rhs.channel_id == this->channel_id &&
        rhs.replica_groups == this->replica_groups &&
        rhs.use_global_device_ids == this->use_global_device_ids &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllGatherOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.all_gather_v2", odsAttrs.getContext());
  }

  AllGatherOpV2GenericAdaptorBase(AllGatherOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getAllGatherDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().all_gather_dim);
    return attr;
  }

  ::mlir::Attribute getAllGatherDim();
  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
    return attr;
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
};
} // namespace detail
template <typename RangeT>
class AllGatherOpV2GenericAdaptor : public detail::AllGatherOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllGatherOpV2GenericAdaptorBase;
public:
  AllGatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllGatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllGatherOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AllGatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AllGatherOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AllGatherOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, AllGatherOpV2>>>
  AllGatherOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return getODSOperands(0);
  }

private:
  RangeT odsOperands;
};
class AllGatherOpV2Adaptor : public AllGatherOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using AllGatherOpV2GenericAdaptor::AllGatherOpV2GenericAdaptor;
  AllGatherOpV2Adaptor(AllGatherOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AllGatherOpV2 : public ::mlir::Op<AllGatherOpV2, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllGatherOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllGatherOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("all_gather_dim"), ::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAllGatherDimAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAllGatherDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_gather_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperands() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getAllGatherDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().all_gather_dim);
  }

  ::mlir::Attribute getAllGatherDim();
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  void setAllGatherDimAttr(::mlir::Attribute attr) {
    getProperties().all_gather_dim = attr;
  }

  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr) {
    getProperties().use_global_device_ids = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange operands, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllGatherOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllReduceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllReduceOpV1GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    using use_global_device_idsTy = ::mlir::Attribute;
    use_global_device_idsTy use_global_device_ids;

    auto getUseGlobalDeviceIds() {
      auto &propStorage = this->use_global_device_ids;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUseGlobalDeviceIds(const ::mlir::Attribute &propValue) {
      this->use_global_device_ids = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.replica_groups == this->replica_groups &&
        rhs.use_global_device_ids == this->use_global_device_ids &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllReduceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.all_reduce_v1", odsAttrs.getContext());
  }

  AllReduceOpV1GenericAdaptorBase(AllReduceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
    return attr;
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  ::mlir::Region &getComputation() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class AllReduceOpV1GenericAdaptor : public detail::AllReduceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllReduceOpV1GenericAdaptorBase;
public:
  AllReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllReduceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AllReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AllReduceOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AllReduceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AllReduceOpV1>>>
  AllReduceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllReduceOpV1Adaptor : public AllReduceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AllReduceOpV1GenericAdaptor::AllReduceOpV1GenericAdaptor;
  AllReduceOpV1Adaptor(AllReduceOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AllReduceOpV1 : public ::mlir::Op<AllReduceOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::vhlo::VersionedOpConstraintInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllReduceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllReduceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_reduce_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  ::mlir::Region &getComputation() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr) {
    getProperties().use_global_device_ids = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  mlir::LogicalResult validateConstraint(mlir::Operation*op, mlir::vhlo::Version targetVersion);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllReduceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllReduceOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllReduceOpV2GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    using use_global_device_idsTy = ::mlir::Attribute;
    use_global_device_idsTy use_global_device_ids;

    auto getUseGlobalDeviceIds() {
      auto &propStorage = this->use_global_device_ids;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUseGlobalDeviceIds(const ::mlir::Attribute &propValue) {
      this->use_global_device_ids = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.replica_groups == this->replica_groups &&
        rhs.use_global_device_ids == this->use_global_device_ids &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllReduceOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.all_reduce_v2", odsAttrs.getContext());
  }

  AllReduceOpV2GenericAdaptorBase(AllReduceOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
    return attr;
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  ::mlir::Region &getComputation() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class AllReduceOpV2GenericAdaptor : public detail::AllReduceOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllReduceOpV2GenericAdaptorBase;
public:
  AllReduceOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllReduceOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllReduceOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AllReduceOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AllReduceOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AllReduceOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, AllReduceOpV2>>>
  AllReduceOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return getODSOperands(0);
  }

private:
  RangeT odsOperands;
};
class AllReduceOpV2Adaptor : public AllReduceOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using AllReduceOpV2GenericAdaptor::AllReduceOpV2GenericAdaptor;
  AllReduceOpV2Adaptor(AllReduceOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AllReduceOpV2 : public ::mlir::Op<AllReduceOpV2, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllReduceOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllReduceOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_reduce_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperands() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getComputation() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr) {
    getProperties().use_global_device_ids = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange operands, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllReduceOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllToAllOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllToAllOpV1GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using concat_dimensionTy = ::mlir::Attribute;
    concat_dimensionTy concat_dimension;

    auto getConcatDimension() {
      auto &propStorage = this->concat_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setConcatDimension(const ::mlir::Attribute &propValue) {
      this->concat_dimension = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    using split_countTy = ::mlir::Attribute;
    split_countTy split_count;

    auto getSplitCount() {
      auto &propStorage = this->split_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSplitCount(const ::mlir::Attribute &propValue) {
      this->split_count = propValue;
    }
    using split_dimensionTy = ::mlir::Attribute;
    split_dimensionTy split_dimension;

    auto getSplitDimension() {
      auto &propStorage = this->split_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSplitDimension(const ::mlir::Attribute &propValue) {
      this->split_dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.concat_dimension == this->concat_dimension &&
        rhs.replica_groups == this->replica_groups &&
        rhs.split_count == this->split_count &&
        rhs.split_dimension == this->split_dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllToAllOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.all_to_all_v1", odsAttrs.getContext());
  }

  AllToAllOpV1GenericAdaptorBase(AllToAllOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getSplitDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().split_dimension);
    return attr;
  }

  ::mlir::Attribute getSplitDimension();
  ::mlir::Attribute getConcatDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().concat_dimension);
    return attr;
  }

  ::mlir::Attribute getConcatDimension();
  ::mlir::Attribute getSplitCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().split_count);
    return attr;
  }

  ::mlir::Attribute getSplitCount();
  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
};
} // namespace detail
template <typename RangeT>
class AllToAllOpV1GenericAdaptor : public detail::AllToAllOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllToAllOpV1GenericAdaptorBase;
public:
  AllToAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllToAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllToAllOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AllToAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AllToAllOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AllToAllOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AllToAllOpV1>>>
  AllToAllOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllToAllOpV1Adaptor : public AllToAllOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AllToAllOpV1GenericAdaptor::AllToAllOpV1GenericAdaptor;
  AllToAllOpV1Adaptor(AllToAllOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AllToAllOpV1 : public ::mlir::Op<AllToAllOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllToAllOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllToAllOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("concat_dimension"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("split_count"), ::llvm::StringRef("split_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getConcatDimensionAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getConcatDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getSplitCountAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getSplitCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSplitDimensionAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSplitDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_to_all_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getSplitDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().split_dimension);
  }

  ::mlir::Attribute getSplitDimension();
  ::mlir::Attribute getConcatDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().concat_dimension);
  }

  ::mlir::Attribute getConcatDimension();
  ::mlir::Attribute getSplitCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().split_count);
  }

  ::mlir::Attribute getSplitCount();
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  void setSplitDimensionAttr(::mlir::Attribute attr) {
    getProperties().split_dimension = attr;
  }

  void setConcatDimensionAttr(::mlir::Attribute attr) {
    getProperties().concat_dimension = attr;
  }

  void setSplitCountAttr(::mlir::Attribute attr) {
    getProperties().split_count = attr;
  }

  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllToAllOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllToAllOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllToAllOpV2GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using concat_dimensionTy = ::mlir::Attribute;
    concat_dimensionTy concat_dimension;

    auto getConcatDimension() {
      auto &propStorage = this->concat_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setConcatDimension(const ::mlir::Attribute &propValue) {
      this->concat_dimension = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    using split_countTy = ::mlir::Attribute;
    split_countTy split_count;

    auto getSplitCount() {
      auto &propStorage = this->split_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSplitCount(const ::mlir::Attribute &propValue) {
      this->split_count = propValue;
    }
    using split_dimensionTy = ::mlir::Attribute;
    split_dimensionTy split_dimension;

    auto getSplitDimension() {
      auto &propStorage = this->split_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSplitDimension(const ::mlir::Attribute &propValue) {
      this->split_dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.concat_dimension == this->concat_dimension &&
        rhs.replica_groups == this->replica_groups &&
        rhs.split_count == this->split_count &&
        rhs.split_dimension == this->split_dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllToAllOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.all_to_all_v2", odsAttrs.getContext());
  }

  AllToAllOpV2GenericAdaptorBase(AllToAllOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getSplitDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().split_dimension);
    return attr;
  }

  ::mlir::Attribute getSplitDimension();
  ::mlir::Attribute getConcatDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().concat_dimension);
    return attr;
  }

  ::mlir::Attribute getConcatDimension();
  ::mlir::Attribute getSplitCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().split_count);
    return attr;
  }

  ::mlir::Attribute getSplitCount();
  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
};
} // namespace detail
template <typename RangeT>
class AllToAllOpV2GenericAdaptor : public detail::AllToAllOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllToAllOpV2GenericAdaptorBase;
public:
  AllToAllOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllToAllOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllToAllOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  AllToAllOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : AllToAllOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = AllToAllOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, AllToAllOpV2>>>
  AllToAllOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return getODSOperands(0);
  }

private:
  RangeT odsOperands;
};
class AllToAllOpV2Adaptor : public AllToAllOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using AllToAllOpV2GenericAdaptor::AllToAllOpV2GenericAdaptor;
  AllToAllOpV2Adaptor(AllToAllOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AllToAllOpV2 : public ::mlir::Op<AllToAllOpV2, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllToAllOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllToAllOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("concat_dimension"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("split_count"), ::llvm::StringRef("split_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getConcatDimensionAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getConcatDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getSplitCountAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getSplitCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSplitDimensionAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSplitDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_to_all_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperands() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getSplitDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().split_dimension);
  }

  ::mlir::Attribute getSplitDimension();
  ::mlir::Attribute getConcatDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().concat_dimension);
  }

  ::mlir::Attribute getConcatDimension();
  ::mlir::Attribute getSplitCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().split_count);
  }

  ::mlir::Attribute getSplitCount();
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  void setSplitDimensionAttr(::mlir::Attribute attr) {
    getProperties().split_dimension = attr;
  }

  void setConcatDimensionAttr(::mlir::Attribute attr) {
    getProperties().concat_dimension = attr;
  }

  void setSplitCountAttr(::mlir::Attribute attr) {
    getProperties().split_count = attr;
  }

  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange operands, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllToAllOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AndOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AndOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AndOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.and_v1", odsAttrs.getContext());
  }

  AndOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class AndOpV1GenericAdaptor : public detail::AndOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AndOpV1GenericAdaptorBase;
public:
  AndOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AndOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AndOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AndOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AndOpV1>>>
  AndOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AndOpV1Adaptor : public AndOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AndOpV1GenericAdaptor::AndOpV1GenericAdaptor;
  AndOpV1Adaptor(AndOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class AndOpV1 : public ::mlir::Op<AndOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AndOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AndOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.and_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AndOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Atan2OpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class Atan2OpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  Atan2OpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.atan2_v1", odsAttrs.getContext());
  }

  Atan2OpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class Atan2OpV1GenericAdaptor : public detail::Atan2OpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::Atan2OpV1GenericAdaptorBase;
public:
  Atan2OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  Atan2OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : Atan2OpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = Atan2OpV1, typename = std::enable_if_t<std::is_same_v<LateInst, Atan2OpV1>>>
  Atan2OpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class Atan2OpV1Adaptor : public Atan2OpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using Atan2OpV1GenericAdaptor::Atan2OpV1GenericAdaptor;
  Atan2OpV1Adaptor(Atan2OpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class Atan2OpV1 : public ::mlir::Op<Atan2OpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Atan2OpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = Atan2OpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.atan2_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::Atan2OpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormGradOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BatchNormGradOpV1GenericAdaptorBase {
public:
  struct Properties {
    using epsilonTy = ::mlir::Attribute;
    epsilonTy epsilon;

    auto getEpsilon() {
      auto &propStorage = this->epsilon;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setEpsilon(const ::mlir::Attribute &propValue) {
      this->epsilon = propValue;
    }
    using feature_indexTy = ::mlir::Attribute;
    feature_indexTy feature_index;

    auto getFeatureIndex() {
      auto &propStorage = this->feature_index;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFeatureIndex(const ::mlir::Attribute &propValue) {
      this->feature_index = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.epsilon == this->epsilon &&
        rhs.feature_index == this->feature_index &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  BatchNormGradOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.batch_norm_grad_v1", odsAttrs.getContext());
  }

  BatchNormGradOpV1GenericAdaptorBase(BatchNormGradOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getEpsilonAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().epsilon);
    return attr;
  }

  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().feature_index);
    return attr;
  }

  ::mlir::Attribute getFeatureIndex();
};
} // namespace detail
template <typename RangeT>
class BatchNormGradOpV1GenericAdaptor : public detail::BatchNormGradOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BatchNormGradOpV1GenericAdaptorBase;
public:
  BatchNormGradOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BatchNormGradOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BatchNormGradOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  BatchNormGradOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : BatchNormGradOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = BatchNormGradOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BatchNormGradOpV1>>>
  BatchNormGradOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getScale() {
    return (*getODSOperands(1).begin());
  }

  ValueT getMean() {
    return (*getODSOperands(2).begin());
  }

  ValueT getVariance() {
    return (*getODSOperands(3).begin());
  }

  ValueT getGradOutput() {
    return (*getODSOperands(4).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BatchNormGradOpV1Adaptor : public BatchNormGradOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BatchNormGradOpV1GenericAdaptor::BatchNormGradOpV1GenericAdaptor;
  BatchNormGradOpV1Adaptor(BatchNormGradOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class BatchNormGradOpV1 : public ::mlir::Op<BatchNormGradOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BatchNormGradOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BatchNormGradOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("epsilon"), ::llvm::StringRef("feature_index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEpsilonAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEpsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureIndexAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.batch_norm_grad_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getScale() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getMean() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getVariance() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(3).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getGradOutput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(4).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getScaleMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getMeanMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getVarianceMutable() {
    auto range = getODSOperandIndexAndLength(3);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getGradOutputMutable() {
    auto range = getODSOperandIndexAndLength(4);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getGradOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getGradScale() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getGradOffset() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(2).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getEpsilonAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().epsilon);
  }

  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().feature_index);
  }

  ::mlir::Attribute getFeatureIndex();
  void setEpsilonAttr(::mlir::Attribute attr) {
    getProperties().epsilon = attr;
  }

  void setFeatureIndexAttr(::mlir::Attribute attr) {
    getProperties().feature_index = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type grad_operand, ::mlir::Type grad_scale, ::mlir::Type grad_offset, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Value grad_output, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Value grad_output, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormGradOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormInferenceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BatchNormInferenceOpV1GenericAdaptorBase {
public:
  struct Properties {
    using epsilonTy = ::mlir::Attribute;
    epsilonTy epsilon;

    auto getEpsilon() {
      auto &propStorage = this->epsilon;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setEpsilon(const ::mlir::Attribute &propValue) {
      this->epsilon = propValue;
    }
    using feature_indexTy = ::mlir::Attribute;
    feature_indexTy feature_index;

    auto getFeatureIndex() {
      auto &propStorage = this->feature_index;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFeatureIndex(const ::mlir::Attribute &propValue) {
      this->feature_index = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.epsilon == this->epsilon &&
        rhs.feature_index == this->feature_index &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  BatchNormInferenceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.batch_norm_inference_v1", odsAttrs.getContext());
  }

  BatchNormInferenceOpV1GenericAdaptorBase(BatchNormInferenceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getEpsilonAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().epsilon);
    return attr;
  }

  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().feature_index);
    return attr;
  }

  ::mlir::Attribute getFeatureIndex();
};
} // namespace detail
template <typename RangeT>
class BatchNormInferenceOpV1GenericAdaptor : public detail::BatchNormInferenceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BatchNormInferenceOpV1GenericAdaptorBase;
public:
  BatchNormInferenceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BatchNormInferenceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BatchNormInferenceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  BatchNormInferenceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : BatchNormInferenceOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = BatchNormInferenceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BatchNormInferenceOpV1>>>
  BatchNormInferenceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getScale() {
    return (*getODSOperands(1).begin());
  }

  ValueT getOffset() {
    return (*getODSOperands(2).begin());
  }

  ValueT getMean() {
    return (*getODSOperands(3).begin());
  }

  ValueT getVariance() {
    return (*getODSOperands(4).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BatchNormInferenceOpV1Adaptor : public BatchNormInferenceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BatchNormInferenceOpV1GenericAdaptor::BatchNormInferenceOpV1GenericAdaptor;
  BatchNormInferenceOpV1Adaptor(BatchNormInferenceOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class BatchNormInferenceOpV1 : public ::mlir::Op<BatchNormInferenceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BatchNormInferenceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BatchNormInferenceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("epsilon"), ::llvm::StringRef("feature_index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEpsilonAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEpsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureIndexAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.batch_norm_inference_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getScale() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOffset() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getMean() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(3).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getVariance() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(4).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getScaleMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getOffsetMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getMeanMutable() {
    auto range = getODSOperandIndexAndLength(3);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getVarianceMutable() {
    auto range = getODSOperandIndexAndLength(4);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getEpsilonAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().epsilon);
  }

  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().feature_index);
  }

  ::mlir::Attribute getFeatureIndex();
  void setEpsilonAttr(::mlir::Attribute attr) {
    getProperties().epsilon = attr;
  }

  void setFeatureIndexAttr(::mlir::Attribute attr) {
    getProperties().feature_index = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormInferenceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormTrainingOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BatchNormTrainingOpV1GenericAdaptorBase {
public:
  struct Properties {
    using epsilonTy = ::mlir::Attribute;
    epsilonTy epsilon;

    auto getEpsilon() {
      auto &propStorage = this->epsilon;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setEpsilon(const ::mlir::Attribute &propValue) {
      this->epsilon = propValue;
    }
    using feature_indexTy = ::mlir::Attribute;
    feature_indexTy feature_index;

    auto getFeatureIndex() {
      auto &propStorage = this->feature_index;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFeatureIndex(const ::mlir::Attribute &propValue) {
      this->feature_index = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.epsilon == this->epsilon &&
        rhs.feature_index == this->feature_index &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  BatchNormTrainingOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.batch_norm_training_v1", odsAttrs.getContext());
  }

  BatchNormTrainingOpV1GenericAdaptorBase(BatchNormTrainingOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getEpsilonAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().epsilon);
    return attr;
  }

  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().feature_index);
    return attr;
  }

  ::mlir::Attribute getFeatureIndex();
};
} // namespace detail
template <typename RangeT>
class BatchNormTrainingOpV1GenericAdaptor : public detail::BatchNormTrainingOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BatchNormTrainingOpV1GenericAdaptorBase;
public:
  BatchNormTrainingOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BatchNormTrainingOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BatchNormTrainingOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  BatchNormTrainingOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : BatchNormTrainingOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = BatchNormTrainingOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BatchNormTrainingOpV1>>>
  BatchNormTrainingOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getScale() {
    return (*getODSOperands(1).begin());
  }

  ValueT getOffset() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BatchNormTrainingOpV1Adaptor : public BatchNormTrainingOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BatchNormTrainingOpV1GenericAdaptor::BatchNormTrainingOpV1GenericAdaptor;
  BatchNormTrainingOpV1Adaptor(BatchNormTrainingOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class BatchNormTrainingOpV1 : public ::mlir::Op<BatchNormTrainingOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BatchNormTrainingOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BatchNormTrainingOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("epsilon"), ::llvm::StringRef("feature_index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEpsilonAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEpsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureIndexAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.batch_norm_training_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getScale() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOffset() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getScaleMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getOffsetMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOutput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getBatchMean() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getBatchVar() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(2).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getEpsilonAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().epsilon);
  }

  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().feature_index);
  }

  ::mlir::Attribute getFeatureIndex();
  void setEpsilonAttr(::mlir::Attribute attr) {
    getProperties().epsilon = attr;
  }

  void setFeatureIndexAttr(::mlir::Attribute attr) {
    getProperties().feature_index = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Type batch_mean, ::mlir::Type batch_var, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormTrainingOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BitcastConvertOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BitcastConvertOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BitcastConvertOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.bitcast_convert_v1", odsAttrs.getContext());
  }

  BitcastConvertOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class BitcastConvertOpV1GenericAdaptor : public detail::BitcastConvertOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BitcastConvertOpV1GenericAdaptorBase;
public:
  BitcastConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BitcastConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BitcastConvertOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BitcastConvertOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BitcastConvertOpV1>>>
  BitcastConvertOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BitcastConvertOpV1Adaptor : public BitcastConvertOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BitcastConvertOpV1GenericAdaptor::BitcastConvertOpV1GenericAdaptor;
  BitcastConvertOpV1Adaptor(BitcastConvertOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class BitcastConvertOpV1 : public ::mlir::Op<BitcastConvertOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BitcastConvertOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BitcastConvertOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.bitcast_convert_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BitcastConvertOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BroadcastInDimOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BroadcastInDimOpV1GenericAdaptorBase {
public:
  struct Properties {
    using broadcast_dimensionsTy = ::mlir::Attribute;
    broadcast_dimensionsTy broadcast_dimensions;

    auto getBroadcastDimensions() {
      auto &propStorage = this->broadcast_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBroadcastDimensions(const ::mlir::Attribute &propValue) {
      this->broadcast_dimensions = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.broadcast_dimensions == this->broadcast_dimensions &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  BroadcastInDimOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.broadcast_in_dim_v1", odsAttrs.getContext());
  }

  BroadcastInDimOpV1GenericAdaptorBase(BroadcastInDimOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getBroadcastDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().broadcast_dimensions);
    return attr;
  }

  ::mlir::Attribute getBroadcastDimensions();
};
} // namespace detail
template <typename RangeT>
class BroadcastInDimOpV1GenericAdaptor : public detail::BroadcastInDimOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BroadcastInDimOpV1GenericAdaptorBase;
public:
  BroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BroadcastInDimOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  BroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : BroadcastInDimOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = BroadcastInDimOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BroadcastInDimOpV1>>>
  BroadcastInDimOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BroadcastInDimOpV1Adaptor : public BroadcastInDimOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BroadcastInDimOpV1GenericAdaptor::BroadcastInDimOpV1GenericAdaptor;
  BroadcastInDimOpV1Adaptor(BroadcastInDimOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class BroadcastInDimOpV1 : public ::mlir::Op<BroadcastInDimOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BroadcastInDimOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BroadcastInDimOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("broadcast_dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBroadcastDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBroadcastDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.broadcast_in_dim_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getBroadcastDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().broadcast_dimensions);
  }

  ::mlir::Attribute getBroadcastDimensions();
  void setBroadcastDimensionsAttr(::mlir::Attribute attr) {
    getProperties().broadcast_dimensions = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute broadcast_dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute broadcast_dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BroadcastInDimOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BroadcastOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BroadcastOpV1GenericAdaptorBase {
public:
  struct Properties {
    using broadcast_sizesTy = ::mlir::Attribute;
    broadcast_sizesTy broadcast_sizes;

    auto getBroadcastSizes() {
      auto &propStorage = this->broadcast_sizes;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBroadcastSizes(const ::mlir::Attribute &propValue) {
      this->broadcast_sizes = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.broadcast_sizes == this->broadcast_sizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  BroadcastOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.broadcast_v1", odsAttrs.getContext());
  }

  BroadcastOpV1GenericAdaptorBase(BroadcastOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getBroadcastSizesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().broadcast_sizes);
    return attr;
  }

  ::mlir::Attribute getBroadcastSizes();
};
} // namespace detail
template <typename RangeT>
class BroadcastOpV1GenericAdaptor : public detail::BroadcastOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BroadcastOpV1GenericAdaptorBase;
public:
  BroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BroadcastOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  BroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : BroadcastOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = BroadcastOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BroadcastOpV1>>>
  BroadcastOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BroadcastOpV1Adaptor : public BroadcastOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BroadcastOpV1GenericAdaptor::BroadcastOpV1GenericAdaptor;
  BroadcastOpV1Adaptor(BroadcastOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class BroadcastOpV1 : public ::mlir::Op<BroadcastOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BroadcastOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BroadcastOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("broadcast_sizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBroadcastSizesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBroadcastSizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.broadcast_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getBroadcastSizesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().broadcast_sizes);
  }

  ::mlir::Attribute getBroadcastSizes();
  void setBroadcastSizesAttr(::mlir::Attribute attr) {
    getProperties().broadcast_sizes = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute broadcast_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute broadcast_sizes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BroadcastOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CallOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CallOpV1GenericAdaptorBase {
public:
  struct Properties {
    using calleeTy = ::mlir::Attribute;
    calleeTy callee;

    auto getCallee() {
      auto &propStorage = this->callee;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCallee(const ::mlir::Attribute &propValue) {
      this->callee = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.callee == this->callee &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CallOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.call_v1", odsAttrs.getContext());
  }

  CallOpV1GenericAdaptorBase(CallOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getCalleeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().callee);
    return attr;
  }

  ::mlir::Attribute getCallee();
};
} // namespace detail
template <typename RangeT>
class CallOpV1GenericAdaptor : public detail::CallOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CallOpV1GenericAdaptorBase;
public:
  CallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CallOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CallOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CallOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CallOpV1>>>
  CallOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return getODSOperands(0);
  }

private:
  RangeT odsOperands;
};
class CallOpV1Adaptor : public CallOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CallOpV1GenericAdaptor::CallOpV1GenericAdaptor;
  CallOpV1Adaptor(CallOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CallOpV1 : public ::mlir::Op<CallOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CallOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CallOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("callee")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCalleeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCalleeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.call_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperands() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getCalleeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().callee);
  }

  ::mlir::Attribute getCallee();
  void setCalleeAttr(::mlir::Attribute attr) {
    getProperties().callee = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Attribute callee, ::mlir::ValueRange operands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CallOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CaseOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CaseOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CaseOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.case_v1", odsAttrs.getContext());
  }

  CaseOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::RegionRange getBranches() {
    return odsRegions.drop_front(0);
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class CaseOpV1GenericAdaptor : public detail::CaseOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CaseOpV1GenericAdaptorBase;
public:
  CaseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CaseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CaseOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CaseOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CaseOpV1>>>
  CaseOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIndex() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CaseOpV1Adaptor : public CaseOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CaseOpV1GenericAdaptor::CaseOpV1GenericAdaptor;
  CaseOpV1Adaptor(CaseOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CaseOpV1 : public ::mlir::Op<CaseOpV1, ::mlir::OpTrait::VariadicRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CaseOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CaseOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.case_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getIndex() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getIndexMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::MutableArrayRef<::mlir::Region> getBranches() {
    return (*this)->getRegions().drop_front(0);
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value index, unsigned branchesCount);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes, unsigned numRegions);
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CaseOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CbrtOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CbrtOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CbrtOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.cbrt_v1", odsAttrs.getContext());
  }

  CbrtOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class CbrtOpV1GenericAdaptor : public detail::CbrtOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CbrtOpV1GenericAdaptorBase;
public:
  CbrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CbrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CbrtOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CbrtOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CbrtOpV1>>>
  CbrtOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CbrtOpV1Adaptor : public CbrtOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CbrtOpV1GenericAdaptor::CbrtOpV1GenericAdaptor;
  CbrtOpV1Adaptor(CbrtOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CbrtOpV1 : public ::mlir::Op<CbrtOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CbrtOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CbrtOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cbrt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CbrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CeilOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CeilOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CeilOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.ceil_v1", odsAttrs.getContext());
  }

  CeilOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class CeilOpV1GenericAdaptor : public detail::CeilOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CeilOpV1GenericAdaptorBase;
public:
  CeilOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CeilOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CeilOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CeilOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CeilOpV1>>>
  CeilOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CeilOpV1Adaptor : public CeilOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CeilOpV1GenericAdaptor::CeilOpV1GenericAdaptor;
  CeilOpV1Adaptor(CeilOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CeilOpV1 : public ::mlir::Op<CeilOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CeilOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CeilOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.ceil_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CeilOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CholeskyOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CholeskyOpV1GenericAdaptorBase {
public:
  struct Properties {
    using lowerTy = ::mlir::Attribute;
    lowerTy lower;

    auto getLower() {
      auto &propStorage = this->lower;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLower(const ::mlir::Attribute &propValue) {
      this->lower = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.lower == this->lower &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CholeskyOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.cholesky_v1", odsAttrs.getContext());
  }

  CholeskyOpV1GenericAdaptorBase(CholeskyOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getLowerAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lower);
    return attr;
  }

  ::mlir::Attribute getLower();
};
} // namespace detail
template <typename RangeT>
class CholeskyOpV1GenericAdaptor : public detail::CholeskyOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CholeskyOpV1GenericAdaptorBase;
public:
  CholeskyOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CholeskyOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CholeskyOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CholeskyOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CholeskyOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CholeskyOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CholeskyOpV1>>>
  CholeskyOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getA() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CholeskyOpV1Adaptor : public CholeskyOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CholeskyOpV1GenericAdaptor::CholeskyOpV1GenericAdaptor;
  CholeskyOpV1Adaptor(CholeskyOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CholeskyOpV1 : public ::mlir::Op<CholeskyOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CholeskyOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CholeskyOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("lower")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLowerAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLowerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cholesky_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getA() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getAMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getLowerAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lower);
  }

  ::mlir::Attribute getLower();
  void setLowerAttr(::mlir::Attribute attr) {
    getProperties().lower = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Attribute lower);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Attribute lower);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CholeskyOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ClampOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ClampOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ClampOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.clamp_v1", odsAttrs.getContext());
  }

  ClampOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ClampOpV1GenericAdaptor : public detail::ClampOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ClampOpV1GenericAdaptorBase;
public:
  ClampOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ClampOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ClampOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ClampOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ClampOpV1>>>
  ClampOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getMin() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOperand() {
    return (*getODSOperands(1).begin());
  }

  ValueT getMax() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ClampOpV1Adaptor : public ClampOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ClampOpV1GenericAdaptor::ClampOpV1GenericAdaptor;
  ClampOpV1Adaptor(ClampOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ClampOpV1 : public ::mlir::Op<ClampOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ClampOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ClampOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.clamp_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getMin() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getMax() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getMinMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getMaxMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value min, ::mlir::Value operand, ::mlir::Value max);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value min, ::mlir::Value operand, ::mlir::Value max);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ClampOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ClzOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ClzOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ClzOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.count_leading_zeros_v1", odsAttrs.getContext());
  }

  ClzOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ClzOpV1GenericAdaptor : public detail::ClzOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ClzOpV1GenericAdaptorBase;
public:
  ClzOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ClzOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ClzOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ClzOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ClzOpV1>>>
  ClzOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ClzOpV1Adaptor : public ClzOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ClzOpV1GenericAdaptor::ClzOpV1GenericAdaptor;
  ClzOpV1Adaptor(ClzOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ClzOpV1 : public ::mlir::Op<ClzOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ClzOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ClzOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.count_leading_zeros_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ClzOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CollectiveBroadcastOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CollectiveBroadcastOpV1GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.replica_groups == this->replica_groups &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CollectiveBroadcastOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.collective_broadcast_v1", odsAttrs.getContext());
  }

  CollectiveBroadcastOpV1GenericAdaptorBase(CollectiveBroadcastOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
};
} // namespace detail
template <typename RangeT>
class CollectiveBroadcastOpV1GenericAdaptor : public detail::CollectiveBroadcastOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CollectiveBroadcastOpV1GenericAdaptorBase;
public:
  CollectiveBroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CollectiveBroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CollectiveBroadcastOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CollectiveBroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CollectiveBroadcastOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CollectiveBroadcastOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CollectiveBroadcastOpV1>>>
  CollectiveBroadcastOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CollectiveBroadcastOpV1Adaptor : public CollectiveBroadcastOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CollectiveBroadcastOpV1GenericAdaptor::CollectiveBroadcastOpV1GenericAdaptor;
  CollectiveBroadcastOpV1Adaptor(CollectiveBroadcastOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CollectiveBroadcastOpV1 : public ::mlir::Op<CollectiveBroadcastOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CollectiveBroadcastOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CollectiveBroadcastOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.collective_broadcast_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CollectiveBroadcastOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CollectivePermuteOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CollectivePermuteOpV1GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using source_target_pairsTy = ::mlir::Attribute;
    source_target_pairsTy source_target_pairs;

    auto getSourceTargetPairs() {
      auto &propStorage = this->source_target_pairs;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSourceTargetPairs(const ::mlir::Attribute &propValue) {
      this->source_target_pairs = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.source_target_pairs == this->source_target_pairs &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CollectivePermuteOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.collective_permute_v1", odsAttrs.getContext());
  }

  CollectivePermuteOpV1GenericAdaptorBase(CollectivePermuteOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getSourceTargetPairsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().source_target_pairs);
    return attr;
  }

  ::mlir::Attribute getSourceTargetPairs();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
};
} // namespace detail
template <typename RangeT>
class CollectivePermuteOpV1GenericAdaptor : public detail::CollectivePermuteOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CollectivePermuteOpV1GenericAdaptorBase;
public:
  CollectivePermuteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CollectivePermuteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CollectivePermuteOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CollectivePermuteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CollectivePermuteOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CollectivePermuteOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CollectivePermuteOpV1>>>
  CollectivePermuteOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CollectivePermuteOpV1Adaptor : public CollectivePermuteOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CollectivePermuteOpV1GenericAdaptor::CollectivePermuteOpV1GenericAdaptor;
  CollectivePermuteOpV1Adaptor(CollectivePermuteOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CollectivePermuteOpV1 : public ::mlir::Op<CollectivePermuteOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CollectivePermuteOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CollectivePermuteOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("source_target_pairs")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getSourceTargetPairsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getSourceTargetPairsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.collective_permute_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getSourceTargetPairsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().source_target_pairs);
  }

  ::mlir::Attribute getSourceTargetPairs();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  void setSourceTargetPairsAttr(::mlir::Attribute attr) {
    getProperties().source_target_pairs = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute source_target_pairs, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute source_target_pairs, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CollectivePermuteOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CompareOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CompareOpV1GenericAdaptorBase {
public:
  struct Properties {
    using compare_typeTy = ::mlir::Attribute;
    compare_typeTy compare_type;

    auto getCompareType() {
      auto &propStorage = this->compare_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCompareType(const ::mlir::Attribute &propValue) {
      this->compare_type = propValue;
    }
    using comparison_directionTy = ::mlir::Attribute;
    comparison_directionTy comparison_direction;

    auto getComparisonDirection() {
      auto &propStorage = this->comparison_direction;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setComparisonDirection(const ::mlir::Attribute &propValue) {
      this->comparison_direction = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.compare_type == this->compare_type &&
        rhs.comparison_direction == this->comparison_direction &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CompareOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.compare_v1", odsAttrs.getContext());
  }

  CompareOpV1GenericAdaptorBase(CompareOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getComparisonDirectionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().comparison_direction);
    return attr;
  }

  ::mlir::Attribute getComparisonDirection();
  ::mlir::Attribute getCompareTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().compare_type);
    return attr;
  }

  ::mlir::Attribute getCompareType();
};
} // namespace detail
template <typename RangeT>
class CompareOpV1GenericAdaptor : public detail::CompareOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CompareOpV1GenericAdaptorBase;
public:
  CompareOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CompareOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CompareOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CompareOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CompareOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CompareOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CompareOpV1>>>
  CompareOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CompareOpV1Adaptor : public CompareOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CompareOpV1GenericAdaptor::CompareOpV1GenericAdaptor;
  CompareOpV1Adaptor(CompareOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CompareOpV1 : public ::mlir::Op<CompareOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CompareOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CompareOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("compare_type"), ::llvm::StringRef("comparison_direction")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCompareTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCompareTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getComparisonDirectionAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getComparisonDirectionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.compare_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getComparisonDirectionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().comparison_direction);
  }

  ::mlir::Attribute getComparisonDirection();
  ::mlir::Attribute getCompareTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().compare_type);
  }

  ::mlir::Attribute getCompareType();
  void setComparisonDirectionAttr(::mlir::Attribute attr) {
    getProperties().comparison_direction = attr;
  }

  void setCompareTypeAttr(::mlir::Attribute attr) {
    getProperties().compare_type = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute comparison_direction, ::mlir::Attribute compare_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute comparison_direction, ::mlir::Attribute compare_type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CompareOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ComplexOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ComplexOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ComplexOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.complex_v1", odsAttrs.getContext());
  }

  ComplexOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ComplexOpV1GenericAdaptor : public detail::ComplexOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ComplexOpV1GenericAdaptorBase;
public:
  ComplexOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ComplexOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ComplexOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ComplexOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ComplexOpV1>>>
  ComplexOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ComplexOpV1Adaptor : public ComplexOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ComplexOpV1GenericAdaptor::ComplexOpV1GenericAdaptor;
  ComplexOpV1Adaptor(ComplexOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ComplexOpV1 : public ::mlir::Op<ComplexOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ComplexOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ComplexOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.complex_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ComplexOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CompositeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CompositeOpV1GenericAdaptorBase {
public:
  struct Properties {
    using composite_attributesTy = ::mlir::Attribute;
    composite_attributesTy composite_attributes;

    auto getCompositeAttributes() {
      auto &propStorage = this->composite_attributes;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCompositeAttributes(const ::mlir::Attribute &propValue) {
      this->composite_attributes = propValue;
    }
    using decompositionTy = ::mlir::Attribute;
    decompositionTy decomposition;

    auto getDecomposition() {
      auto &propStorage = this->decomposition;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDecomposition(const ::mlir::Attribute &propValue) {
      this->decomposition = propValue;
    }
    using nameTy = ::mlir::Attribute;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setName(const ::mlir::Attribute &propValue) {
      this->name = propValue;
    }
    using versionTy = ::mlir::Attribute;
    versionTy version;

    auto getVersion() {
      auto &propStorage = this->version;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setVersion(const ::mlir::Attribute &propValue) {
      this->version = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.composite_attributes == this->composite_attributes &&
        rhs.decomposition == this->decomposition &&
        rhs.name == this->name &&
        rhs.version == this->version &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CompositeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.composite_v1", odsAttrs.getContext());
  }

  CompositeOpV1GenericAdaptorBase(CompositeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getNameAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().name);
    return attr;
  }

  ::mlir::Attribute getName();
  ::mlir::Attribute getCompositeAttributesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().composite_attributes);
    return attr;
  }

  ::mlir::Attribute getCompositeAttributes();
  ::mlir::Attribute getDecompositionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().decomposition);
    return attr;
  }

  ::mlir::Attribute getDecomposition();
  ::mlir::Attribute getVersionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().version);
    return attr;
  }

  ::mlir::Attribute getVersion();
};
} // namespace detail
template <typename RangeT>
class CompositeOpV1GenericAdaptor : public detail::CompositeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CompositeOpV1GenericAdaptorBase;
public:
  CompositeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CompositeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CompositeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CompositeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CompositeOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CompositeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CompositeOpV1>>>
  CompositeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CompositeOpV1Adaptor : public CompositeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CompositeOpV1GenericAdaptor::CompositeOpV1GenericAdaptor;
  CompositeOpV1Adaptor(CompositeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CompositeOpV1 : public ::mlir::Op<CompositeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CompositeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CompositeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("composite_attributes"), ::llvm::StringRef("decomposition"), ::llvm::StringRef("name"), ::llvm::StringRef("version")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCompositeAttributesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCompositeAttributesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getDecompositionAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getDecompositionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getVersionAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getVersionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.composite_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getNameAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().name);
  }

  ::mlir::Attribute getName();
  ::mlir::Attribute getCompositeAttributesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().composite_attributes);
  }

  ::mlir::Attribute getCompositeAttributes();
  ::mlir::Attribute getDecompositionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().decomposition);
  }

  ::mlir::Attribute getDecomposition();
  ::mlir::Attribute getVersionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().version);
  }

  ::mlir::Attribute getVersion();
  void setNameAttr(::mlir::Attribute attr) {
    getProperties().name = attr;
  }

  void setCompositeAttributesAttr(::mlir::Attribute attr) {
    getProperties().composite_attributes = attr;
  }

  void setDecompositionAttr(::mlir::Attribute attr) {
    getProperties().decomposition = attr;
  }

  void setVersionAttr(::mlir::Attribute attr) {
    getProperties().version = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute name, ::mlir::Attribute composite_attributes, ::mlir::Attribute decomposition, ::mlir::Attribute version);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CompositeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConcatenateOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConcatenateOpV1GenericAdaptorBase {
public:
  struct Properties {
    using dimensionTy = ::mlir::Attribute;
    dimensionTy dimension;

    auto getDimension() {
      auto &propStorage = this->dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDimension(const ::mlir::Attribute &propValue) {
      this->dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dimension == this->dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ConcatenateOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.concatenate_v1", odsAttrs.getContext());
  }

  ConcatenateOpV1GenericAdaptorBase(ConcatenateOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
    return attr;
  }

  ::mlir::Attribute getDimension();
};
} // namespace detail
template <typename RangeT>
class ConcatenateOpV1GenericAdaptor : public detail::ConcatenateOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConcatenateOpV1GenericAdaptorBase;
public:
  ConcatenateOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConcatenateOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConcatenateOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ConcatenateOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ConcatenateOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ConcatenateOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConcatenateOpV1>>>
  ConcatenateOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConcatenateOpV1Adaptor : public ConcatenateOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConcatenateOpV1GenericAdaptor::ConcatenateOpV1GenericAdaptor;
  ConcatenateOpV1Adaptor(ConcatenateOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ConcatenateOpV1 : public ::mlir::Op<ConcatenateOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConcatenateOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConcatenateOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.concatenate_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
  }

  ::mlir::Attribute getDimension();
  void setDimensionAttr(::mlir::Attribute attr) {
    getProperties().dimension = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConcatenateOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConstantOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConstantOpV1GenericAdaptorBase {
public:
  struct Properties {
    using valueTy = ::mlir::Attribute;
    valueTy value;

    auto getValue() {
      auto &propStorage = this->value;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setValue(const ::mlir::Attribute &propValue) {
      this->value = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.value == this->value &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ConstantOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.constant_v1", odsAttrs.getContext());
  }

  ConstantOpV1GenericAdaptorBase(ConstantOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getValueAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().value);
    return attr;
  }

  ::mlir::Attribute getValue();
};
} // namespace detail
template <typename RangeT>
class ConstantOpV1GenericAdaptor : public detail::ConstantOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConstantOpV1GenericAdaptorBase;
public:
  ConstantOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConstantOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConstantOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ConstantOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ConstantOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ConstantOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConstantOpV1>>>
  ConstantOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConstantOpV1Adaptor : public ConstantOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConstantOpV1GenericAdaptor::ConstantOpV1GenericAdaptor;
  ConstantOpV1Adaptor(ConstantOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ConstantOpV1 : public ::mlir::Op<ConstantOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConstantOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConstantOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("value")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getValueAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getValueAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.constant_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOutput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getValueAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().value);
  }

  ::mlir::Attribute getValue();
  void setValueAttr(::mlir::Attribute attr) {
    getProperties().value = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Attribute value);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute value);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConstantOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConvertOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConvertOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ConvertOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.convert_v1", odsAttrs.getContext());
  }

  ConvertOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ConvertOpV1GenericAdaptor : public detail::ConvertOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConvertOpV1GenericAdaptorBase;
public:
  ConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConvertOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ConvertOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConvertOpV1>>>
  ConvertOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConvertOpV1Adaptor : public ConvertOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConvertOpV1GenericAdaptor::ConvertOpV1GenericAdaptor;
  ConvertOpV1Adaptor(ConvertOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ConvertOpV1 : public ::mlir::Op<ConvertOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConvertOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConvertOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.convert_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConvertOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConvolutionOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConvolutionOpV1GenericAdaptorBase {
public:
  struct Properties {
    using batch_group_countTy = ::mlir::Attribute;
    batch_group_countTy batch_group_count;

    auto getBatchGroupCount() {
      auto &propStorage = this->batch_group_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBatchGroupCount(const ::mlir::Attribute &propValue) {
      this->batch_group_count = propValue;
    }
    using feature_group_countTy = ::mlir::Attribute;
    feature_group_countTy feature_group_count;

    auto getFeatureGroupCount() {
      auto &propStorage = this->feature_group_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFeatureGroupCount(const ::mlir::Attribute &propValue) {
      this->feature_group_count = propValue;
    }
    using input_batch_dimensionTy = ::mlir::Attribute;
    input_batch_dimensionTy input_batch_dimension;

    auto getInputBatchDimension() {
      auto &propStorage = this->input_batch_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputBatchDimension(const ::mlir::Attribute &propValue) {
      this->input_batch_dimension = propValue;
    }
    using input_feature_dimensionTy = ::mlir::Attribute;
    input_feature_dimensionTy input_feature_dimension;

    auto getInputFeatureDimension() {
      auto &propStorage = this->input_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->input_feature_dimension = propValue;
    }
    using input_spatial_dimensionsTy = ::mlir::Attribute;
    input_spatial_dimensionsTy input_spatial_dimensions;

    auto getInputSpatialDimensions() {
      auto &propStorage = this->input_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->input_spatial_dimensions = propValue;
    }
    using kernel_input_feature_dimensionTy = ::mlir::Attribute;
    kernel_input_feature_dimensionTy kernel_input_feature_dimension;

    auto getKernelInputFeatureDimension() {
      auto &propStorage = this->kernel_input_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelInputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->kernel_input_feature_dimension = propValue;
    }
    using kernel_output_feature_dimensionTy = ::mlir::Attribute;
    kernel_output_feature_dimensionTy kernel_output_feature_dimension;

    auto getKernelOutputFeatureDimension() {
      auto &propStorage = this->kernel_output_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelOutputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->kernel_output_feature_dimension = propValue;
    }
    using kernel_spatial_dimensionsTy = ::mlir::Attribute;
    kernel_spatial_dimensionsTy kernel_spatial_dimensions;

    auto getKernelSpatialDimensions() {
      auto &propStorage = this->kernel_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->kernel_spatial_dimensions = propValue;
    }
    using lhs_dilationTy = ::mlir::Attribute;
    lhs_dilationTy lhs_dilation;

    auto getLhsDilation() {
      auto &propStorage = this->lhs_dilation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsDilation(const ::mlir::Attribute &propValue) {
      this->lhs_dilation = propValue;
    }
    using output_batch_dimensionTy = ::mlir::Attribute;
    output_batch_dimensionTy output_batch_dimension;

    auto getOutputBatchDimension() {
      auto &propStorage = this->output_batch_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputBatchDimension(const ::mlir::Attribute &propValue) {
      this->output_batch_dimension = propValue;
    }
    using output_feature_dimensionTy = ::mlir::Attribute;
    output_feature_dimensionTy output_feature_dimension;

    auto getOutputFeatureDimension() {
      auto &propStorage = this->output_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->output_feature_dimension = propValue;
    }
    using output_spatial_dimensionsTy = ::mlir::Attribute;
    output_spatial_dimensionsTy output_spatial_dimensions;

    auto getOutputSpatialDimensions() {
      auto &propStorage = this->output_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->output_spatial_dimensions = propValue;
    }
    using paddingTy = ::mlir::Attribute;
    paddingTy padding;

    auto getPadding() {
      auto &propStorage = this->padding;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPadding(const ::mlir::Attribute &propValue) {
      this->padding = propValue;
    }
    using precision_configTy = ::mlir::Attribute;
    precision_configTy precision_config;

    auto getPrecisionConfig() {
      auto &propStorage = this->precision_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPrecisionConfig(const ::mlir::Attribute &propValue) {
      this->precision_config = propValue;
    }
    using rhs_dilationTy = ::mlir::Attribute;
    rhs_dilationTy rhs_dilation;

    auto getRhsDilation() {
      auto &propStorage = this->rhs_dilation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsDilation(const ::mlir::Attribute &propValue) {
      this->rhs_dilation = propValue;
    }
    using window_reversalTy = ::mlir::Attribute;
    window_reversalTy window_reversal;

    auto getWindowReversal() {
      auto &propStorage = this->window_reversal;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowReversal(const ::mlir::Attribute &propValue) {
      this->window_reversal = propValue;
    }
    using window_stridesTy = ::mlir::Attribute;
    window_stridesTy window_strides;

    auto getWindowStrides() {
      auto &propStorage = this->window_strides;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowStrides(const ::mlir::Attribute &propValue) {
      this->window_strides = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.batch_group_count == this->batch_group_count &&
        rhs.feature_group_count == this->feature_group_count &&
        rhs.input_batch_dimension == this->input_batch_dimension &&
        rhs.input_feature_dimension == this->input_feature_dimension &&
        rhs.input_spatial_dimensions == this->input_spatial_dimensions &&
        rhs.kernel_input_feature_dimension == this->kernel_input_feature_dimension &&
        rhs.kernel_output_feature_dimension == this->kernel_output_feature_dimension &&
        rhs.kernel_spatial_dimensions == this->kernel_spatial_dimensions &&
        rhs.lhs_dilation == this->lhs_dilation &&
        rhs.output_batch_dimension == this->output_batch_dimension &&
        rhs.output_feature_dimension == this->output_feature_dimension &&
        rhs.output_spatial_dimensions == this->output_spatial_dimensions &&
        rhs.padding == this->padding &&
        rhs.precision_config == this->precision_config &&
        rhs.rhs_dilation == this->rhs_dilation &&
        rhs.window_reversal == this->window_reversal &&
        rhs.window_strides == this->window_strides &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ConvolutionOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.convolution_v1", odsAttrs.getContext());
  }

  ConvolutionOpV1GenericAdaptorBase(ConvolutionOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getWindowStridesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
    return attr;
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().padding);
    return attr;
  }

  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_dilation);
    return attr;
  }

  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_dilation);
    return attr;
  }

  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_reversal);
    return attr;
  }

  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_batch_dimension);
    return attr;
  }

  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_input_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_output_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_batch_dimension);
    return attr;
  }

  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().feature_group_count);
    return attr;
  }

  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().batch_group_count);
    return attr;
  }

  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
    return attr;
  }

  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class ConvolutionOpV1GenericAdaptor : public detail::ConvolutionOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConvolutionOpV1GenericAdaptorBase;
public:
  ConvolutionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConvolutionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConvolutionOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ConvolutionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ConvolutionOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ConvolutionOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConvolutionOpV1>>>
  ConvolutionOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConvolutionOpV1Adaptor : public ConvolutionOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConvolutionOpV1GenericAdaptor::ConvolutionOpV1GenericAdaptor;
  ConvolutionOpV1Adaptor(ConvolutionOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ConvolutionOpV1 : public ::mlir::Op<ConvolutionOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConvolutionOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConvolutionOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_group_count"), ::llvm::StringRef("feature_group_count"), ::llvm::StringRef("input_batch_dimension"), ::llvm::StringRef("input_feature_dimension"), ::llvm::StringRef("input_spatial_dimensions"), ::llvm::StringRef("kernel_input_feature_dimension"), ::llvm::StringRef("kernel_output_feature_dimension"), ::llvm::StringRef("kernel_spatial_dimensions"), ::llvm::StringRef("lhs_dilation"), ::llvm::StringRef("output_batch_dimension"), ::llvm::StringRef("output_feature_dimension"), ::llvm::StringRef("output_spatial_dimensions"), ::llvm::StringRef("padding"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_dilation"), ::llvm::StringRef("window_reversal"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchGroupCountAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureGroupCountAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInputBatchDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getInputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getInputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getKernelInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getKernelInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getKernelSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getKernelSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getLhsDilationAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getLhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getOutputBatchDimensionAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getOutputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getOutputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getOutputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getRhsDilationAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getRhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getWindowReversalAttrName() {
    return getAttributeNameForIndex(15);
  }

  static ::mlir::StringAttr getWindowReversalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 15);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(16);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 16);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.convolution_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getWindowStridesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().padding);
  }

  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_dilation);
  }

  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_dilation);
  }

  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_reversal);
  }

  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_batch_dimension);
  }

  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_feature_dimension);
  }

  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_spatial_dimensions);
  }

  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_input_feature_dimension);
  }

  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_output_feature_dimension);
  }

  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_spatial_dimensions);
  }

  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_batch_dimension);
  }

  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_feature_dimension);
  }

  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_spatial_dimensions);
  }

  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().feature_group_count);
  }

  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().batch_group_count);
  }

  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
  }

  ::mlir::Attribute getPrecisionConfig();
  void setWindowStridesAttr(::mlir::Attribute attr) {
    getProperties().window_strides = attr;
  }

  void setPaddingAttr(::mlir::Attribute attr) {
    getProperties().padding = attr;
  }

  void setLhsDilationAttr(::mlir::Attribute attr) {
    getProperties().lhs_dilation = attr;
  }

  void setRhsDilationAttr(::mlir::Attribute attr) {
    getProperties().rhs_dilation = attr;
  }

  void setWindowReversalAttr(::mlir::Attribute attr) {
    getProperties().window_reversal = attr;
  }

  void setInputBatchDimensionAttr(::mlir::Attribute attr) {
    getProperties().input_batch_dimension = attr;
  }

  void setInputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().input_feature_dimension = attr;
  }

  void setInputSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().input_spatial_dimensions = attr;
  }

  void setKernelInputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().kernel_input_feature_dimension = attr;
  }

  void setKernelOutputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().kernel_output_feature_dimension = attr;
  }

  void setKernelSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().kernel_spatial_dimensions = attr;
  }

  void setOutputBatchDimensionAttr(::mlir::Attribute attr) {
    getProperties().output_batch_dimension = attr;
  }

  void setOutputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().output_feature_dimension = attr;
  }

  void setOutputSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().output_spatial_dimensions = attr;
  }

  void setFeatureGroupCountAttr(::mlir::Attribute attr) {
    getProperties().feature_group_count = attr;
  }

  void setBatchGroupCountAttr(::mlir::Attribute attr) {
    getProperties().batch_group_count = attr;
  }

  void setPrecisionConfigAttr(::mlir::Attribute attr) {
    getProperties().precision_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 17 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConvolutionOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CosineOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CosineOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CosineOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.cosine_v1", odsAttrs.getContext());
  }

  CosineOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class CosineOpV1GenericAdaptor : public detail::CosineOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CosineOpV1GenericAdaptorBase;
public:
  CosineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CosineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CosineOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CosineOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CosineOpV1>>>
  CosineOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CosineOpV1Adaptor : public CosineOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CosineOpV1GenericAdaptor::CosineOpV1GenericAdaptor;
  CosineOpV1Adaptor(CosineOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CosineOpV1 : public ::mlir::Op<CosineOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CosineOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CosineOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cosine_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CosineOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CreateTokenOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CreateTokenOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CreateTokenOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.create_token_v1", odsAttrs.getContext());
  }

  CreateTokenOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class CreateTokenOpV1GenericAdaptor : public detail::CreateTokenOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CreateTokenOpV1GenericAdaptorBase;
public:
  CreateTokenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CreateTokenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CreateTokenOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CreateTokenOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CreateTokenOpV1>>>
  CreateTokenOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CreateTokenOpV1Adaptor : public CreateTokenOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CreateTokenOpV1GenericAdaptor::CreateTokenOpV1GenericAdaptor;
  CreateTokenOpV1Adaptor(CreateTokenOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CreateTokenOpV1 : public ::mlir::Op<CreateTokenOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CreateTokenOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CreateTokenOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.create_token_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOutput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CreateTokenOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CrossReplicaSumOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CrossReplicaSumOpV1GenericAdaptorBase {
public:
  struct Properties {
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.replica_groups == this->replica_groups &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CrossReplicaSumOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.cross-replica-sum_v1", odsAttrs.getContext());
  }

  CrossReplicaSumOpV1GenericAdaptorBase(CrossReplicaSumOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
};
} // namespace detail
template <typename RangeT>
class CrossReplicaSumOpV1GenericAdaptor : public detail::CrossReplicaSumOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CrossReplicaSumOpV1GenericAdaptorBase;
public:
  CrossReplicaSumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CrossReplicaSumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CrossReplicaSumOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CrossReplicaSumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CrossReplicaSumOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CrossReplicaSumOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CrossReplicaSumOpV1>>>
  CrossReplicaSumOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CrossReplicaSumOpV1Adaptor : public CrossReplicaSumOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CrossReplicaSumOpV1GenericAdaptor::CrossReplicaSumOpV1GenericAdaptor;
  CrossReplicaSumOpV1Adaptor(CrossReplicaSumOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CrossReplicaSumOpV1 : public ::mlir::Op<CrossReplicaSumOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CrossReplicaSumOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CrossReplicaSumOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("replica_groups")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cross-replica-sum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CrossReplicaSumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CustomCallOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CustomCallOpV1GenericAdaptorBase {
public:
  struct Properties {
    using api_versionTy = ::mlir::Attribute;
    api_versionTy api_version;

    auto getApiVersion() {
      auto &propStorage = this->api_version;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setApiVersion(const ::mlir::Attribute &propValue) {
      this->api_version = propValue;
    }
    using backend_configTy = ::mlir::Attribute;
    backend_configTy backend_config;

    auto getBackendConfig() {
      auto &propStorage = this->backend_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBackendConfig(const ::mlir::Attribute &propValue) {
      this->backend_config = propValue;
    }
    using call_target_nameTy = ::mlir::Attribute;
    call_target_nameTy call_target_name;

    auto getCallTargetName() {
      auto &propStorage = this->call_target_name;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCallTargetName(const ::mlir::Attribute &propValue) {
      this->call_target_name = propValue;
    }
    using called_computationsTy = ::mlir::Attribute;
    called_computationsTy called_computations;

    auto getCalledComputations() {
      auto &propStorage = this->called_computations;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCalledComputations(const ::mlir::Attribute &propValue) {
      this->called_computations = propValue;
    }
    using has_side_effectTy = ::mlir::Attribute;
    has_side_effectTy has_side_effect;

    auto getHasSideEffect() {
      auto &propStorage = this->has_side_effect;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setHasSideEffect(const ::mlir::Attribute &propValue) {
      this->has_side_effect = propValue;
    }
    using operand_layoutsTy = ::mlir::Attribute;
    operand_layoutsTy operand_layouts;

    auto getOperandLayouts() {
      auto &propStorage = this->operand_layouts;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOperandLayouts(const ::mlir::Attribute &propValue) {
      this->operand_layouts = propValue;
    }
    using output_operand_aliasesTy = ::mlir::Attribute;
    output_operand_aliasesTy output_operand_aliases;

    auto getOutputOperandAliases() {
      auto &propStorage = this->output_operand_aliases;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputOperandAliases(const ::mlir::Attribute &propValue) {
      this->output_operand_aliases = propValue;
    }
    using result_layoutsTy = ::mlir::Attribute;
    result_layoutsTy result_layouts;

    auto getResultLayouts() {
      auto &propStorage = this->result_layouts;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setResultLayouts(const ::mlir::Attribute &propValue) {
      this->result_layouts = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.api_version == this->api_version &&
        rhs.backend_config == this->backend_config &&
        rhs.call_target_name == this->call_target_name &&
        rhs.called_computations == this->called_computations &&
        rhs.has_side_effect == this->has_side_effect &&
        rhs.operand_layouts == this->operand_layouts &&
        rhs.output_operand_aliases == this->output_operand_aliases &&
        rhs.result_layouts == this->result_layouts &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CustomCallOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.custom_call_v1", odsAttrs.getContext());
  }

  CustomCallOpV1GenericAdaptorBase(CustomCallOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getCallTargetNameAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().call_target_name);
    return attr;
  }

  ::mlir::Attribute getCallTargetName();
  ::mlir::Attribute getHasSideEffectAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().has_side_effect);
    return attr;
  }

  ::mlir::Attribute getHasSideEffect();
  ::mlir::Attribute getBackendConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().backend_config);
    return attr;
  }

  ::mlir::Attribute getBackendConfig();
  ::mlir::Attribute getApiVersionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().api_version);
    return attr;
  }

  ::mlir::Attribute getApiVersion();
  ::mlir::Attribute getCalledComputationsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().called_computations);
    return attr;
  }

  ::mlir::Attribute getCalledComputations();
  ::mlir::Attribute getOperandLayoutsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().operand_layouts);
    return attr;
  }

  ::mlir::Attribute getOperandLayouts();
  ::mlir::Attribute getResultLayoutsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().result_layouts);
    return attr;
  }

  ::mlir::Attribute getResultLayouts();
  ::mlir::Attribute getOutputOperandAliasesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_operand_aliases);
    return attr;
  }

  ::mlir::Attribute getOutputOperandAliases();
};
} // namespace detail
template <typename RangeT>
class CustomCallOpV1GenericAdaptor : public detail::CustomCallOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CustomCallOpV1GenericAdaptorBase;
public:
  CustomCallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CustomCallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CustomCallOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  CustomCallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : CustomCallOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = CustomCallOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CustomCallOpV1>>>
  CustomCallOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CustomCallOpV1Adaptor : public CustomCallOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CustomCallOpV1GenericAdaptor::CustomCallOpV1GenericAdaptor;
  CustomCallOpV1Adaptor(CustomCallOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class CustomCallOpV1 : public ::mlir::Op<CustomCallOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::vhlo::VersionedOpConstraintInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CustomCallOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CustomCallOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("api_version"), ::llvm::StringRef("backend_config"), ::llvm::StringRef("call_target_name"), ::llvm::StringRef("called_computations"), ::llvm::StringRef("has_side_effect"), ::llvm::StringRef("operand_layouts"), ::llvm::StringRef("output_operand_aliases"), ::llvm::StringRef("result_layouts")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getApiVersionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getApiVersionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getBackendConfigAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getBackendConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getCallTargetNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getCallTargetNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getCalledComputationsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getCalledComputationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getHasSideEffectAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getHasSideEffectAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getOperandLayoutsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getOperandLayoutsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getOutputOperandAliasesAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getOutputOperandAliasesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getResultLayoutsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getResultLayoutsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.custom_call_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getCallTargetNameAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().call_target_name);
  }

  ::mlir::Attribute getCallTargetName();
  ::mlir::Attribute getHasSideEffectAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().has_side_effect);
  }

  ::mlir::Attribute getHasSideEffect();
  ::mlir::Attribute getBackendConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().backend_config);
  }

  ::mlir::Attribute getBackendConfig();
  ::mlir::Attribute getApiVersionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().api_version);
  }

  ::mlir::Attribute getApiVersion();
  ::mlir::Attribute getCalledComputationsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().called_computations);
  }

  ::mlir::Attribute getCalledComputations();
  ::mlir::Attribute getOperandLayoutsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().operand_layouts);
  }

  ::mlir::Attribute getOperandLayouts();
  ::mlir::Attribute getResultLayoutsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().result_layouts);
  }

  ::mlir::Attribute getResultLayouts();
  ::mlir::Attribute getOutputOperandAliasesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_operand_aliases);
  }

  ::mlir::Attribute getOutputOperandAliases();
  void setCallTargetNameAttr(::mlir::Attribute attr) {
    getProperties().call_target_name = attr;
  }

  void setHasSideEffectAttr(::mlir::Attribute attr) {
    getProperties().has_side_effect = attr;
  }

  void setBackendConfigAttr(::mlir::Attribute attr) {
    getProperties().backend_config = attr;
  }

  void setApiVersionAttr(::mlir::Attribute attr) {
    getProperties().api_version = attr;
  }

  void setCalledComputationsAttr(::mlir::Attribute attr) {
    getProperties().called_computations = attr;
  }

  void setOperandLayoutsAttr(::mlir::Attribute attr) {
    getProperties().operand_layouts = attr;
  }

  void setResultLayoutsAttr(::mlir::Attribute attr) {
    getProperties().result_layouts = attr;
  }

  void setOutputOperandAliasesAttr(::mlir::Attribute attr) {
    getProperties().output_operand_aliases = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute call_target_name, ::mlir::Attribute has_side_effect, ::mlir::Attribute backend_config, ::mlir::Attribute api_version, ::mlir::Attribute called_computations, ::mlir::Attribute operand_layouts, ::mlir::Attribute result_layouts, ::mlir::Attribute output_operand_aliases);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  mlir::LogicalResult validateConstraint(mlir::Operation*op, mlir::vhlo::Version targetVersion);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 8 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CustomCallOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DivOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DivOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DivOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.divide_v1", odsAttrs.getContext());
  }

  DivOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class DivOpV1GenericAdaptor : public detail::DivOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DivOpV1GenericAdaptorBase;
public:
  DivOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DivOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DivOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DivOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DivOpV1>>>
  DivOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DivOpV1Adaptor : public DivOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DivOpV1GenericAdaptor::DivOpV1GenericAdaptor;
  DivOpV1Adaptor(DivOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DivOpV1 : public ::mlir::Op<DivOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DivOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DivOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.divide_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DivOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotGeneralOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DotGeneralOpV1GenericAdaptorBase {
public:
  struct Properties {
    using lhs_batching_dimensionsTy = ::mlir::Attribute;
    lhs_batching_dimensionsTy lhs_batching_dimensions;

    auto getLhsBatchingDimensions() {
      auto &propStorage = this->lhs_batching_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsBatchingDimensions(const ::mlir::Attribute &propValue) {
      this->lhs_batching_dimensions = propValue;
    }
    using lhs_contracting_dimensionsTy = ::mlir::Attribute;
    lhs_contracting_dimensionsTy lhs_contracting_dimensions;

    auto getLhsContractingDimensions() {
      auto &propStorage = this->lhs_contracting_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsContractingDimensions(const ::mlir::Attribute &propValue) {
      this->lhs_contracting_dimensions = propValue;
    }
    using precision_configTy = ::mlir::Attribute;
    precision_configTy precision_config;

    auto getPrecisionConfig() {
      auto &propStorage = this->precision_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPrecisionConfig(const ::mlir::Attribute &propValue) {
      this->precision_config = propValue;
    }
    using rhs_batching_dimensionsTy = ::mlir::Attribute;
    rhs_batching_dimensionsTy rhs_batching_dimensions;

    auto getRhsBatchingDimensions() {
      auto &propStorage = this->rhs_batching_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsBatchingDimensions(const ::mlir::Attribute &propValue) {
      this->rhs_batching_dimensions = propValue;
    }
    using rhs_contracting_dimensionsTy = ::mlir::Attribute;
    rhs_contracting_dimensionsTy rhs_contracting_dimensions;

    auto getRhsContractingDimensions() {
      auto &propStorage = this->rhs_contracting_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsContractingDimensions(const ::mlir::Attribute &propValue) {
      this->rhs_contracting_dimensions = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.lhs_batching_dimensions == this->lhs_batching_dimensions &&
        rhs.lhs_contracting_dimensions == this->lhs_contracting_dimensions &&
        rhs.precision_config == this->precision_config &&
        rhs.rhs_batching_dimensions == this->rhs_batching_dimensions &&
        rhs.rhs_contracting_dimensions == this->rhs_contracting_dimensions &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DotGeneralOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dot_general_v1", odsAttrs.getContext());
  }

  DotGeneralOpV1GenericAdaptorBase(DotGeneralOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getLhsBatchingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_batching_dimensions);
    return attr;
  }

  ::mlir::Attribute getLhsBatchingDimensions();
  ::mlir::Attribute getRhsBatchingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_batching_dimensions);
    return attr;
  }

  ::mlir::Attribute getRhsBatchingDimensions();
  ::mlir::Attribute getLhsContractingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_contracting_dimensions);
    return attr;
  }

  ::mlir::Attribute getLhsContractingDimensions();
  ::mlir::Attribute getRhsContractingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_contracting_dimensions);
    return attr;
  }

  ::mlir::Attribute getRhsContractingDimensions();
  ::mlir::Attribute getPrecisionConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
    return attr;
  }

  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class DotGeneralOpV1GenericAdaptor : public detail::DotGeneralOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DotGeneralOpV1GenericAdaptorBase;
public:
  DotGeneralOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DotGeneralOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DotGeneralOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DotGeneralOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DotGeneralOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DotGeneralOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DotGeneralOpV1>>>
  DotGeneralOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DotGeneralOpV1Adaptor : public DotGeneralOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DotGeneralOpV1GenericAdaptor::DotGeneralOpV1GenericAdaptor;
  DotGeneralOpV1Adaptor(DotGeneralOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DotGeneralOpV1 : public ::mlir::Op<DotGeneralOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DotGeneralOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DotGeneralOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("lhs_batching_dimensions"), ::llvm::StringRef("lhs_contracting_dimensions"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_batching_dimensions"), ::llvm::StringRef("rhs_contracting_dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLhsBatchingDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLhsBatchingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getLhsContractingDimensionsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getLhsContractingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getRhsBatchingDimensionsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getRhsBatchingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getRhsContractingDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getRhsContractingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dot_general_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getLhsBatchingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_batching_dimensions);
  }

  ::mlir::Attribute getLhsBatchingDimensions();
  ::mlir::Attribute getRhsBatchingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_batching_dimensions);
  }

  ::mlir::Attribute getRhsBatchingDimensions();
  ::mlir::Attribute getLhsContractingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_contracting_dimensions);
  }

  ::mlir::Attribute getLhsContractingDimensions();
  ::mlir::Attribute getRhsContractingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_contracting_dimensions);
  }

  ::mlir::Attribute getRhsContractingDimensions();
  ::mlir::Attribute getPrecisionConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
  }

  ::mlir::Attribute getPrecisionConfig();
  void setLhsBatchingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().lhs_batching_dimensions = attr;
  }

  void setRhsBatchingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().rhs_batching_dimensions = attr;
  }

  void setLhsContractingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().lhs_contracting_dimensions = attr;
  }

  void setRhsContractingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().rhs_contracting_dimensions = attr;
  }

  void setPrecisionConfigAttr(::mlir::Attribute attr) {
    getProperties().precision_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotGeneralOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotGeneralOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DotGeneralOpV2GenericAdaptorBase {
public:
  struct Properties {
    using accumulation_typeTy = ::mlir::Attribute;
    accumulation_typeTy accumulation_type;

    auto getAccumulationType() {
      auto &propStorage = this->accumulation_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setAccumulationType(const ::mlir::Attribute &propValue) {
      this->accumulation_type = propValue;
    }
    using allow_imprecise_accumulationTy = ::mlir::Attribute;
    allow_imprecise_accumulationTy allow_imprecise_accumulation;

    auto getAllowImpreciseAccumulation() {
      auto &propStorage = this->allow_imprecise_accumulation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setAllowImpreciseAccumulation(const ::mlir::Attribute &propValue) {
      this->allow_imprecise_accumulation = propValue;
    }
    using lhs_batching_dimensionsTy = ::mlir::Attribute;
    lhs_batching_dimensionsTy lhs_batching_dimensions;

    auto getLhsBatchingDimensions() {
      auto &propStorage = this->lhs_batching_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsBatchingDimensions(const ::mlir::Attribute &propValue) {
      this->lhs_batching_dimensions = propValue;
    }
    using lhs_component_countTy = ::mlir::Attribute;
    lhs_component_countTy lhs_component_count;

    auto getLhsComponentCount() {
      auto &propStorage = this->lhs_component_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsComponentCount(const ::mlir::Attribute &propValue) {
      this->lhs_component_count = propValue;
    }
    using lhs_contracting_dimensionsTy = ::mlir::Attribute;
    lhs_contracting_dimensionsTy lhs_contracting_dimensions;

    auto getLhsContractingDimensions() {
      auto &propStorage = this->lhs_contracting_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsContractingDimensions(const ::mlir::Attribute &propValue) {
      this->lhs_contracting_dimensions = propValue;
    }
    using lhs_precision_typeTy = ::mlir::Attribute;
    lhs_precision_typeTy lhs_precision_type;

    auto getLhsPrecisionType() {
      auto &propStorage = this->lhs_precision_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsPrecisionType(const ::mlir::Attribute &propValue) {
      this->lhs_precision_type = propValue;
    }
    using num_primitive_operationsTy = ::mlir::Attribute;
    num_primitive_operationsTy num_primitive_operations;

    auto getNumPrimitiveOperations() {
      auto &propStorage = this->num_primitive_operations;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setNumPrimitiveOperations(const ::mlir::Attribute &propValue) {
      this->num_primitive_operations = propValue;
    }
    using precision_configTy = ::mlir::Attribute;
    precision_configTy precision_config;

    auto getPrecisionConfig() {
      auto &propStorage = this->precision_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPrecisionConfig(const ::mlir::Attribute &propValue) {
      this->precision_config = propValue;
    }
    using rhs_batching_dimensionsTy = ::mlir::Attribute;
    rhs_batching_dimensionsTy rhs_batching_dimensions;

    auto getRhsBatchingDimensions() {
      auto &propStorage = this->rhs_batching_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsBatchingDimensions(const ::mlir::Attribute &propValue) {
      this->rhs_batching_dimensions = propValue;
    }
    using rhs_component_countTy = ::mlir::Attribute;
    rhs_component_countTy rhs_component_count;

    auto getRhsComponentCount() {
      auto &propStorage = this->rhs_component_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsComponentCount(const ::mlir::Attribute &propValue) {
      this->rhs_component_count = propValue;
    }
    using rhs_contracting_dimensionsTy = ::mlir::Attribute;
    rhs_contracting_dimensionsTy rhs_contracting_dimensions;

    auto getRhsContractingDimensions() {
      auto &propStorage = this->rhs_contracting_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsContractingDimensions(const ::mlir::Attribute &propValue) {
      this->rhs_contracting_dimensions = propValue;
    }
    using rhs_precision_typeTy = ::mlir::Attribute;
    rhs_precision_typeTy rhs_precision_type;

    auto getRhsPrecisionType() {
      auto &propStorage = this->rhs_precision_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsPrecisionType(const ::mlir::Attribute &propValue) {
      this->rhs_precision_type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.accumulation_type == this->accumulation_type &&
        rhs.allow_imprecise_accumulation == this->allow_imprecise_accumulation &&
        rhs.lhs_batching_dimensions == this->lhs_batching_dimensions &&
        rhs.lhs_component_count == this->lhs_component_count &&
        rhs.lhs_contracting_dimensions == this->lhs_contracting_dimensions &&
        rhs.lhs_precision_type == this->lhs_precision_type &&
        rhs.num_primitive_operations == this->num_primitive_operations &&
        rhs.precision_config == this->precision_config &&
        rhs.rhs_batching_dimensions == this->rhs_batching_dimensions &&
        rhs.rhs_component_count == this->rhs_component_count &&
        rhs.rhs_contracting_dimensions == this->rhs_contracting_dimensions &&
        rhs.rhs_precision_type == this->rhs_precision_type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DotGeneralOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dot_general_v2", odsAttrs.getContext());
  }

  DotGeneralOpV2GenericAdaptorBase(DotGeneralOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getLhsBatchingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_batching_dimensions);
    return attr;
  }

  ::mlir::Attribute getLhsBatchingDimensions();
  ::mlir::Attribute getRhsBatchingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_batching_dimensions);
    return attr;
  }

  ::mlir::Attribute getRhsBatchingDimensions();
  ::mlir::Attribute getLhsContractingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_contracting_dimensions);
    return attr;
  }

  ::mlir::Attribute getLhsContractingDimensions();
  ::mlir::Attribute getRhsContractingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_contracting_dimensions);
    return attr;
  }

  ::mlir::Attribute getRhsContractingDimensions();
  ::mlir::Attribute getPrecisionConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
    return attr;
  }

  ::mlir::Attribute getPrecisionConfig();
  ::mlir::Attribute getLhsPrecisionTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_precision_type);
    return attr;
  }

  ::mlir::Attribute getLhsPrecisionType();
  ::mlir::Attribute getRhsPrecisionTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_precision_type);
    return attr;
  }

  ::mlir::Attribute getRhsPrecisionType();
  ::mlir::Attribute getAccumulationTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().accumulation_type);
    return attr;
  }

  ::mlir::Attribute getAccumulationType();
  ::mlir::Attribute getLhsComponentCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_component_count);
    return attr;
  }

  ::mlir::Attribute getLhsComponentCount();
  ::mlir::Attribute getRhsComponentCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_component_count);
    return attr;
  }

  ::mlir::Attribute getRhsComponentCount();
  ::mlir::Attribute getNumPrimitiveOperationsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().num_primitive_operations);
    return attr;
  }

  ::mlir::Attribute getNumPrimitiveOperations();
  ::mlir::Attribute getAllowImpreciseAccumulationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().allow_imprecise_accumulation);
    return attr;
  }

  ::mlir::Attribute getAllowImpreciseAccumulation();
};
} // namespace detail
template <typename RangeT>
class DotGeneralOpV2GenericAdaptor : public detail::DotGeneralOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DotGeneralOpV2GenericAdaptorBase;
public:
  DotGeneralOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DotGeneralOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DotGeneralOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DotGeneralOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DotGeneralOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DotGeneralOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, DotGeneralOpV2>>>
  DotGeneralOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DotGeneralOpV2Adaptor : public DotGeneralOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using DotGeneralOpV2GenericAdaptor::DotGeneralOpV2GenericAdaptor;
  DotGeneralOpV2Adaptor(DotGeneralOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DotGeneralOpV2 : public ::mlir::Op<DotGeneralOpV2, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DotGeneralOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DotGeneralOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("accumulation_type"), ::llvm::StringRef("allow_imprecise_accumulation"), ::llvm::StringRef("lhs_batching_dimensions"), ::llvm::StringRef("lhs_component_count"), ::llvm::StringRef("lhs_contracting_dimensions"), ::llvm::StringRef("lhs_precision_type"), ::llvm::StringRef("num_primitive_operations"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_batching_dimensions"), ::llvm::StringRef("rhs_component_count"), ::llvm::StringRef("rhs_contracting_dimensions"), ::llvm::StringRef("rhs_precision_type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAccumulationTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAccumulationTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getAllowImpreciseAccumulationAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getAllowImpreciseAccumulationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getLhsBatchingDimensionsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getLhsBatchingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getLhsComponentCountAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getLhsComponentCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getLhsContractingDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getLhsContractingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getLhsPrecisionTypeAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getLhsPrecisionTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getNumPrimitiveOperationsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getNumPrimitiveOperationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getRhsBatchingDimensionsAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getRhsBatchingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getRhsComponentCountAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getRhsComponentCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getRhsContractingDimensionsAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getRhsContractingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getRhsPrecisionTypeAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getRhsPrecisionTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dot_general_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getLhsBatchingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_batching_dimensions);
  }

  ::mlir::Attribute getLhsBatchingDimensions();
  ::mlir::Attribute getRhsBatchingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_batching_dimensions);
  }

  ::mlir::Attribute getRhsBatchingDimensions();
  ::mlir::Attribute getLhsContractingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_contracting_dimensions);
  }

  ::mlir::Attribute getLhsContractingDimensions();
  ::mlir::Attribute getRhsContractingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_contracting_dimensions);
  }

  ::mlir::Attribute getRhsContractingDimensions();
  ::mlir::Attribute getPrecisionConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
  }

  ::mlir::Attribute getPrecisionConfig();
  ::mlir::Attribute getLhsPrecisionTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_precision_type);
  }

  ::mlir::Attribute getLhsPrecisionType();
  ::mlir::Attribute getRhsPrecisionTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_precision_type);
  }

  ::mlir::Attribute getRhsPrecisionType();
  ::mlir::Attribute getAccumulationTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().accumulation_type);
  }

  ::mlir::Attribute getAccumulationType();
  ::mlir::Attribute getLhsComponentCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_component_count);
  }

  ::mlir::Attribute getLhsComponentCount();
  ::mlir::Attribute getRhsComponentCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_component_count);
  }

  ::mlir::Attribute getRhsComponentCount();
  ::mlir::Attribute getNumPrimitiveOperationsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().num_primitive_operations);
  }

  ::mlir::Attribute getNumPrimitiveOperations();
  ::mlir::Attribute getAllowImpreciseAccumulationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().allow_imprecise_accumulation);
  }

  ::mlir::Attribute getAllowImpreciseAccumulation();
  void setLhsBatchingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().lhs_batching_dimensions = attr;
  }

  void setRhsBatchingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().rhs_batching_dimensions = attr;
  }

  void setLhsContractingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().lhs_contracting_dimensions = attr;
  }

  void setRhsContractingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().rhs_contracting_dimensions = attr;
  }

  void setPrecisionConfigAttr(::mlir::Attribute attr) {
    getProperties().precision_config = attr;
  }

  void setLhsPrecisionTypeAttr(::mlir::Attribute attr) {
    getProperties().lhs_precision_type = attr;
  }

  void setRhsPrecisionTypeAttr(::mlir::Attribute attr) {
    getProperties().rhs_precision_type = attr;
  }

  void setAccumulationTypeAttr(::mlir::Attribute attr) {
    getProperties().accumulation_type = attr;
  }

  void setLhsComponentCountAttr(::mlir::Attribute attr) {
    getProperties().lhs_component_count = attr;
  }

  void setRhsComponentCountAttr(::mlir::Attribute attr) {
    getProperties().rhs_component_count = attr;
  }

  void setNumPrimitiveOperationsAttr(::mlir::Attribute attr) {
    getProperties().num_primitive_operations = attr;
  }

  void setAllowImpreciseAccumulationAttr(::mlir::Attribute attr) {
    getProperties().allow_imprecise_accumulation = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config, ::mlir::Attribute lhs_precision_type, ::mlir::Attribute rhs_precision_type, ::mlir::Attribute accumulation_type, ::mlir::Attribute lhs_component_count, ::mlir::Attribute rhs_component_count, ::mlir::Attribute num_primitive_operations, ::mlir::Attribute allow_imprecise_accumulation);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config, ::mlir::Attribute lhs_precision_type, ::mlir::Attribute rhs_precision_type, ::mlir::Attribute accumulation_type, ::mlir::Attribute lhs_component_count, ::mlir::Attribute rhs_component_count, ::mlir::Attribute num_primitive_operations, ::mlir::Attribute allow_imprecise_accumulation);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 12 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotGeneralOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DotOpV1GenericAdaptorBase {
public:
  struct Properties {
    using precision_configTy = ::mlir::Attribute;
    precision_configTy precision_config;

    auto getPrecisionConfig() {
      auto &propStorage = this->precision_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPrecisionConfig(const ::mlir::Attribute &propValue) {
      this->precision_config = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.precision_config == this->precision_config &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DotOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dot_v1", odsAttrs.getContext());
  }

  DotOpV1GenericAdaptorBase(DotOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getPrecisionConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
    return attr;
  }

  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class DotOpV1GenericAdaptor : public detail::DotOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DotOpV1GenericAdaptorBase;
public:
  DotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DotOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DotOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DotOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DotOpV1>>>
  DotOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DotOpV1Adaptor : public DotOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DotOpV1GenericAdaptor::DotOpV1GenericAdaptor;
  DotOpV1Adaptor(DotOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DotOpV1 : public ::mlir::Op<DotOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DotOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DotOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("precision_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dot_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getPrecisionConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
  }

  ::mlir::Attribute getPrecisionConfig();
  void setPrecisionConfigAttr(::mlir::Attribute attr) {
    getProperties().precision_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicBroadcastInDimOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicBroadcastInDimOpV1GenericAdaptorBase {
public:
  struct Properties {
    using broadcast_dimensionsTy = ::mlir::Attribute;
    broadcast_dimensionsTy broadcast_dimensions;

    auto getBroadcastDimensions() {
      auto &propStorage = this->broadcast_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBroadcastDimensions(const ::mlir::Attribute &propValue) {
      this->broadcast_dimensions = propValue;
    }
    using known_expanding_dimensionsTy = ::mlir::Attribute;
    known_expanding_dimensionsTy known_expanding_dimensions;

    auto getKnownExpandingDimensions() {
      auto &propStorage = this->known_expanding_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKnownExpandingDimensions(const ::mlir::Attribute &propValue) {
      this->known_expanding_dimensions = propValue;
    }
    using known_nonexpanding_dimensionsTy = ::mlir::Attribute;
    known_nonexpanding_dimensionsTy known_nonexpanding_dimensions;

    auto getKnownNonexpandingDimensions() {
      auto &propStorage = this->known_nonexpanding_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKnownNonexpandingDimensions(const ::mlir::Attribute &propValue) {
      this->known_nonexpanding_dimensions = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.broadcast_dimensions == this->broadcast_dimensions &&
        rhs.known_expanding_dimensions == this->known_expanding_dimensions &&
        rhs.known_nonexpanding_dimensions == this->known_nonexpanding_dimensions &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DynamicBroadcastInDimOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_broadcast_in_dim_v1", odsAttrs.getContext());
  }

  DynamicBroadcastInDimOpV1GenericAdaptorBase(DynamicBroadcastInDimOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getBroadcastDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().broadcast_dimensions);
    return attr;
  }

  ::mlir::Attribute getBroadcastDimensions();
  ::mlir::Attribute getKnownExpandingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().known_expanding_dimensions);
    return attr;
  }

  ::mlir::Attribute getKnownExpandingDimensions();
  ::mlir::Attribute getKnownNonexpandingDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().known_nonexpanding_dimensions);
    return attr;
  }

  ::mlir::Attribute getKnownNonexpandingDimensions();
};
} // namespace detail
template <typename RangeT>
class DynamicBroadcastInDimOpV1GenericAdaptor : public detail::DynamicBroadcastInDimOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicBroadcastInDimOpV1GenericAdaptorBase;
public:
  DynamicBroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicBroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicBroadcastInDimOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DynamicBroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DynamicBroadcastInDimOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DynamicBroadcastInDimOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicBroadcastInDimOpV1>>>
  DynamicBroadcastInDimOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOutputDimensions() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicBroadcastInDimOpV1Adaptor : public DynamicBroadcastInDimOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicBroadcastInDimOpV1GenericAdaptor::DynamicBroadcastInDimOpV1GenericAdaptor;
  DynamicBroadcastInDimOpV1Adaptor(DynamicBroadcastInDimOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicBroadcastInDimOpV1 : public ::mlir::Op<DynamicBroadcastInDimOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicBroadcastInDimOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicBroadcastInDimOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("broadcast_dimensions"), ::llvm::StringRef("known_expanding_dimensions"), ::llvm::StringRef("known_nonexpanding_dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBroadcastDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBroadcastDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getKnownExpandingDimensionsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getKnownExpandingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getKnownNonexpandingDimensionsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getKnownNonexpandingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_broadcast_in_dim_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOutputDimensions() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getOutputDimensionsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getBroadcastDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().broadcast_dimensions);
  }

  ::mlir::Attribute getBroadcastDimensions();
  ::mlir::Attribute getKnownExpandingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().known_expanding_dimensions);
  }

  ::mlir::Attribute getKnownExpandingDimensions();
  ::mlir::Attribute getKnownNonexpandingDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().known_nonexpanding_dimensions);
  }

  ::mlir::Attribute getKnownNonexpandingDimensions();
  void setBroadcastDimensionsAttr(::mlir::Attribute attr) {
    getProperties().broadcast_dimensions = attr;
  }

  void setKnownExpandingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().known_expanding_dimensions = attr;
  }

  void setKnownNonexpandingDimensionsAttr(::mlir::Attribute attr) {
    getProperties().known_nonexpanding_dimensions = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value output_dimensions, ::mlir::Attribute broadcast_dimensions, ::mlir::Attribute known_expanding_dimensions, ::mlir::Attribute known_nonexpanding_dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value output_dimensions, ::mlir::Attribute broadcast_dimensions, ::mlir::Attribute known_expanding_dimensions, ::mlir::Attribute known_nonexpanding_dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicBroadcastInDimOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicConvOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicConvOpV1GenericAdaptorBase {
public:
  struct Properties {
    using batch_group_countTy = ::mlir::Attribute;
    batch_group_countTy batch_group_count;

    auto getBatchGroupCount() {
      auto &propStorage = this->batch_group_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBatchGroupCount(const ::mlir::Attribute &propValue) {
      this->batch_group_count = propValue;
    }
    using feature_group_countTy = ::mlir::Attribute;
    feature_group_countTy feature_group_count;

    auto getFeatureGroupCount() {
      auto &propStorage = this->feature_group_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFeatureGroupCount(const ::mlir::Attribute &propValue) {
      this->feature_group_count = propValue;
    }
    using input_batch_dimensionTy = ::mlir::Attribute;
    input_batch_dimensionTy input_batch_dimension;

    auto getInputBatchDimension() {
      auto &propStorage = this->input_batch_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputBatchDimension(const ::mlir::Attribute &propValue) {
      this->input_batch_dimension = propValue;
    }
    using input_feature_dimensionTy = ::mlir::Attribute;
    input_feature_dimensionTy input_feature_dimension;

    auto getInputFeatureDimension() {
      auto &propStorage = this->input_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->input_feature_dimension = propValue;
    }
    using input_spatial_dimensionsTy = ::mlir::Attribute;
    input_spatial_dimensionsTy input_spatial_dimensions;

    auto getInputSpatialDimensions() {
      auto &propStorage = this->input_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->input_spatial_dimensions = propValue;
    }
    using kernel_input_feature_dimensionTy = ::mlir::Attribute;
    kernel_input_feature_dimensionTy kernel_input_feature_dimension;

    auto getKernelInputFeatureDimension() {
      auto &propStorage = this->kernel_input_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelInputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->kernel_input_feature_dimension = propValue;
    }
    using kernel_output_feature_dimensionTy = ::mlir::Attribute;
    kernel_output_feature_dimensionTy kernel_output_feature_dimension;

    auto getKernelOutputFeatureDimension() {
      auto &propStorage = this->kernel_output_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelOutputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->kernel_output_feature_dimension = propValue;
    }
    using kernel_spatial_dimensionsTy = ::mlir::Attribute;
    kernel_spatial_dimensionsTy kernel_spatial_dimensions;

    auto getKernelSpatialDimensions() {
      auto &propStorage = this->kernel_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->kernel_spatial_dimensions = propValue;
    }
    using lhs_dilationTy = ::mlir::Attribute;
    lhs_dilationTy lhs_dilation;

    auto getLhsDilation() {
      auto &propStorage = this->lhs_dilation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsDilation(const ::mlir::Attribute &propValue) {
      this->lhs_dilation = propValue;
    }
    using output_batch_dimensionTy = ::mlir::Attribute;
    output_batch_dimensionTy output_batch_dimension;

    auto getOutputBatchDimension() {
      auto &propStorage = this->output_batch_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputBatchDimension(const ::mlir::Attribute &propValue) {
      this->output_batch_dimension = propValue;
    }
    using output_feature_dimensionTy = ::mlir::Attribute;
    output_feature_dimensionTy output_feature_dimension;

    auto getOutputFeatureDimension() {
      auto &propStorage = this->output_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->output_feature_dimension = propValue;
    }
    using output_spatial_dimensionsTy = ::mlir::Attribute;
    output_spatial_dimensionsTy output_spatial_dimensions;

    auto getOutputSpatialDimensions() {
      auto &propStorage = this->output_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->output_spatial_dimensions = propValue;
    }
    using paddingTy = ::mlir::Attribute;
    paddingTy padding;

    auto getPadding() {
      auto &propStorage = this->padding;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPadding(const ::mlir::Attribute &propValue) {
      this->padding = propValue;
    }
    using precision_configTy = ::mlir::Attribute;
    precision_configTy precision_config;

    auto getPrecisionConfig() {
      auto &propStorage = this->precision_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPrecisionConfig(const ::mlir::Attribute &propValue) {
      this->precision_config = propValue;
    }
    using rhs_dilationTy = ::mlir::Attribute;
    rhs_dilationTy rhs_dilation;

    auto getRhsDilation() {
      auto &propStorage = this->rhs_dilation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsDilation(const ::mlir::Attribute &propValue) {
      this->rhs_dilation = propValue;
    }
    using window_reversalTy = ::mlir::Attribute;
    window_reversalTy window_reversal;

    auto getWindowReversal() {
      auto &propStorage = this->window_reversal;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowReversal(const ::mlir::Attribute &propValue) {
      this->window_reversal = propValue;
    }
    using window_stridesTy = ::mlir::Attribute;
    window_stridesTy window_strides;

    auto getWindowStrides() {
      auto &propStorage = this->window_strides;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowStrides(const ::mlir::Attribute &propValue) {
      this->window_strides = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.batch_group_count == this->batch_group_count &&
        rhs.feature_group_count == this->feature_group_count &&
        rhs.input_batch_dimension == this->input_batch_dimension &&
        rhs.input_feature_dimension == this->input_feature_dimension &&
        rhs.input_spatial_dimensions == this->input_spatial_dimensions &&
        rhs.kernel_input_feature_dimension == this->kernel_input_feature_dimension &&
        rhs.kernel_output_feature_dimension == this->kernel_output_feature_dimension &&
        rhs.kernel_spatial_dimensions == this->kernel_spatial_dimensions &&
        rhs.lhs_dilation == this->lhs_dilation &&
        rhs.output_batch_dimension == this->output_batch_dimension &&
        rhs.output_feature_dimension == this->output_feature_dimension &&
        rhs.output_spatial_dimensions == this->output_spatial_dimensions &&
        rhs.padding == this->padding &&
        rhs.precision_config == this->precision_config &&
        rhs.rhs_dilation == this->rhs_dilation &&
        rhs.window_reversal == this->window_reversal &&
        rhs.window_strides == this->window_strides &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DynamicConvOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_conv_v1", odsAttrs.getContext());
  }

  DynamicConvOpV1GenericAdaptorBase(DynamicConvOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getWindowStridesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
    return attr;
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().padding);
    return attr;
  }

  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_dilation);
    return attr;
  }

  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_dilation);
    return attr;
  }

  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_reversal);
    return attr;
  }

  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_batch_dimension);
    return attr;
  }

  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_input_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_output_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_batch_dimension);
    return attr;
  }

  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().feature_group_count);
    return attr;
  }

  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().batch_group_count);
    return attr;
  }

  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
    return attr;
  }

  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class DynamicConvOpV1GenericAdaptor : public detail::DynamicConvOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicConvOpV1GenericAdaptorBase;
public:
  DynamicConvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicConvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicConvOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DynamicConvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DynamicConvOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DynamicConvOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicConvOpV1>>>
  DynamicConvOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  ValueT getDPadding() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicConvOpV1Adaptor : public DynamicConvOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicConvOpV1GenericAdaptor::DynamicConvOpV1GenericAdaptor;
  DynamicConvOpV1Adaptor(DynamicConvOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicConvOpV1 : public ::mlir::Op<DynamicConvOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicConvOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicConvOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_group_count"), ::llvm::StringRef("feature_group_count"), ::llvm::StringRef("input_batch_dimension"), ::llvm::StringRef("input_feature_dimension"), ::llvm::StringRef("input_spatial_dimensions"), ::llvm::StringRef("kernel_input_feature_dimension"), ::llvm::StringRef("kernel_output_feature_dimension"), ::llvm::StringRef("kernel_spatial_dimensions"), ::llvm::StringRef("lhs_dilation"), ::llvm::StringRef("output_batch_dimension"), ::llvm::StringRef("output_feature_dimension"), ::llvm::StringRef("output_spatial_dimensions"), ::llvm::StringRef("padding"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_dilation"), ::llvm::StringRef("window_reversal"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchGroupCountAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureGroupCountAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInputBatchDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getInputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getInputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getKernelInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getKernelInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getKernelSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getKernelSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getLhsDilationAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getLhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getOutputBatchDimensionAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getOutputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getOutputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getOutputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getRhsDilationAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getRhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getWindowReversalAttrName() {
    return getAttributeNameForIndex(15);
  }

  static ::mlir::StringAttr getWindowReversalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 15);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(16);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 16);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_conv_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getDPadding() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getDPaddingMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getWindowStridesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().padding);
  }

  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_dilation);
  }

  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_dilation);
  }

  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_reversal);
  }

  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_batch_dimension);
  }

  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_feature_dimension);
  }

  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_spatial_dimensions);
  }

  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_input_feature_dimension);
  }

  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_output_feature_dimension);
  }

  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_spatial_dimensions);
  }

  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_batch_dimension);
  }

  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_feature_dimension);
  }

  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_spatial_dimensions);
  }

  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().feature_group_count);
  }

  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().batch_group_count);
  }

  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
  }

  ::mlir::Attribute getPrecisionConfig();
  void setWindowStridesAttr(::mlir::Attribute attr) {
    getProperties().window_strides = attr;
  }

  void setPaddingAttr(::mlir::Attribute attr) {
    getProperties().padding = attr;
  }

  void setLhsDilationAttr(::mlir::Attribute attr) {
    getProperties().lhs_dilation = attr;
  }

  void setRhsDilationAttr(::mlir::Attribute attr) {
    getProperties().rhs_dilation = attr;
  }

  void setWindowReversalAttr(::mlir::Attribute attr) {
    getProperties().window_reversal = attr;
  }

  void setInputBatchDimensionAttr(::mlir::Attribute attr) {
    getProperties().input_batch_dimension = attr;
  }

  void setInputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().input_feature_dimension = attr;
  }

  void setInputSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().input_spatial_dimensions = attr;
  }

  void setKernelInputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().kernel_input_feature_dimension = attr;
  }

  void setKernelOutputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().kernel_output_feature_dimension = attr;
  }

  void setKernelSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().kernel_spatial_dimensions = attr;
  }

  void setOutputBatchDimensionAttr(::mlir::Attribute attr) {
    getProperties().output_batch_dimension = attr;
  }

  void setOutputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().output_feature_dimension = attr;
  }

  void setOutputSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().output_spatial_dimensions = attr;
  }

  void setFeatureGroupCountAttr(::mlir::Attribute attr) {
    getProperties().feature_group_count = attr;
  }

  void setBatchGroupCountAttr(::mlir::Attribute attr) {
    getProperties().batch_group_count = attr;
  }

  void setPrecisionConfigAttr(::mlir::Attribute attr) {
    getProperties().precision_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value d_padding, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value d_padding, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 17 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicConvOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicConvOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicConvOpV2GenericAdaptorBase {
public:
  struct Properties {
    using batch_group_countTy = ::mlir::Attribute;
    batch_group_countTy batch_group_count;

    auto getBatchGroupCount() {
      auto &propStorage = this->batch_group_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBatchGroupCount(const ::mlir::Attribute &propValue) {
      this->batch_group_count = propValue;
    }
    using feature_group_countTy = ::mlir::Attribute;
    feature_group_countTy feature_group_count;

    auto getFeatureGroupCount() {
      auto &propStorage = this->feature_group_count;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFeatureGroupCount(const ::mlir::Attribute &propValue) {
      this->feature_group_count = propValue;
    }
    using input_batch_dimensionTy = ::mlir::Attribute;
    input_batch_dimensionTy input_batch_dimension;

    auto getInputBatchDimension() {
      auto &propStorage = this->input_batch_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputBatchDimension(const ::mlir::Attribute &propValue) {
      this->input_batch_dimension = propValue;
    }
    using input_feature_dimensionTy = ::mlir::Attribute;
    input_feature_dimensionTy input_feature_dimension;

    auto getInputFeatureDimension() {
      auto &propStorage = this->input_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->input_feature_dimension = propValue;
    }
    using input_spatial_dimensionsTy = ::mlir::Attribute;
    input_spatial_dimensionsTy input_spatial_dimensions;

    auto getInputSpatialDimensions() {
      auto &propStorage = this->input_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->input_spatial_dimensions = propValue;
    }
    using kernel_input_feature_dimensionTy = ::mlir::Attribute;
    kernel_input_feature_dimensionTy kernel_input_feature_dimension;

    auto getKernelInputFeatureDimension() {
      auto &propStorage = this->kernel_input_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelInputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->kernel_input_feature_dimension = propValue;
    }
    using kernel_output_feature_dimensionTy = ::mlir::Attribute;
    kernel_output_feature_dimensionTy kernel_output_feature_dimension;

    auto getKernelOutputFeatureDimension() {
      auto &propStorage = this->kernel_output_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelOutputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->kernel_output_feature_dimension = propValue;
    }
    using kernel_spatial_dimensionsTy = ::mlir::Attribute;
    kernel_spatial_dimensionsTy kernel_spatial_dimensions;

    auto getKernelSpatialDimensions() {
      auto &propStorage = this->kernel_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setKernelSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->kernel_spatial_dimensions = propValue;
    }
    using lhs_dilationTy = ::mlir::Attribute;
    lhs_dilationTy lhs_dilation;

    auto getLhsDilation() {
      auto &propStorage = this->lhs_dilation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLhsDilation(const ::mlir::Attribute &propValue) {
      this->lhs_dilation = propValue;
    }
    using output_batch_dimensionTy = ::mlir::Attribute;
    output_batch_dimensionTy output_batch_dimension;

    auto getOutputBatchDimension() {
      auto &propStorage = this->output_batch_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputBatchDimension(const ::mlir::Attribute &propValue) {
      this->output_batch_dimension = propValue;
    }
    using output_feature_dimensionTy = ::mlir::Attribute;
    output_feature_dimensionTy output_feature_dimension;

    auto getOutputFeatureDimension() {
      auto &propStorage = this->output_feature_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputFeatureDimension(const ::mlir::Attribute &propValue) {
      this->output_feature_dimension = propValue;
    }
    using output_spatial_dimensionsTy = ::mlir::Attribute;
    output_spatial_dimensionsTy output_spatial_dimensions;

    auto getOutputSpatialDimensions() {
      auto &propStorage = this->output_spatial_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutputSpatialDimensions(const ::mlir::Attribute &propValue) {
      this->output_spatial_dimensions = propValue;
    }
    using precision_configTy = ::mlir::Attribute;
    precision_configTy precision_config;

    auto getPrecisionConfig() {
      auto &propStorage = this->precision_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPrecisionConfig(const ::mlir::Attribute &propValue) {
      this->precision_config = propValue;
    }
    using rhs_dilationTy = ::mlir::Attribute;
    rhs_dilationTy rhs_dilation;

    auto getRhsDilation() {
      auto &propStorage = this->rhs_dilation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRhsDilation(const ::mlir::Attribute &propValue) {
      this->rhs_dilation = propValue;
    }
    using window_reversalTy = ::mlir::Attribute;
    window_reversalTy window_reversal;

    auto getWindowReversal() {
      auto &propStorage = this->window_reversal;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowReversal(const ::mlir::Attribute &propValue) {
      this->window_reversal = propValue;
    }
    using window_stridesTy = ::mlir::Attribute;
    window_stridesTy window_strides;

    auto getWindowStrides() {
      auto &propStorage = this->window_strides;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowStrides(const ::mlir::Attribute &propValue) {
      this->window_strides = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.batch_group_count == this->batch_group_count &&
        rhs.feature_group_count == this->feature_group_count &&
        rhs.input_batch_dimension == this->input_batch_dimension &&
        rhs.input_feature_dimension == this->input_feature_dimension &&
        rhs.input_spatial_dimensions == this->input_spatial_dimensions &&
        rhs.kernel_input_feature_dimension == this->kernel_input_feature_dimension &&
        rhs.kernel_output_feature_dimension == this->kernel_output_feature_dimension &&
        rhs.kernel_spatial_dimensions == this->kernel_spatial_dimensions &&
        rhs.lhs_dilation == this->lhs_dilation &&
        rhs.output_batch_dimension == this->output_batch_dimension &&
        rhs.output_feature_dimension == this->output_feature_dimension &&
        rhs.output_spatial_dimensions == this->output_spatial_dimensions &&
        rhs.precision_config == this->precision_config &&
        rhs.rhs_dilation == this->rhs_dilation &&
        rhs.window_reversal == this->window_reversal &&
        rhs.window_strides == this->window_strides &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DynamicConvOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_conv_v2", odsAttrs.getContext());
  }

  DynamicConvOpV2GenericAdaptorBase(DynamicConvOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getWindowStridesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
    return attr;
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getLhsDilationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lhs_dilation);
    return attr;
  }

  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rhs_dilation);
    return attr;
  }

  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_reversal);
    return attr;
  }

  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_batch_dimension);
    return attr;
  }

  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_input_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_output_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().kernel_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_batch_dimension);
    return attr;
  }

  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_feature_dimension);
    return attr;
  }

  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().output_spatial_dimensions);
    return attr;
  }

  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().feature_group_count);
    return attr;
  }

  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().batch_group_count);
    return attr;
  }

  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
    return attr;
  }

  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class DynamicConvOpV2GenericAdaptor : public detail::DynamicConvOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicConvOpV2GenericAdaptorBase;
public:
  DynamicConvOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicConvOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicConvOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DynamicConvOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DynamicConvOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DynamicConvOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicConvOpV2>>>
  DynamicConvOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  ValueT getPadding() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicConvOpV2Adaptor : public DynamicConvOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicConvOpV2GenericAdaptor::DynamicConvOpV2GenericAdaptor;
  DynamicConvOpV2Adaptor(DynamicConvOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicConvOpV2 : public ::mlir::Op<DynamicConvOpV2, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicConvOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicConvOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_group_count"), ::llvm::StringRef("feature_group_count"), ::llvm::StringRef("input_batch_dimension"), ::llvm::StringRef("input_feature_dimension"), ::llvm::StringRef("input_spatial_dimensions"), ::llvm::StringRef("kernel_input_feature_dimension"), ::llvm::StringRef("kernel_output_feature_dimension"), ::llvm::StringRef("kernel_spatial_dimensions"), ::llvm::StringRef("lhs_dilation"), ::llvm::StringRef("output_batch_dimension"), ::llvm::StringRef("output_feature_dimension"), ::llvm::StringRef("output_spatial_dimensions"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_dilation"), ::llvm::StringRef("window_reversal"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchGroupCountAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureGroupCountAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInputBatchDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getInputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getInputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getKernelInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getKernelInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getKernelSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getKernelSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getLhsDilationAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getLhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getOutputBatchDimensionAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getOutputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getOutputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getOutputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getRhsDilationAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getRhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getWindowReversalAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getWindowReversalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(15);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 15);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_conv_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getPadding() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getPaddingMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getWindowStridesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getLhsDilationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lhs_dilation);
  }

  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rhs_dilation);
  }

  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_reversal);
  }

  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_batch_dimension);
  }

  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_feature_dimension);
  }

  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_spatial_dimensions);
  }

  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_input_feature_dimension);
  }

  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_output_feature_dimension);
  }

  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().kernel_spatial_dimensions);
  }

  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_batch_dimension);
  }

  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_feature_dimension);
  }

  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().output_spatial_dimensions);
  }

  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().feature_group_count);
  }

  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().batch_group_count);
  }

  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().precision_config);
  }

  ::mlir::Attribute getPrecisionConfig();
  void setWindowStridesAttr(::mlir::Attribute attr) {
    getProperties().window_strides = attr;
  }

  void setLhsDilationAttr(::mlir::Attribute attr) {
    getProperties().lhs_dilation = attr;
  }

  void setRhsDilationAttr(::mlir::Attribute attr) {
    getProperties().rhs_dilation = attr;
  }

  void setWindowReversalAttr(::mlir::Attribute attr) {
    getProperties().window_reversal = attr;
  }

  void setInputBatchDimensionAttr(::mlir::Attribute attr) {
    getProperties().input_batch_dimension = attr;
  }

  void setInputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().input_feature_dimension = attr;
  }

  void setInputSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().input_spatial_dimensions = attr;
  }

  void setKernelInputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().kernel_input_feature_dimension = attr;
  }

  void setKernelOutputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().kernel_output_feature_dimension = attr;
  }

  void setKernelSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().kernel_spatial_dimensions = attr;
  }

  void setOutputBatchDimensionAttr(::mlir::Attribute attr) {
    getProperties().output_batch_dimension = attr;
  }

  void setOutputFeatureDimensionAttr(::mlir::Attribute attr) {
    getProperties().output_feature_dimension = attr;
  }

  void setOutputSpatialDimensionsAttr(::mlir::Attribute attr) {
    getProperties().output_spatial_dimensions = attr;
  }

  void setFeatureGroupCountAttr(::mlir::Attribute attr) {
    getProperties().feature_group_count = attr;
  }

  void setBatchGroupCountAttr(::mlir::Attribute attr) {
    getProperties().batch_group_count = attr;
  }

  void setPrecisionConfigAttr(::mlir::Attribute attr) {
    getProperties().precision_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value padding, ::mlir::Attribute window_strides, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value padding, ::mlir::Attribute window_strides, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 16 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicConvOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicGatherOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicGatherOpV1GenericAdaptorBase {
public:
  struct Properties {
    using collapsed_slice_dimsTy = ::mlir::Attribute;
    collapsed_slice_dimsTy collapsed_slice_dims;

    auto getCollapsedSliceDims() {
      auto &propStorage = this->collapsed_slice_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCollapsedSliceDims(const ::mlir::Attribute &propValue) {
      this->collapsed_slice_dims = propValue;
    }
    using index_vector_dimTy = ::mlir::Attribute;
    index_vector_dimTy index_vector_dim;

    auto getIndexVectorDim() {
      auto &propStorage = this->index_vector_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndexVectorDim(const ::mlir::Attribute &propValue) {
      this->index_vector_dim = propValue;
    }
    using indices_are_sortedTy = ::mlir::Attribute;
    indices_are_sortedTy indices_are_sorted;

    auto getIndicesAreSorted() {
      auto &propStorage = this->indices_are_sorted;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndicesAreSorted(const ::mlir::Attribute &propValue) {
      this->indices_are_sorted = propValue;
    }
    using offset_dimsTy = ::mlir::Attribute;
    offset_dimsTy offset_dims;

    auto getOffsetDims() {
      auto &propStorage = this->offset_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOffsetDims(const ::mlir::Attribute &propValue) {
      this->offset_dims = propValue;
    }
    using start_index_mapTy = ::mlir::Attribute;
    start_index_mapTy start_index_map;

    auto getStartIndexMap() {
      auto &propStorage = this->start_index_map;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStartIndexMap(const ::mlir::Attribute &propValue) {
      this->start_index_map = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.collapsed_slice_dims == this->collapsed_slice_dims &&
        rhs.index_vector_dim == this->index_vector_dim &&
        rhs.indices_are_sorted == this->indices_are_sorted &&
        rhs.offset_dims == this->offset_dims &&
        rhs.start_index_map == this->start_index_map &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DynamicGatherOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_gather_v1", odsAttrs.getContext());
  }

  DynamicGatherOpV1GenericAdaptorBase(DynamicGatherOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getOffsetDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
    return attr;
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
    return attr;
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
    return attr;
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
    return attr;
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
    return attr;
  }

  ::mlir::Attribute getIndicesAreSorted();
};
} // namespace detail
template <typename RangeT>
class DynamicGatherOpV1GenericAdaptor : public detail::DynamicGatherOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicGatherOpV1GenericAdaptorBase;
public:
  DynamicGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicGatherOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DynamicGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DynamicGatherOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DynamicGatherOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicGatherOpV1>>>
  DynamicGatherOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  ValueT getSliceSizes() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicGatherOpV1Adaptor : public DynamicGatherOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicGatherOpV1GenericAdaptor::DynamicGatherOpV1GenericAdaptor;
  DynamicGatherOpV1Adaptor(DynamicGatherOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicGatherOpV1 : public ::mlir::Op<DynamicGatherOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicGatherOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicGatherOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("collapsed_slice_dims"), ::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("offset_dims"), ::llvm::StringRef("start_index_map")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCollapsedSliceDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCollapsedSliceDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOffsetDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getOffsetDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getStartIndexMapAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getStartIndexMapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_gather_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStartIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getSliceSizes() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getStartIndicesMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getSliceSizesMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getOffsetDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
  }

  ::mlir::Attribute getIndicesAreSorted();
  void setOffsetDimsAttr(::mlir::Attribute attr) {
    getProperties().offset_dims = attr;
  }

  void setCollapsedSliceDimsAttr(::mlir::Attribute attr) {
    getProperties().collapsed_slice_dims = attr;
  }

  void setStartIndexMapAttr(::mlir::Attribute attr) {
    getProperties().start_index_map = attr;
  }

  void setIndexVectorDimAttr(::mlir::Attribute attr) {
    getProperties().index_vector_dim = attr;
  }

  void setIndicesAreSortedAttr(::mlir::Attribute attr) {
    getProperties().indices_are_sorted = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicGatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicGatherOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicGatherOpV2GenericAdaptorBase {
public:
  struct Properties {
    using collapsed_slice_dimsTy = ::mlir::Attribute;
    collapsed_slice_dimsTy collapsed_slice_dims;

    auto getCollapsedSliceDims() {
      auto &propStorage = this->collapsed_slice_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCollapsedSliceDims(const ::mlir::Attribute &propValue) {
      this->collapsed_slice_dims = propValue;
    }
    using index_vector_dimTy = ::mlir::Attribute;
    index_vector_dimTy index_vector_dim;

    auto getIndexVectorDim() {
      auto &propStorage = this->index_vector_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndexVectorDim(const ::mlir::Attribute &propValue) {
      this->index_vector_dim = propValue;
    }
    using indices_are_sortedTy = ::mlir::Attribute;
    indices_are_sortedTy indices_are_sorted;

    auto getIndicesAreSorted() {
      auto &propStorage = this->indices_are_sorted;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndicesAreSorted(const ::mlir::Attribute &propValue) {
      this->indices_are_sorted = propValue;
    }
    using offset_dimsTy = ::mlir::Attribute;
    offset_dimsTy offset_dims;

    auto getOffsetDims() {
      auto &propStorage = this->offset_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOffsetDims(const ::mlir::Attribute &propValue) {
      this->offset_dims = propValue;
    }
    using operand_batching_dimsTy = ::mlir::Attribute;
    operand_batching_dimsTy operand_batching_dims;

    auto getOperandBatchingDims() {
      auto &propStorage = this->operand_batching_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOperandBatchingDims(const ::mlir::Attribute &propValue) {
      this->operand_batching_dims = propValue;
    }
    using start_index_mapTy = ::mlir::Attribute;
    start_index_mapTy start_index_map;

    auto getStartIndexMap() {
      auto &propStorage = this->start_index_map;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStartIndexMap(const ::mlir::Attribute &propValue) {
      this->start_index_map = propValue;
    }
    using start_indices_batching_dimsTy = ::mlir::Attribute;
    start_indices_batching_dimsTy start_indices_batching_dims;

    auto getStartIndicesBatchingDims() {
      auto &propStorage = this->start_indices_batching_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStartIndicesBatchingDims(const ::mlir::Attribute &propValue) {
      this->start_indices_batching_dims = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.collapsed_slice_dims == this->collapsed_slice_dims &&
        rhs.index_vector_dim == this->index_vector_dim &&
        rhs.indices_are_sorted == this->indices_are_sorted &&
        rhs.offset_dims == this->offset_dims &&
        rhs.operand_batching_dims == this->operand_batching_dims &&
        rhs.start_index_map == this->start_index_map &&
        rhs.start_indices_batching_dims == this->start_indices_batching_dims &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DynamicGatherOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_gather_v2", odsAttrs.getContext());
  }

  DynamicGatherOpV2GenericAdaptorBase(DynamicGatherOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getOffsetDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
    return attr;
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
    return attr;
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getOperandBatchingDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().operand_batching_dims);
    return attr;
  }

  ::mlir::Attribute getOperandBatchingDims();
  ::mlir::Attribute getStartIndicesBatchingDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().start_indices_batching_dims);
    return attr;
  }

  ::mlir::Attribute getStartIndicesBatchingDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
    return attr;
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
    return attr;
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
    return attr;
  }

  ::mlir::Attribute getIndicesAreSorted();
};
} // namespace detail
template <typename RangeT>
class DynamicGatherOpV2GenericAdaptor : public detail::DynamicGatherOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicGatherOpV2GenericAdaptorBase;
public:
  DynamicGatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicGatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicGatherOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DynamicGatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DynamicGatherOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DynamicGatherOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicGatherOpV2>>>
  DynamicGatherOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  ValueT getSliceSizes() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicGatherOpV2Adaptor : public DynamicGatherOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicGatherOpV2GenericAdaptor::DynamicGatherOpV2GenericAdaptor;
  DynamicGatherOpV2Adaptor(DynamicGatherOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicGatherOpV2 : public ::mlir::Op<DynamicGatherOpV2, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicGatherOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicGatherOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("collapsed_slice_dims"), ::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("offset_dims"), ::llvm::StringRef("operand_batching_dims"), ::llvm::StringRef("start_index_map"), ::llvm::StringRef("start_indices_batching_dims")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCollapsedSliceDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCollapsedSliceDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOffsetDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getOffsetDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandBatchingDimsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getOperandBatchingDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getStartIndexMapAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getStartIndexMapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getStartIndicesBatchingDimsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getStartIndicesBatchingDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_gather_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStartIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getSliceSizes() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getStartIndicesMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getSliceSizesMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getOffsetDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getOperandBatchingDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().operand_batching_dims);
  }

  ::mlir::Attribute getOperandBatchingDims();
  ::mlir::Attribute getStartIndicesBatchingDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().start_indices_batching_dims);
  }

  ::mlir::Attribute getStartIndicesBatchingDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
  }

  ::mlir::Attribute getIndicesAreSorted();
  void setOffsetDimsAttr(::mlir::Attribute attr) {
    getProperties().offset_dims = attr;
  }

  void setCollapsedSliceDimsAttr(::mlir::Attribute attr) {
    getProperties().collapsed_slice_dims = attr;
  }

  void setOperandBatchingDimsAttr(::mlir::Attribute attr) {
    getProperties().operand_batching_dims = attr;
  }

  void setStartIndicesBatchingDimsAttr(::mlir::Attribute attr) {
    getProperties().start_indices_batching_dims = attr;
  }

  void setStartIndexMapAttr(::mlir::Attribute attr) {
    getProperties().start_index_map = attr;
  }

  void setIndexVectorDimAttr(::mlir::Attribute attr) {
    getProperties().index_vector_dim = attr;
  }

  void setIndicesAreSortedAttr(::mlir::Attribute attr) {
    getProperties().indices_are_sorted = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 7 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicGatherOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicIotaOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicIotaOpV1GenericAdaptorBase {
public:
  struct Properties {
    using iota_dimensionTy = ::mlir::Attribute;
    iota_dimensionTy iota_dimension;

    auto getIotaDimension() {
      auto &propStorage = this->iota_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIotaDimension(const ::mlir::Attribute &propValue) {
      this->iota_dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.iota_dimension == this->iota_dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DynamicIotaOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_iota_v1", odsAttrs.getContext());
  }

  DynamicIotaOpV1GenericAdaptorBase(DynamicIotaOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getIotaDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().iota_dimension);
    return attr;
  }

  ::mlir::Attribute getIotaDimension();
};
} // namespace detail
template <typename RangeT>
class DynamicIotaOpV1GenericAdaptor : public detail::DynamicIotaOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicIotaOpV1GenericAdaptorBase;
public:
  DynamicIotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicIotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicIotaOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DynamicIotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DynamicIotaOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DynamicIotaOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicIotaOpV1>>>
  DynamicIotaOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOutputShape() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicIotaOpV1Adaptor : public DynamicIotaOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicIotaOpV1GenericAdaptor::DynamicIotaOpV1GenericAdaptor;
  DynamicIotaOpV1Adaptor(DynamicIotaOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicIotaOpV1 : public ::mlir::Op<DynamicIotaOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicIotaOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicIotaOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("iota_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIotaDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIotaDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_iota_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOutputShape() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOutputShapeMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getIotaDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().iota_dimension);
  }

  ::mlir::Attribute getIotaDimension();
  void setIotaDimensionAttr(::mlir::Attribute attr) {
    getProperties().iota_dimension = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value output_shape, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value output_shape, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicIotaOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicPadOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicPadOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicPadOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_pad_v1", odsAttrs.getContext());
  }

  DynamicPadOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class DynamicPadOpV1GenericAdaptor : public detail::DynamicPadOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicPadOpV1GenericAdaptorBase;
public:
  DynamicPadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicPadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicPadOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicPadOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicPadOpV1>>>
  DynamicPadOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getPaddingValue() {
    return (*getODSOperands(1).begin());
  }

  ValueT getEdgePaddingLow() {
    return (*getODSOperands(2).begin());
  }

  ValueT getEdgePaddingHigh() {
    return (*getODSOperands(3).begin());
  }

  ValueT getInteriorPadding() {
    return (*getODSOperands(4).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicPadOpV1Adaptor : public DynamicPadOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicPadOpV1GenericAdaptor::DynamicPadOpV1GenericAdaptor;
  DynamicPadOpV1Adaptor(DynamicPadOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicPadOpV1 : public ::mlir::Op<DynamicPadOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicPadOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicPadOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_pad_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getPaddingValue() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getEdgePaddingLow() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getEdgePaddingHigh() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(3).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getInteriorPadding() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(4).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getPaddingValueMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getEdgePaddingLowMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getEdgePaddingHighMutable() {
    auto range = getODSOperandIndexAndLength(3);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getInteriorPaddingMutable() {
    auto range = getODSOperandIndexAndLength(4);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Value edge_padding_low, ::mlir::Value edge_padding_high, ::mlir::Value interior_padding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Value edge_padding_low, ::mlir::Value edge_padding_high, ::mlir::Value interior_padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicPadOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicReshapeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicReshapeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicReshapeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_reshape_v1", odsAttrs.getContext());
  }

  DynamicReshapeOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class DynamicReshapeOpV1GenericAdaptor : public detail::DynamicReshapeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicReshapeOpV1GenericAdaptorBase;
public:
  DynamicReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicReshapeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicReshapeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicReshapeOpV1>>>
  DynamicReshapeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOutputShape() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicReshapeOpV1Adaptor : public DynamicReshapeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicReshapeOpV1GenericAdaptor::DynamicReshapeOpV1GenericAdaptor;
  DynamicReshapeOpV1Adaptor(DynamicReshapeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicReshapeOpV1 : public ::mlir::Op<DynamicReshapeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicReshapeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicReshapeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_reshape_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOutputShape() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getOutputShapeMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value output_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value output_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicReshapeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicSliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicSliceOpV1GenericAdaptorBase {
public:
  struct Properties {
    using slice_sizesTy = ::mlir::Attribute;
    slice_sizesTy slice_sizes;

    auto getSliceSizes() {
      auto &propStorage = this->slice_sizes;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSliceSizes(const ::mlir::Attribute &propValue) {
      this->slice_sizes = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.slice_sizes == this->slice_sizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DynamicSliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_slice_v1", odsAttrs.getContext());
  }

  DynamicSliceOpV1GenericAdaptorBase(DynamicSliceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getSliceSizesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().slice_sizes);
    return attr;
  }

  ::mlir::Attribute getSliceSizes();
};
} // namespace detail
template <typename RangeT>
class DynamicSliceOpV1GenericAdaptor : public detail::DynamicSliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicSliceOpV1GenericAdaptorBase;
public:
  DynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicSliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  DynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : DynamicSliceOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = DynamicSliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicSliceOpV1>>>
  DynamicSliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getStartIndices() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicSliceOpV1Adaptor : public DynamicSliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicSliceOpV1GenericAdaptor::DynamicSliceOpV1GenericAdaptor;
  DynamicSliceOpV1Adaptor(DynamicSliceOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicSliceOpV1 : public ::mlir::Op<DynamicSliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicSliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicSliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("slice_sizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getSliceSizesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getSliceSizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::Operation::operand_range getStartIndices() {
    return getODSOperands(1);
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::MutableOperandRange getStartIndicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getSliceSizesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().slice_sizes);
  }

  ::mlir::Attribute getSliceSizes();
  void setSliceSizesAttr(::mlir::Attribute attr) {
    getProperties().slice_sizes = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::ValueRange start_indices, ::mlir::Attribute slice_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::ValueRange start_indices, ::mlir::Attribute slice_sizes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicUpdateSliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicUpdateSliceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicUpdateSliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.dynamic_update_slice_v1", odsAttrs.getContext());
  }

  DynamicUpdateSliceOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class DynamicUpdateSliceOpV1GenericAdaptor : public detail::DynamicUpdateSliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicUpdateSliceOpV1GenericAdaptorBase;
public:
  DynamicUpdateSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicUpdateSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicUpdateSliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicUpdateSliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicUpdateSliceOpV1>>>
  DynamicUpdateSliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getUpdate() {
    return (*getODSOperands(1).begin());
  }

  RangeT getStartIndices() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicUpdateSliceOpV1Adaptor : public DynamicUpdateSliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicUpdateSliceOpV1GenericAdaptor::DynamicUpdateSliceOpV1GenericAdaptor;
  DynamicUpdateSliceOpV1Adaptor(DynamicUpdateSliceOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class DynamicUpdateSliceOpV1 : public ::mlir::Op<DynamicUpdateSliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicUpdateSliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicUpdateSliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_update_slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getUpdate() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::Operation::operand_range getStartIndices() {
    return getODSOperands(2);
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getUpdateMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::MutableOperandRange getStartIndicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value update, ::mlir::ValueRange start_indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value update, ::mlir::ValueRange start_indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicUpdateSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::EinsumOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class EinsumOpV1GenericAdaptorBase {
public:
  struct Properties {
    using einsum_configTy = ::mlir::Attribute;
    einsum_configTy einsum_config;

    auto getEinsumConfig() {
      auto &propStorage = this->einsum_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setEinsumConfig(const ::mlir::Attribute &propValue) {
      this->einsum_config = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.einsum_config == this->einsum_config &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  EinsumOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.einsum_v1", odsAttrs.getContext());
  }

  EinsumOpV1GenericAdaptorBase(EinsumOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getEinsumConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().einsum_config);
    return attr;
  }

  ::mlir::Attribute getEinsumConfig();
};
} // namespace detail
template <typename RangeT>
class EinsumOpV1GenericAdaptor : public detail::EinsumOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::EinsumOpV1GenericAdaptorBase;
public:
  EinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  EinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : EinsumOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  EinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : EinsumOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = EinsumOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, EinsumOpV1>>>
  EinsumOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class EinsumOpV1Adaptor : public EinsumOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using EinsumOpV1GenericAdaptor::EinsumOpV1GenericAdaptor;
  EinsumOpV1Adaptor(EinsumOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class EinsumOpV1 : public ::mlir::Op<EinsumOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = EinsumOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = EinsumOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("einsum_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEinsumConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEinsumConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.einsum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getEinsumConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().einsum_config);
  }

  ::mlir::Attribute getEinsumConfig();
  void setEinsumConfigAttr(::mlir::Attribute attr) {
    getProperties().einsum_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::EinsumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ExpOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ExpOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ExpOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.exponential_v1", odsAttrs.getContext());
  }

  ExpOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ExpOpV1GenericAdaptor : public detail::ExpOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ExpOpV1GenericAdaptorBase;
public:
  ExpOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ExpOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ExpOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ExpOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ExpOpV1>>>
  ExpOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ExpOpV1Adaptor : public ExpOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ExpOpV1GenericAdaptor::ExpOpV1GenericAdaptor;
  ExpOpV1Adaptor(ExpOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ExpOpV1 : public ::mlir::Op<ExpOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ExpOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ExpOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.exponential_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ExpOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Expm1OpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class Expm1OpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  Expm1OpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.exponential_minus_one_v1", odsAttrs.getContext());
  }

  Expm1OpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class Expm1OpV1GenericAdaptor : public detail::Expm1OpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::Expm1OpV1GenericAdaptorBase;
public:
  Expm1OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  Expm1OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : Expm1OpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = Expm1OpV1, typename = std::enable_if_t<std::is_same_v<LateInst, Expm1OpV1>>>
  Expm1OpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class Expm1OpV1Adaptor : public Expm1OpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using Expm1OpV1GenericAdaptor::Expm1OpV1GenericAdaptor;
  Expm1OpV1Adaptor(Expm1OpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class Expm1OpV1 : public ::mlir::Op<Expm1OpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Expm1OpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = Expm1OpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.exponential_minus_one_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::Expm1OpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FftOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FftOpV1GenericAdaptorBase {
public:
  struct Properties {
    using fft_lengthTy = ::mlir::Attribute;
    fft_lengthTy fft_length;

    auto getFftLength() {
      auto &propStorage = this->fft_length;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFftLength(const ::mlir::Attribute &propValue) {
      this->fft_length = propValue;
    }
    using fft_typeTy = ::mlir::Attribute;
    fft_typeTy fft_type;

    auto getFftType() {
      auto &propStorage = this->fft_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFftType(const ::mlir::Attribute &propValue) {
      this->fft_type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.fft_length == this->fft_length &&
        rhs.fft_type == this->fft_type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  FftOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.fft_v1", odsAttrs.getContext());
  }

  FftOpV1GenericAdaptorBase(FftOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getFftTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().fft_type);
    return attr;
  }

  ::mlir::Attribute getFftType();
  ::mlir::Attribute getFftLengthAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().fft_length);
    return attr;
  }

  ::mlir::Attribute getFftLength();
};
} // namespace detail
template <typename RangeT>
class FftOpV1GenericAdaptor : public detail::FftOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FftOpV1GenericAdaptorBase;
public:
  FftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FftOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  FftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : FftOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = FftOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, FftOpV1>>>
  FftOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FftOpV1Adaptor : public FftOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using FftOpV1GenericAdaptor::FftOpV1GenericAdaptor;
  FftOpV1Adaptor(FftOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class FftOpV1 : public ::mlir::Op<FftOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FftOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = FftOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("fft_length"), ::llvm::StringRef("fft_type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getFftLengthAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getFftLengthAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFftTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFftTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.fft_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getFftTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().fft_type);
  }

  ::mlir::Attribute getFftType();
  ::mlir::Attribute getFftLengthAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().fft_length);
  }

  ::mlir::Attribute getFftLength();
  void setFftTypeAttr(::mlir::Attribute attr) {
    getProperties().fft_type = attr;
  }

  void setFftLengthAttr(::mlir::Attribute attr) {
    getProperties().fft_length = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute fft_type, ::mlir::Attribute fft_length);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute fft_type, ::mlir::Attribute fft_length);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::FftOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FloorOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FloorOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  FloorOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.floor_v1", odsAttrs.getContext());
  }

  FloorOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class FloorOpV1GenericAdaptor : public detail::FloorOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FloorOpV1GenericAdaptorBase;
public:
  FloorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FloorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FloorOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = FloorOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, FloorOpV1>>>
  FloorOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FloorOpV1Adaptor : public FloorOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using FloorOpV1GenericAdaptor::FloorOpV1GenericAdaptor;
  FloorOpV1Adaptor(FloorOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class FloorOpV1 : public ::mlir::Op<FloorOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FloorOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = FloorOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.floor_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::FloorOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FuncOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FuncOpV1GenericAdaptorBase {
public:
  struct Properties {
    using arg_attrsTy = ::mlir::Attribute;
    arg_attrsTy arg_attrs;

    auto getArgAttrs() {
      auto &propStorage = this->arg_attrs;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setArgAttrs(const ::mlir::Attribute &propValue) {
      this->arg_attrs = propValue;
    }
    using function_typeTy = ::mlir::Attribute;
    function_typeTy function_type;

    auto getFunctionType() {
      auto &propStorage = this->function_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setFunctionType(const ::mlir::Attribute &propValue) {
      this->function_type = propValue;
    }
    using res_attrsTy = ::mlir::Attribute;
    res_attrsTy res_attrs;

    auto getResAttrs() {
      auto &propStorage = this->res_attrs;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setResAttrs(const ::mlir::Attribute &propValue) {
      this->res_attrs = propValue;
    }
    using sym_nameTy = ::mlir::Attribute;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSymName(const ::mlir::Attribute &propValue) {
      this->sym_name = propValue;
    }
    using sym_visibilityTy = ::mlir::Attribute;
    sym_visibilityTy sym_visibility;

    auto getSymVisibility() {
      auto &propStorage = this->sym_visibility;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSymVisibility(const ::mlir::Attribute &propValue) {
      this->sym_visibility = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.arg_attrs == this->arg_attrs &&
        rhs.function_type == this->function_type &&
        rhs.res_attrs == this->res_attrs &&
        rhs.sym_name == this->sym_name &&
        rhs.sym_visibility == this->sym_visibility &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  FuncOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.func_v1", odsAttrs.getContext());
  }

  FuncOpV1GenericAdaptorBase(FuncOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getSymNameAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().sym_name);
    return attr;
  }

  ::mlir::Attribute getSymName();
  ::mlir::Attribute getFunctionTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().function_type);
    return attr;
  }

  ::mlir::Attribute getFunctionType();
  ::mlir::Attribute getSymVisibilityAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().sym_visibility);
    return attr;
  }

  ::mlir::Attribute getSymVisibility();
  ::mlir::Attribute getArgAttrsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().arg_attrs);
    return attr;
  }

  ::mlir::Attribute getArgAttrs();
  ::mlir::Attribute getResAttrsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().res_attrs);
    return attr;
  }

  ::mlir::Attribute getResAttrs();
  ::mlir::Region &getBody() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class FuncOpV1GenericAdaptor : public detail::FuncOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FuncOpV1GenericAdaptorBase;
public:
  FuncOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FuncOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FuncOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  FuncOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : FuncOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = FuncOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, FuncOpV1>>>
  FuncOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FuncOpV1Adaptor : public FuncOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using FuncOpV1GenericAdaptor::FuncOpV1GenericAdaptor;
  FuncOpV1Adaptor(FuncOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class FuncOpV1 : public ::mlir::Op<FuncOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FuncOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = FuncOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("arg_attrs"), ::llvm::StringRef("function_type"), ::llvm::StringRef("res_attrs"), ::llvm::StringRef("sym_name"), ::llvm::StringRef("sym_visibility")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getArgAttrsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getArgAttrsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFunctionTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFunctionTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getResAttrsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getResAttrsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSymVisibilityAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSymVisibilityAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.func_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Region &getBody() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getSymNameAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().sym_name);
  }

  ::mlir::Attribute getSymName();
  ::mlir::Attribute getFunctionTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().function_type);
  }

  ::mlir::Attribute getFunctionType();
  ::mlir::Attribute getSymVisibilityAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().sym_visibility);
  }

  ::mlir::Attribute getSymVisibility();
  ::mlir::Attribute getArgAttrsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().arg_attrs);
  }

  ::mlir::Attribute getArgAttrs();
  ::mlir::Attribute getResAttrsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().res_attrs);
  }

  ::mlir::Attribute getResAttrs();
  void setSymNameAttr(::mlir::Attribute attr) {
    getProperties().sym_name = attr;
  }

  void setFunctionTypeAttr(::mlir::Attribute attr) {
    getProperties().function_type = attr;
  }

  void setSymVisibilityAttr(::mlir::Attribute attr) {
    getProperties().sym_visibility = attr;
  }

  void setArgAttrsAttr(::mlir::Attribute attr) {
    getProperties().arg_attrs = attr;
  }

  void setResAttrsAttr(::mlir::Attribute attr) {
    getProperties().res_attrs = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Attribute sym_name, ::mlir::Attribute function_type, ::mlir::Attribute sym_visibility, ::mlir::Attribute arg_attrs, ::mlir::Attribute res_attrs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute sym_name, ::mlir::Attribute function_type, ::mlir::Attribute sym_visibility, ::mlir::Attribute arg_attrs, ::mlir::Attribute res_attrs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::FuncOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GatherOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GatherOpV1GenericAdaptorBase {
public:
  struct Properties {
    using collapsed_slice_dimsTy = ::mlir::Attribute;
    collapsed_slice_dimsTy collapsed_slice_dims;

    auto getCollapsedSliceDims() {
      auto &propStorage = this->collapsed_slice_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCollapsedSliceDims(const ::mlir::Attribute &propValue) {
      this->collapsed_slice_dims = propValue;
    }
    using index_vector_dimTy = ::mlir::Attribute;
    index_vector_dimTy index_vector_dim;

    auto getIndexVectorDim() {
      auto &propStorage = this->index_vector_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndexVectorDim(const ::mlir::Attribute &propValue) {
      this->index_vector_dim = propValue;
    }
    using indices_are_sortedTy = ::mlir::Attribute;
    indices_are_sortedTy indices_are_sorted;

    auto getIndicesAreSorted() {
      auto &propStorage = this->indices_are_sorted;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndicesAreSorted(const ::mlir::Attribute &propValue) {
      this->indices_are_sorted = propValue;
    }
    using offset_dimsTy = ::mlir::Attribute;
    offset_dimsTy offset_dims;

    auto getOffsetDims() {
      auto &propStorage = this->offset_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOffsetDims(const ::mlir::Attribute &propValue) {
      this->offset_dims = propValue;
    }
    using slice_sizesTy = ::mlir::Attribute;
    slice_sizesTy slice_sizes;

    auto getSliceSizes() {
      auto &propStorage = this->slice_sizes;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSliceSizes(const ::mlir::Attribute &propValue) {
      this->slice_sizes = propValue;
    }
    using start_index_mapTy = ::mlir::Attribute;
    start_index_mapTy start_index_map;

    auto getStartIndexMap() {
      auto &propStorage = this->start_index_map;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStartIndexMap(const ::mlir::Attribute &propValue) {
      this->start_index_map = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.collapsed_slice_dims == this->collapsed_slice_dims &&
        rhs.index_vector_dim == this->index_vector_dim &&
        rhs.indices_are_sorted == this->indices_are_sorted &&
        rhs.offset_dims == this->offset_dims &&
        rhs.slice_sizes == this->slice_sizes &&
        rhs.start_index_map == this->start_index_map &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  GatherOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.gather_v1", odsAttrs.getContext());
  }

  GatherOpV1GenericAdaptorBase(GatherOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getOffsetDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
    return attr;
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
    return attr;
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
    return attr;
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
    return attr;
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getSliceSizesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().slice_sizes);
    return attr;
  }

  ::mlir::Attribute getSliceSizes();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
    return attr;
  }

  ::mlir::Attribute getIndicesAreSorted();
};
} // namespace detail
template <typename RangeT>
class GatherOpV1GenericAdaptor : public detail::GatherOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GatherOpV1GenericAdaptorBase;
public:
  GatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GatherOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  GatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : GatherOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = GatherOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, GatherOpV1>>>
  GatherOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GatherOpV1Adaptor : public GatherOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using GatherOpV1GenericAdaptor::GatherOpV1GenericAdaptor;
  GatherOpV1Adaptor(GatherOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class GatherOpV1 : public ::mlir::Op<GatherOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GatherOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = GatherOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("collapsed_slice_dims"), ::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("offset_dims"), ::llvm::StringRef("slice_sizes"), ::llvm::StringRef("start_index_map")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCollapsedSliceDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCollapsedSliceDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOffsetDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getOffsetDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSliceSizesAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSliceSizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getStartIndexMapAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getStartIndexMapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.gather_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStartIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getStartIndicesMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getOffsetDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getSliceSizesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().slice_sizes);
  }

  ::mlir::Attribute getSliceSizes();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
  }

  ::mlir::Attribute getIndicesAreSorted();
  void setOffsetDimsAttr(::mlir::Attribute attr) {
    getProperties().offset_dims = attr;
  }

  void setCollapsedSliceDimsAttr(::mlir::Attribute attr) {
    getProperties().collapsed_slice_dims = attr;
  }

  void setStartIndexMapAttr(::mlir::Attribute attr) {
    getProperties().start_index_map = attr;
  }

  void setIndexVectorDimAttr(::mlir::Attribute attr) {
    getProperties().index_vector_dim = attr;
  }

  void setSliceSizesAttr(::mlir::Attribute attr) {
    getProperties().slice_sizes = attr;
  }

  void setIndicesAreSortedAttr(::mlir::Attribute attr) {
    getProperties().indices_are_sorted = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 6 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::GatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GatherOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GatherOpV2GenericAdaptorBase {
public:
  struct Properties {
    using collapsed_slice_dimsTy = ::mlir::Attribute;
    collapsed_slice_dimsTy collapsed_slice_dims;

    auto getCollapsedSliceDims() {
      auto &propStorage = this->collapsed_slice_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setCollapsedSliceDims(const ::mlir::Attribute &propValue) {
      this->collapsed_slice_dims = propValue;
    }
    using index_vector_dimTy = ::mlir::Attribute;
    index_vector_dimTy index_vector_dim;

    auto getIndexVectorDim() {
      auto &propStorage = this->index_vector_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndexVectorDim(const ::mlir::Attribute &propValue) {
      this->index_vector_dim = propValue;
    }
    using indices_are_sortedTy = ::mlir::Attribute;
    indices_are_sortedTy indices_are_sorted;

    auto getIndicesAreSorted() {
      auto &propStorage = this->indices_are_sorted;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndicesAreSorted(const ::mlir::Attribute &propValue) {
      this->indices_are_sorted = propValue;
    }
    using offset_dimsTy = ::mlir::Attribute;
    offset_dimsTy offset_dims;

    auto getOffsetDims() {
      auto &propStorage = this->offset_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOffsetDims(const ::mlir::Attribute &propValue) {
      this->offset_dims = propValue;
    }
    using operand_batching_dimsTy = ::mlir::Attribute;
    operand_batching_dimsTy operand_batching_dims;

    auto getOperandBatchingDims() {
      auto &propStorage = this->operand_batching_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOperandBatchingDims(const ::mlir::Attribute &propValue) {
      this->operand_batching_dims = propValue;
    }
    using slice_sizesTy = ::mlir::Attribute;
    slice_sizesTy slice_sizes;

    auto getSliceSizes() {
      auto &propStorage = this->slice_sizes;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setSliceSizes(const ::mlir::Attribute &propValue) {
      this->slice_sizes = propValue;
    }
    using start_index_mapTy = ::mlir::Attribute;
    start_index_mapTy start_index_map;

    auto getStartIndexMap() {
      auto &propStorage = this->start_index_map;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStartIndexMap(const ::mlir::Attribute &propValue) {
      this->start_index_map = propValue;
    }
    using start_indices_batching_dimsTy = ::mlir::Attribute;
    start_indices_batching_dimsTy start_indices_batching_dims;

    auto getStartIndicesBatchingDims() {
      auto &propStorage = this->start_indices_batching_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStartIndicesBatchingDims(const ::mlir::Attribute &propValue) {
      this->start_indices_batching_dims = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.collapsed_slice_dims == this->collapsed_slice_dims &&
        rhs.index_vector_dim == this->index_vector_dim &&
        rhs.indices_are_sorted == this->indices_are_sorted &&
        rhs.offset_dims == this->offset_dims &&
        rhs.operand_batching_dims == this->operand_batching_dims &&
        rhs.slice_sizes == this->slice_sizes &&
        rhs.start_index_map == this->start_index_map &&
        rhs.start_indices_batching_dims == this->start_indices_batching_dims &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  GatherOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.gather_v2", odsAttrs.getContext());
  }

  GatherOpV2GenericAdaptorBase(GatherOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getOffsetDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
    return attr;
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
    return attr;
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getOperandBatchingDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().operand_batching_dims);
    return attr;
  }

  ::mlir::Attribute getOperandBatchingDims();
  ::mlir::Attribute getStartIndicesBatchingDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().start_indices_batching_dims);
    return attr;
  }

  ::mlir::Attribute getStartIndicesBatchingDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
    return attr;
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
    return attr;
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getSliceSizesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().slice_sizes);
    return attr;
  }

  ::mlir::Attribute getSliceSizes();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
    return attr;
  }

  ::mlir::Attribute getIndicesAreSorted();
};
} // namespace detail
template <typename RangeT>
class GatherOpV2GenericAdaptor : public detail::GatherOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GatherOpV2GenericAdaptorBase;
public:
  GatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GatherOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  GatherOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : GatherOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = GatherOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, GatherOpV2>>>
  GatherOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GatherOpV2Adaptor : public GatherOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using GatherOpV2GenericAdaptor::GatherOpV2GenericAdaptor;
  GatherOpV2Adaptor(GatherOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class GatherOpV2 : public ::mlir::Op<GatherOpV2, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GatherOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = GatherOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("collapsed_slice_dims"), ::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("offset_dims"), ::llvm::StringRef("operand_batching_dims"), ::llvm::StringRef("slice_sizes"), ::llvm::StringRef("start_index_map"), ::llvm::StringRef("start_indices_batching_dims")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCollapsedSliceDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCollapsedSliceDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOffsetDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getOffsetDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandBatchingDimsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getOperandBatchingDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getSliceSizesAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getSliceSizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getStartIndexMapAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getStartIndexMapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getStartIndicesBatchingDimsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getStartIndicesBatchingDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.gather_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStartIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getStartIndicesMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getOffsetDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().offset_dims);
  }

  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().collapsed_slice_dims);
  }

  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getOperandBatchingDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().operand_batching_dims);
  }

  ::mlir::Attribute getOperandBatchingDims();
  ::mlir::Attribute getStartIndicesBatchingDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().start_indices_batching_dims);
  }

  ::mlir::Attribute getStartIndicesBatchingDims();
  ::mlir::Attribute getStartIndexMapAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().start_index_map);
  }

  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getSliceSizesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().slice_sizes);
  }

  ::mlir::Attribute getSliceSizes();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
  }

  ::mlir::Attribute getIndicesAreSorted();
  void setOffsetDimsAttr(::mlir::Attribute attr) {
    getProperties().offset_dims = attr;
  }

  void setCollapsedSliceDimsAttr(::mlir::Attribute attr) {
    getProperties().collapsed_slice_dims = attr;
  }

  void setOperandBatchingDimsAttr(::mlir::Attribute attr) {
    getProperties().operand_batching_dims = attr;
  }

  void setStartIndicesBatchingDimsAttr(::mlir::Attribute attr) {
    getProperties().start_indices_batching_dims = attr;
  }

  void setStartIndexMapAttr(::mlir::Attribute attr) {
    getProperties().start_index_map = attr;
  }

  void setIndexVectorDimAttr(::mlir::Attribute attr) {
    getProperties().index_vector_dim = attr;
  }

  void setSliceSizesAttr(::mlir::Attribute attr) {
    getProperties().slice_sizes = attr;
  }

  void setIndicesAreSortedAttr(::mlir::Attribute attr) {
    getProperties().indices_are_sorted = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute operand_batching_dims, ::mlir::Attribute start_indices_batching_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 8 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::GatherOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GetDimensionSizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GetDimensionSizeOpV1GenericAdaptorBase {
public:
  struct Properties {
    using dimensionTy = ::mlir::Attribute;
    dimensionTy dimension;

    auto getDimension() {
      auto &propStorage = this->dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDimension(const ::mlir::Attribute &propValue) {
      this->dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dimension == this->dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  GetDimensionSizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.get_dimension_size_v1", odsAttrs.getContext());
  }

  GetDimensionSizeOpV1GenericAdaptorBase(GetDimensionSizeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
    return attr;
  }

  ::mlir::Attribute getDimension();
};
} // namespace detail
template <typename RangeT>
class GetDimensionSizeOpV1GenericAdaptor : public detail::GetDimensionSizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GetDimensionSizeOpV1GenericAdaptorBase;
public:
  GetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GetDimensionSizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  GetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : GetDimensionSizeOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = GetDimensionSizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, GetDimensionSizeOpV1>>>
  GetDimensionSizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GetDimensionSizeOpV1Adaptor : public GetDimensionSizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using GetDimensionSizeOpV1GenericAdaptor::GetDimensionSizeOpV1GenericAdaptor;
  GetDimensionSizeOpV1Adaptor(GetDimensionSizeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class GetDimensionSizeOpV1 : public ::mlir::Op<GetDimensionSizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GetDimensionSizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = GetDimensionSizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.get_dimension_size_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
  }

  ::mlir::Attribute getDimension();
  void setDimensionAttr(::mlir::Attribute attr) {
    getProperties().dimension = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::GetDimensionSizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GetTupleElementOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GetTupleElementOpV1GenericAdaptorBase {
public:
  struct Properties {
    using indexTy = ::mlir::Attribute;
    indexTy index;

    auto getIndex() {
      auto &propStorage = this->index;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndex(const ::mlir::Attribute &propValue) {
      this->index = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.index == this->index &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  GetTupleElementOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.get_tuple_element_v1", odsAttrs.getContext());
  }

  GetTupleElementOpV1GenericAdaptorBase(GetTupleElementOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getIndexAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().index);
    return attr;
  }

  ::mlir::Attribute getIndex();
};
} // namespace detail
template <typename RangeT>
class GetTupleElementOpV1GenericAdaptor : public detail::GetTupleElementOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GetTupleElementOpV1GenericAdaptorBase;
public:
  GetTupleElementOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GetTupleElementOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GetTupleElementOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  GetTupleElementOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : GetTupleElementOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = GetTupleElementOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, GetTupleElementOpV1>>>
  GetTupleElementOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GetTupleElementOpV1Adaptor : public GetTupleElementOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using GetTupleElementOpV1GenericAdaptor::GetTupleElementOpV1GenericAdaptor;
  GetTupleElementOpV1Adaptor(GetTupleElementOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class GetTupleElementOpV1 : public ::mlir::Op<GetTupleElementOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GetTupleElementOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = GetTupleElementOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIndexAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.get_tuple_element_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getIndexAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().index);
  }

  ::mlir::Attribute getIndex();
  void setIndexAttr(::mlir::Attribute attr) {
    getProperties().index = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::GetTupleElementOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IfOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class IfOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  IfOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.if_v1", odsAttrs.getContext());
  }

  IfOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Region &getTrueBranch() {
    return *odsRegions[0];
  }

  ::mlir::Region &getFalseBranch() {
    return *odsRegions[1];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class IfOpV1GenericAdaptor : public detail::IfOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::IfOpV1GenericAdaptorBase;
public:
  IfOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  IfOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : IfOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = IfOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, IfOpV1>>>
  IfOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getPred() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class IfOpV1Adaptor : public IfOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using IfOpV1GenericAdaptor::IfOpV1GenericAdaptor;
  IfOpV1Adaptor(IfOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class IfOpV1 : public ::mlir::Op<IfOpV1, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = IfOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = IfOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.if_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getPred() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getPredMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getTrueBranch() {
    return (*this)->getRegion(0);
  }

  ::mlir::Region &getFalseBranch() {
    return (*this)->getRegion(1);
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value pred);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::IfOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ImagOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ImagOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ImagOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.imag_v1", odsAttrs.getContext());
  }

  ImagOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ImagOpV1GenericAdaptor : public detail::ImagOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ImagOpV1GenericAdaptorBase;
public:
  ImagOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ImagOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ImagOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ImagOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ImagOpV1>>>
  ImagOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ImagOpV1Adaptor : public ImagOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ImagOpV1GenericAdaptor::ImagOpV1GenericAdaptor;
  ImagOpV1Adaptor(ImagOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ImagOpV1 : public ::mlir::Op<ImagOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ImagOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ImagOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.imag_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ImagOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::InfeedOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class InfeedOpV1GenericAdaptorBase {
public:
  struct Properties {
    using infeed_configTy = ::mlir::Attribute;
    infeed_configTy infeed_config;

    auto getInfeedConfig() {
      auto &propStorage = this->infeed_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInfeedConfig(const ::mlir::Attribute &propValue) {
      this->infeed_config = propValue;
    }
    using layoutTy = ::mlir::Attribute;
    layoutTy layout;

    auto getLayout() {
      auto &propStorage = this->layout;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLayout(const ::mlir::Attribute &propValue) {
      this->layout = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.infeed_config == this->infeed_config &&
        rhs.layout == this->layout &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  InfeedOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.infeed_v1", odsAttrs.getContext());
  }

  InfeedOpV1GenericAdaptorBase(InfeedOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getInfeedConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().infeed_config);
    return attr;
  }

  ::mlir::Attribute getInfeedConfig();
  ::mlir::Attribute getLayoutAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().layout);
    return attr;
  }

  ::mlir::Attribute getLayout();
};
} // namespace detail
template <typename RangeT>
class InfeedOpV1GenericAdaptor : public detail::InfeedOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::InfeedOpV1GenericAdaptorBase;
public:
  InfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  InfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : InfeedOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  InfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : InfeedOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = InfeedOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, InfeedOpV1>>>
  InfeedOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getToken() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class InfeedOpV1Adaptor : public InfeedOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using InfeedOpV1GenericAdaptor::InfeedOpV1GenericAdaptor;
  InfeedOpV1Adaptor(InfeedOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class InfeedOpV1 : public ::mlir::Op<InfeedOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = InfeedOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = InfeedOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("infeed_config"), ::llvm::StringRef("layout")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getInfeedConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getInfeedConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getLayoutAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getLayoutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.infeed_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getToken() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getTokenMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getInfeedConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().infeed_config);
  }

  ::mlir::Attribute getInfeedConfig();
  ::mlir::Attribute getLayoutAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().layout);
  }

  ::mlir::Attribute getLayout();
  void setInfeedConfigAttr(::mlir::Attribute attr) {
    getProperties().infeed_config = attr;
  }

  void setLayoutAttr(::mlir::Attribute attr) {
    getProperties().layout = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value token, ::mlir::Attribute infeed_config, ::mlir::Attribute layout);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::InfeedOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IotaOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class IotaOpV1GenericAdaptorBase {
public:
  struct Properties {
    using iota_dimensionTy = ::mlir::Attribute;
    iota_dimensionTy iota_dimension;

    auto getIotaDimension() {
      auto &propStorage = this->iota_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIotaDimension(const ::mlir::Attribute &propValue) {
      this->iota_dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.iota_dimension == this->iota_dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  IotaOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.iota_v1", odsAttrs.getContext());
  }

  IotaOpV1GenericAdaptorBase(IotaOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getIotaDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().iota_dimension);
    return attr;
  }

  ::mlir::Attribute getIotaDimension();
};
} // namespace detail
template <typename RangeT>
class IotaOpV1GenericAdaptor : public detail::IotaOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::IotaOpV1GenericAdaptorBase;
public:
  IotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  IotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : IotaOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  IotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : IotaOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = IotaOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, IotaOpV1>>>
  IotaOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class IotaOpV1Adaptor : public IotaOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using IotaOpV1GenericAdaptor::IotaOpV1GenericAdaptor;
  IotaOpV1Adaptor(IotaOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class IotaOpV1 : public ::mlir::Op<IotaOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = IotaOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = IotaOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("iota_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIotaDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIotaDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.iota_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOutput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getIotaDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().iota_dimension);
  }

  ::mlir::Attribute getIotaDimension();
  void setIotaDimensionAttr(::mlir::Attribute attr) {
    getProperties().iota_dimension = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::IotaOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IsFiniteOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class IsFiniteOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  IsFiniteOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.is_finite_v1", odsAttrs.getContext());
  }

  IsFiniteOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class IsFiniteOpV1GenericAdaptor : public detail::IsFiniteOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::IsFiniteOpV1GenericAdaptorBase;
public:
  IsFiniteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  IsFiniteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : IsFiniteOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = IsFiniteOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, IsFiniteOpV1>>>
  IsFiniteOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class IsFiniteOpV1Adaptor : public IsFiniteOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using IsFiniteOpV1GenericAdaptor::IsFiniteOpV1GenericAdaptor;
  IsFiniteOpV1Adaptor(IsFiniteOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class IsFiniteOpV1 : public ::mlir::Op<IsFiniteOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = IsFiniteOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = IsFiniteOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.is_finite_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getX() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getXMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getY() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::IsFiniteOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Log1pOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class Log1pOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  Log1pOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.log_plus_one_v1", odsAttrs.getContext());
  }

  Log1pOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class Log1pOpV1GenericAdaptor : public detail::Log1pOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::Log1pOpV1GenericAdaptorBase;
public:
  Log1pOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  Log1pOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : Log1pOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = Log1pOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, Log1pOpV1>>>
  Log1pOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class Log1pOpV1Adaptor : public Log1pOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using Log1pOpV1GenericAdaptor::Log1pOpV1GenericAdaptor;
  Log1pOpV1Adaptor(Log1pOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class Log1pOpV1 : public ::mlir::Op<Log1pOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Log1pOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = Log1pOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.log_plus_one_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::Log1pOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::LogOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class LogOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  LogOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.log_v1", odsAttrs.getContext());
  }

  LogOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class LogOpV1GenericAdaptor : public detail::LogOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::LogOpV1GenericAdaptorBase;
public:
  LogOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  LogOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : LogOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = LogOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, LogOpV1>>>
  LogOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class LogOpV1Adaptor : public LogOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using LogOpV1GenericAdaptor::LogOpV1GenericAdaptor;
  LogOpV1Adaptor(LogOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class LogOpV1 : public ::mlir::Op<LogOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = LogOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = LogOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.log_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::LogOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::LogisticOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class LogisticOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  LogisticOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.logistic_v1", odsAttrs.getContext());
  }

  LogisticOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class LogisticOpV1GenericAdaptor : public detail::LogisticOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::LogisticOpV1GenericAdaptorBase;
public:
  LogisticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  LogisticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : LogisticOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = LogisticOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, LogisticOpV1>>>
  LogisticOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class LogisticOpV1Adaptor : public LogisticOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using LogisticOpV1GenericAdaptor::LogisticOpV1GenericAdaptor;
  LogisticOpV1Adaptor(LogisticOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class LogisticOpV1 : public ::mlir::Op<LogisticOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = LogisticOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = LogisticOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.logistic_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::LogisticOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MapOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MapOpV1GenericAdaptorBase {
public:
  struct Properties {
    using dimensionsTy = ::mlir::Attribute;
    dimensionsTy dimensions;

    auto getDimensions() {
      auto &propStorage = this->dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDimensions(const ::mlir::Attribute &propValue) {
      this->dimensions = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dimensions == this->dimensions &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  MapOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.map_v1", odsAttrs.getContext());
  }

  MapOpV1GenericAdaptorBase(MapOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dimensions);
    return attr;
  }

  ::mlir::Attribute getDimensions();
  ::mlir::Region &getComputation() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class MapOpV1GenericAdaptor : public detail::MapOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MapOpV1GenericAdaptorBase;
public:
  MapOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MapOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MapOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  MapOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : MapOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = MapOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MapOpV1>>>
  MapOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MapOpV1Adaptor : public MapOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MapOpV1GenericAdaptor::MapOpV1GenericAdaptor;
  MapOpV1Adaptor(MapOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MapOpV1 : public ::mlir::Op<MapOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MapOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MapOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.map_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  ::mlir::Region &getComputation() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dimensions);
  }

  ::mlir::Attribute getDimensions();
  void setDimensionsAttr(::mlir::Attribute attr) {
    getProperties().dimensions = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MapOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MaxOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MaxOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MaxOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.maximum_v1", odsAttrs.getContext());
  }

  MaxOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class MaxOpV1GenericAdaptor : public detail::MaxOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MaxOpV1GenericAdaptorBase;
public:
  MaxOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MaxOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MaxOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MaxOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MaxOpV1>>>
  MaxOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MaxOpV1Adaptor : public MaxOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MaxOpV1GenericAdaptor::MaxOpV1GenericAdaptor;
  MaxOpV1Adaptor(MaxOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MaxOpV1 : public ::mlir::Op<MaxOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MaxOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MaxOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.maximum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MaxOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MinOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MinOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MinOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.minimum_v1", odsAttrs.getContext());
  }

  MinOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class MinOpV1GenericAdaptor : public detail::MinOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MinOpV1GenericAdaptorBase;
public:
  MinOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MinOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MinOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MinOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MinOpV1>>>
  MinOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MinOpV1Adaptor : public MinOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MinOpV1GenericAdaptor::MinOpV1GenericAdaptor;
  MinOpV1Adaptor(MinOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MinOpV1 : public ::mlir::Op<MinOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MinOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MinOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.minimum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MinOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MulOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MulOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MulOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.multiply_v1", odsAttrs.getContext());
  }

  MulOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class MulOpV1GenericAdaptor : public detail::MulOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MulOpV1GenericAdaptorBase;
public:
  MulOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MulOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MulOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MulOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MulOpV1>>>
  MulOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MulOpV1Adaptor : public MulOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MulOpV1GenericAdaptor::MulOpV1GenericAdaptor;
  MulOpV1Adaptor(MulOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class MulOpV1 : public ::mlir::Op<MulOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MulOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MulOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.multiply_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MulOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::NegOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class NegOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  NegOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.negate_v1", odsAttrs.getContext());
  }

  NegOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class NegOpV1GenericAdaptor : public detail::NegOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::NegOpV1GenericAdaptorBase;
public:
  NegOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  NegOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : NegOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = NegOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, NegOpV1>>>
  NegOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class NegOpV1Adaptor : public NegOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using NegOpV1GenericAdaptor::NegOpV1GenericAdaptor;
  NegOpV1Adaptor(NegOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class NegOpV1 : public ::mlir::Op<NegOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NegOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = NegOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.negate_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::NegOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::NotOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class NotOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  NotOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.not_v1", odsAttrs.getContext());
  }

  NotOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class NotOpV1GenericAdaptor : public detail::NotOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::NotOpV1GenericAdaptorBase;
public:
  NotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  NotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : NotOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = NotOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, NotOpV1>>>
  NotOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class NotOpV1Adaptor : public NotOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using NotOpV1GenericAdaptor::NotOpV1GenericAdaptor;
  NotOpV1Adaptor(NotOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class NotOpV1 : public ::mlir::Op<NotOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NotOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = NotOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.not_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::NotOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OptimizationBarrierOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OptimizationBarrierOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  OptimizationBarrierOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.optimization_barrier_v1", odsAttrs.getContext());
  }

  OptimizationBarrierOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class OptimizationBarrierOpV1GenericAdaptor : public detail::OptimizationBarrierOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OptimizationBarrierOpV1GenericAdaptorBase;
public:
  OptimizationBarrierOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OptimizationBarrierOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OptimizationBarrierOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = OptimizationBarrierOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, OptimizationBarrierOpV1>>>
  OptimizationBarrierOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperand() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OptimizationBarrierOpV1Adaptor : public OptimizationBarrierOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using OptimizationBarrierOpV1GenericAdaptor::OptimizationBarrierOpV1GenericAdaptor;
  OptimizationBarrierOpV1Adaptor(OptimizationBarrierOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class OptimizationBarrierOpV1 : public ::mlir::Op<OptimizationBarrierOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OptimizationBarrierOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = OptimizationBarrierOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.optimization_barrier_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperand() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResult() {
    return getODSResults(0);
  }

  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::OptimizationBarrierOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OrOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OrOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  OrOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.or_v1", odsAttrs.getContext());
  }

  OrOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class OrOpV1GenericAdaptor : public detail::OrOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OrOpV1GenericAdaptorBase;
public:
  OrOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OrOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OrOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = OrOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, OrOpV1>>>
  OrOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OrOpV1Adaptor : public OrOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using OrOpV1GenericAdaptor::OrOpV1GenericAdaptor;
  OrOpV1Adaptor(OrOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class OrOpV1 : public ::mlir::Op<OrOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OrOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = OrOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.or_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::OrOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OutfeedOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OutfeedOpV1GenericAdaptorBase {
public:
  struct Properties {
    using outfeed_configTy = ::mlir::Attribute;
    outfeed_configTy outfeed_config;

    auto getOutfeedConfig() {
      auto &propStorage = this->outfeed_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setOutfeedConfig(const ::mlir::Attribute &propValue) {
      this->outfeed_config = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.outfeed_config == this->outfeed_config &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  OutfeedOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.outfeed_v1", odsAttrs.getContext());
  }

  OutfeedOpV1GenericAdaptorBase(OutfeedOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getOutfeedConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().outfeed_config);
    return attr;
  }

  ::mlir::Attribute getOutfeedConfig();
};
} // namespace detail
template <typename RangeT>
class OutfeedOpV1GenericAdaptor : public detail::OutfeedOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OutfeedOpV1GenericAdaptorBase;
public:
  OutfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OutfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OutfeedOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  OutfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : OutfeedOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = OutfeedOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, OutfeedOpV1>>>
  OutfeedOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  ValueT getToken() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OutfeedOpV1Adaptor : public OutfeedOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using OutfeedOpV1GenericAdaptor::OutfeedOpV1GenericAdaptor;
  OutfeedOpV1Adaptor(OutfeedOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class OutfeedOpV1 : public ::mlir::Op<OutfeedOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OutfeedOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = OutfeedOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("outfeed_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getOutfeedConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getOutfeedConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.outfeed_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::Type> getToken() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::OpOperand &getTokenMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getOutfeedConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().outfeed_config);
  }

  ::mlir::Attribute getOutfeedConfig();
  void setOutfeedConfigAttr(::mlir::Attribute attr) {
    getProperties().outfeed_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute outfeed_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute outfeed_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::OutfeedOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PadOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PadOpV1GenericAdaptorBase {
public:
  struct Properties {
    using edge_padding_highTy = ::mlir::Attribute;
    edge_padding_highTy edge_padding_high;

    auto getEdgePaddingHigh() {
      auto &propStorage = this->edge_padding_high;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setEdgePaddingHigh(const ::mlir::Attribute &propValue) {
      this->edge_padding_high = propValue;
    }
    using edge_padding_lowTy = ::mlir::Attribute;
    edge_padding_lowTy edge_padding_low;

    auto getEdgePaddingLow() {
      auto &propStorage = this->edge_padding_low;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setEdgePaddingLow(const ::mlir::Attribute &propValue) {
      this->edge_padding_low = propValue;
    }
    using interior_paddingTy = ::mlir::Attribute;
    interior_paddingTy interior_padding;

    auto getInteriorPadding() {
      auto &propStorage = this->interior_padding;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInteriorPadding(const ::mlir::Attribute &propValue) {
      this->interior_padding = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.edge_padding_high == this->edge_padding_high &&
        rhs.edge_padding_low == this->edge_padding_low &&
        rhs.interior_padding == this->interior_padding &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  PadOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.pad_v1", odsAttrs.getContext());
  }

  PadOpV1GenericAdaptorBase(PadOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getEdgePaddingLowAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().edge_padding_low);
    return attr;
  }

  ::mlir::Attribute getEdgePaddingLow();
  ::mlir::Attribute getEdgePaddingHighAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().edge_padding_high);
    return attr;
  }

  ::mlir::Attribute getEdgePaddingHigh();
  ::mlir::Attribute getInteriorPaddingAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().interior_padding);
    return attr;
  }

  ::mlir::Attribute getInteriorPadding();
};
} // namespace detail
template <typename RangeT>
class PadOpV1GenericAdaptor : public detail::PadOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PadOpV1GenericAdaptorBase;
public:
  PadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PadOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  PadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : PadOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = PadOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PadOpV1>>>
  PadOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getPaddingValue() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PadOpV1Adaptor : public PadOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PadOpV1GenericAdaptor::PadOpV1GenericAdaptor;
  PadOpV1Adaptor(PadOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class PadOpV1 : public ::mlir::Op<PadOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PadOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PadOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("edge_padding_high"), ::llvm::StringRef("edge_padding_low"), ::llvm::StringRef("interior_padding")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEdgePaddingHighAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEdgePaddingHighAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getEdgePaddingLowAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getEdgePaddingLowAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInteriorPaddingAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInteriorPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.pad_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getPaddingValue() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getPaddingValueMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getEdgePaddingLowAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().edge_padding_low);
  }

  ::mlir::Attribute getEdgePaddingLow();
  ::mlir::Attribute getEdgePaddingHighAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().edge_padding_high);
  }

  ::mlir::Attribute getEdgePaddingHigh();
  ::mlir::Attribute getInteriorPaddingAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().interior_padding);
  }

  ::mlir::Attribute getInteriorPadding();
  void setEdgePaddingLowAttr(::mlir::Attribute attr) {
    getProperties().edge_padding_low = attr;
  }

  void setEdgePaddingHighAttr(::mlir::Attribute attr) {
    getProperties().edge_padding_high = attr;
  }

  void setInteriorPaddingAttr(::mlir::Attribute attr) {
    getProperties().interior_padding = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Attribute edge_padding_low, ::mlir::Attribute edge_padding_high, ::mlir::Attribute interior_padding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Attribute edge_padding_low, ::mlir::Attribute edge_padding_high, ::mlir::Attribute interior_padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PadOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PartitionIdOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PartitionIdOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PartitionIdOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.partition_id_v1", odsAttrs.getContext());
  }

  PartitionIdOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class PartitionIdOpV1GenericAdaptor : public detail::PartitionIdOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PartitionIdOpV1GenericAdaptorBase;
public:
  PartitionIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PartitionIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PartitionIdOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PartitionIdOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PartitionIdOpV1>>>
  PartitionIdOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PartitionIdOpV1Adaptor : public PartitionIdOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PartitionIdOpV1GenericAdaptor::PartitionIdOpV1GenericAdaptor;
  PartitionIdOpV1Adaptor(PartitionIdOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class PartitionIdOpV1 : public ::mlir::Op<PartitionIdOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PartitionIdOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PartitionIdOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.partition_id_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PartitionIdOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PopulationCountOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PopulationCountOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PopulationCountOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.popcnt_v1", odsAttrs.getContext());
  }

  PopulationCountOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class PopulationCountOpV1GenericAdaptor : public detail::PopulationCountOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PopulationCountOpV1GenericAdaptorBase;
public:
  PopulationCountOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PopulationCountOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PopulationCountOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PopulationCountOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PopulationCountOpV1>>>
  PopulationCountOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PopulationCountOpV1Adaptor : public PopulationCountOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PopulationCountOpV1GenericAdaptor::PopulationCountOpV1GenericAdaptor;
  PopulationCountOpV1Adaptor(PopulationCountOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class PopulationCountOpV1 : public ::mlir::Op<PopulationCountOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PopulationCountOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PopulationCountOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.popcnt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PopulationCountOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PowOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PowOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PowOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.power_v1", odsAttrs.getContext());
  }

  PowOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class PowOpV1GenericAdaptor : public detail::PowOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PowOpV1GenericAdaptorBase;
public:
  PowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PowOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PowOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PowOpV1>>>
  PowOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PowOpV1Adaptor : public PowOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PowOpV1GenericAdaptor::PowOpV1GenericAdaptor;
  PowOpV1Adaptor(PowOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class PowOpV1 : public ::mlir::Op<PowOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PowOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PowOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.power_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PowOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RealDynamicSliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RealDynamicSliceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RealDynamicSliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.real_dynamic_slice_v1", odsAttrs.getContext());
  }

  RealDynamicSliceOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class RealDynamicSliceOpV1GenericAdaptor : public detail::RealDynamicSliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RealDynamicSliceOpV1GenericAdaptorBase;
public:
  RealDynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RealDynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RealDynamicSliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RealDynamicSliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RealDynamicSliceOpV1>>>
  RealDynamicSliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  ValueT getLimitIndices() {
    return (*getODSOperands(2).begin());
  }

  ValueT getStrides() {
    return (*getODSOperands(3).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RealDynamicSliceOpV1Adaptor : public RealDynamicSliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RealDynamicSliceOpV1GenericAdaptor::RealDynamicSliceOpV1GenericAdaptor;
  RealDynamicSliceOpV1Adaptor(RealDynamicSliceOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RealDynamicSliceOpV1 : public ::mlir::Op<RealDynamicSliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RealDynamicSliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RealDynamicSliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.real_dynamic_slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStartIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getLimitIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getStrides() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(3).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getStartIndicesMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getLimitIndicesMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getStridesMutable() {
    auto range = getODSOperandIndexAndLength(3);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value limit_indices, ::mlir::Value strides);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value limit_indices, ::mlir::Value strides);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RealDynamicSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RealOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RealOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RealOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.real_v1", odsAttrs.getContext());
  }

  RealOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class RealOpV1GenericAdaptor : public detail::RealOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RealOpV1GenericAdaptorBase;
public:
  RealOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RealOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RealOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RealOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RealOpV1>>>
  RealOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RealOpV1Adaptor : public RealOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RealOpV1GenericAdaptor::RealOpV1GenericAdaptor;
  RealOpV1Adaptor(RealOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RealOpV1 : public ::mlir::Op<RealOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RealOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RealOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.real_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RealOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RecvOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RecvOpV1GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using channel_typeTy = ::mlir::Attribute;
    channel_typeTy channel_type;

    auto getChannelType() {
      auto &propStorage = this->channel_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelType(const ::mlir::Attribute &propValue) {
      this->channel_type = propValue;
    }
    using is_host_transferTy = ::mlir::Attribute;
    is_host_transferTy is_host_transfer;

    auto getIsHostTransfer() {
      auto &propStorage = this->is_host_transfer;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIsHostTransfer(const ::mlir::Attribute &propValue) {
      this->is_host_transfer = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.channel_type == this->channel_type &&
        rhs.is_host_transfer == this->is_host_transfer &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  RecvOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.recv_v1", odsAttrs.getContext());
  }

  RecvOpV1GenericAdaptorBase(RecvOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_type);
    return attr;
  }

  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().is_host_transfer);
    return attr;
  }

  ::mlir::Attribute getIsHostTransfer();
};
} // namespace detail
template <typename RangeT>
class RecvOpV1GenericAdaptor : public detail::RecvOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RecvOpV1GenericAdaptorBase;
public:
  RecvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RecvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RecvOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  RecvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : RecvOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = RecvOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RecvOpV1>>>
  RecvOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getToken() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RecvOpV1Adaptor : public RecvOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RecvOpV1GenericAdaptor::RecvOpV1GenericAdaptor;
  RecvOpV1Adaptor(RecvOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RecvOpV1 : public ::mlir::Op<RecvOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RecvOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RecvOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("channel_type"), ::llvm::StringRef("is_host_transfer")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getChannelTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getChannelTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIsHostTransferAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIsHostTransferAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.recv_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getToken() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getTokenMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_type);
  }

  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().is_host_transfer);
  }

  ::mlir::Attribute getIsHostTransfer();
  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  void setChannelTypeAttr(::mlir::Attribute attr) {
    getProperties().channel_type = attr;
  }

  void setIsHostTransferAttr(::mlir::Attribute attr) {
    getProperties().is_host_transfer = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RecvOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReduceOpV1GenericAdaptorBase {
public:
  struct Properties {
    using dimensionsTy = ::mlir::Attribute;
    dimensionsTy dimensions;

    auto getDimensions() {
      auto &propStorage = this->dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDimensions(const ::mlir::Attribute &propValue) {
      this->dimensions = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dimensions == this->dimensions &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ReduceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.reduce_v1", odsAttrs.getContext());
  }

  ReduceOpV1GenericAdaptorBase(ReduceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dimensions);
    return attr;
  }

  ::mlir::Attribute getDimensions();
  ::mlir::Region &getBody() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class ReduceOpV1GenericAdaptor : public detail::ReduceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReduceOpV1GenericAdaptorBase;
public:
  ReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReduceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ReduceOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ReduceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReduceOpV1>>>
  ReduceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getInitValues() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReduceOpV1Adaptor : public ReduceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReduceOpV1GenericAdaptor::ReduceOpV1GenericAdaptor;
  ReduceOpV1Adaptor(ReduceOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReduceOpV1 : public ::mlir::Op<ReduceOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::vhlo::VersionedOpConstraintInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReduceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getInitValues() {
    return getODSOperands(1);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::MutableOperandRange getInitValuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getBody() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dimensions);
  }

  ::mlir::Attribute getDimensions();
  void setDimensionsAttr(::mlir::Attribute attr) {
    getProperties().dimensions = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::ValueRange init_values, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  mlir::LogicalResult validateConstraint(mlir::Operation*op, mlir::vhlo::Version targetVersion);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReducePrecisionOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReducePrecisionOpV1GenericAdaptorBase {
public:
  struct Properties {
    using exponent_bitsTy = ::mlir::Attribute;
    exponent_bitsTy exponent_bits;

    auto getExponentBits() {
      auto &propStorage = this->exponent_bits;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setExponentBits(const ::mlir::Attribute &propValue) {
      this->exponent_bits = propValue;
    }
    using mantissa_bitsTy = ::mlir::Attribute;
    mantissa_bitsTy mantissa_bits;

    auto getMantissaBits() {
      auto &propStorage = this->mantissa_bits;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setMantissaBits(const ::mlir::Attribute &propValue) {
      this->mantissa_bits = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.exponent_bits == this->exponent_bits &&
        rhs.mantissa_bits == this->mantissa_bits &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ReducePrecisionOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.reduce_precision_v1", odsAttrs.getContext());
  }

  ReducePrecisionOpV1GenericAdaptorBase(ReducePrecisionOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getExponentBitsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().exponent_bits);
    return attr;
  }

  ::mlir::Attribute getExponentBits();
  ::mlir::Attribute getMantissaBitsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().mantissa_bits);
    return attr;
  }

  ::mlir::Attribute getMantissaBits();
};
} // namespace detail
template <typename RangeT>
class ReducePrecisionOpV1GenericAdaptor : public detail::ReducePrecisionOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReducePrecisionOpV1GenericAdaptorBase;
public:
  ReducePrecisionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReducePrecisionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReducePrecisionOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ReducePrecisionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ReducePrecisionOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ReducePrecisionOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReducePrecisionOpV1>>>
  ReducePrecisionOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReducePrecisionOpV1Adaptor : public ReducePrecisionOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReducePrecisionOpV1GenericAdaptor::ReducePrecisionOpV1GenericAdaptor;
  ReducePrecisionOpV1Adaptor(ReducePrecisionOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReducePrecisionOpV1 : public ::mlir::Op<ReducePrecisionOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReducePrecisionOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReducePrecisionOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("exponent_bits"), ::llvm::StringRef("mantissa_bits")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getExponentBitsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getExponentBitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getMantissaBitsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getMantissaBitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_precision_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOutput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getExponentBitsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().exponent_bits);
  }

  ::mlir::Attribute getExponentBits();
  ::mlir::Attribute getMantissaBitsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().mantissa_bits);
  }

  ::mlir::Attribute getMantissaBits();
  void setExponentBitsAttr(::mlir::Attribute attr) {
    getProperties().exponent_bits = attr;
  }

  void setMantissaBitsAttr(::mlir::Attribute attr) {
    getProperties().mantissa_bits = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Attribute exponent_bits, ::mlir::Attribute mantissa_bits);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute exponent_bits, ::mlir::Attribute mantissa_bits);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReducePrecisionOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceScatterOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReduceScatterOpV1GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using replica_groupsTy = ::mlir::Attribute;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setReplicaGroups(const ::mlir::Attribute &propValue) {
      this->replica_groups = propValue;
    }
    using scatter_dimensionTy = ::mlir::Attribute;
    scatter_dimensionTy scatter_dimension;

    auto getScatterDimension() {
      auto &propStorage = this->scatter_dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setScatterDimension(const ::mlir::Attribute &propValue) {
      this->scatter_dimension = propValue;
    }
    using use_global_device_idsTy = ::mlir::Attribute;
    use_global_device_idsTy use_global_device_ids;

    auto getUseGlobalDeviceIds() {
      auto &propStorage = this->use_global_device_ids;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUseGlobalDeviceIds(const ::mlir::Attribute &propValue) {
      this->use_global_device_ids = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.replica_groups == this->replica_groups &&
        rhs.scatter_dimension == this->scatter_dimension &&
        rhs.use_global_device_ids == this->use_global_device_ids &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ReduceScatterOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.reduce_scatter_v1", odsAttrs.getContext());
  }

  ReduceScatterOpV1GenericAdaptorBase(ReduceScatterOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getScatterDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().scatter_dimension);
    return attr;
  }

  ::mlir::Attribute getScatterDimension();
  ::mlir::Attribute getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
    return attr;
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  ::mlir::Region &getComputation() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class ReduceScatterOpV1GenericAdaptor : public detail::ReduceScatterOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReduceScatterOpV1GenericAdaptorBase;
public:
  ReduceScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReduceScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReduceScatterOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ReduceScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ReduceScatterOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ReduceScatterOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReduceScatterOpV1>>>
  ReduceScatterOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReduceScatterOpV1Adaptor : public ReduceScatterOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReduceScatterOpV1GenericAdaptor::ReduceScatterOpV1GenericAdaptor;
  ReduceScatterOpV1Adaptor(ReduceScatterOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReduceScatterOpV1 : public ::mlir::Op<ReduceScatterOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::vhlo::VersionedOpConstraintInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceScatterOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReduceScatterOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("scatter_dimension"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getScatterDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getScatterDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_scatter_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  ::mlir::Region &getComputation() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getScatterDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().scatter_dimension);
  }

  ::mlir::Attribute getScatterDimension();
  ::mlir::Attribute getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().replica_groups);
  }

  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().use_global_device_ids);
  }

  ::mlir::Attribute getUseGlobalDeviceIds();
  void setScatterDimensionAttr(::mlir::Attribute attr) {
    getProperties().scatter_dimension = attr;
  }

  void setReplicaGroupsAttr(::mlir::Attribute attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr) {
    getProperties().use_global_device_ids = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute scatter_dimension, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute scatter_dimension, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  mlir::LogicalResult validateConstraint(mlir::Operation*op, mlir::vhlo::Version targetVersion);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceWindowOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReduceWindowOpV1GenericAdaptorBase {
public:
  struct Properties {
    using base_dilationsTy = ::mlir::Attribute;
    base_dilationsTy base_dilations;

    auto getBaseDilations() {
      auto &propStorage = this->base_dilations;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBaseDilations(const ::mlir::Attribute &propValue) {
      this->base_dilations = propValue;
    }
    using paddingTy = ::mlir::Attribute;
    paddingTy padding;

    auto getPadding() {
      auto &propStorage = this->padding;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPadding(const ::mlir::Attribute &propValue) {
      this->padding = propValue;
    }
    using window_dilationsTy = ::mlir::Attribute;
    window_dilationsTy window_dilations;

    auto getWindowDilations() {
      auto &propStorage = this->window_dilations;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowDilations(const ::mlir::Attribute &propValue) {
      this->window_dilations = propValue;
    }
    using window_dimensionsTy = ::mlir::Attribute;
    window_dimensionsTy window_dimensions;

    auto getWindowDimensions() {
      auto &propStorage = this->window_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowDimensions(const ::mlir::Attribute &propValue) {
      this->window_dimensions = propValue;
    }
    using window_stridesTy = ::mlir::Attribute;
    window_stridesTy window_strides;

    auto getWindowStrides() {
      auto &propStorage = this->window_strides;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowStrides(const ::mlir::Attribute &propValue) {
      this->window_strides = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.base_dilations == this->base_dilations &&
        rhs.padding == this->padding &&
        rhs.window_dilations == this->window_dilations &&
        rhs.window_dimensions == this->window_dimensions &&
        rhs.window_strides == this->window_strides &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ReduceWindowOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.reduce_window_v1", odsAttrs.getContext());
  }

  ReduceWindowOpV1GenericAdaptorBase(ReduceWindowOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getWindowDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_dimensions);
    return attr;
  }

  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
    return attr;
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getBaseDilationsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().base_dilations);
    return attr;
  }

  ::mlir::Attribute getBaseDilations();
  ::mlir::Attribute getWindowDilationsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_dilations);
    return attr;
  }

  ::mlir::Attribute getWindowDilations();
  ::mlir::Attribute getPaddingAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().padding);
    return attr;
  }

  ::mlir::Attribute getPadding();
  ::mlir::Region &getBody() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class ReduceWindowOpV1GenericAdaptor : public detail::ReduceWindowOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReduceWindowOpV1GenericAdaptorBase;
public:
  ReduceWindowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReduceWindowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReduceWindowOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ReduceWindowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ReduceWindowOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ReduceWindowOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReduceWindowOpV1>>>
  ReduceWindowOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getInitValues() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReduceWindowOpV1Adaptor : public ReduceWindowOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReduceWindowOpV1GenericAdaptor::ReduceWindowOpV1GenericAdaptor;
  ReduceWindowOpV1Adaptor(ReduceWindowOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReduceWindowOpV1 : public ::mlir::Op<ReduceWindowOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::vhlo::VersionedOpConstraintInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceWindowOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReduceWindowOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("base_dilations"), ::llvm::StringRef("padding"), ::llvm::StringRef("window_dilations"), ::llvm::StringRef("window_dimensions"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBaseDilationsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBaseDilationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getWindowDilationsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getWindowDilationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getWindowDimensionsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getWindowDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_window_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getInitValues() {
    return getODSOperands(1);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::MutableOperandRange getInitValuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getBody() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getWindowDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_dimensions);
  }

  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getBaseDilationsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().base_dilations);
  }

  ::mlir::Attribute getBaseDilations();
  ::mlir::Attribute getWindowDilationsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_dilations);
  }

  ::mlir::Attribute getWindowDilations();
  ::mlir::Attribute getPaddingAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().padding);
  }

  ::mlir::Attribute getPadding();
  void setWindowDimensionsAttr(::mlir::Attribute attr) {
    getProperties().window_dimensions = attr;
  }

  void setWindowStridesAttr(::mlir::Attribute attr) {
    getProperties().window_strides = attr;
  }

  void setBaseDilationsAttr(::mlir::Attribute attr) {
    getProperties().base_dilations = attr;
  }

  void setWindowDilationsAttr(::mlir::Attribute attr) {
    getProperties().window_dilations = attr;
  }

  void setPaddingAttr(::mlir::Attribute attr) {
    getProperties().padding = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::ValueRange init_values, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute base_dilations, ::mlir::Attribute window_dilations, ::mlir::Attribute padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  mlir::LogicalResult validateConstraint(mlir::Operation*op, mlir::vhlo::Version targetVersion);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceWindowOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RemOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RemOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RemOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.remainder_v1", odsAttrs.getContext());
  }

  RemOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class RemOpV1GenericAdaptor : public detail::RemOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RemOpV1GenericAdaptorBase;
public:
  RemOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RemOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RemOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RemOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RemOpV1>>>
  RemOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RemOpV1Adaptor : public RemOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RemOpV1GenericAdaptor::RemOpV1GenericAdaptor;
  RemOpV1Adaptor(RemOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RemOpV1 : public ::mlir::Op<RemOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RemOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RemOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.remainder_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RemOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReplicaIdOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReplicaIdOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReplicaIdOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.replica_id_v1", odsAttrs.getContext());
  }

  ReplicaIdOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ReplicaIdOpV1GenericAdaptor : public detail::ReplicaIdOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReplicaIdOpV1GenericAdaptorBase;
public:
  ReplicaIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReplicaIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReplicaIdOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReplicaIdOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReplicaIdOpV1>>>
  ReplicaIdOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReplicaIdOpV1Adaptor : public ReplicaIdOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReplicaIdOpV1GenericAdaptor::ReplicaIdOpV1GenericAdaptor;
  ReplicaIdOpV1Adaptor(ReplicaIdOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReplicaIdOpV1 : public ::mlir::Op<ReplicaIdOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReplicaIdOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReplicaIdOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.replica_id_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReplicaIdOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReshapeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReshapeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReshapeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.reshape_v1", odsAttrs.getContext());
  }

  ReshapeOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ReshapeOpV1GenericAdaptor : public detail::ReshapeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReshapeOpV1GenericAdaptorBase;
public:
  ReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReshapeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReshapeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReshapeOpV1>>>
  ReshapeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReshapeOpV1Adaptor : public ReshapeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReshapeOpV1GenericAdaptor::ReshapeOpV1GenericAdaptor;
  ReshapeOpV1Adaptor(ReshapeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReshapeOpV1 : public ::mlir::Op<ReshapeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReshapeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReshapeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reshape_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReshapeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReturnOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReturnOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReturnOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.return_v1", odsAttrs.getContext());
  }

  ReturnOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ReturnOpV1GenericAdaptor : public detail::ReturnOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReturnOpV1GenericAdaptorBase;
public:
  ReturnOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReturnOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReturnOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReturnOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReturnOpV1>>>
  ReturnOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getResults() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReturnOpV1Adaptor : public ReturnOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReturnOpV1GenericAdaptor::ReturnOpV1GenericAdaptor;
  ReturnOpV1Adaptor(ReturnOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReturnOpV1 : public ::mlir::Op<ReturnOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpTrait::IsTerminator> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReturnOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReturnOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.return_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getResults() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getResultsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange results);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReturnOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReverseOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReverseOpV1GenericAdaptorBase {
public:
  struct Properties {
    using dimensionsTy = ::mlir::Attribute;
    dimensionsTy dimensions;

    auto getDimensions() {
      auto &propStorage = this->dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDimensions(const ::mlir::Attribute &propValue) {
      this->dimensions = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dimensions == this->dimensions &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ReverseOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.reverse_v1", odsAttrs.getContext());
  }

  ReverseOpV1GenericAdaptorBase(ReverseOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dimensions);
    return attr;
  }

  ::mlir::Attribute getDimensions();
};
} // namespace detail
template <typename RangeT>
class ReverseOpV1GenericAdaptor : public detail::ReverseOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReverseOpV1GenericAdaptorBase;
public:
  ReverseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReverseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReverseOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ReverseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ReverseOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ReverseOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReverseOpV1>>>
  ReverseOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReverseOpV1Adaptor : public ReverseOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReverseOpV1GenericAdaptor::ReverseOpV1GenericAdaptor;
  ReverseOpV1Adaptor(ReverseOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ReverseOpV1 : public ::mlir::Op<ReverseOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReverseOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReverseOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reverse_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dimensions);
  }

  ::mlir::Attribute getDimensions();
  void setDimensionsAttr(::mlir::Attribute attr) {
    getProperties().dimensions = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReverseOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RngBitGeneratorOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RngBitGeneratorOpV1GenericAdaptorBase {
public:
  struct Properties {
    using rng_algorithmTy = ::mlir::Attribute;
    rng_algorithmTy rng_algorithm;

    auto getRngAlgorithm() {
      auto &propStorage = this->rng_algorithm;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRngAlgorithm(const ::mlir::Attribute &propValue) {
      this->rng_algorithm = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.rng_algorithm == this->rng_algorithm &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  RngBitGeneratorOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.rng_bit_generator_v1", odsAttrs.getContext());
  }

  RngBitGeneratorOpV1GenericAdaptorBase(RngBitGeneratorOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getRngAlgorithmAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rng_algorithm);
    return attr;
  }

  ::mlir::Attribute getRngAlgorithm();
};
} // namespace detail
template <typename RangeT>
class RngBitGeneratorOpV1GenericAdaptor : public detail::RngBitGeneratorOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RngBitGeneratorOpV1GenericAdaptorBase;
public:
  RngBitGeneratorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RngBitGeneratorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RngBitGeneratorOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  RngBitGeneratorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : RngBitGeneratorOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = RngBitGeneratorOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RngBitGeneratorOpV1>>>
  RngBitGeneratorOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getInitialState() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RngBitGeneratorOpV1Adaptor : public RngBitGeneratorOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RngBitGeneratorOpV1GenericAdaptor::RngBitGeneratorOpV1GenericAdaptor;
  RngBitGeneratorOpV1Adaptor(RngBitGeneratorOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RngBitGeneratorOpV1 : public ::mlir::Op<RngBitGeneratorOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RngBitGeneratorOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RngBitGeneratorOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("rng_algorithm")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getRngAlgorithmAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getRngAlgorithmAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.rng_bit_generator_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getInitialState() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getInitialStateMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOutputState() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOutput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(1).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getRngAlgorithmAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rng_algorithm);
  }

  ::mlir::Attribute getRngAlgorithm();
  void setRngAlgorithmAttr(::mlir::Attribute attr) {
    getProperties().rng_algorithm = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_state, ::mlir::Type output, ::mlir::Attribute rng_algorithm, ::mlir::Value initial_state);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute rng_algorithm, ::mlir::Value initial_state);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RngBitGeneratorOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RngOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RngOpV1GenericAdaptorBase {
public:
  struct Properties {
    using rng_distributionTy = ::mlir::Attribute;
    rng_distributionTy rng_distribution;

    auto getRngDistribution() {
      auto &propStorage = this->rng_distribution;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRngDistribution(const ::mlir::Attribute &propValue) {
      this->rng_distribution = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.rng_distribution == this->rng_distribution &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  RngOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.rng_v1", odsAttrs.getContext());
  }

  RngOpV1GenericAdaptorBase(RngOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getRngDistributionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rng_distribution);
    return attr;
  }

  ::mlir::Attribute getRngDistribution();
};
} // namespace detail
template <typename RangeT>
class RngOpV1GenericAdaptor : public detail::RngOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RngOpV1GenericAdaptorBase;
public:
  RngOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RngOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RngOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  RngOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : RngOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = RngOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RngOpV1>>>
  RngOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getA() {
    return (*getODSOperands(0).begin());
  }

  ValueT getB() {
    return (*getODSOperands(1).begin());
  }

  ValueT getShape() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RngOpV1Adaptor : public RngOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RngOpV1GenericAdaptor::RngOpV1GenericAdaptor;
  RngOpV1Adaptor(RngOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RngOpV1 : public ::mlir::Op<RngOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RngOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RngOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("rng_distribution")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getRngDistributionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getRngDistributionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.rng_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getA() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getB() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getShape() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getAMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getBMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getShapeMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getRngDistributionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rng_distribution);
  }

  ::mlir::Attribute getRngDistribution();
  void setRngDistributionAttr(::mlir::Attribute attr) {
    getProperties().rng_distribution = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Value b, ::mlir::Value shape, ::mlir::Attribute rng_distribution);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Value shape, ::mlir::Attribute rng_distribution);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RngOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RoundNearestEvenOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RoundNearestEvenOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RoundNearestEvenOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.round_nearest_even_v1", odsAttrs.getContext());
  }

  RoundNearestEvenOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class RoundNearestEvenOpV1GenericAdaptor : public detail::RoundNearestEvenOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RoundNearestEvenOpV1GenericAdaptorBase;
public:
  RoundNearestEvenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RoundNearestEvenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RoundNearestEvenOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RoundNearestEvenOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RoundNearestEvenOpV1>>>
  RoundNearestEvenOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RoundNearestEvenOpV1Adaptor : public RoundNearestEvenOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RoundNearestEvenOpV1GenericAdaptor::RoundNearestEvenOpV1GenericAdaptor;
  RoundNearestEvenOpV1Adaptor(RoundNearestEvenOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RoundNearestEvenOpV1 : public ::mlir::Op<RoundNearestEvenOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RoundNearestEvenOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RoundNearestEvenOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.round_nearest_even_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RoundNearestEvenOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RoundOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RoundOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RoundOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.round_nearest_afz_v1", odsAttrs.getContext());
  }

  RoundOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class RoundOpV1GenericAdaptor : public detail::RoundOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RoundOpV1GenericAdaptorBase;
public:
  RoundOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RoundOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RoundOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RoundOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RoundOpV1>>>
  RoundOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RoundOpV1Adaptor : public RoundOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RoundOpV1GenericAdaptor::RoundOpV1GenericAdaptor;
  RoundOpV1Adaptor(RoundOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RoundOpV1 : public ::mlir::Op<RoundOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RoundOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RoundOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.round_nearest_afz_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RoundOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RsqrtOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RsqrtOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RsqrtOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.rsqrt_v1", odsAttrs.getContext());
  }

  RsqrtOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class RsqrtOpV1GenericAdaptor : public detail::RsqrtOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RsqrtOpV1GenericAdaptorBase;
public:
  RsqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RsqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RsqrtOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RsqrtOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RsqrtOpV1>>>
  RsqrtOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RsqrtOpV1Adaptor : public RsqrtOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RsqrtOpV1GenericAdaptor::RsqrtOpV1GenericAdaptor;
  RsqrtOpV1Adaptor(RsqrtOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class RsqrtOpV1 : public ::mlir::Op<RsqrtOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RsqrtOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RsqrtOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.rsqrt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RsqrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ScatterOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ScatterOpV1GenericAdaptorBase {
public:
  struct Properties {
    using index_vector_dimTy = ::mlir::Attribute;
    index_vector_dimTy index_vector_dim;

    auto getIndexVectorDim() {
      auto &propStorage = this->index_vector_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndexVectorDim(const ::mlir::Attribute &propValue) {
      this->index_vector_dim = propValue;
    }
    using indices_are_sortedTy = ::mlir::Attribute;
    indices_are_sortedTy indices_are_sorted;

    auto getIndicesAreSorted() {
      auto &propStorage = this->indices_are_sorted;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndicesAreSorted(const ::mlir::Attribute &propValue) {
      this->indices_are_sorted = propValue;
    }
    using inserted_window_dimsTy = ::mlir::Attribute;
    inserted_window_dimsTy inserted_window_dims;

    auto getInsertedWindowDims() {
      auto &propStorage = this->inserted_window_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInsertedWindowDims(const ::mlir::Attribute &propValue) {
      this->inserted_window_dims = propValue;
    }
    using scatter_dims_to_operand_dimsTy = ::mlir::Attribute;
    scatter_dims_to_operand_dimsTy scatter_dims_to_operand_dims;

    auto getScatterDimsToOperandDims() {
      auto &propStorage = this->scatter_dims_to_operand_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setScatterDimsToOperandDims(const ::mlir::Attribute &propValue) {
      this->scatter_dims_to_operand_dims = propValue;
    }
    using unique_indicesTy = ::mlir::Attribute;
    unique_indicesTy unique_indices;

    auto getUniqueIndices() {
      auto &propStorage = this->unique_indices;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUniqueIndices(const ::mlir::Attribute &propValue) {
      this->unique_indices = propValue;
    }
    using update_window_dimsTy = ::mlir::Attribute;
    update_window_dimsTy update_window_dims;

    auto getUpdateWindowDims() {
      auto &propStorage = this->update_window_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUpdateWindowDims(const ::mlir::Attribute &propValue) {
      this->update_window_dims = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.index_vector_dim == this->index_vector_dim &&
        rhs.indices_are_sorted == this->indices_are_sorted &&
        rhs.inserted_window_dims == this->inserted_window_dims &&
        rhs.scatter_dims_to_operand_dims == this->scatter_dims_to_operand_dims &&
        rhs.unique_indices == this->unique_indices &&
        rhs.update_window_dims == this->update_window_dims &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ScatterOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.scatter_v1", odsAttrs.getContext());
  }

  ScatterOpV1GenericAdaptorBase(ScatterOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getUpdateWindowDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().update_window_dims);
    return attr;
  }

  ::mlir::Attribute getUpdateWindowDims();
  ::mlir::Attribute getInsertedWindowDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().inserted_window_dims);
    return attr;
  }

  ::mlir::Attribute getInsertedWindowDims();
  ::mlir::Attribute getScatterDimsToOperandDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().scatter_dims_to_operand_dims);
    return attr;
  }

  ::mlir::Attribute getScatterDimsToOperandDims();
  ::mlir::Attribute getIndexVectorDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
    return attr;
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
    return attr;
  }

  ::mlir::Attribute getIndicesAreSorted();
  ::mlir::Attribute getUniqueIndicesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().unique_indices);
    return attr;
  }

  ::mlir::Attribute getUniqueIndices();
  ::mlir::Region &getUpdateComputation() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class ScatterOpV1GenericAdaptor : public detail::ScatterOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ScatterOpV1GenericAdaptorBase;
public:
  ScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ScatterOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ScatterOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ScatterOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ScatterOpV1>>>
  ScatterOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  ValueT getScatterIndices() {
    return (*getODSOperands(1).begin());
  }

  RangeT getUpdates() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ScatterOpV1Adaptor : public ScatterOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ScatterOpV1GenericAdaptor::ScatterOpV1GenericAdaptor;
  ScatterOpV1Adaptor(ScatterOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ScatterOpV1 : public ::mlir::Op<ScatterOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::vhlo::VersionedOpConstraintInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ScatterOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ScatterOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("inserted_window_dims"), ::llvm::StringRef("scatter_dims_to_operand_dims"), ::llvm::StringRef("unique_indices"), ::llvm::StringRef("update_window_dims")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInsertedWindowDimsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInsertedWindowDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getScatterDimsToOperandDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getScatterDimsToOperandDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getUniqueIndicesAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getUniqueIndicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getUpdateWindowDimsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getUpdateWindowDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.scatter_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::Type> getScatterIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::Operation::operand_range getUpdates() {
    return getODSOperands(2);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::OpOperand &getScatterIndicesMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::MutableOperandRange getUpdatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getUpdateComputation() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getUpdateWindowDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().update_window_dims);
  }

  ::mlir::Attribute getUpdateWindowDims();
  ::mlir::Attribute getInsertedWindowDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().inserted_window_dims);
  }

  ::mlir::Attribute getInsertedWindowDims();
  ::mlir::Attribute getScatterDimsToOperandDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().scatter_dims_to_operand_dims);
  }

  ::mlir::Attribute getScatterDimsToOperandDims();
  ::mlir::Attribute getIndexVectorDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
  }

  ::mlir::Attribute getIndicesAreSorted();
  ::mlir::Attribute getUniqueIndicesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().unique_indices);
  }

  ::mlir::Attribute getUniqueIndices();
  void setUpdateWindowDimsAttr(::mlir::Attribute attr) {
    getProperties().update_window_dims = attr;
  }

  void setInsertedWindowDimsAttr(::mlir::Attribute attr) {
    getProperties().inserted_window_dims = attr;
  }

  void setScatterDimsToOperandDimsAttr(::mlir::Attribute attr) {
    getProperties().scatter_dims_to_operand_dims = attr;
  }

  void setIndexVectorDimAttr(::mlir::Attribute attr) {
    getProperties().index_vector_dim = attr;
  }

  void setIndicesAreSortedAttr(::mlir::Attribute attr) {
    getProperties().indices_are_sorted = attr;
  }

  void setUniqueIndicesAttr(::mlir::Attribute attr) {
    getProperties().unique_indices = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Value scatter_indices, ::mlir::ValueRange updates, ::mlir::Attribute update_window_dims, ::mlir::Attribute inserted_window_dims, ::mlir::Attribute scatter_dims_to_operand_dims, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted, ::mlir::Attribute unique_indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  mlir::LogicalResult validateConstraint(mlir::Operation*op, mlir::vhlo::Version targetVersion);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 6 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ScatterOpV2 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ScatterOpV2GenericAdaptorBase {
public:
  struct Properties {
    using index_vector_dimTy = ::mlir::Attribute;
    index_vector_dimTy index_vector_dim;

    auto getIndexVectorDim() {
      auto &propStorage = this->index_vector_dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndexVectorDim(const ::mlir::Attribute &propValue) {
      this->index_vector_dim = propValue;
    }
    using indices_are_sortedTy = ::mlir::Attribute;
    indices_are_sortedTy indices_are_sorted;

    auto getIndicesAreSorted() {
      auto &propStorage = this->indices_are_sorted;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIndicesAreSorted(const ::mlir::Attribute &propValue) {
      this->indices_are_sorted = propValue;
    }
    using input_batching_dimsTy = ::mlir::Attribute;
    input_batching_dimsTy input_batching_dims;

    auto getInputBatchingDims() {
      auto &propStorage = this->input_batching_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInputBatchingDims(const ::mlir::Attribute &propValue) {
      this->input_batching_dims = propValue;
    }
    using inserted_window_dimsTy = ::mlir::Attribute;
    inserted_window_dimsTy inserted_window_dims;

    auto getInsertedWindowDims() {
      auto &propStorage = this->inserted_window_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setInsertedWindowDims(const ::mlir::Attribute &propValue) {
      this->inserted_window_dims = propValue;
    }
    using scatter_dims_to_operand_dimsTy = ::mlir::Attribute;
    scatter_dims_to_operand_dimsTy scatter_dims_to_operand_dims;

    auto getScatterDimsToOperandDims() {
      auto &propStorage = this->scatter_dims_to_operand_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setScatterDimsToOperandDims(const ::mlir::Attribute &propValue) {
      this->scatter_dims_to_operand_dims = propValue;
    }
    using scatter_indices_batching_dimsTy = ::mlir::Attribute;
    scatter_indices_batching_dimsTy scatter_indices_batching_dims;

    auto getScatterIndicesBatchingDims() {
      auto &propStorage = this->scatter_indices_batching_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setScatterIndicesBatchingDims(const ::mlir::Attribute &propValue) {
      this->scatter_indices_batching_dims = propValue;
    }
    using unique_indicesTy = ::mlir::Attribute;
    unique_indicesTy unique_indices;

    auto getUniqueIndices() {
      auto &propStorage = this->unique_indices;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUniqueIndices(const ::mlir::Attribute &propValue) {
      this->unique_indices = propValue;
    }
    using update_window_dimsTy = ::mlir::Attribute;
    update_window_dimsTy update_window_dims;

    auto getUpdateWindowDims() {
      auto &propStorage = this->update_window_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUpdateWindowDims(const ::mlir::Attribute &propValue) {
      this->update_window_dims = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.index_vector_dim == this->index_vector_dim &&
        rhs.indices_are_sorted == this->indices_are_sorted &&
        rhs.input_batching_dims == this->input_batching_dims &&
        rhs.inserted_window_dims == this->inserted_window_dims &&
        rhs.scatter_dims_to_operand_dims == this->scatter_dims_to_operand_dims &&
        rhs.scatter_indices_batching_dims == this->scatter_indices_batching_dims &&
        rhs.unique_indices == this->unique_indices &&
        rhs.update_window_dims == this->update_window_dims &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ScatterOpV2GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.scatter_v2", odsAttrs.getContext());
  }

  ScatterOpV2GenericAdaptorBase(ScatterOpV2 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getUpdateWindowDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().update_window_dims);
    return attr;
  }

  ::mlir::Attribute getUpdateWindowDims();
  ::mlir::Attribute getInsertedWindowDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().inserted_window_dims);
    return attr;
  }

  ::mlir::Attribute getInsertedWindowDims();
  ::mlir::Attribute getInputBatchingDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().input_batching_dims);
    return attr;
  }

  ::mlir::Attribute getInputBatchingDims();
  ::mlir::Attribute getScatterIndicesBatchingDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().scatter_indices_batching_dims);
    return attr;
  }

  ::mlir::Attribute getScatterIndicesBatchingDims();
  ::mlir::Attribute getScatterDimsToOperandDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().scatter_dims_to_operand_dims);
    return attr;
  }

  ::mlir::Attribute getScatterDimsToOperandDims();
  ::mlir::Attribute getIndexVectorDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
    return attr;
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
    return attr;
  }

  ::mlir::Attribute getIndicesAreSorted();
  ::mlir::Attribute getUniqueIndicesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().unique_indices);
    return attr;
  }

  ::mlir::Attribute getUniqueIndices();
  ::mlir::Region &getUpdateComputation() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class ScatterOpV2GenericAdaptor : public detail::ScatterOpV2GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ScatterOpV2GenericAdaptorBase;
public:
  ScatterOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ScatterOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ScatterOpV2GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  ScatterOpV2GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : ScatterOpV2GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = ScatterOpV2, typename = std::enable_if_t<std::is_same_v<LateInst, ScatterOpV2>>>
  ScatterOpV2GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  ValueT getScatterIndices() {
    return (*getODSOperands(1).begin());
  }

  RangeT getUpdates() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ScatterOpV2Adaptor : public ScatterOpV2GenericAdaptor<::mlir::ValueRange> {
public:
  using ScatterOpV2GenericAdaptor::ScatterOpV2GenericAdaptor;
  ScatterOpV2Adaptor(ScatterOpV2 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ScatterOpV2 : public ::mlir::Op<ScatterOpV2, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ScatterOpV2Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ScatterOpV2GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("input_batching_dims"), ::llvm::StringRef("inserted_window_dims"), ::llvm::StringRef("scatter_dims_to_operand_dims"), ::llvm::StringRef("scatter_indices_batching_dims"), ::llvm::StringRef("unique_indices"), ::llvm::StringRef("update_window_dims")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInputBatchingDimsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInputBatchingDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getInsertedWindowDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getInsertedWindowDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getScatterDimsToOperandDimsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getScatterDimsToOperandDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getScatterIndicesBatchingDimsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getScatterIndicesBatchingDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getUniqueIndicesAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getUniqueIndicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getUpdateWindowDimsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getUpdateWindowDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.scatter_v2");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::Type> getScatterIndices() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::Operation::operand_range getUpdates() {
    return getODSOperands(2);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::OpOperand &getScatterIndicesMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::MutableOperandRange getUpdatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getUpdateComputation() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getUpdateWindowDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().update_window_dims);
  }

  ::mlir::Attribute getUpdateWindowDims();
  ::mlir::Attribute getInsertedWindowDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().inserted_window_dims);
  }

  ::mlir::Attribute getInsertedWindowDims();
  ::mlir::Attribute getInputBatchingDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().input_batching_dims);
  }

  ::mlir::Attribute getInputBatchingDims();
  ::mlir::Attribute getScatterIndicesBatchingDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().scatter_indices_batching_dims);
  }

  ::mlir::Attribute getScatterIndicesBatchingDims();
  ::mlir::Attribute getScatterDimsToOperandDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().scatter_dims_to_operand_dims);
  }

  ::mlir::Attribute getScatterDimsToOperandDims();
  ::mlir::Attribute getIndexVectorDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().index_vector_dim);
  }

  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().indices_are_sorted);
  }

  ::mlir::Attribute getIndicesAreSorted();
  ::mlir::Attribute getUniqueIndicesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().unique_indices);
  }

  ::mlir::Attribute getUniqueIndices();
  void setUpdateWindowDimsAttr(::mlir::Attribute attr) {
    getProperties().update_window_dims = attr;
  }

  void setInsertedWindowDimsAttr(::mlir::Attribute attr) {
    getProperties().inserted_window_dims = attr;
  }

  void setInputBatchingDimsAttr(::mlir::Attribute attr) {
    getProperties().input_batching_dims = attr;
  }

  void setScatterIndicesBatchingDimsAttr(::mlir::Attribute attr) {
    getProperties().scatter_indices_batching_dims = attr;
  }

  void setScatterDimsToOperandDimsAttr(::mlir::Attribute attr) {
    getProperties().scatter_dims_to_operand_dims = attr;
  }

  void setIndexVectorDimAttr(::mlir::Attribute attr) {
    getProperties().index_vector_dim = attr;
  }

  void setIndicesAreSortedAttr(::mlir::Attribute attr) {
    getProperties().indices_are_sorted = attr;
  }

  void setUniqueIndicesAttr(::mlir::Attribute attr) {
    getProperties().unique_indices = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Value scatter_indices, ::mlir::ValueRange updates, ::mlir::Attribute update_window_dims, ::mlir::Attribute inserted_window_dims, ::mlir::Attribute input_batching_dims, ::mlir::Attribute scatter_indices_batching_dims, ::mlir::Attribute scatter_dims_to_operand_dims, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted, ::mlir::Attribute unique_indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 8 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ScatterOpV2)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SelectAndScatterOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SelectAndScatterOpV1GenericAdaptorBase {
public:
  struct Properties {
    using paddingTy = ::mlir::Attribute;
    paddingTy padding;

    auto getPadding() {
      auto &propStorage = this->padding;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPadding(const ::mlir::Attribute &propValue) {
      this->padding = propValue;
    }
    using window_dimensionsTy = ::mlir::Attribute;
    window_dimensionsTy window_dimensions;

    auto getWindowDimensions() {
      auto &propStorage = this->window_dimensions;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowDimensions(const ::mlir::Attribute &propValue) {
      this->window_dimensions = propValue;
    }
    using window_stridesTy = ::mlir::Attribute;
    window_stridesTy window_strides;

    auto getWindowStrides() {
      auto &propStorage = this->window_strides;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setWindowStrides(const ::mlir::Attribute &propValue) {
      this->window_strides = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.padding == this->padding &&
        rhs.window_dimensions == this->window_dimensions &&
        rhs.window_strides == this->window_strides &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SelectAndScatterOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.select_and_scatter_v1", odsAttrs.getContext());
  }

  SelectAndScatterOpV1GenericAdaptorBase(SelectAndScatterOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getWindowDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_dimensions);
    return attr;
  }

  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
    return attr;
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().padding);
    return attr;
  }

  ::mlir::Attribute getPadding();
  ::mlir::Region &getSelect() {
    return *odsRegions[0];
  }

  ::mlir::Region &getScatter() {
    return *odsRegions[1];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class SelectAndScatterOpV1GenericAdaptor : public detail::SelectAndScatterOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SelectAndScatterOpV1GenericAdaptorBase;
public:
  SelectAndScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SelectAndScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SelectAndScatterOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SelectAndScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : SelectAndScatterOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SelectAndScatterOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SelectAndScatterOpV1>>>
  SelectAndScatterOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getSource() {
    return (*getODSOperands(1).begin());
  }

  ValueT getInitValue() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SelectAndScatterOpV1Adaptor : public SelectAndScatterOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SelectAndScatterOpV1GenericAdaptor::SelectAndScatterOpV1GenericAdaptor;
  SelectAndScatterOpV1Adaptor(SelectAndScatterOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SelectAndScatterOpV1 : public ::mlir::Op<SelectAndScatterOpV1, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::vhlo::VersionedOpConstraintInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SelectAndScatterOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SelectAndScatterOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("padding"), ::llvm::StringRef("window_dimensions"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getWindowDimensionsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getWindowDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.select_and_scatter_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getSource() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getInitValue() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getSourceMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getInitValueMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  ::mlir::Region &getSelect() {
    return (*this)->getRegion(0);
  }

  ::mlir::Region &getScatter() {
    return (*this)->getRegion(1);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getWindowDimensionsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_dimensions);
  }

  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().window_strides);
  }

  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().padding);
  }

  ::mlir::Attribute getPadding();
  void setWindowDimensionsAttr(::mlir::Attribute attr) {
    getProperties().window_dimensions = attr;
  }

  void setWindowStridesAttr(::mlir::Attribute attr) {
    getProperties().window_strides = attr;
  }

  void setPaddingAttr(::mlir::Attribute attr) {
    getProperties().padding = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value source, ::mlir::Value init_value, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute padding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value source, ::mlir::Value init_value, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  mlir::LogicalResult validateConstraint(mlir::Operation*op, mlir::vhlo::Version targetVersion);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SelectAndScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SelectOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SelectOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SelectOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.select_v1", odsAttrs.getContext());
  }

  SelectOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class SelectOpV1GenericAdaptor : public detail::SelectOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SelectOpV1GenericAdaptorBase;
public:
  SelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SelectOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SelectOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SelectOpV1>>>
  SelectOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getPred() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOnTrue() {
    return (*getODSOperands(1).begin());
  }

  ValueT getOnFalse() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SelectOpV1Adaptor : public SelectOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SelectOpV1GenericAdaptor::SelectOpV1GenericAdaptor;
  SelectOpV1Adaptor(SelectOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SelectOpV1 : public ::mlir::Op<SelectOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SelectOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SelectOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.select_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getPred() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOnTrue() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getOnFalse() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getPredMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getOnTrueMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getOnFalseMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pred, ::mlir::Value on_true, ::mlir::Value on_false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pred, ::mlir::Value on_true, ::mlir::Value on_false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SelectOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SendOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SendOpV1GenericAdaptorBase {
public:
  struct Properties {
    using channel_idTy = ::mlir::Attribute;
    channel_idTy channel_id;

    auto getChannelId() {
      auto &propStorage = this->channel_id;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelId(const ::mlir::Attribute &propValue) {
      this->channel_id = propValue;
    }
    using channel_typeTy = ::mlir::Attribute;
    channel_typeTy channel_type;

    auto getChannelType() {
      auto &propStorage = this->channel_type;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setChannelType(const ::mlir::Attribute &propValue) {
      this->channel_type = propValue;
    }
    using is_host_transferTy = ::mlir::Attribute;
    is_host_transferTy is_host_transfer;

    auto getIsHostTransfer() {
      auto &propStorage = this->is_host_transfer;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIsHostTransfer(const ::mlir::Attribute &propValue) {
      this->is_host_transfer = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id == this->channel_id &&
        rhs.channel_type == this->channel_type &&
        rhs.is_host_transfer == this->is_host_transfer &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SendOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.send_v1", odsAttrs.getContext());
  }

  SendOpV1GenericAdaptorBase(SendOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getChannelIdAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
    return attr;
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().channel_type);
    return attr;
  }

  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().is_host_transfer);
    return attr;
  }

  ::mlir::Attribute getIsHostTransfer();
};
} // namespace detail
template <typename RangeT>
class SendOpV1GenericAdaptor : public detail::SendOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SendOpV1GenericAdaptorBase;
public:
  SendOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SendOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SendOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SendOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : SendOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SendOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SendOpV1>>>
  SendOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  ValueT getToken() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SendOpV1Adaptor : public SendOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SendOpV1GenericAdaptor::SendOpV1GenericAdaptor;
  SendOpV1Adaptor(SendOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SendOpV1 : public ::mlir::Op<SendOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SendOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SendOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("channel_type"), ::llvm::StringRef("is_host_transfer")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getChannelTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getChannelTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIsHostTransferAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIsHostTransferAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.send_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::TypedValue<::mlir::Type> getToken() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::OpOperand &getTokenMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getChannelIdAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_id);
  }

  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().channel_type);
  }

  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().is_host_transfer);
  }

  ::mlir::Attribute getIsHostTransfer();
  void setChannelIdAttr(::mlir::Attribute attr) {
    getProperties().channel_id = attr;
  }

  void setChannelTypeAttr(::mlir::Attribute attr) {
    getProperties().channel_type = attr;
  }

  void setIsHostTransferAttr(::mlir::Attribute attr) {
    getProperties().is_host_transfer = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SendOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SetDimensionSizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SetDimensionSizeOpV1GenericAdaptorBase {
public:
  struct Properties {
    using dimensionTy = ::mlir::Attribute;
    dimensionTy dimension;

    auto getDimension() {
      auto &propStorage = this->dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDimension(const ::mlir::Attribute &propValue) {
      this->dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dimension == this->dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SetDimensionSizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.set_dimension_size_v1", odsAttrs.getContext());
  }

  SetDimensionSizeOpV1GenericAdaptorBase(SetDimensionSizeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
    return attr;
  }

  ::mlir::Attribute getDimension();
};
} // namespace detail
template <typename RangeT>
class SetDimensionSizeOpV1GenericAdaptor : public detail::SetDimensionSizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SetDimensionSizeOpV1GenericAdaptorBase;
public:
  SetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SetDimensionSizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : SetDimensionSizeOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SetDimensionSizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SetDimensionSizeOpV1>>>
  SetDimensionSizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getSize() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SetDimensionSizeOpV1Adaptor : public SetDimensionSizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SetDimensionSizeOpV1GenericAdaptor::SetDimensionSizeOpV1GenericAdaptor;
  SetDimensionSizeOpV1Adaptor(SetDimensionSizeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SetDimensionSizeOpV1 : public ::mlir::Op<SetDimensionSizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SetDimensionSizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SetDimensionSizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.set_dimension_size_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getSize() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getSizeMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
  }

  ::mlir::Attribute getDimension();
  void setDimensionAttr(::mlir::Attribute attr) {
    getProperties().dimension = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value size, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value size, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SetDimensionSizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftLeftOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ShiftLeftOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ShiftLeftOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.shift_left_v1", odsAttrs.getContext());
  }

  ShiftLeftOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ShiftLeftOpV1GenericAdaptor : public detail::ShiftLeftOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ShiftLeftOpV1GenericAdaptorBase;
public:
  ShiftLeftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ShiftLeftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ShiftLeftOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ShiftLeftOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ShiftLeftOpV1>>>
  ShiftLeftOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ShiftLeftOpV1Adaptor : public ShiftLeftOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ShiftLeftOpV1GenericAdaptor::ShiftLeftOpV1GenericAdaptor;
  ShiftLeftOpV1Adaptor(ShiftLeftOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ShiftLeftOpV1 : public ::mlir::Op<ShiftLeftOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShiftLeftOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ShiftLeftOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.shift_left_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftLeftOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftRightArithmeticOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ShiftRightArithmeticOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ShiftRightArithmeticOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.shift_right_arithmetic_v1", odsAttrs.getContext());
  }

  ShiftRightArithmeticOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ShiftRightArithmeticOpV1GenericAdaptor : public detail::ShiftRightArithmeticOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ShiftRightArithmeticOpV1GenericAdaptorBase;
public:
  ShiftRightArithmeticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ShiftRightArithmeticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ShiftRightArithmeticOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ShiftRightArithmeticOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ShiftRightArithmeticOpV1>>>
  ShiftRightArithmeticOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ShiftRightArithmeticOpV1Adaptor : public ShiftRightArithmeticOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ShiftRightArithmeticOpV1GenericAdaptor::ShiftRightArithmeticOpV1GenericAdaptor;
  ShiftRightArithmeticOpV1Adaptor(ShiftRightArithmeticOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ShiftRightArithmeticOpV1 : public ::mlir::Op<ShiftRightArithmeticOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShiftRightArithmeticOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ShiftRightArithmeticOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.shift_right_arithmetic_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftRightArithmeticOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftRightLogicalOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ShiftRightLogicalOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ShiftRightLogicalOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.shift_right_logical_v1", odsAttrs.getContext());
  }

  ShiftRightLogicalOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ShiftRightLogicalOpV1GenericAdaptor : public detail::ShiftRightLogicalOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ShiftRightLogicalOpV1GenericAdaptorBase;
public:
  ShiftRightLogicalOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ShiftRightLogicalOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ShiftRightLogicalOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ShiftRightLogicalOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ShiftRightLogicalOpV1>>>
  ShiftRightLogicalOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ShiftRightLogicalOpV1Adaptor : public ShiftRightLogicalOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ShiftRightLogicalOpV1GenericAdaptor::ShiftRightLogicalOpV1GenericAdaptor;
  ShiftRightLogicalOpV1Adaptor(ShiftRightLogicalOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class ShiftRightLogicalOpV1 : public ::mlir::Op<ShiftRightLogicalOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShiftRightLogicalOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ShiftRightLogicalOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.shift_right_logical_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftRightLogicalOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SignOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SignOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SignOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.sign_v1", odsAttrs.getContext());
  }

  SignOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class SignOpV1GenericAdaptor : public detail::SignOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SignOpV1GenericAdaptorBase;
public:
  SignOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SignOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SignOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SignOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SignOpV1>>>
  SignOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SignOpV1Adaptor : public SignOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SignOpV1GenericAdaptor::SignOpV1GenericAdaptor;
  SignOpV1Adaptor(SignOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SignOpV1 : public ::mlir::Op<SignOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SignOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SignOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sign_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SignOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SineOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SineOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SineOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.sine_v1", odsAttrs.getContext());
  }

  SineOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class SineOpV1GenericAdaptor : public detail::SineOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SineOpV1GenericAdaptorBase;
public:
  SineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SineOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SineOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SineOpV1>>>
  SineOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SineOpV1Adaptor : public SineOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SineOpV1GenericAdaptor::SineOpV1GenericAdaptor;
  SineOpV1Adaptor(SineOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SineOpV1 : public ::mlir::Op<SineOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SineOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SineOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sine_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SineOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SliceOpV1GenericAdaptorBase {
public:
  struct Properties {
    using limit_indicesTy = ::mlir::Attribute;
    limit_indicesTy limit_indices;

    auto getLimitIndices() {
      auto &propStorage = this->limit_indices;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLimitIndices(const ::mlir::Attribute &propValue) {
      this->limit_indices = propValue;
    }
    using start_indicesTy = ::mlir::Attribute;
    start_indicesTy start_indices;

    auto getStartIndices() {
      auto &propStorage = this->start_indices;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStartIndices(const ::mlir::Attribute &propValue) {
      this->start_indices = propValue;
    }
    using stridesTy = ::mlir::Attribute;
    stridesTy strides;

    auto getStrides() {
      auto &propStorage = this->strides;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setStrides(const ::mlir::Attribute &propValue) {
      this->strides = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.limit_indices == this->limit_indices &&
        rhs.start_indices == this->start_indices &&
        rhs.strides == this->strides &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.slice_v1", odsAttrs.getContext());
  }

  SliceOpV1GenericAdaptorBase(SliceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getStartIndicesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().start_indices);
    return attr;
  }

  ::mlir::Attribute getStartIndices();
  ::mlir::Attribute getLimitIndicesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().limit_indices);
    return attr;
  }

  ::mlir::Attribute getLimitIndices();
  ::mlir::Attribute getStridesAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().strides);
    return attr;
  }

  ::mlir::Attribute getStrides();
};
} // namespace detail
template <typename RangeT>
class SliceOpV1GenericAdaptor : public detail::SliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SliceOpV1GenericAdaptorBase;
public:
  SliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : SliceOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SliceOpV1>>>
  SliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SliceOpV1Adaptor : public SliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SliceOpV1GenericAdaptor::SliceOpV1GenericAdaptor;
  SliceOpV1Adaptor(SliceOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SliceOpV1 : public ::mlir::Op<SliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("limit_indices"), ::llvm::StringRef("start_indices"), ::llvm::StringRef("strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLimitIndicesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLimitIndicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getStartIndicesAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getStartIndicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getStridesAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getStartIndicesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().start_indices);
  }

  ::mlir::Attribute getStartIndices();
  ::mlir::Attribute getLimitIndicesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().limit_indices);
  }

  ::mlir::Attribute getLimitIndices();
  ::mlir::Attribute getStridesAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().strides);
  }

  ::mlir::Attribute getStrides();
  void setStartIndicesAttr(::mlir::Attribute attr) {
    getProperties().start_indices = attr;
  }

  void setLimitIndicesAttr(::mlir::Attribute attr) {
    getProperties().limit_indices = attr;
  }

  void setStridesAttr(::mlir::Attribute attr) {
    getProperties().strides = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute start_indices, ::mlir::Attribute limit_indices, ::mlir::Attribute strides);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute start_indices, ::mlir::Attribute limit_indices, ::mlir::Attribute strides);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SortOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SortOpV1GenericAdaptorBase {
public:
  struct Properties {
    using dimensionTy = ::mlir::Attribute;
    dimensionTy dimension;

    auto getDimension() {
      auto &propStorage = this->dimension;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDimension(const ::mlir::Attribute &propValue) {
      this->dimension = propValue;
    }
    using is_stableTy = ::mlir::Attribute;
    is_stableTy is_stable;

    auto getIsStable() {
      auto &propStorage = this->is_stable;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setIsStable(const ::mlir::Attribute &propValue) {
      this->is_stable = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dimension == this->dimension &&
        rhs.is_stable == this->is_stable &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SortOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.sort_v1", odsAttrs.getContext());
  }

  SortOpV1GenericAdaptorBase(SortOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
    return attr;
  }

  ::mlir::Attribute getDimension();
  ::mlir::Attribute getIsStableAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().is_stable);
    return attr;
  }

  ::mlir::Attribute getIsStable();
  ::mlir::Region &getComparator() {
    return *odsRegions[0];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class SortOpV1GenericAdaptor : public detail::SortOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SortOpV1GenericAdaptorBase;
public:
  SortOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SortOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SortOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  SortOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : SortOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = SortOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SortOpV1>>>
  SortOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SortOpV1Adaptor : public SortOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SortOpV1GenericAdaptor::SortOpV1GenericAdaptor;
  SortOpV1Adaptor(SortOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SortOpV1 : public ::mlir::Op<SortOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SortOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SortOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension"), ::llvm::StringRef("is_stable")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIsStableAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIsStableAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sort_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getInputs() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getComparator() {
    return (*this)->getRegion(0);
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimensionAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dimension);
  }

  ::mlir::Attribute getDimension();
  ::mlir::Attribute getIsStableAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().is_stable);
  }

  ::mlir::Attribute getIsStable();
  void setDimensionAttr(::mlir::Attribute attr) {
    getProperties().dimension = attr;
  }

  void setIsStableAttr(::mlir::Attribute attr) {
    getProperties().is_stable = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute dimension, ::mlir::Attribute is_stable);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SortOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SqrtOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SqrtOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SqrtOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.sqrt_v1", odsAttrs.getContext());
  }

  SqrtOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class SqrtOpV1GenericAdaptor : public detail::SqrtOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SqrtOpV1GenericAdaptorBase;
public:
  SqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SqrtOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SqrtOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SqrtOpV1>>>
  SqrtOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SqrtOpV1Adaptor : public SqrtOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SqrtOpV1GenericAdaptor::SqrtOpV1GenericAdaptor;
  SqrtOpV1Adaptor(SqrtOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SqrtOpV1 : public ::mlir::Op<SqrtOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SqrtOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SqrtOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sqrt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SqrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SubtractOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SubtractOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SubtractOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.subtract_v1", odsAttrs.getContext());
  }

  SubtractOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class SubtractOpV1GenericAdaptor : public detail::SubtractOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SubtractOpV1GenericAdaptorBase;
public:
  SubtractOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SubtractOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SubtractOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SubtractOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SubtractOpV1>>>
  SubtractOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SubtractOpV1Adaptor : public SubtractOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SubtractOpV1GenericAdaptor::SubtractOpV1GenericAdaptor;
  SubtractOpV1Adaptor(SubtractOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class SubtractOpV1 : public ::mlir::Op<SubtractOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SubtractOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SubtractOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.subtract_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SubtractOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TanOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TanOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TanOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.tan_v1", odsAttrs.getContext());
  }

  TanOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class TanOpV1GenericAdaptor : public detail::TanOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TanOpV1GenericAdaptorBase;
public:
  TanOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TanOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TanOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TanOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TanOpV1>>>
  TanOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TanOpV1Adaptor : public TanOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TanOpV1GenericAdaptor::TanOpV1GenericAdaptor;
  TanOpV1Adaptor(TanOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TanOpV1 : public ::mlir::Op<TanOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TanOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TanOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.tan_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TanOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TanhOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TanhOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TanhOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.tanh_v1", odsAttrs.getContext());
  }

  TanhOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class TanhOpV1GenericAdaptor : public detail::TanhOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TanhOpV1GenericAdaptorBase;
public:
  TanhOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TanhOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TanhOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TanhOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TanhOpV1>>>
  TanhOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TanhOpV1Adaptor : public TanhOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TanhOpV1GenericAdaptor::TanhOpV1GenericAdaptor;
  TanhOpV1Adaptor(TanhOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TanhOpV1 : public ::mlir::Op<TanhOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TanhOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TanhOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.tanh_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TanhOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TorchIndexSelectOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TorchIndexSelectOpV1GenericAdaptorBase {
public:
  struct Properties {
    using batch_dimsTy = ::mlir::Attribute;
    batch_dimsTy batch_dims;

    auto getBatchDims() {
      auto &propStorage = this->batch_dims;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setBatchDims(const ::mlir::Attribute &propValue) {
      this->batch_dims = propValue;
    }
    using dimTy = ::mlir::Attribute;
    dimTy dim;

    auto getDim() {
      auto &propStorage = this->dim;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setDim(const ::mlir::Attribute &propValue) {
      this->dim = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.batch_dims == this->batch_dims &&
        rhs.dim == this->dim &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TorchIndexSelectOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.torch_index_select_v1", odsAttrs.getContext());
  }

  TorchIndexSelectOpV1GenericAdaptorBase(TorchIndexSelectOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getDimAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().dim);
    return attr;
  }

  ::mlir::Attribute getDim();
  ::mlir::Attribute getBatchDimsAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().batch_dims);
    return attr;
  }

  ::mlir::Attribute getBatchDims();
};
} // namespace detail
template <typename RangeT>
class TorchIndexSelectOpV1GenericAdaptor : public detail::TorchIndexSelectOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TorchIndexSelectOpV1GenericAdaptorBase;
public:
  TorchIndexSelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TorchIndexSelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TorchIndexSelectOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TorchIndexSelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : TorchIndexSelectOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TorchIndexSelectOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TorchIndexSelectOpV1>>>
  TorchIndexSelectOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getIndex() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TorchIndexSelectOpV1Adaptor : public TorchIndexSelectOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TorchIndexSelectOpV1GenericAdaptor::TorchIndexSelectOpV1GenericAdaptor;
  TorchIndexSelectOpV1Adaptor(TorchIndexSelectOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TorchIndexSelectOpV1 : public ::mlir::Op<TorchIndexSelectOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TorchIndexSelectOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TorchIndexSelectOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_dims"), ::llvm::StringRef("dim")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.torch_index_select_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getIndex() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getIndexMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getDimAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().dim);
  }

  ::mlir::Attribute getDim();
  ::mlir::Attribute getBatchDimsAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().batch_dims);
  }

  ::mlir::Attribute getBatchDims();
  void setDimAttr(::mlir::Attribute attr) {
    getProperties().dim = attr;
  }

  void setBatchDimsAttr(::mlir::Attribute attr) {
    getProperties().batch_dims = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value index, ::mlir::Attribute dim, ::mlir::Attribute batch_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value index, ::mlir::Attribute dim, ::mlir::Attribute batch_dims);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TorchIndexSelectOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TransposeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TransposeOpV1GenericAdaptorBase {
public:
  struct Properties {
    using permutationTy = ::mlir::Attribute;
    permutationTy permutation;

    auto getPermutation() {
      auto &propStorage = this->permutation;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setPermutation(const ::mlir::Attribute &propValue) {
      this->permutation = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.permutation == this->permutation &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TransposeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.transpose_v1", odsAttrs.getContext());
  }

  TransposeOpV1GenericAdaptorBase(TransposeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getPermutationAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().permutation);
    return attr;
  }

  ::mlir::Attribute getPermutation();
};
} // namespace detail
template <typename RangeT>
class TransposeOpV1GenericAdaptor : public detail::TransposeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TransposeOpV1GenericAdaptorBase;
public:
  TransposeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TransposeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TransposeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TransposeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : TransposeOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TransposeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TransposeOpV1>>>
  TransposeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TransposeOpV1Adaptor : public TransposeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TransposeOpV1GenericAdaptor::TransposeOpV1GenericAdaptor;
  TransposeOpV1Adaptor(TransposeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TransposeOpV1 : public ::mlir::Op<TransposeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TransposeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TransposeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("permutation")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPermutationAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPermutationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.transpose_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getPermutationAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().permutation);
  }

  ::mlir::Attribute getPermutation();
  void setPermutationAttr(::mlir::Attribute attr) {
    getProperties().permutation = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute permutation);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute permutation);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TransposeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TriangularSolveOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TriangularSolveOpV1GenericAdaptorBase {
public:
  struct Properties {
    using left_sideTy = ::mlir::Attribute;
    left_sideTy left_side;

    auto getLeftSide() {
      auto &propStorage = this->left_side;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLeftSide(const ::mlir::Attribute &propValue) {
      this->left_side = propValue;
    }
    using lowerTy = ::mlir::Attribute;
    lowerTy lower;

    auto getLower() {
      auto &propStorage = this->lower;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setLower(const ::mlir::Attribute &propValue) {
      this->lower = propValue;
    }
    using transpose_aTy = ::mlir::Attribute;
    transpose_aTy transpose_a;

    auto getTransposeA() {
      auto &propStorage = this->transpose_a;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setTransposeA(const ::mlir::Attribute &propValue) {
      this->transpose_a = propValue;
    }
    using unit_diagonalTy = ::mlir::Attribute;
    unit_diagonalTy unit_diagonal;

    auto getUnitDiagonal() {
      auto &propStorage = this->unit_diagonal;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setUnitDiagonal(const ::mlir::Attribute &propValue) {
      this->unit_diagonal = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.left_side == this->left_side &&
        rhs.lower == this->lower &&
        rhs.transpose_a == this->transpose_a &&
        rhs.unit_diagonal == this->unit_diagonal &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  TriangularSolveOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.triangular_solve_v1", odsAttrs.getContext());
  }

  TriangularSolveOpV1GenericAdaptorBase(TriangularSolveOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getLeftSideAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().left_side);
    return attr;
  }

  ::mlir::Attribute getLeftSide();
  ::mlir::Attribute getLowerAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().lower);
    return attr;
  }

  ::mlir::Attribute getLower();
  ::mlir::Attribute getUnitDiagonalAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().unit_diagonal);
    return attr;
  }

  ::mlir::Attribute getUnitDiagonal();
  ::mlir::Attribute getTransposeAAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().transpose_a);
    return attr;
  }

  ::mlir::Attribute getTransposeA();
};
} // namespace detail
template <typename RangeT>
class TriangularSolveOpV1GenericAdaptor : public detail::TriangularSolveOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TriangularSolveOpV1GenericAdaptorBase;
public:
  TriangularSolveOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TriangularSolveOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TriangularSolveOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  TriangularSolveOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : TriangularSolveOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = TriangularSolveOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TriangularSolveOpV1>>>
  TriangularSolveOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getA() {
    return (*getODSOperands(0).begin());
  }

  ValueT getB() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TriangularSolveOpV1Adaptor : public TriangularSolveOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TriangularSolveOpV1GenericAdaptor::TriangularSolveOpV1GenericAdaptor;
  TriangularSolveOpV1Adaptor(TriangularSolveOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TriangularSolveOpV1 : public ::mlir::Op<TriangularSolveOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TriangularSolveOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TriangularSolveOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("left_side"), ::llvm::StringRef("lower"), ::llvm::StringRef("transpose_a"), ::llvm::StringRef("unit_diagonal")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLeftSideAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLeftSideAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getLowerAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getLowerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getTransposeAAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getTransposeAAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUnitDiagonalAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUnitDiagonalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.triangular_solve_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getA() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getB() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getAMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getBMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getLeftSideAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().left_side);
  }

  ::mlir::Attribute getLeftSide();
  ::mlir::Attribute getLowerAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().lower);
  }

  ::mlir::Attribute getLower();
  ::mlir::Attribute getUnitDiagonalAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().unit_diagonal);
  }

  ::mlir::Attribute getUnitDiagonal();
  ::mlir::Attribute getTransposeAAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().transpose_a);
  }

  ::mlir::Attribute getTransposeA();
  void setLeftSideAttr(::mlir::Attribute attr) {
    getProperties().left_side = attr;
  }

  void setLowerAttr(::mlir::Attribute attr) {
    getProperties().lower = attr;
  }

  void setUnitDiagonalAttr(::mlir::Attribute attr) {
    getProperties().unit_diagonal = attr;
  }

  void setTransposeAAttr(::mlir::Attribute attr) {
    getProperties().transpose_a = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Value b, ::mlir::Attribute left_side, ::mlir::Attribute lower, ::mlir::Attribute unit_diagonal, ::mlir::Attribute transpose_a);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Attribute left_side, ::mlir::Attribute lower, ::mlir::Attribute unit_diagonal, ::mlir::Attribute transpose_a);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TriangularSolveOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TupleOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TupleOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TupleOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.tuple_v1", odsAttrs.getContext());
  }

  TupleOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class TupleOpV1GenericAdaptor : public detail::TupleOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TupleOpV1GenericAdaptorBase;
public:
  TupleOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TupleOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TupleOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TupleOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TupleOpV1>>>
  TupleOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getVal() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TupleOpV1Adaptor : public TupleOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TupleOpV1GenericAdaptor::TupleOpV1GenericAdaptor;
  TupleOpV1Adaptor(TupleOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class TupleOpV1 : public ::mlir::Op<TupleOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TupleOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TupleOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.tuple_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getVal() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getValMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange val);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TupleOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UnaryEinsumOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UnaryEinsumOpV1GenericAdaptorBase {
public:
  struct Properties {
    using einsum_configTy = ::mlir::Attribute;
    einsum_configTy einsum_config;

    auto getEinsumConfig() {
      auto &propStorage = this->einsum_config;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setEinsumConfig(const ::mlir::Attribute &propValue) {
      this->einsum_config = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.einsum_config == this->einsum_config &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  UnaryEinsumOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), properties(properties), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.unary_einsum_v1", odsAttrs.getContext());
  }

  UnaryEinsumOpV1GenericAdaptorBase(UnaryEinsumOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getEinsumConfigAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().einsum_config);
    return attr;
  }

  ::mlir::Attribute getEinsumConfig();
};
} // namespace detail
template <typename RangeT>
class UnaryEinsumOpV1GenericAdaptor : public detail::UnaryEinsumOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UnaryEinsumOpV1GenericAdaptorBase;
public:
  UnaryEinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UnaryEinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UnaryEinsumOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  UnaryEinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr) : UnaryEinsumOpV1GenericAdaptor(values, attrs, Properties{}, {}) {}

  template <typename LateInst = UnaryEinsumOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, UnaryEinsumOpV1>>>
  UnaryEinsumOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UnaryEinsumOpV1Adaptor : public UnaryEinsumOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using UnaryEinsumOpV1GenericAdaptor::UnaryEinsumOpV1GenericAdaptor;
  UnaryEinsumOpV1Adaptor(UnaryEinsumOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class UnaryEinsumOpV1 : public ::mlir::Op<UnaryEinsumOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UnaryEinsumOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = UnaryEinsumOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("einsum_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEinsumConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEinsumConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.unary_einsum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static ::llvm::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::llvm::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::llvm::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getEinsumConfigAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().einsum_config);
  }

  ::mlir::Attribute getEinsumConfig();
  void setEinsumConfigAttr(::mlir::Attribute attr) {
    getProperties().einsum_config = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::UnaryEinsumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UniformDequantizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UniformDequantizeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  UniformDequantizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.uniform_dequantize_v1", odsAttrs.getContext());
  }

  UniformDequantizeOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class UniformDequantizeOpV1GenericAdaptor : public detail::UniformDequantizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UniformDequantizeOpV1GenericAdaptorBase;
public:
  UniformDequantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UniformDequantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UniformDequantizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = UniformDequantizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, UniformDequantizeOpV1>>>
  UniformDequantizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UniformDequantizeOpV1Adaptor : public UniformDequantizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using UniformDequantizeOpV1GenericAdaptor::UniformDequantizeOpV1GenericAdaptor;
  UniformDequantizeOpV1Adaptor(UniformDequantizeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class UniformDequantizeOpV1 : public ::mlir::Op<UniformDequantizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UniformDequantizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = UniformDequantizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.uniform_dequantize_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::UniformDequantizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UniformQuantizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UniformQuantizeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  UniformQuantizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.uniform_quantize_v1", odsAttrs.getContext());
  }

  UniformQuantizeOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class UniformQuantizeOpV1GenericAdaptor : public detail::UniformQuantizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UniformQuantizeOpV1GenericAdaptorBase;
public:
  UniformQuantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UniformQuantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UniformQuantizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = UniformQuantizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, UniformQuantizeOpV1>>>
  UniformQuantizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UniformQuantizeOpV1Adaptor : public UniformQuantizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using UniformQuantizeOpV1GenericAdaptor::UniformQuantizeOpV1GenericAdaptor;
  UniformQuantizeOpV1Adaptor(UniformQuantizeOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class UniformQuantizeOpV1 : public ::mlir::Op<UniformQuantizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UniformQuantizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = UniformQuantizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.uniform_quantize_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::UniformQuantizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::WhileOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class WhileOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  WhileOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.while_v1", odsAttrs.getContext());
  }

  WhileOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Region &getCond() {
    return *odsRegions[0];
  }

  ::mlir::Region &getBody() {
    return *odsRegions[1];
  }

  ::mlir::RegionRange getRegions() {
    return odsRegions;
  }

};
} // namespace detail
template <typename RangeT>
class WhileOpV1GenericAdaptor : public detail::WhileOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::WhileOpV1GenericAdaptorBase;
public:
  WhileOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  WhileOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : WhileOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = WhileOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, WhileOpV1>>>
  WhileOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperand() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class WhileOpV1Adaptor : public WhileOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using WhileOpV1GenericAdaptor::WhileOpV1GenericAdaptor;
  WhileOpV1Adaptor(WhileOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class WhileOpV1 : public ::mlir::Op<WhileOpV1, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WhileOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = WhileOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.while_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperand() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::result_range getResults() {
    return getODSResults(0);
  }

  ::mlir::Region &getCond() {
    return (*this)->getRegion(0);
  }

  ::mlir::Region &getBody() {
    return (*this)->getRegion(1);
  }

  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::WhileOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::XorOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class XorOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  XorOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : odsAttrs(attrs), odsRegions(regions) {  if (odsAttrs)
      odsOpName.emplace("vhlo.xor_v1", odsAttrs.getContext());
  }

  XorOpV1GenericAdaptorBase(::mlir::Operation *op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), odsRegions(op->getRegions()) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class XorOpV1GenericAdaptor : public detail::XorOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::XorOpV1GenericAdaptorBase;
public:
  XorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = {}, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  XorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : XorOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = XorOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, XorOpV1>>>
  XorOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class XorOpV1Adaptor : public XorOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using XorOpV1GenericAdaptor::XorOpV1GenericAdaptor;
  XorOpV1Adaptor(XorOpV1 op);

  ::llvm::LogicalResult verify(::mlir::Location loc);
};
class XorOpV1 : public ::mlir::Op<XorOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XorOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = XorOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.xor_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getLhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::Type> getRhs() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getLhsMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getRhsMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::Type> getResult() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::Type>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::llvm::LogicalResult verifyInvariantsImpl();
  ::llvm::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::XorOpV1)


#endif  // GET_OP_CLASSES

