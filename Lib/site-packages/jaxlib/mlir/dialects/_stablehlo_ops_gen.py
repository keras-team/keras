
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "stablehlo"

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def abs(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return AbsOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def add(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return AddOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AfterAllOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.after_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def after_all(inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return AfterAllOp(inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.all_gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operands_, all_gather_dim, replica_groups, *, channel_handle=None, use_global_device_ids=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["all_gather_dim"] = (all_gather_dim if (
    isinstance(all_gather_dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(all_gather_dim, context=_ods_context))
    attributes["replica_groups"] = (replica_groups if (
    isinstance(replica_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(replica_groups, context=_ods_context))
    if channel_handle is not None: attributes["channel_handle"] = (channel_handle if (
        isinstance(channel_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
          _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    if bool(use_global_device_ids): attributes["use_global_device_ids"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def all_gather_dim(self):
    return self.operation.attributes["all_gather_dim"]

  @all_gather_dim.setter
  def all_gather_dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["all_gather_dim"] = value

  @builtins.property
  def replica_groups(self):
    return self.operation.attributes["replica_groups"]

  @replica_groups.setter
  def replica_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replica_groups"] = value

  @builtins.property
  def channel_handle(self):
    if "channel_handle" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is not None:
      self.operation.attributes["channel_handle"] = value
    elif "channel_handle" in self.operation.attributes:
      del self.operation.attributes["channel_handle"]

  @channel_handle.deleter
  def channel_handle(self):
    del self.operation.attributes["channel_handle"]

  @builtins.property
  def use_global_device_ids(self):
    return "use_global_device_ids" in self.operation.attributes

  @use_global_device_ids.setter
  def use_global_device_ids(self, value):
    if bool(value):
      self.operation.attributes["use_global_device_ids"] = _ods_ir.UnitAttr.get()
    elif "use_global_device_ids" in self.operation.attributes:
      del self.operation.attributes["use_global_device_ids"]

  @use_global_device_ids.deleter
  def use_global_device_ids(self):
    del self.operation.attributes["use_global_device_ids"]

def all_gather(result, operands_, all_gather_dim, replica_groups, *, channel_handle=None, use_global_device_ids=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AllGatherOp(result=result, operands_=operands_, all_gather_dim=all_gather_dim, replica_groups=replica_groups, channel_handle=channel_handle, use_global_device_ids=use_global_device_ids, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AllReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.all_reduce"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, operands_, replica_groups, *, channel_handle=None, use_global_device_ids=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["replica_groups"] = (replica_groups if (
    isinstance(replica_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(replica_groups, context=_ods_context))
    if channel_handle is not None: attributes["channel_handle"] = (channel_handle if (
        isinstance(channel_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
          _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    if bool(use_global_device_ids): attributes["use_global_device_ids"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def replica_groups(self):
    return self.operation.attributes["replica_groups"]

  @replica_groups.setter
  def replica_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replica_groups"] = value

  @builtins.property
  def channel_handle(self):
    if "channel_handle" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is not None:
      self.operation.attributes["channel_handle"] = value
    elif "channel_handle" in self.operation.attributes:
      del self.operation.attributes["channel_handle"]

  @channel_handle.deleter
  def channel_handle(self):
    del self.operation.attributes["channel_handle"]

  @builtins.property
  def use_global_device_ids(self):
    return "use_global_device_ids" in self.operation.attributes

  @use_global_device_ids.setter
  def use_global_device_ids(self, value):
    if bool(value):
      self.operation.attributes["use_global_device_ids"] = _ods_ir.UnitAttr.get()
    elif "use_global_device_ids" in self.operation.attributes:
      del self.operation.attributes["use_global_device_ids"]

  @use_global_device_ids.deleter
  def use_global_device_ids(self):
    del self.operation.attributes["use_global_device_ids"]

  @builtins.property
  def computation(self):
    return self.regions[0]

def all_reduce(result, operands_, replica_groups, *, channel_handle=None, use_global_device_ids=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AllReduceOp(result=result, operands_=operands_, replica_groups=replica_groups, channel_handle=channel_handle, use_global_device_ids=use_global_device_ids, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AllToAllOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.all_to_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, split_dimension, concat_dimension, split_count, replica_groups, *, channel_handle=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["split_dimension"] = (split_dimension if (
    isinstance(split_dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(split_dimension, context=_ods_context))
    attributes["concat_dimension"] = (concat_dimension if (
    isinstance(concat_dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(concat_dimension, context=_ods_context))
    attributes["split_count"] = (split_count if (
    isinstance(split_count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(split_count, context=_ods_context))
    attributes["replica_groups"] = (replica_groups if (
    isinstance(replica_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(replica_groups, context=_ods_context))
    if channel_handle is not None: attributes["channel_handle"] = (channel_handle if (
        isinstance(channel_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
          _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def split_dimension(self):
    return self.operation.attributes["split_dimension"]

  @split_dimension.setter
  def split_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["split_dimension"] = value

  @builtins.property
  def concat_dimension(self):
    return self.operation.attributes["concat_dimension"]

  @concat_dimension.setter
  def concat_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["concat_dimension"] = value

  @builtins.property
  def split_count(self):
    return self.operation.attributes["split_count"]

  @split_count.setter
  def split_count(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["split_count"] = value

  @builtins.property
  def replica_groups(self):
    return self.operation.attributes["replica_groups"]

  @replica_groups.setter
  def replica_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replica_groups"] = value

  @builtins.property
  def channel_handle(self):
    if "channel_handle" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is not None:
      self.operation.attributes["channel_handle"] = value
    elif "channel_handle" in self.operation.attributes:
      del self.operation.attributes["channel_handle"]

  @channel_handle.deleter
  def channel_handle(self):
    del self.operation.attributes["channel_handle"]

def all_to_all(operands_, split_dimension, concat_dimension, split_count, replica_groups, *, channel_handle=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AllToAllOp(operands_=operands_, split_dimension=split_dimension, concat_dimension=concat_dimension, split_count=split_count, replica_groups=replica_groups, channel_handle=channel_handle, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def and_(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return AndOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Atan2Op(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.atan2"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atan2(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return Atan2Op(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BatchNormGradOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.batch_norm_grad"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, scale, mean, variance, grad_output, epsilon, feature_index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(variance))
    operands.append(_get_op_result_or_value(grad_output))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["epsilon"] = (epsilon if (
    isinstance(epsilon, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F32Attr')) else
      _ods_ir.AttrBuilder.get('F32Attr')(epsilon, context=_ods_context))
    attributes["feature_index"] = (feature_index if (
    isinstance(feature_index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(feature_index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def mean(self):
    return self.operation.operands[2]

  @builtins.property
  def variance(self):
    return self.operation.operands[3]

  @builtins.property
  def grad_output(self):
    return self.operation.operands[4]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def feature_index(self):
    return self.operation.attributes["feature_index"]

  @feature_index.setter
  def feature_index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["feature_index"] = value

  @builtins.property
  def grad_operand(self):
    return self.operation.results[0]

  @builtins.property
  def grad_scale(self):
    return self.operation.results[1]

  @builtins.property
  def grad_offset(self):
    return self.operation.results[2]

def batch_norm_grad(operand, scale, mean, variance, grad_output, epsilon, feature_index, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return BatchNormGradOp(operand=operand, scale=scale, mean=mean, variance=variance, grad_output=grad_output, epsilon=epsilon, feature_index=feature_index, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BatchNormInferenceOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.batch_norm_inference"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, scale, offset, mean, variance, epsilon, feature_index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(offset))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(variance))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["epsilon"] = (epsilon if (
    isinstance(epsilon, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F32Attr')) else
      _ods_ir.AttrBuilder.get('F32Attr')(epsilon, context=_ods_context))
    attributes["feature_index"] = (feature_index if (
    isinstance(feature_index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(feature_index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def mean(self):
    return self.operation.operands[3]

  @builtins.property
  def variance(self):
    return self.operation.operands[4]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def feature_index(self):
    return self.operation.attributes["feature_index"]

  @feature_index.setter
  def feature_index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["feature_index"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def batch_norm_inference(operand, scale, offset, mean, variance, epsilon, feature_index, *, loc=None, ip=None) -> _ods_ir.Value:
  return BatchNormInferenceOp(operand=operand, scale=scale, offset=offset, mean=mean, variance=variance, epsilon=epsilon, feature_index=feature_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BatchNormTrainingOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.batch_norm_training"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, scale, offset, epsilon, feature_index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(offset))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["epsilon"] = (epsilon if (
    isinstance(epsilon, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F32Attr')) else
      _ods_ir.AttrBuilder.get('F32Attr')(epsilon, context=_ods_context))
    attributes["feature_index"] = (feature_index if (
    isinstance(feature_index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(feature_index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def feature_index(self):
    return self.operation.attributes["feature_index"]

  @feature_index.setter
  def feature_index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["feature_index"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def batch_mean(self):
    return self.operation.results[1]

  @builtins.property
  def batch_var(self):
    return self.operation.results[2]

def batch_norm_training(operand, scale, offset, epsilon, feature_index, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return BatchNormTrainingOp(operand=operand, scale=scale, offset=offset, epsilon=epsilon, feature_index=feature_index, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BitcastConvertOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.bitcast_convert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

def bitcast_convert(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitcastConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastInDimOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.broadcast_in_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, broadcast_dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["broadcast_dimensions"] = (broadcast_dimensions if (
    isinstance(broadcast_dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(broadcast_dimensions, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def broadcast_dimensions(self):
    return self.operation.attributes["broadcast_dimensions"]

  @broadcast_dimensions.setter
  def broadcast_dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["broadcast_dimensions"] = value

def broadcast_in_dim(result, operand, broadcast_dimensions, *, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastInDimOp(result=result, operand=operand, broadcast_dimensions=broadcast_dimensions, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.broadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, broadcast_sizes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["broadcast_sizes"] = (broadcast_sizes if (
    isinstance(broadcast_sizes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(broadcast_sizes, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def broadcast_sizes(self):
    return self.operation.attributes["broadcast_sizes"]

  @broadcast_sizes.setter
  def broadcast_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["broadcast_sizes"] = value

def broadcast(operand, broadcast_sizes, *, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastOp(operand=operand, broadcast_sizes=broadcast_sizes, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CaseOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.case"

  _ODS_REGIONS = (0, False)

  def __init__(self, result, index, num_branches, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(index))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(result)
    _ods_successors = None
    regions = 0 + num_branches
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def branches(self):
    return self.regions[0:]

def case(result, index, num_branches, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CaseOp(result=result, index=index, num_branches=num_branches, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CbrtOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.cbrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cbrt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CbrtOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ceil(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CeilOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CholeskyOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.cholesky"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, *, lower=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    _ods_context = _ods_get_default_loc_context(loc)
    if lower is not None: attributes["lower"] = (lower if (
        isinstance(lower, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(lower, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def lower(self):
    if "lower" not in self.operation.attributes:
      return None
    return self.operation.attributes["lower"]

  @lower.setter
  def lower(self, value):
    if value is not None:
      self.operation.attributes["lower"] = value
    elif "lower" in self.operation.attributes:
      del self.operation.attributes["lower"]

  @lower.deleter
  def lower(self):
    del self.operation.attributes["lower"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cholesky(a, *, lower=None, loc=None, ip=None) -> _ods_ir.Value:
  return CholeskyOp(a=a, lower=lower, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClampOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.clamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, min, operand, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(min))
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(max))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def min(self):
    return self.operation.operands[0]

  @builtins.property
  def operand(self):
    return self.operation.operands[1]

  @builtins.property
  def max(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def clamp(min, operand, max, *, loc=None, ip=None) -> _ods_ir.Value:
  return ClampOp(min=min, operand=operand, max=max, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClzOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.count_leading_zeros"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def count_leading_zeros(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ClzOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveBroadcastOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.collective_broadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, replica_groups, *, channel_handle=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["replica_groups"] = (replica_groups if (
    isinstance(replica_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(replica_groups, context=_ods_context))
    if channel_handle is not None: attributes["channel_handle"] = (channel_handle if (
        isinstance(channel_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
          _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def replica_groups(self):
    return self.operation.attributes["replica_groups"]

  @replica_groups.setter
  def replica_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replica_groups"] = value

  @builtins.property
  def channel_handle(self):
    if "channel_handle" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is not None:
      self.operation.attributes["channel_handle"] = value
    elif "channel_handle" in self.operation.attributes:
      del self.operation.attributes["channel_handle"]

  @channel_handle.deleter
  def channel_handle(self):
    del self.operation.attributes["channel_handle"]

def collective_broadcast(operand, replica_groups, *, channel_handle=None, loc=None, ip=None) -> _ods_ir.Value:
  return CollectiveBroadcastOp(operand=operand, replica_groups=replica_groups, channel_handle=channel_handle, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectivePermuteOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.collective_permute"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, source_target_pairs, *, channel_handle=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_target_pairs"] = (source_target_pairs if (
    isinstance(source_target_pairs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(source_target_pairs, context=_ods_context))
    if channel_handle is not None: attributes["channel_handle"] = (channel_handle if (
        isinstance(channel_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
          _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def source_target_pairs(self):
    return self.operation.attributes["source_target_pairs"]

  @source_target_pairs.setter
  def source_target_pairs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_target_pairs"] = value

  @builtins.property
  def channel_handle(self):
    if "channel_handle" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is not None:
      self.operation.attributes["channel_handle"] = value
    elif "channel_handle" in self.operation.attributes:
      del self.operation.attributes["channel_handle"]

  @channel_handle.deleter
  def channel_handle(self):
    del self.operation.attributes["channel_handle"]

def collective_permute(operand, source_target_pairs, *, channel_handle=None, loc=None, ip=None) -> _ods_ir.Value:
  return CollectivePermuteOp(operand=operand, source_target_pairs=source_target_pairs, channel_handle=channel_handle, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompareOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.compare"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, comparison_direction, *, compare_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["comparison_direction"] = (comparison_direction if (
    isinstance(comparison_direction, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_ComparisonDirectionAttr')) else
      _ods_ir.AttrBuilder.get('StableHLO_ComparisonDirectionAttr')(comparison_direction, context=_ods_context))
    if compare_type is not None: attributes["compare_type"] = (compare_type if (
        isinstance(compare_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ComparisonTypeAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_ComparisonTypeAttr')(compare_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def comparison_direction(self):
    return self.operation.attributes["comparison_direction"]

  @comparison_direction.setter
  def comparison_direction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["comparison_direction"] = value

  @builtins.property
  def compare_type(self):
    if "compare_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["compare_type"]

  @compare_type.setter
  def compare_type(self, value):
    if value is not None:
      self.operation.attributes["compare_type"] = value
    elif "compare_type" in self.operation.attributes:
      del self.operation.attributes["compare_type"]

  @compare_type.deleter
  def compare_type(self):
    del self.operation.attributes["compare_type"]

def compare(lhs, rhs, comparison_direction, *, compare_type=None, loc=None, ip=None) -> _ods_ir.Value:
  return CompareOp(lhs=lhs, rhs=rhs, comparison_direction=comparison_direction, compare_type=compare_type, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ComplexOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.complex"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def complex(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ComplexOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.composite"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, name, decomposition, *, composite_attributes=None, version=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if composite_attributes is not None: attributes["composite_attributes"] = (composite_attributes if (
        isinstance(composite_attributes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(composite_attributes, context=_ods_context))
    attributes["decomposition"] = (decomposition if (
    isinstance(decomposition, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(decomposition, context=_ods_context))
    if version is not None: attributes["version"] = (version if (
        isinstance(version, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(version, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def composite_attributes(self):
    if "composite_attributes" not in self.operation.attributes:
      return None
    return self.operation.attributes["composite_attributes"]

  @composite_attributes.setter
  def composite_attributes(self, value):
    if value is not None:
      self.operation.attributes["composite_attributes"] = value
    elif "composite_attributes" in self.operation.attributes:
      del self.operation.attributes["composite_attributes"]

  @composite_attributes.deleter
  def composite_attributes(self):
    del self.operation.attributes["composite_attributes"]

  @builtins.property
  def decomposition(self):
    return self.operation.attributes["decomposition"]

  @decomposition.setter
  def decomposition(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["decomposition"] = value

  @builtins.property
  def version(self):
    if "version" not in self.operation.attributes:
      return None
    return self.operation.attributes["version"]

  @version.setter
  def version(self, value):
    if value is not None:
      self.operation.attributes["version"] = value
    elif "version" in self.operation.attributes:
      del self.operation.attributes["version"]

  @version.deleter
  def version(self):
    del self.operation.attributes["version"]

def composite(result, inputs, name, decomposition, *, composite_attributes=None, version=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CompositeOp(result=result, inputs=inputs, name=name, decomposition=decomposition, composite_attributes=composite_attributes, version=version, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConcatenateOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.concatenate"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

def concatenate(inputs, dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConcatenateOp(inputs=inputs, dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def constant(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.convert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def convert(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvolutionOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.convolution"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, dimension_numbers, feature_group_count, batch_group_count, *, window_strides=None, padding=None, lhs_dilation=None, rhs_dilation=None, window_reversal=None, precision_config=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if window_strides is not None: attributes["window_strides"] = (window_strides if (
        isinstance(window_strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(window_strides, context=_ods_context))
    if padding is not None: attributes["padding"] = (padding if (
        isinstance(padding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
          _ods_ir.AttrBuilder.get('I64ElementsAttr')(padding, context=_ods_context))
    if lhs_dilation is not None: attributes["lhs_dilation"] = (lhs_dilation if (
        isinstance(lhs_dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(lhs_dilation, context=_ods_context))
    if rhs_dilation is not None: attributes["rhs_dilation"] = (rhs_dilation if (
        isinstance(rhs_dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(rhs_dilation, context=_ods_context))
    if window_reversal is not None: attributes["window_reversal"] = (window_reversal if (
        isinstance(window_reversal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(window_reversal, context=_ods_context))
    attributes["dimension_numbers"] = (dimension_numbers if (
    isinstance(dimension_numbers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_ConvDimensionNumbers')) else
      _ods_ir.AttrBuilder.get('StableHLO_ConvDimensionNumbers')(dimension_numbers, context=_ods_context))
    attributes["feature_group_count"] = (feature_group_count if (
    isinstance(feature_group_count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(feature_group_count, context=_ods_context))
    attributes["batch_group_count"] = (batch_group_count if (
    isinstance(batch_group_count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(batch_group_count, context=_ods_context))
    if precision_config is not None: attributes["precision_config"] = (precision_config if (
        isinstance(precision_config, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_PrecisionConfigAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_PrecisionConfigAttr')(precision_config, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def window_strides(self):
    if "window_strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_strides"]

  @window_strides.setter
  def window_strides(self, value):
    if value is not None:
      self.operation.attributes["window_strides"] = value
    elif "window_strides" in self.operation.attributes:
      del self.operation.attributes["window_strides"]

  @window_strides.deleter
  def window_strides(self):
    del self.operation.attributes["window_strides"]

  @builtins.property
  def padding(self):
    if "padding" not in self.operation.attributes:
      return None
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is not None:
      self.operation.attributes["padding"] = value
    elif "padding" in self.operation.attributes:
      del self.operation.attributes["padding"]

  @padding.deleter
  def padding(self):
    del self.operation.attributes["padding"]

  @builtins.property
  def lhs_dilation(self):
    if "lhs_dilation" not in self.operation.attributes:
      return None
    return self.operation.attributes["lhs_dilation"]

  @lhs_dilation.setter
  def lhs_dilation(self, value):
    if value is not None:
      self.operation.attributes["lhs_dilation"] = value
    elif "lhs_dilation" in self.operation.attributes:
      del self.operation.attributes["lhs_dilation"]

  @lhs_dilation.deleter
  def lhs_dilation(self):
    del self.operation.attributes["lhs_dilation"]

  @builtins.property
  def rhs_dilation(self):
    if "rhs_dilation" not in self.operation.attributes:
      return None
    return self.operation.attributes["rhs_dilation"]

  @rhs_dilation.setter
  def rhs_dilation(self, value):
    if value is not None:
      self.operation.attributes["rhs_dilation"] = value
    elif "rhs_dilation" in self.operation.attributes:
      del self.operation.attributes["rhs_dilation"]

  @rhs_dilation.deleter
  def rhs_dilation(self):
    del self.operation.attributes["rhs_dilation"]

  @builtins.property
  def window_reversal(self):
    if "window_reversal" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_reversal"]

  @window_reversal.setter
  def window_reversal(self, value):
    if value is not None:
      self.operation.attributes["window_reversal"] = value
    elif "window_reversal" in self.operation.attributes:
      del self.operation.attributes["window_reversal"]

  @window_reversal.deleter
  def window_reversal(self):
    del self.operation.attributes["window_reversal"]

  @builtins.property
  def dimension_numbers(self):
    return self.operation.attributes["dimension_numbers"]

  @dimension_numbers.setter
  def dimension_numbers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension_numbers"] = value

  @builtins.property
  def feature_group_count(self):
    return self.operation.attributes["feature_group_count"]

  @feature_group_count.setter
  def feature_group_count(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["feature_group_count"] = value

  @builtins.property
  def batch_group_count(self):
    return self.operation.attributes["batch_group_count"]

  @batch_group_count.setter
  def batch_group_count(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_group_count"] = value

  @builtins.property
  def precision_config(self):
    if "precision_config" not in self.operation.attributes:
      return None
    return self.operation.attributes["precision_config"]

  @precision_config.setter
  def precision_config(self, value):
    if value is not None:
      self.operation.attributes["precision_config"] = value
    elif "precision_config" in self.operation.attributes:
      del self.operation.attributes["precision_config"]

  @precision_config.deleter
  def precision_config(self):
    del self.operation.attributes["precision_config"]

def convolution(result, lhs, rhs, dimension_numbers, feature_group_count, batch_group_count, *, window_strides=None, padding=None, lhs_dilation=None, rhs_dilation=None, window_reversal=None, precision_config=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConvolutionOp(result=result, lhs=lhs, rhs=rhs, dimension_numbers=dimension_numbers, feature_group_count=feature_group_count, batch_group_count=batch_group_count, window_strides=window_strides, padding=padding, lhs_dilation=lhs_dilation, rhs_dilation=rhs_dilation, window_reversal=window_reversal, precision_config=precision_config, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosineOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.cosine"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cosine(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CosineOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateTokenOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.create_token"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def output(self):
    return self.operation.results[0]

def create_token(*, loc=None, ip=None) -> _ods_ir.Value:
  return CreateTokenOp(loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CrossReplicaSumOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.cross-replica-sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, replica_groups, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["replica_groups"] = (replica_groups if (
    isinstance(replica_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(replica_groups, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def replica_groups(self):
    return self.operation.attributes["replica_groups"]

  @replica_groups.setter
  def replica_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replica_groups"] = value

def cross_replica_sum(operand, replica_groups, *, loc=None, ip=None) -> _ods_ir.Value:
  return CrossReplicaSumOp(operand=operand, replica_groups=replica_groups, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CustomCallOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.custom_call"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, call_target_name, *, has_side_effect=None, backend_config=None, api_version=None, called_computations=None, operand_layouts=None, result_layouts=None, output_operand_aliases=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["call_target_name"] = (call_target_name if (
    isinstance(call_target_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(call_target_name, context=_ods_context))
    if has_side_effect is not None: attributes["has_side_effect"] = (has_side_effect if (
        isinstance(has_side_effect, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(has_side_effect, context=_ods_context))
    if backend_config is not None: attributes["backend_config"] = (backend_config if (
        isinstance(backend_config, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_753')) else
          _ods_ir.AttrBuilder.get('anonymous_753')(backend_config, context=_ods_context))
    if api_version is not None: attributes["api_version"] = (api_version if (
        isinstance(api_version, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_CustomCallApiVersionAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_CustomCallApiVersionAttr')(api_version, context=_ods_context))
    if called_computations is not None: attributes["called_computations"] = (called_computations if (
        isinstance(called_computations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_FlatSymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_FlatSymbolRefArrayAttr')(called_computations, context=_ods_context))
    if operand_layouts is not None: attributes["operand_layouts"] = (operand_layouts if (
        isinstance(operand_layouts, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ArrayOfLayoutAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_ArrayOfLayoutAttr')(operand_layouts, context=_ods_context))
    if result_layouts is not None: attributes["result_layouts"] = (result_layouts if (
        isinstance(result_layouts, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ArrayOfLayoutAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_ArrayOfLayoutAttr')(result_layouts, context=_ods_context))
    if output_operand_aliases is not None: attributes["output_operand_aliases"] = (output_operand_aliases if (
        isinstance(output_operand_aliases, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_759')) else
          _ods_ir.AttrBuilder.get('anonymous_759')(output_operand_aliases, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def call_target_name(self):
    return self.operation.attributes["call_target_name"]

  @call_target_name.setter
  def call_target_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["call_target_name"] = value

  @builtins.property
  def has_side_effect(self):
    if "has_side_effect" not in self.operation.attributes:
      return None
    return self.operation.attributes["has_side_effect"]

  @has_side_effect.setter
  def has_side_effect(self, value):
    if value is not None:
      self.operation.attributes["has_side_effect"] = value
    elif "has_side_effect" in self.operation.attributes:
      del self.operation.attributes["has_side_effect"]

  @has_side_effect.deleter
  def has_side_effect(self):
    del self.operation.attributes["has_side_effect"]

  @builtins.property
  def backend_config(self):
    if "backend_config" not in self.operation.attributes:
      return None
    return self.operation.attributes["backend_config"]

  @backend_config.setter
  def backend_config(self, value):
    if value is not None:
      self.operation.attributes["backend_config"] = value
    elif "backend_config" in self.operation.attributes:
      del self.operation.attributes["backend_config"]

  @backend_config.deleter
  def backend_config(self):
    del self.operation.attributes["backend_config"]

  @builtins.property
  def api_version(self):
    if "api_version" not in self.operation.attributes:
      return None
    return self.operation.attributes["api_version"]

  @api_version.setter
  def api_version(self, value):
    if value is not None:
      self.operation.attributes["api_version"] = value
    elif "api_version" in self.operation.attributes:
      del self.operation.attributes["api_version"]

  @api_version.deleter
  def api_version(self):
    del self.operation.attributes["api_version"]

  @builtins.property
  def called_computations(self):
    if "called_computations" not in self.operation.attributes:
      return None
    return self.operation.attributes["called_computations"]

  @called_computations.setter
  def called_computations(self, value):
    if value is not None:
      self.operation.attributes["called_computations"] = value
    elif "called_computations" in self.operation.attributes:
      del self.operation.attributes["called_computations"]

  @called_computations.deleter
  def called_computations(self):
    del self.operation.attributes["called_computations"]

  @builtins.property
  def operand_layouts(self):
    if "operand_layouts" not in self.operation.attributes:
      return None
    return self.operation.attributes["operand_layouts"]

  @operand_layouts.setter
  def operand_layouts(self, value):
    if value is not None:
      self.operation.attributes["operand_layouts"] = value
    elif "operand_layouts" in self.operation.attributes:
      del self.operation.attributes["operand_layouts"]

  @operand_layouts.deleter
  def operand_layouts(self):
    del self.operation.attributes["operand_layouts"]

  @builtins.property
  def result_layouts(self):
    if "result_layouts" not in self.operation.attributes:
      return None
    return self.operation.attributes["result_layouts"]

  @result_layouts.setter
  def result_layouts(self, value):
    if value is not None:
      self.operation.attributes["result_layouts"] = value
    elif "result_layouts" in self.operation.attributes:
      del self.operation.attributes["result_layouts"]

  @result_layouts.deleter
  def result_layouts(self):
    del self.operation.attributes["result_layouts"]

  @builtins.property
  def output_operand_aliases(self):
    if "output_operand_aliases" not in self.operation.attributes:
      return None
    return self.operation.attributes["output_operand_aliases"]

  @output_operand_aliases.setter
  def output_operand_aliases(self, value):
    if value is not None:
      self.operation.attributes["output_operand_aliases"] = value
    elif "output_operand_aliases" in self.operation.attributes:
      del self.operation.attributes["output_operand_aliases"]

  @output_operand_aliases.deleter
  def output_operand_aliases(self):
    del self.operation.attributes["output_operand_aliases"]

def custom_call(result, inputs, call_target_name, *, has_side_effect=None, backend_config=None, api_version=None, called_computations=None, operand_layouts=None, result_layouts=None, output_operand_aliases=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CustomCallOp(result=result, inputs=inputs, call_target_name=call_target_name, has_side_effect=has_side_effect, backend_config=backend_config, api_version=api_version, called_computations=called_computations, operand_layouts=operand_layouts, result_layouts=result_layouts, output_operand_aliases=output_operand_aliases, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.divide"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def divide(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return DivOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DotGeneralOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dot_general"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, dot_dimension_numbers, *, precision_config=None, algorithm=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dot_dimension_numbers"] = (dot_dimension_numbers if (
    isinstance(dot_dimension_numbers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_DotDimensionNumbers')) else
      _ods_ir.AttrBuilder.get('StableHLO_DotDimensionNumbers')(dot_dimension_numbers, context=_ods_context))
    if precision_config is not None: attributes["precision_config"] = (precision_config if (
        isinstance(precision_config, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_PrecisionConfigAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_PrecisionConfigAttr')(precision_config, context=_ods_context))
    if algorithm is not None: attributes["algorithm"] = (algorithm if (
        isinstance(algorithm, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_DotAlgorithm')) else
          _ods_ir.AttrBuilder.get('StableHLO_DotAlgorithm')(algorithm, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def dot_dimension_numbers(self):
    return self.operation.attributes["dot_dimension_numbers"]

  @dot_dimension_numbers.setter
  def dot_dimension_numbers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dot_dimension_numbers"] = value

  @builtins.property
  def precision_config(self):
    if "precision_config" not in self.operation.attributes:
      return None
    return self.operation.attributes["precision_config"]

  @precision_config.setter
  def precision_config(self, value):
    if value is not None:
      self.operation.attributes["precision_config"] = value
    elif "precision_config" in self.operation.attributes:
      del self.operation.attributes["precision_config"]

  @precision_config.deleter
  def precision_config(self):
    del self.operation.attributes["precision_config"]

  @builtins.property
  def algorithm(self):
    if "algorithm" not in self.operation.attributes:
      return None
    return self.operation.attributes["algorithm"]

  @algorithm.setter
  def algorithm(self, value):
    if value is not None:
      self.operation.attributes["algorithm"] = value
    elif "algorithm" in self.operation.attributes:
      del self.operation.attributes["algorithm"]

  @algorithm.deleter
  def algorithm(self):
    del self.operation.attributes["algorithm"]

def dot_general(result, lhs, rhs, dot_dimension_numbers, *, precision_config=None, algorithm=None, loc=None, ip=None) -> _ods_ir.Value:
  return DotGeneralOp(result=result, lhs=lhs, rhs=rhs, dot_dimension_numbers=dot_dimension_numbers, precision_config=precision_config, algorithm=algorithm, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DotOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, precision_config=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if precision_config is not None: attributes["precision_config"] = (precision_config if (
        isinstance(precision_config, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_PrecisionConfigAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_PrecisionConfigAttr')(precision_config, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def precision_config(self):
    if "precision_config" not in self.operation.attributes:
      return None
    return self.operation.attributes["precision_config"]

  @precision_config.setter
  def precision_config(self, value):
    if value is not None:
      self.operation.attributes["precision_config"] = value
    elif "precision_config" in self.operation.attributes:
      del self.operation.attributes["precision_config"]

  @precision_config.deleter
  def precision_config(self):
    del self.operation.attributes["precision_config"]

def dot(result, lhs, rhs, *, precision_config=None, loc=None, ip=None) -> _ods_ir.Value:
  return DotOp(result=result, lhs=lhs, rhs=rhs, precision_config=precision_config, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicBroadcastInDimOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_broadcast_in_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, output_dimensions, broadcast_dimensions, *, known_expanding_dimensions=None, known_nonexpanding_dimensions=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(output_dimensions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["broadcast_dimensions"] = (broadcast_dimensions if (
    isinstance(broadcast_dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(broadcast_dimensions, context=_ods_context))
    if known_expanding_dimensions is not None: attributes["known_expanding_dimensions"] = (known_expanding_dimensions if (
        isinstance(known_expanding_dimensions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(known_expanding_dimensions, context=_ods_context))
    if known_nonexpanding_dimensions is not None: attributes["known_nonexpanding_dimensions"] = (known_nonexpanding_dimensions if (
        isinstance(known_nonexpanding_dimensions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(known_nonexpanding_dimensions, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def output_dimensions(self):
    return self.operation.operands[1]

  @builtins.property
  def broadcast_dimensions(self):
    return self.operation.attributes["broadcast_dimensions"]

  @broadcast_dimensions.setter
  def broadcast_dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["broadcast_dimensions"] = value

  @builtins.property
  def known_expanding_dimensions(self):
    if "known_expanding_dimensions" not in self.operation.attributes:
      return None
    return self.operation.attributes["known_expanding_dimensions"]

  @known_expanding_dimensions.setter
  def known_expanding_dimensions(self, value):
    if value is not None:
      self.operation.attributes["known_expanding_dimensions"] = value
    elif "known_expanding_dimensions" in self.operation.attributes:
      del self.operation.attributes["known_expanding_dimensions"]

  @known_expanding_dimensions.deleter
  def known_expanding_dimensions(self):
    del self.operation.attributes["known_expanding_dimensions"]

  @builtins.property
  def known_nonexpanding_dimensions(self):
    if "known_nonexpanding_dimensions" not in self.operation.attributes:
      return None
    return self.operation.attributes["known_nonexpanding_dimensions"]

  @known_nonexpanding_dimensions.setter
  def known_nonexpanding_dimensions(self, value):
    if value is not None:
      self.operation.attributes["known_nonexpanding_dimensions"] = value
    elif "known_nonexpanding_dimensions" in self.operation.attributes:
      del self.operation.attributes["known_nonexpanding_dimensions"]

  @known_nonexpanding_dimensions.deleter
  def known_nonexpanding_dimensions(self):
    del self.operation.attributes["known_nonexpanding_dimensions"]

def dynamic_broadcast_in_dim(result, operand, output_dimensions, broadcast_dimensions, *, known_expanding_dimensions=None, known_nonexpanding_dimensions=None, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicBroadcastInDimOp(result=result, operand=operand, output_dimensions=output_dimensions, broadcast_dimensions=broadcast_dimensions, known_expanding_dimensions=known_expanding_dimensions, known_nonexpanding_dimensions=known_nonexpanding_dimensions, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicConvOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, padding, dimension_numbers, feature_group_count, batch_group_count, *, window_strides=None, lhs_dilation=None, rhs_dilation=None, window_reversal=None, precision_config=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    operands.append(_get_op_result_or_value(padding))
    _ods_context = _ods_get_default_loc_context(loc)
    if window_strides is not None: attributes["window_strides"] = (window_strides if (
        isinstance(window_strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(window_strides, context=_ods_context))
    if lhs_dilation is not None: attributes["lhs_dilation"] = (lhs_dilation if (
        isinstance(lhs_dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(lhs_dilation, context=_ods_context))
    if rhs_dilation is not None: attributes["rhs_dilation"] = (rhs_dilation if (
        isinstance(rhs_dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(rhs_dilation, context=_ods_context))
    if window_reversal is not None: attributes["window_reversal"] = (window_reversal if (
        isinstance(window_reversal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(window_reversal, context=_ods_context))
    attributes["dimension_numbers"] = (dimension_numbers if (
    isinstance(dimension_numbers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_ConvDimensionNumbers')) else
      _ods_ir.AttrBuilder.get('StableHLO_ConvDimensionNumbers')(dimension_numbers, context=_ods_context))
    attributes["feature_group_count"] = (feature_group_count if (
    isinstance(feature_group_count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(feature_group_count, context=_ods_context))
    attributes["batch_group_count"] = (batch_group_count if (
    isinstance(batch_group_count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(batch_group_count, context=_ods_context))
    if precision_config is not None: attributes["precision_config"] = (precision_config if (
        isinstance(precision_config, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_PrecisionConfigAttr')) else
          _ods_ir.AttrBuilder.get('StableHLO_PrecisionConfigAttr')(precision_config, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def padding(self):
    return self.operation.operands[2]

  @builtins.property
  def window_strides(self):
    if "window_strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_strides"]

  @window_strides.setter
  def window_strides(self, value):
    if value is not None:
      self.operation.attributes["window_strides"] = value
    elif "window_strides" in self.operation.attributes:
      del self.operation.attributes["window_strides"]

  @window_strides.deleter
  def window_strides(self):
    del self.operation.attributes["window_strides"]

  @builtins.property
  def lhs_dilation(self):
    if "lhs_dilation" not in self.operation.attributes:
      return None
    return self.operation.attributes["lhs_dilation"]

  @lhs_dilation.setter
  def lhs_dilation(self, value):
    if value is not None:
      self.operation.attributes["lhs_dilation"] = value
    elif "lhs_dilation" in self.operation.attributes:
      del self.operation.attributes["lhs_dilation"]

  @lhs_dilation.deleter
  def lhs_dilation(self):
    del self.operation.attributes["lhs_dilation"]

  @builtins.property
  def rhs_dilation(self):
    if "rhs_dilation" not in self.operation.attributes:
      return None
    return self.operation.attributes["rhs_dilation"]

  @rhs_dilation.setter
  def rhs_dilation(self, value):
    if value is not None:
      self.operation.attributes["rhs_dilation"] = value
    elif "rhs_dilation" in self.operation.attributes:
      del self.operation.attributes["rhs_dilation"]

  @rhs_dilation.deleter
  def rhs_dilation(self):
    del self.operation.attributes["rhs_dilation"]

  @builtins.property
  def window_reversal(self):
    if "window_reversal" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_reversal"]

  @window_reversal.setter
  def window_reversal(self, value):
    if value is not None:
      self.operation.attributes["window_reversal"] = value
    elif "window_reversal" in self.operation.attributes:
      del self.operation.attributes["window_reversal"]

  @window_reversal.deleter
  def window_reversal(self):
    del self.operation.attributes["window_reversal"]

  @builtins.property
  def dimension_numbers(self):
    return self.operation.attributes["dimension_numbers"]

  @dimension_numbers.setter
  def dimension_numbers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension_numbers"] = value

  @builtins.property
  def feature_group_count(self):
    return self.operation.attributes["feature_group_count"]

  @feature_group_count.setter
  def feature_group_count(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["feature_group_count"] = value

  @builtins.property
  def batch_group_count(self):
    return self.operation.attributes["batch_group_count"]

  @batch_group_count.setter
  def batch_group_count(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_group_count"] = value

  @builtins.property
  def precision_config(self):
    if "precision_config" not in self.operation.attributes:
      return None
    return self.operation.attributes["precision_config"]

  @precision_config.setter
  def precision_config(self, value):
    if value is not None:
      self.operation.attributes["precision_config"] = value
    elif "precision_config" in self.operation.attributes:
      del self.operation.attributes["precision_config"]

  @precision_config.deleter
  def precision_config(self):
    del self.operation.attributes["precision_config"]

def dynamic_conv(result, lhs, rhs, padding, dimension_numbers, feature_group_count, batch_group_count, *, window_strides=None, lhs_dilation=None, rhs_dilation=None, window_reversal=None, precision_config=None, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicConvOp(result=result, lhs=lhs, rhs=rhs, padding=padding, dimension_numbers=dimension_numbers, feature_group_count=feature_group_count, batch_group_count=batch_group_count, window_strides=window_strides, lhs_dilation=lhs_dilation, rhs_dilation=rhs_dilation, window_reversal=window_reversal, precision_config=precision_config, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, start_indices, slice_sizes, dimension_numbers, *, indices_are_sorted=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(start_indices))
    operands.append(_get_op_result_or_value(slice_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension_numbers"] = (dimension_numbers if (
    isinstance(dimension_numbers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_GatherDimensionNumbers')) else
      _ods_ir.AttrBuilder.get('StableHLO_GatherDimensionNumbers')(dimension_numbers, context=_ods_context))
    if indices_are_sorted is not None: attributes["indices_are_sorted"] = (indices_are_sorted if (
        isinstance(indices_are_sorted, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(indices_are_sorted, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def start_indices(self):
    return self.operation.operands[1]

  @builtins.property
  def slice_sizes(self):
    return self.operation.operands[2]

  @builtins.property
  def dimension_numbers(self):
    return self.operation.attributes["dimension_numbers"]

  @dimension_numbers.setter
  def dimension_numbers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension_numbers"] = value

  @builtins.property
  def indices_are_sorted(self):
    if "indices_are_sorted" not in self.operation.attributes:
      return None
    return self.operation.attributes["indices_are_sorted"]

  @indices_are_sorted.setter
  def indices_are_sorted(self, value):
    if value is not None:
      self.operation.attributes["indices_are_sorted"] = value
    elif "indices_are_sorted" in self.operation.attributes:
      del self.operation.attributes["indices_are_sorted"]

  @indices_are_sorted.deleter
  def indices_are_sorted(self):
    del self.operation.attributes["indices_are_sorted"]

def dynamic_gather(operand, start_indices, slice_sizes, dimension_numbers, *, indices_are_sorted=None, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicGatherOp(operand=operand, start_indices=start_indices, slice_sizes=slice_sizes, dimension_numbers=dimension_numbers, indices_are_sorted=indices_are_sorted, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicIotaOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_iota"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, output_shape, iota_dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(output_shape))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["iota_dimension"] = (iota_dimension if (
    isinstance(iota_dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(iota_dimension, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def output_shape(self):
    return self.operation.operands[0]

  @builtins.property
  def iota_dimension(self):
    return self.operation.attributes["iota_dimension"]

  @iota_dimension.setter
  def iota_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iota_dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dynamic_iota(result, output_shape, iota_dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicIotaOp(result=result, output_shape=output_shape, iota_dimension=iota_dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicPadOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, padding_value, edge_padding_low, edge_padding_high, interior_padding, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(padding_value))
    operands.append(_get_op_result_or_value(edge_padding_low))
    operands.append(_get_op_result_or_value(edge_padding_high))
    operands.append(_get_op_result_or_value(interior_padding))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def padding_value(self):
    return self.operation.operands[1]

  @builtins.property
  def edge_padding_low(self):
    return self.operation.operands[2]

  @builtins.property
  def edge_padding_high(self):
    return self.operation.operands[3]

  @builtins.property
  def interior_padding(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dynamic_pad(result, operand, padding_value, edge_padding_low, edge_padding_high, interior_padding, *, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicPadOp(result=result, operand=operand, padding_value=padding_value, edge_padding_low=edge_padding_low, edge_padding_high=edge_padding_high, interior_padding=interior_padding, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, output_shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(output_shape))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def output_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dynamic_reshape(result, operand, output_shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicReshapeOp(result=result, operand=operand, output_shape=output_shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, start_indices, slice_sizes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.extend(_get_op_results_or_values(start_indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["slice_sizes"] = (slice_sizes if (
    isinstance(slice_sizes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(slice_sizes, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def start_indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def slice_sizes(self):
    return self.operation.attributes["slice_sizes"]

  @slice_sizes.setter
  def slice_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["slice_sizes"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dynamic_slice(operand, start_indices, slice_sizes, *, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicSliceOp(operand=operand, start_indices=start_indices, slice_sizes=slice_sizes, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DynamicUpdateSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.dynamic_update_slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, update, start_indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(update))
    operands.extend(_get_op_results_or_values(start_indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def update(self):
    return self.operation.operands[1]

  @builtins.property
  def start_indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dynamic_update_slice(operand, update, start_indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return DynamicUpdateSliceOp(operand=operand, update=update, start_indices=start_indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EinsumOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.einsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, einsum_config, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["einsum_config"] = (einsum_config if (
    isinstance(einsum_config, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(einsum_config, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def einsum_config(self):
    return self.operation.attributes["einsum_config"]

  @einsum_config.setter
  def einsum_config(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["einsum_config"] = value

def einsum(result, lhs, rhs, einsum_config, *, loc=None, ip=None) -> _ods_ir.Value:
  return EinsumOp(result=result, lhs=lhs, rhs=rhs, einsum_config=einsum_config, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.exponential"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def exponential(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExpOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Expm1Op(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.exponential_minus_one"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def exponential_minus_one(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return Expm1Op(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FftOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.fft"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, fft_type, fft_length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fft_type"] = (fft_type if (
    isinstance(fft_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_FftTypeAttr')) else
      _ods_ir.AttrBuilder.get('StableHLO_FftTypeAttr')(fft_type, context=_ods_context))
    attributes["fft_length"] = (fft_length if (
    isinstance(fft_length, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(fft_length, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fft_type(self):
    return self.operation.attributes["fft_type"]

  @fft_type.setter
  def fft_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fft_type"] = value

  @builtins.property
  def fft_length(self):
    return self.operation.attributes["fft_length"]

  @fft_length.setter
  def fft_length(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fft_length"] = value

def fft(operand, fft_type, fft_length, *, loc=None, ip=None) -> _ods_ir.Value:
  return FftOp(operand=operand, fft_type=fft_type, fft_length=fft_length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def floor(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return FloorOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, start_indices, dimension_numbers, slice_sizes, *, indices_are_sorted=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(start_indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension_numbers"] = (dimension_numbers if (
    isinstance(dimension_numbers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_GatherDimensionNumbers')) else
      _ods_ir.AttrBuilder.get('StableHLO_GatherDimensionNumbers')(dimension_numbers, context=_ods_context))
    attributes["slice_sizes"] = (slice_sizes if (
    isinstance(slice_sizes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(slice_sizes, context=_ods_context))
    if indices_are_sorted is not None: attributes["indices_are_sorted"] = (indices_are_sorted if (
        isinstance(indices_are_sorted, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(indices_are_sorted, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def start_indices(self):
    return self.operation.operands[1]

  @builtins.property
  def dimension_numbers(self):
    return self.operation.attributes["dimension_numbers"]

  @dimension_numbers.setter
  def dimension_numbers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension_numbers"] = value

  @builtins.property
  def slice_sizes(self):
    return self.operation.attributes["slice_sizes"]

  @slice_sizes.setter
  def slice_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["slice_sizes"] = value

  @builtins.property
  def indices_are_sorted(self):
    if "indices_are_sorted" not in self.operation.attributes:
      return None
    return self.operation.attributes["indices_are_sorted"]

  @indices_are_sorted.setter
  def indices_are_sorted(self, value):
    if value is not None:
      self.operation.attributes["indices_are_sorted"] = value
    elif "indices_are_sorted" in self.operation.attributes:
      del self.operation.attributes["indices_are_sorted"]

  @indices_are_sorted.deleter
  def indices_are_sorted(self):
    del self.operation.attributes["indices_are_sorted"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gather(operand, start_indices, dimension_numbers, slice_sizes, *, indices_are_sorted=None, loc=None, ip=None) -> _ods_ir.Value:
  return GatherOp(operand=operand, start_indices=start_indices, dimension_numbers=dimension_numbers, slice_sizes=slice_sizes, indices_are_sorted=indices_are_sorted, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetDimensionSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.get_dimension_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

def get_dimension_size(operand, dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetDimensionSizeOp(operand=operand, dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetTupleElementOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.get_tuple_element"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

def get_tuple_element(operand, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetTupleElementOp(operand=operand, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IfOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.if"

  _ODS_REGIONS = (2, True)

  def __init__(self, result, pred, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(pred))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def pred(self):
    return self.operation.operands[0]

  @builtins.property
  def true_branch(self):
    return self.regions[0]

  @builtins.property
  def false_branch(self):
    return self.regions[1]

def if_(result, pred, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IfOp(result=result, pred=pred, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ImagOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.imag"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def imag(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ImagOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InfeedOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.infeed"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, token, *, infeed_config=None, layout=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(token))
    _ods_context = _ods_get_default_loc_context(loc)
    if infeed_config is not None: attributes["infeed_config"] = (infeed_config if (
        isinstance(infeed_config, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(infeed_config, context=_ods_context))
    if layout is not None: attributes["layout"] = (layout if (
        isinstance(layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(layout, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def token(self):
    return self.operation.operands[0]

  @builtins.property
  def infeed_config(self):
    return self.operation.attributes["infeed_config"]

  @infeed_config.setter
  def infeed_config(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["infeed_config"] = value

  @builtins.property
  def layout(self):
    if "layout" not in self.operation.attributes:
      return None
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is not None:
      self.operation.attributes["layout"] = value
    elif "layout" in self.operation.attributes:
      del self.operation.attributes["layout"]

  @layout.deleter
  def layout(self):
    del self.operation.attributes["layout"]

def infeed(result, token, *, infeed_config=None, layout=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(InfeedOp(result=result, token=token, infeed_config=infeed_config, layout=layout, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class IotaOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.iota"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, iota_dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["iota_dimension"] = (iota_dimension if (
    isinstance(iota_dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(iota_dimension, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def iota_dimension(self):
    return self.operation.attributes["iota_dimension"]

  @iota_dimension.setter
  def iota_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iota_dimension"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def iota(output, iota_dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return IotaOp(output=output, iota_dimension=iota_dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsFiniteOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.is_finite"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(x))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.results[0]

def is_finite(x, *, loc=None, ip=None) -> _ods_ir.Value:
  return IsFiniteOp(x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log1pOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.log_plus_one"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log_plus_one(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return Log1pOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogisticOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.logistic"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def logistic(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogisticOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MapOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.map"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimensions"] = (dimensions if (
    isinstance(dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(dimensions, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def dimensions(self):
    return self.operation.attributes["dimensions"]

  @dimensions.setter
  def dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimensions"] = value

  @builtins.property
  def computation(self):
    return self.regions[0]

def map(result, inputs, dimensions, *, loc=None, ip=None) -> _ods_ir.Value:
  return MapOp(result=result, inputs=inputs, dimensions=dimensions, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.maximum"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def maximum(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return MaxOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.minimum"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def minimum(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return MinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.multiply"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def multiply(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return MulOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NegOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.negate"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def negate(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return NegOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def not_(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return NotOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OptimizationBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.optimization_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def optimization_barrier(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(OptimizationBarrierOp(operand=operand, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def or_(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return OrOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OutfeedOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.outfeed"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, token, *, outfeed_config=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(_get_op_result_or_value(token))
    _ods_context = _ods_get_default_loc_context(loc)
    if outfeed_config is not None: attributes["outfeed_config"] = (outfeed_config if (
        isinstance(outfeed_config, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(outfeed_config, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def token(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def outfeed_config(self):
    return self.operation.attributes["outfeed_config"]

  @outfeed_config.setter
  def outfeed_config(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outfeed_config"] = value

def outfeed(inputs, token, *, outfeed_config=None, loc=None, ip=None) -> _ods_ir.Value:
  return OutfeedOp(inputs=inputs, token=token, outfeed_config=outfeed_config, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, padding_value, edge_padding_low, edge_padding_high, interior_padding, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(padding_value))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["edge_padding_low"] = (edge_padding_low if (
    isinstance(edge_padding_low, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(edge_padding_low, context=_ods_context))
    attributes["edge_padding_high"] = (edge_padding_high if (
    isinstance(edge_padding_high, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(edge_padding_high, context=_ods_context))
    attributes["interior_padding"] = (interior_padding if (
    isinstance(interior_padding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(interior_padding, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def padding_value(self):
    return self.operation.operands[1]

  @builtins.property
  def edge_padding_low(self):
    return self.operation.attributes["edge_padding_low"]

  @edge_padding_low.setter
  def edge_padding_low(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["edge_padding_low"] = value

  @builtins.property
  def edge_padding_high(self):
    return self.operation.attributes["edge_padding_high"]

  @edge_padding_high.setter
  def edge_padding_high(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["edge_padding_high"] = value

  @builtins.property
  def interior_padding(self):
    return self.operation.attributes["interior_padding"]

  @interior_padding.setter
  def interior_padding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interior_padding"] = value

def pad(operand, padding_value, edge_padding_low, edge_padding_high, interior_padding, *, loc=None, ip=None) -> _ods_ir.Value:
  return PadOp(operand=operand, padding_value=padding_value, edge_padding_low=edge_padding_low, edge_padding_high=edge_padding_high, interior_padding=interior_padding, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PartitionIdOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.partition_id"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

def partition_id(*, loc=None, ip=None) -> _ods_ir.Value:
  return PartitionIdOp(loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PopulationCountOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.popcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def popcnt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return PopulationCountOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.power"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def power(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return PowOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RealDynamicSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.real_dynamic_slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, start_indices, limit_indices, strides, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(start_indices))
    operands.append(_get_op_result_or_value(limit_indices))
    operands.append(_get_op_result_or_value(strides))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def start_indices(self):
    return self.operation.operands[1]

  @builtins.property
  def limit_indices(self):
    return self.operation.operands[2]

  @builtins.property
  def strides(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def real_dynamic_slice(result, operand, start_indices, limit_indices, strides, *, loc=None, ip=None) -> _ods_ir.Value:
  return RealDynamicSliceOp(result=result, operand=operand, start_indices=start_indices, limit_indices=limit_indices, strides=strides, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RealOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.real"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def real(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return RealOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RecvOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.recv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, token, channel_handle, *, is_host_transfer=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(token))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["channel_handle"] = (channel_handle if (
    isinstance(channel_handle, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
      _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    if is_host_transfer is not None: attributes["is_host_transfer"] = (is_host_transfer if (
        isinstance(is_host_transfer, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_host_transfer, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def token(self):
    return self.operation.operands[0]

  @builtins.property
  def channel_handle(self):
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_handle"] = value

  @builtins.property
  def is_host_transfer(self):
    if "is_host_transfer" not in self.operation.attributes:
      return None
    return self.operation.attributes["is_host_transfer"]

  @is_host_transfer.setter
  def is_host_transfer(self, value):
    if value is not None:
      self.operation.attributes["is_host_transfer"] = value
    elif "is_host_transfer" in self.operation.attributes:
      del self.operation.attributes["is_host_transfer"]

  @is_host_transfer.deleter
  def is_host_transfer(self):
    del self.operation.attributes["is_host_transfer"]

def recv(result, token, channel_handle, *, is_host_transfer=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RecvOp(result=result, token=token, channel_handle=channel_handle, is_host_transfer=is_host_transfer, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.reduce"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, init_values, dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(init_values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimensions"] = (dimensions if (
    isinstance(dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(dimensions, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def init_values(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def dimensions(self):
    return self.operation.attributes["dimensions"]

  @dimensions.setter
  def dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimensions"] = value

  @builtins.property
  def body(self):
    return self.regions[0]

def reduce(result, inputs, init_values, dimensions, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceOp(result=result, inputs=inputs, init_values=init_values, dimensions=dimensions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReducePrecisionOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.reduce_precision"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, exponent_bits, mantissa_bits, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exponent_bits"] = (exponent_bits if (
    isinstance(exponent_bits, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(exponent_bits, context=_ods_context))
    attributes["mantissa_bits"] = (mantissa_bits if (
    isinstance(mantissa_bits, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(mantissa_bits, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def exponent_bits(self):
    return self.operation.attributes["exponent_bits"]

  @exponent_bits.setter
  def exponent_bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exponent_bits"] = value

  @builtins.property
  def mantissa_bits(self):
    return self.operation.attributes["mantissa_bits"]

  @mantissa_bits.setter
  def mantissa_bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mantissa_bits"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_precision(operand, exponent_bits, mantissa_bits, *, loc=None, ip=None) -> _ods_ir.Value:
  return ReducePrecisionOp(operand=operand, exponent_bits=exponent_bits, mantissa_bits=mantissa_bits, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.reduce_scatter"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, operand, scatter_dimension, replica_groups, *, channel_handle=None, use_global_device_ids=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scatter_dimension"] = (scatter_dimension if (
    isinstance(scatter_dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scatter_dimension, context=_ods_context))
    attributes["replica_groups"] = (replica_groups if (
    isinstance(replica_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(replica_groups, context=_ods_context))
    if channel_handle is not None: attributes["channel_handle"] = (channel_handle if (
        isinstance(channel_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
          _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    if bool(use_global_device_ids): attributes["use_global_device_ids"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def scatter_dimension(self):
    return self.operation.attributes["scatter_dimension"]

  @scatter_dimension.setter
  def scatter_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scatter_dimension"] = value

  @builtins.property
  def replica_groups(self):
    return self.operation.attributes["replica_groups"]

  @replica_groups.setter
  def replica_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replica_groups"] = value

  @builtins.property
  def channel_handle(self):
    if "channel_handle" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is not None:
      self.operation.attributes["channel_handle"] = value
    elif "channel_handle" in self.operation.attributes:
      del self.operation.attributes["channel_handle"]

  @channel_handle.deleter
  def channel_handle(self):
    del self.operation.attributes["channel_handle"]

  @builtins.property
  def use_global_device_ids(self):
    return "use_global_device_ids" in self.operation.attributes

  @use_global_device_ids.setter
  def use_global_device_ids(self, value):
    if bool(value):
      self.operation.attributes["use_global_device_ids"] = _ods_ir.UnitAttr.get()
    elif "use_global_device_ids" in self.operation.attributes:
      del self.operation.attributes["use_global_device_ids"]

  @use_global_device_ids.deleter
  def use_global_device_ids(self):
    del self.operation.attributes["use_global_device_ids"]

  @builtins.property
  def computation(self):
    return self.regions[0]

def reduce_scatter(result, operand, scatter_dimension, replica_groups, *, channel_handle=None, use_global_device_ids=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReduceScatterOp(result=result, operand=operand, scatter_dimension=scatter_dimension, replica_groups=replica_groups, channel_handle=channel_handle, use_global_device_ids=use_global_device_ids, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceWindowOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.reduce_window"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, init_values, window_dimensions, *, window_strides=None, base_dilations=None, window_dilations=None, padding=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(init_values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["window_dimensions"] = (window_dimensions if (
    isinstance(window_dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(window_dimensions, context=_ods_context))
    if window_strides is not None: attributes["window_strides"] = (window_strides if (
        isinstance(window_strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(window_strides, context=_ods_context))
    if base_dilations is not None: attributes["base_dilations"] = (base_dilations if (
        isinstance(base_dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(base_dilations, context=_ods_context))
    if window_dilations is not None: attributes["window_dilations"] = (window_dilations if (
        isinstance(window_dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(window_dilations, context=_ods_context))
    if padding is not None: attributes["padding"] = (padding if (
        isinstance(padding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
          _ods_ir.AttrBuilder.get('I64ElementsAttr')(padding, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def init_values(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def window_dimensions(self):
    return self.operation.attributes["window_dimensions"]

  @window_dimensions.setter
  def window_dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["window_dimensions"] = value

  @builtins.property
  def window_strides(self):
    if "window_strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_strides"]

  @window_strides.setter
  def window_strides(self, value):
    if value is not None:
      self.operation.attributes["window_strides"] = value
    elif "window_strides" in self.operation.attributes:
      del self.operation.attributes["window_strides"]

  @window_strides.deleter
  def window_strides(self):
    del self.operation.attributes["window_strides"]

  @builtins.property
  def base_dilations(self):
    if "base_dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["base_dilations"]

  @base_dilations.setter
  def base_dilations(self, value):
    if value is not None:
      self.operation.attributes["base_dilations"] = value
    elif "base_dilations" in self.operation.attributes:
      del self.operation.attributes["base_dilations"]

  @base_dilations.deleter
  def base_dilations(self):
    del self.operation.attributes["base_dilations"]

  @builtins.property
  def window_dilations(self):
    if "window_dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_dilations"]

  @window_dilations.setter
  def window_dilations(self, value):
    if value is not None:
      self.operation.attributes["window_dilations"] = value
    elif "window_dilations" in self.operation.attributes:
      del self.operation.attributes["window_dilations"]

  @window_dilations.deleter
  def window_dilations(self):
    del self.operation.attributes["window_dilations"]

  @builtins.property
  def padding(self):
    if "padding" not in self.operation.attributes:
      return None
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is not None:
      self.operation.attributes["padding"] = value
    elif "padding" in self.operation.attributes:
      del self.operation.attributes["padding"]

  @padding.deleter
  def padding(self):
    del self.operation.attributes["padding"]

  @builtins.property
  def body(self):
    return self.regions[0]

def reduce_window(result, inputs, init_values, window_dimensions, *, window_strides=None, base_dilations=None, window_dilations=None, padding=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceWindowOp(result=result, inputs=inputs, init_values=init_values, window_dimensions=window_dimensions, window_strides=window_strides, base_dilations=base_dilations, window_dilations=window_dilations, padding=padding, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RemOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.remainder"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def remainder(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return RemOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReplicaIdOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.replica_id"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

def replica_id(*, loc=None, ip=None) -> _ods_ir.Value:
  return ReplicaIdOp(loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

def reshape(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ReshapeOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(results_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(results_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnOp(results_=results_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimensions"] = (dimensions if (
    isinstance(dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(dimensions, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def dimensions(self):
    return self.operation.attributes["dimensions"]

  @dimensions.setter
  def dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimensions"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reverse(operand, dimensions, *, loc=None, ip=None) -> _ods_ir.Value:
  return ReverseOp(operand=operand, dimensions=dimensions, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RngBitGeneratorOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.rng_bit_generator"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_state, output, rng_algorithm, initial_state, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(initial_state))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["rng_algorithm"] = (rng_algorithm if (
    isinstance(rng_algorithm, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_RngAlgorithmAttr')) else
      _ods_ir.AttrBuilder.get('StableHLO_RngAlgorithmAttr')(rng_algorithm, context=_ods_context))
    results.append(output_state)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def initial_state(self):
    return self.operation.operands[0]

  @builtins.property
  def rng_algorithm(self):
    return self.operation.attributes["rng_algorithm"]

  @rng_algorithm.setter
  def rng_algorithm(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rng_algorithm"] = value

  @builtins.property
  def output_state(self):
    return self.operation.results[0]

  @builtins.property
  def output(self):
    return self.operation.results[1]

def rng_bit_generator(output_state, output, rng_algorithm, initial_state, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return RngBitGeneratorOp(output_state=output_state, output=output, rng_algorithm=rng_algorithm, initial_state=initial_state, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class RngOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.rng"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, shape, rng_distribution, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    operands.append(_get_op_result_or_value(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["rng_distribution"] = (rng_distribution if (
    isinstance(rng_distribution, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_RngDistributionAttr')) else
      _ods_ir.AttrBuilder.get('StableHLO_RngDistributionAttr')(rng_distribution, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def shape(self):
    return self.operation.operands[2]

  @builtins.property
  def rng_distribution(self):
    return self.operation.attributes["rng_distribution"]

  @rng_distribution.setter
  def rng_distribution(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rng_distribution"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def rng(a, b, shape, rng_distribution, *, loc=None, ip=None) -> _ods_ir.Value:
  return RngOp(a=a, b=b, shape=shape, rng_distribution=rng_distribution, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundNearestEvenOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.round_nearest_even"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def round_nearest_even(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return RoundNearestEvenOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.round_nearest_afz"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def round_nearest_afz(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return RoundOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def rsqrt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return RsqrtOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.scatter"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, scatter_indices, updates, scatter_dimension_numbers, *, indices_are_sorted=None, unique_indices=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(_get_op_result_or_value(scatter_indices))
    operands.extend(_get_op_results_or_values(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scatter_dimension_numbers"] = (scatter_dimension_numbers if (
    isinstance(scatter_dimension_numbers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_ScatterDimensionNumbers')) else
      _ods_ir.AttrBuilder.get('StableHLO_ScatterDimensionNumbers')(scatter_dimension_numbers, context=_ods_context))
    if indices_are_sorted is not None: attributes["indices_are_sorted"] = (indices_are_sorted if (
        isinstance(indices_are_sorted, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(indices_are_sorted, context=_ods_context))
    if unique_indices is not None: attributes["unique_indices"] = (unique_indices if (
        isinstance(unique_indices, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(unique_indices, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def scatter_indices(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 1)
    return self.operation.operands[start]

  @builtins.property
  def updates(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 1, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def scatter_dimension_numbers(self):
    return self.operation.attributes["scatter_dimension_numbers"]

  @scatter_dimension_numbers.setter
  def scatter_dimension_numbers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scatter_dimension_numbers"] = value

  @builtins.property
  def indices_are_sorted(self):
    if "indices_are_sorted" not in self.operation.attributes:
      return None
    return self.operation.attributes["indices_are_sorted"]

  @indices_are_sorted.setter
  def indices_are_sorted(self, value):
    if value is not None:
      self.operation.attributes["indices_are_sorted"] = value
    elif "indices_are_sorted" in self.operation.attributes:
      del self.operation.attributes["indices_are_sorted"]

  @indices_are_sorted.deleter
  def indices_are_sorted(self):
    del self.operation.attributes["indices_are_sorted"]

  @builtins.property
  def unique_indices(self):
    if "unique_indices" not in self.operation.attributes:
      return None
    return self.operation.attributes["unique_indices"]

  @unique_indices.setter
  def unique_indices(self, value):
    if value is not None:
      self.operation.attributes["unique_indices"] = value
    elif "unique_indices" in self.operation.attributes:
      del self.operation.attributes["unique_indices"]

  @unique_indices.deleter
  def unique_indices(self):
    del self.operation.attributes["unique_indices"]

  @builtins.property
  def update_computation(self):
    return self.regions[0]

def scatter(result, inputs, scatter_indices, updates, scatter_dimension_numbers, *, indices_are_sorted=None, unique_indices=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ScatterOp(result=result, inputs=inputs, scatter_indices=scatter_indices, updates=updates, scatter_dimension_numbers=scatter_dimension_numbers, indices_are_sorted=indices_are_sorted, unique_indices=unique_indices, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SelectAndScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.select_and_scatter"

  _ODS_REGIONS = (2, True)

  def __init__(self, result, operand, source, init_value, *, window_dimensions=None, window_strides=None, padding=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(source))
    operands.append(_get_op_result_or_value(init_value))
    _ods_context = _ods_get_default_loc_context(loc)
    if window_dimensions is not None: attributes["window_dimensions"] = (window_dimensions if (
        isinstance(window_dimensions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(window_dimensions, context=_ods_context))
    if window_strides is not None: attributes["window_strides"] = (window_strides if (
        isinstance(window_strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(window_strides, context=_ods_context))
    if padding is not None: attributes["padding"] = (padding if (
        isinstance(padding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
          _ods_ir.AttrBuilder.get('I64ElementsAttr')(padding, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def source(self):
    return self.operation.operands[1]

  @builtins.property
  def init_value(self):
    return self.operation.operands[2]

  @builtins.property
  def window_dimensions(self):
    if "window_dimensions" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_dimensions"]

  @window_dimensions.setter
  def window_dimensions(self, value):
    if value is not None:
      self.operation.attributes["window_dimensions"] = value
    elif "window_dimensions" in self.operation.attributes:
      del self.operation.attributes["window_dimensions"]

  @window_dimensions.deleter
  def window_dimensions(self):
    del self.operation.attributes["window_dimensions"]

  @builtins.property
  def window_strides(self):
    if "window_strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["window_strides"]

  @window_strides.setter
  def window_strides(self, value):
    if value is not None:
      self.operation.attributes["window_strides"] = value
    elif "window_strides" in self.operation.attributes:
      del self.operation.attributes["window_strides"]

  @window_strides.deleter
  def window_strides(self):
    del self.operation.attributes["window_strides"]

  @builtins.property
  def padding(self):
    if "padding" not in self.operation.attributes:
      return None
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is not None:
      self.operation.attributes["padding"] = value
    elif "padding" in self.operation.attributes:
      del self.operation.attributes["padding"]

  @padding.deleter
  def padding(self):
    del self.operation.attributes["padding"]

  @builtins.property
  def select(self):
    return self.regions[0]

  @builtins.property
  def scatter(self):
    return self.regions[1]

def select_and_scatter(result, operand, source, init_value, *, window_dimensions=None, window_strides=None, padding=None, loc=None, ip=None) -> _ods_ir.Value:
  return SelectAndScatterOp(result=result, operand=operand, source=source, init_value=init_value, window_dimensions=window_dimensions, window_strides=window_strides, padding=padding, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, pred, on_true, on_false, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(pred))
    operands.append(_get_op_result_or_value(on_true))
    operands.append(_get_op_result_or_value(on_false))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def pred(self):
    return self.operation.operands[0]

  @builtins.property
  def on_true(self):
    return self.operation.operands[1]

  @builtins.property
  def on_false(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def select(pred, on_true, on_false, *, loc=None, ip=None) -> _ods_ir.Value:
  return SelectOp(pred=pred, on_true=on_true, on_false=on_false, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SendOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.send"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, token, channel_handle, *, is_host_transfer=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(_get_op_result_or_value(token))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["channel_handle"] = (channel_handle if (
    isinstance(channel_handle, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_ChannelHandle')) else
      _ods_ir.AttrBuilder.get('StableHLO_ChannelHandle')(channel_handle, context=_ods_context))
    if is_host_transfer is not None: attributes["is_host_transfer"] = (is_host_transfer if (
        isinstance(is_host_transfer, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_host_transfer, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def token(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel_handle(self):
    return self.operation.attributes["channel_handle"]

  @channel_handle.setter
  def channel_handle(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_handle"] = value

  @builtins.property
  def is_host_transfer(self):
    if "is_host_transfer" not in self.operation.attributes:
      return None
    return self.operation.attributes["is_host_transfer"]

  @is_host_transfer.setter
  def is_host_transfer(self, value):
    if value is not None:
      self.operation.attributes["is_host_transfer"] = value
    elif "is_host_transfer" in self.operation.attributes:
      del self.operation.attributes["is_host_transfer"]

  @is_host_transfer.deleter
  def is_host_transfer(self):
    del self.operation.attributes["is_host_transfer"]

def send(inputs, token, channel_handle, *, is_host_transfer=None, loc=None, ip=None) -> _ods_ir.Value:
  return SendOp(inputs=inputs, token=token, channel_handle=channel_handle, is_host_transfer=is_host_transfer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SetDimensionSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.set_dimension_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, size, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(size))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

def set_dimension_size(operand, size, dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return SetDimensionSizeOp(operand=operand, size=size, dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftLeftOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.shift_left"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shift_left(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShiftLeftOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftRightArithmeticOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.shift_right_arithmetic"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shift_right_arithmetic(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShiftRightArithmeticOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftRightLogicalOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.shift_right_logical"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shift_right_logical(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShiftRightLogicalOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SignOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.sign"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sign(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return SignOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SineOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.sine"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sine(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return SineOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, start_indices, limit_indices, strides, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["start_indices"] = (start_indices if (
    isinstance(start_indices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(start_indices, context=_ods_context))
    attributes["limit_indices"] = (limit_indices if (
    isinstance(limit_indices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(limit_indices, context=_ods_context))
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(strides, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def start_indices(self):
    return self.operation.attributes["start_indices"]

  @start_indices.setter
  def start_indices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["start_indices"] = value

  @builtins.property
  def limit_indices(self):
    return self.operation.attributes["limit_indices"]

  @limit_indices.setter
  def limit_indices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["limit_indices"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

def slice(operand, start_indices, limit_indices, strides, *, loc=None, ip=None) -> _ods_ir.Value:
  return SliceOp(operand=operand, start_indices=start_indices, limit_indices=limit_indices, strides=strides, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SortOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.sort"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, *, dimension=None, is_stable=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if dimension is not None: attributes["dimension"] = (dimension if (
        isinstance(dimension, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    if is_stable is not None: attributes["is_stable"] = (is_stable if (
        isinstance(is_stable, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_stable, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def dimension(self):
    if "dimension" not in self.operation.attributes:
      return None
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is not None:
      self.operation.attributes["dimension"] = value
    elif "dimension" in self.operation.attributes:
      del self.operation.attributes["dimension"]

  @dimension.deleter
  def dimension(self):
    del self.operation.attributes["dimension"]

  @builtins.property
  def is_stable(self):
    if "is_stable" not in self.operation.attributes:
      return None
    return self.operation.attributes["is_stable"]

  @is_stable.setter
  def is_stable(self, value):
    if value is not None:
      self.operation.attributes["is_stable"] = value
    elif "is_stable" in self.operation.attributes:
      del self.operation.attributes["is_stable"]

  @is_stable.deleter
  def is_stable(self):
    del self.operation.attributes["is_stable"]

  @builtins.property
  def comparator(self):
    return self.regions[0]

def sort(result, inputs, *, dimension=None, is_stable=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SortOp(result=result, inputs=inputs, dimension=dimension, is_stable=is_stable, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sqrt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return SqrtOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubtractOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.subtract"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def subtract(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return SubtractOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tan(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return TanOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tanh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return TanhOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TorchIndexSelectOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.torch_index_select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, index, dim, batch_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.append(_get_op_result_or_value(index))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    attributes["batch_dims"] = (batch_dims if (
    isinstance(batch_dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(batch_dims, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def batch_dims(self):
    return self.operation.attributes["batch_dims"]

  @batch_dims.setter
  def batch_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_dims"] = value

def torch_index_select(result, operand, index, dim, batch_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TorchIndexSelectOp(result=result, operand=operand, index=index, dim=dim, batch_dims=batch_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, permutation, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["permutation"] = (permutation if (
    isinstance(permutation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(permutation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def permutation(self):
    return self.operation.attributes["permutation"]

  @permutation.setter
  def permutation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["permutation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def transpose(operand, permutation, *, loc=None, ip=None) -> _ods_ir.Value:
  return TransposeOp(operand=operand, permutation=permutation, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TriangularSolveOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.triangular_solve"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, left_side, lower, unit_diagonal, transpose_a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["left_side"] = (left_side if (
    isinstance(left_side, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(left_side, context=_ods_context))
    attributes["lower"] = (lower if (
    isinstance(lower, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(lower, context=_ods_context))
    attributes["unit_diagonal"] = (unit_diagonal if (
    isinstance(unit_diagonal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(unit_diagonal, context=_ods_context))
    attributes["transpose_a"] = (transpose_a if (
    isinstance(transpose_a, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StableHLO_TransposeAttr')) else
      _ods_ir.AttrBuilder.get('StableHLO_TransposeAttr')(transpose_a, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def left_side(self):
    return self.operation.attributes["left_side"]

  @left_side.setter
  def left_side(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_side"] = value

  @builtins.property
  def lower(self):
    return self.operation.attributes["lower"]

  @lower.setter
  def lower(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lower"] = value

  @builtins.property
  def unit_diagonal(self):
    return self.operation.attributes["unit_diagonal"]

  @unit_diagonal.setter
  def unit_diagonal(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["unit_diagonal"] = value

  @builtins.property
  def transpose_a(self):
    return self.operation.attributes["transpose_a"]

  @transpose_a.setter
  def transpose_a(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose_a"] = value

def triangular_solve(a, b, left_side, lower, unit_diagonal, transpose_a, *, loc=None, ip=None) -> _ods_ir.Value:
  return TriangularSolveOp(a=a, b=b, left_side=left_side, lower=lower, unit_diagonal=unit_diagonal, transpose_a=transpose_a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(val))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def val(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple(val, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleOp(val=val, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnaryEinsumOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.unary_einsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, einsum_config, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["einsum_config"] = (einsum_config if (
    isinstance(einsum_config, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(einsum_config, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def einsum_config(self):
    return self.operation.attributes["einsum_config"]

  @einsum_config.setter
  def einsum_config(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["einsum_config"] = value

def unary_einsum(result, operand, einsum_config, *, loc=None, ip=None) -> _ods_ir.Value:
  return UnaryEinsumOp(result=result, operand=operand, einsum_config=einsum_config, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UniformDequantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.uniform_dequantize"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def uniform_dequantize(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return UniformDequantizeOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UniformQuantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.uniform_quantize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def uniform_quantize(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return UniformQuantizeOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WhileOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.while"

  _ODS_REGIONS = (2, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def cond(self):
    return self.regions[0]

  @builtins.property
  def body(self):
    return self.regions[1]

def while_(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WhileOp(result=result, operand=operand, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class XorOp(_ods_ir.OpView):
  OPERATION_NAME = "stablehlo.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def xor(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return XorOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result
