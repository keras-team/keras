
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "math"

@_ods_cext.register_operation(_Dialect)
class AbsFOp(_ods_ir.OpView):
  OPERATION_NAME = "math.absf"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def absf(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AbsFOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AbsIOp(_ods_ir.OpView):
  OPERATION_NAME = "math.absi"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def absi(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return AbsIOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AcosOp(_ods_ir.OpView):
  OPERATION_NAME = "math.acos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def acos(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AcosOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AcoshOp(_ods_ir.OpView):
  OPERATION_NAME = "math.acosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def acosh(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AcoshOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsinOp(_ods_ir.OpView):
  OPERATION_NAME = "math.asin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def asin(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsinOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsinhOp(_ods_ir.OpView):
  OPERATION_NAME = "math.asinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def asinh(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsinhOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Atan2Op(_ods_ir.OpView):
  OPERATION_NAME = "math.atan2"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atan2(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return Atan2Op(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtanOp(_ods_ir.OpView):
  OPERATION_NAME = "math.atan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atan(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtanOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtanhOp(_ods_ir.OpView):
  OPERATION_NAME = "math.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atanh(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtanhOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CbrtOp(_ods_ir.OpView):
  OPERATION_NAME = "math.cbrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cbrt(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return CbrtOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  OPERATION_NAME = "math.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ceil(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return CeilOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopySignOp(_ods_ir.OpView):
  OPERATION_NAME = "math.copysign"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def copysign(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return CopySignOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosOp(_ods_ir.OpView):
  OPERATION_NAME = "math.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cos(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return CosOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CoshOp(_ods_ir.OpView):
  OPERATION_NAME = "math.cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cosh(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return CoshOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CountLeadingZerosOp(_ods_ir.OpView):
  OPERATION_NAME = "math.ctlz"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ctlz(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CountLeadingZerosOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CountTrailingZerosOp(_ods_ir.OpView):
  OPERATION_NAME = "math.cttz"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cttz(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CountTrailingZerosOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CtPopOp(_ods_ir.OpView):
  OPERATION_NAME = "math.ctpop"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ctpop(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CtPopOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ErfOp(_ods_ir.OpView):
  OPERATION_NAME = "math.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def erf(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return ErfOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Exp2Op(_ods_ir.OpView):
  OPERATION_NAME = "math.exp2"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def exp2(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return Exp2Op(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpM1Op(_ods_ir.OpView):
  OPERATION_NAME = "math.expm1"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def expm1(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return ExpM1Op(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  OPERATION_NAME = "math.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def exp(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return ExpOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FPowIOp(_ods_ir.OpView):
  OPERATION_NAME = "math.fpowi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def fpowi(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return FPowIOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  OPERATION_NAME = "math.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def floor(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return FloorOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FmaOp(_ods_ir.OpView):
  OPERATION_NAME = "math.fma"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, c, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    operands.append(_get_op_result_or_value(c))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def c(self):
    return self.operation.operands[2]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def fma(a, b, c, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return FmaOp(a=a, b=b, c=c, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IPowIOp(_ods_ir.OpView):
  OPERATION_NAME = "math.ipowi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ipowi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return IPowIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log1pOp(_ods_ir.OpView):
  OPERATION_NAME = "math.log1p"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log1p(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return Log1pOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log2Op(_ods_ir.OpView):
  OPERATION_NAME = "math.log2"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log2(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return Log2Op(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log10Op(_ods_ir.OpView):
  OPERATION_NAME = "math.log10"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log10(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return Log10Op(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  OPERATION_NAME = "math.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return LogOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowFOp(_ods_ir.OpView):
  OPERATION_NAME = "math.powf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def powf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return PowFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundEvenOp(_ods_ir.OpView):
  OPERATION_NAME = "math.roundeven"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def roundeven(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return RoundEvenOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundOp(_ods_ir.OpView):
  OPERATION_NAME = "math.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def round(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return RoundOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "math.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def rsqrt(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return RsqrtOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinOp(_ods_ir.OpView):
  OPERATION_NAME = "math.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sin(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return SinOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinhOp(_ods_ir.OpView):
  OPERATION_NAME = "math.sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sinh(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return SinhOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "math.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sqrt(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return SqrtOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanOp(_ods_ir.OpView):
  OPERATION_NAME = "math.tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tan(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return TanOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  OPERATION_NAME = "math.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tanh(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return TanhOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncOp(_ods_ir.OpView):
  OPERATION_NAME = "math.trunc"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def trunc(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return TruncOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result
