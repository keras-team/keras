
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "arith"

@_ods_cext.register_operation(_Dialect)
class AddFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.addf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def addf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return AddFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.addi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, overflowFlags=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if overflowFlags is not None: attributes["overflowFlags"] = (overflowFlags if (
        isinstance(overflowFlags, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_IntegerOverflowAttr')) else
          _ods_ir.AttrBuilder.get('Arith_IntegerOverflowAttr')(overflowFlags, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def overflowFlags(self):
    return self.operation.attributes["overflowFlags"]

  @overflowFlags.setter
  def overflowFlags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["overflowFlags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def addi(lhs, rhs, *, overflow_flags=None, loc=None, ip=None) -> _ods_ir.Value:
  return AddIOp(lhs=lhs, rhs=rhs, overflowFlags=overflow_flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddUIExtendedOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.addui_extended"

  _ODS_REGIONS = (0, True)

  def __init__(self, sum, overflow, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(sum)
    results.append(overflow)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def sum(self):
    return self.operation.results[0]

  @builtins.property
  def overflow(self):
    return self.operation.results[1]

def addui_extended(sum, overflow, lhs, rhs, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AddUIExtendedOp(sum=sum, overflow=overflow, lhs=lhs, rhs=rhs, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AndIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.andi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def andi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return AndIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.bitcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def bitcast(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitcastOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilDivSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.ceildivsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ceildivsi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CeilDivSIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilDivUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.ceildivui"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ceildivui(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CeilDivUIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.cmpf"

  _ODS_REGIONS = (0, True)

  def __init__(self, predicate, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["predicate"] = (predicate if (
    isinstance(predicate, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Arith_CmpFPredicateAttr')) else
      _ods_ir.AttrBuilder.get('Arith_CmpFPredicateAttr')(predicate, context=_ods_context))
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def predicate(self):
    return self.operation.attributes["predicate"]

  @predicate.setter
  def predicate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["predicate"] = value

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cmpf(predicate, lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return CmpFOp(predicate=predicate, lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.cmpi"

  _ODS_REGIONS = (0, True)

  def __init__(self, predicate, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["predicate"] = (predicate if (
    isinstance(predicate, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Arith_CmpIPredicateAttr')) else
      _ods_ir.AttrBuilder.get('Arith_CmpIPredicateAttr')(predicate, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def predicate(self):
    return self.operation.attributes["predicate"]

  @predicate.setter
  def predicate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["predicate"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cmpi(predicate, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CmpIOp(predicate=predicate, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.divf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def divf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return DivFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.divsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def divsi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return DivSIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.divui"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def divui(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return DivUIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.extf"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    if "fastmath" not in self.operation.attributes:
      return None
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is not None:
      self.operation.attributes["fastmath"] = value
    elif "fastmath" in self.operation.attributes:
      del self.operation.attributes["fastmath"]

  @fastmath.deleter
  def fastmath(self):
    del self.operation.attributes["fastmath"]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def extf(out, in_, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return ExtFOp(out=out, in_=in_, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.extsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def extsi(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExtSIOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.extui"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def extui(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExtUIOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FPToSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.fptosi"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def fptosi(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return FPToSIOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FPToUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.fptoui"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def fptoui(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return FPToUIOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FloorDivSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.floordivsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def floordivsi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return FloorDivSIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IndexCastOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.index_cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def index_cast(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return IndexCastOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IndexCastUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.index_castui"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def index_castui(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return IndexCastUIOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxNumFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.maxnumf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def maxnumf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return MaxNumFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.maxsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def maxsi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return MaxSIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.maxui"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def maxui(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return MaxUIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaximumFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.maximumf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def maximumf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return MaximumFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinNumFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.minnumf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def minnumf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return MinNumFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.minsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def minsi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return MinSIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.minui"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def minui(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return MinUIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinimumFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.minimumf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def minimumf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return MinimumFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.mulf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mulf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return MulFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.muli"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, overflowFlags=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if overflowFlags is not None: attributes["overflowFlags"] = (overflowFlags if (
        isinstance(overflowFlags, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_IntegerOverflowAttr')) else
          _ods_ir.AttrBuilder.get('Arith_IntegerOverflowAttr')(overflowFlags, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def overflowFlags(self):
    return self.operation.attributes["overflowFlags"]

  @overflowFlags.setter
  def overflowFlags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["overflowFlags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def muli(lhs, rhs, *, overflow_flags=None, loc=None, ip=None) -> _ods_ir.Value:
  return MulIOp(lhs=lhs, rhs=rhs, overflowFlags=overflow_flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulSIExtendedOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.mulsi_extended"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def low(self):
    return self.operation.results[0]

  @builtins.property
  def high(self):
    return self.operation.results[1]

def mulsi_extended(lhs, rhs, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MulSIExtendedOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MulUIExtendedOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.mului_extended"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def low(self):
    return self.operation.results[0]

  @builtins.property
  def high(self):
    return self.operation.results[1]

def mului_extended(lhs, rhs, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MulUIExtendedOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class NegFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.negf"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def negf(operand, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return NegFOp(operand=operand, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.ori"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ori(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return OrIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.remf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def remf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return RemFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.remsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def remsi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return RemSIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.remui"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def remui(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return RemUIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SIToFPOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.sitofp"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def sitofp(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return SIToFPOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShLIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.shli"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, overflowFlags=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if overflowFlags is not None: attributes["overflowFlags"] = (overflowFlags if (
        isinstance(overflowFlags, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_IntegerOverflowAttr')) else
          _ods_ir.AttrBuilder.get('Arith_IntegerOverflowAttr')(overflowFlags, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def overflowFlags(self):
    return self.operation.attributes["overflowFlags"]

  @overflowFlags.setter
  def overflowFlags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["overflowFlags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shli(lhs, rhs, *, overflow_flags=None, loc=None, ip=None) -> _ods_ir.Value:
  return ShLIOp(lhs=lhs, rhs=rhs, overflowFlags=overflow_flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShRSIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.shrsi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shrsi(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShRSIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShRUIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.shrui"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shrui(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShRUIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.subf"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self):
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def subf(lhs, rhs, *, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return SubFOp(lhs=lhs, rhs=rhs, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.subi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, overflowFlags=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if overflowFlags is not None: attributes["overflowFlags"] = (overflowFlags if (
        isinstance(overflowFlags, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_IntegerOverflowAttr')) else
          _ods_ir.AttrBuilder.get('Arith_IntegerOverflowAttr')(overflowFlags, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def overflowFlags(self):
    return self.operation.attributes["overflowFlags"]

  @overflowFlags.setter
  def overflowFlags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["overflowFlags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def subi(lhs, rhs, *, overflow_flags=None, loc=None, ip=None) -> _ods_ir.Value:
  return SubIOp(lhs=lhs, rhs=rhs, overflowFlags=overflow_flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncFOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.truncf"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, roundingmode=None, fastmath=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    if roundingmode is not None: attributes["roundingmode"] = (roundingmode if (
        isinstance(roundingmode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_RoundingModeAttr')) else
          _ods_ir.AttrBuilder.get('Arith_RoundingModeAttr')(roundingmode, context=_ods_context))
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def roundingmode(self):
    if "roundingmode" not in self.operation.attributes:
      return None
    return self.operation.attributes["roundingmode"]

  @roundingmode.setter
  def roundingmode(self, value):
    if value is not None:
      self.operation.attributes["roundingmode"] = value
    elif "roundingmode" in self.operation.attributes:
      del self.operation.attributes["roundingmode"]

  @roundingmode.deleter
  def roundingmode(self):
    del self.operation.attributes["roundingmode"]

  @builtins.property
  def fastmath(self):
    if "fastmath" not in self.operation.attributes:
      return None
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value):
    if value is not None:
      self.operation.attributes["fastmath"] = value
    elif "fastmath" in self.operation.attributes:
      del self.operation.attributes["fastmath"]

  @fastmath.deleter
  def fastmath(self):
    del self.operation.attributes["fastmath"]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def truncf(out, in_, *, roundingmode=None, fastmath=None, loc=None, ip=None) -> _ods_ir.Value:
  return TruncFOp(out=out, in_=in_, roundingmode=roundingmode, fastmath=fastmath, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.trunci"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def trunci(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return TruncIOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UIToFPOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.uitofp"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(in_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def in_(self):
    return self.operation.operands[0]

  @builtins.property
  def out(self):
    return self.operation.results[0]

def uitofp(out, in_, *, loc=None, ip=None) -> _ods_ir.Value:
  return UIToFPOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class XOrIOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.xori"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def xori(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return XOrIOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "arith.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, true_value, false_value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(condition))
    operands.append(_get_op_result_or_value(true_value))
    operands.append(_get_op_result_or_value(false_value))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def true_value(self):
    return self.operation.operands[1]

  @builtins.property
  def false_value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def select(condition, true_value, false_value, *, loc=None, ip=None) -> _ods_ir.Value:
  return SelectOp(condition=condition, true_value=true_value, false_value=false_value, loc=loc, ip=ip).result
