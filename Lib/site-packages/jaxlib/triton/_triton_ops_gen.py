# pytype: skip-file

# Autogenerated by mlir-tblgen; don't manually edit.

from jaxlib.mlir.dialects._ods_common import _cext as _ods_cext
from jaxlib.mlir.dialects._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "tt"

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, callee, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self):
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

def call(result, callee, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CallOp(result=result, callee=callee, operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_657')) else
      _ods_ir.AttrBuilder.get('anonymous_657')(function_type, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def func(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return FuncOp(sym_name=sym_name, function_type=function_type, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReinterpretTensorDescOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.reinterpret_tensor_descriptor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, rawDesc, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(rawDesc))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def rawDesc(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reinterpret_tensor_descriptor(result, raw_desc, *, loc=None, ip=None) -> _ods_ir.Value:
  return ReinterpretTensorDescOp(result=result, rawDesc=raw_desc, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, srcs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(srcs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def srcs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(srcs, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnOp(srcs=srcs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AddPtrOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.addptr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, ptr, offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    operands.append(_get_op_result_or_value(offset))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def addptr(result, ptr, offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return AddPtrOp(result=result, ptr=ptr, offset=offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AdvanceOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.advance"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, ptr, offsets, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    operands.extend(_get_op_results_or_values(offsets))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def offsets(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def advance(result, ptr, offsets, *, loc=None, ip=None) -> _ods_ir.Value:
  return AdvanceOp(result=result, ptr=ptr, offsets=offsets, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssertOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, message, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(condition))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def message(self):
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

def assert_(condition, message, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AssertOp(condition=condition, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AtomicCASOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.atomic_cas"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, ptr, cmp, val, sem, scope, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    operands.append(_get_op_result_or_value(cmp))
    operands.append(_get_op_result_or_value(val))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sem"] = (sem if (
    isinstance(sem, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_MemSemanticAttr')) else
      _ods_ir.AttrBuilder.get('TT_MemSemanticAttr')(sem, context=_ods_context))
    attributes["scope"] = (scope if (
    isinstance(scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_MemSyncScopeAttr')) else
      _ods_ir.AttrBuilder.get('TT_MemSyncScopeAttr')(scope, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def cmp(self):
    return self.operation.operands[1]

  @builtins.property
  def val(self):
    return self.operation.operands[2]

  @builtins.property
  def sem(self):
    return self.operation.attributes["sem"]

  @sem.setter
  def sem(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sem"] = value

  @builtins.property
  def scope(self):
    return self.operation.attributes["scope"]

  @scope.setter
  def scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atomic_cas(result, ptr, cmp, val, sem, scope, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicCASOp(result=result, ptr=ptr, cmp=cmp, val=val, sem=sem, scope=scope, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicRMWOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.atomic_rmw"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, atomic_rmw_op, ptr, val, sem, scope, *, mask=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    operands.append(_get_op_result_or_value(val))
    if mask is not None: operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["atomic_rmw_op"] = (atomic_rmw_op if (
    isinstance(atomic_rmw_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_AtomicRMWAttr')) else
      _ods_ir.AttrBuilder.get('TT_AtomicRMWAttr')(atomic_rmw_op, context=_ods_context))
    attributes["sem"] = (sem if (
    isinstance(sem, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_MemSemanticAttr')) else
      _ods_ir.AttrBuilder.get('TT_MemSemanticAttr')(sem, context=_ods_context))
    attributes["scope"] = (scope if (
    isinstance(scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_MemSyncScopeAttr')) else
      _ods_ir.AttrBuilder.get('TT_MemSyncScopeAttr')(scope, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def val(self):
    return self.operation.operands[1]

  @builtins.property
  def mask(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def atomic_rmw_op(self):
    return self.operation.attributes["atomic_rmw_op"]

  @atomic_rmw_op.setter
  def atomic_rmw_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["atomic_rmw_op"] = value

  @builtins.property
  def sem(self):
    return self.operation.attributes["sem"]

  @sem.setter
  def sem(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sem"] = value

  @builtins.property
  def scope(self):
    return self.operation.attributes["scope"]

  @scope.setter
  def scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atomic_rmw(result, atomic_rmw_op, ptr, val, sem, scope, *, mask=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicRMWOp(result=result, atomic_rmw_op=atomic_rmw_op, ptr=ptr, val=val, sem=sem, scope=scope, mask=mask, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.bitcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def bitcast(result, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitcastOp(result=result, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.broadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def broadcast(result, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastOp(result=result, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CatOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.cat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cat(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CatOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClampFOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.clampf"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, min, max, propagateNan, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(x))
    operands.append(_get_op_result_or_value(min))
    operands.append(_get_op_result_or_value(max))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["propagateNan"] = (propagateNan if (
    isinstance(propagateNan, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_PropagateNanAttr')) else
      _ods_ir.AttrBuilder.get('TT_PropagateNanAttr')(propagateNan, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.operands[1]

  @builtins.property
  def max(self):
    return self.operation.operands[2]

  @builtins.property
  def propagateNan(self):
    return self.operation.attributes["propagateNan"]

  @propagateNan.setter
  def propagateNan(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["propagateNan"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def clampf(x, min, max, propagate_nan, *, loc=None, ip=None) -> _ods_ir.Value:
  return ClampFOp(x=x, min=min, max=max, propagateNan=propagate_nan, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DotOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.dot"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, c, *, inputPrecision=None, maxNumImpreciseAcc=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    operands.append(_get_op_result_or_value(c))
    _ods_context = _ods_get_default_loc_context(loc)
    if inputPrecision is not None: attributes["inputPrecision"] = (inputPrecision if (
        isinstance(inputPrecision, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_InputPrecisionAttr')) else
          _ods_ir.AttrBuilder.get('TT_InputPrecisionAttr')(inputPrecision, context=_ods_context))
    if maxNumImpreciseAcc is not None: attributes["maxNumImpreciseAcc"] = (maxNumImpreciseAcc if (
        isinstance(maxNumImpreciseAcc, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(maxNumImpreciseAcc, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def c(self):
    return self.operation.operands[2]

  @builtins.property
  def inputPrecision(self):
    return self.operation.attributes["inputPrecision"]

  @inputPrecision.setter
  def inputPrecision(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputPrecision"] = value

  @builtins.property
  def maxNumImpreciseAcc(self):
    return self.operation.attributes["maxNumImpreciseAcc"]

  @maxNumImpreciseAcc.setter
  def maxNumImpreciseAcc(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maxNumImpreciseAcc"] = value

  @builtins.property
  def d(self):
    return self.operation.results[0]

def dot(a, b, c, *, input_precision=None, max_num_imprecise_acc=None, loc=None, ip=None) -> _ods_ir.Value:
  return DotOp(a=a, b=b, c=c, inputPrecision=input_precision, maxNumImpreciseAcc=max_num_imprecise_acc, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DotScaledOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.dot_scaled"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, d, lhs, rhs, c, lhs_type, rhs_type, *, lhs_scale=None, rhs_scale=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    operands.append(_get_op_result_or_value(c))
    operands.append(_get_op_result_or_value(lhs_scale) if lhs_scale is not None else None)
    operands.append(_get_op_result_or_value(rhs_scale) if rhs_scale is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lhs_type"] = (lhs_type if (
    isinstance(lhs_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_ScaleDotElemTypeAttr')) else
      _ods_ir.AttrBuilder.get('TT_ScaleDotElemTypeAttr')(lhs_type, context=_ods_context))
    attributes["rhs_type"] = (rhs_type if (
    isinstance(rhs_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_ScaleDotElemTypeAttr')) else
      _ods_ir.AttrBuilder.get('TT_ScaleDotElemTypeAttr')(rhs_type, context=_ods_context))
    results.append(d)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def rhs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def c(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def lhs_scale(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def rhs_scale(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def lhs_type(self):
    return self.operation.attributes["lhs_type"]

  @lhs_type.setter
  def lhs_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lhs_type"] = value

  @builtins.property
  def rhs_type(self):
    return self.operation.attributes["rhs_type"]

  @rhs_type.setter
  def rhs_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rhs_type"] = value

  @builtins.property
  def d(self):
    return self.operation.results[0]

def dot_scaled(d, lhs, rhs, c, lhs_type, rhs_type, *, lhs_scale=None, rhs_scale=None, loc=None, ip=None) -> _ods_ir.Value:
  return DotScaledOp(d=d, lhs=lhs, rhs=rhs, c=c, lhs_type=lhs_type, rhs_type=rhs_type, lhs_scale=lhs_scale, rhs_scale=rhs_scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ElementwiseInlineAsmOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.elementwise_inline_asm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, asm_string, constraints, pure, packed_element, args, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["asm_string"] = (asm_string if (
    isinstance(asm_string, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(asm_string, context=_ods_context))
    attributes["constraints"] = (constraints if (
    isinstance(constraints, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(constraints, context=_ods_context))
    attributes["pure"] = (pure if (
    isinstance(pure, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(pure, context=_ods_context))
    attributes["packed_element"] = (packed_element if (
    isinstance(packed_element, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(packed_element, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def args(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def asm_string(self):
    return self.operation.attributes["asm_string"]

  @asm_string.setter
  def asm_string(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["asm_string"] = value

  @builtins.property
  def constraints(self):
    return self.operation.attributes["constraints"]

  @constraints.setter
  def constraints(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["constraints"] = value

  @builtins.property
  def pure(self):
    return self.operation.attributes["pure"]

  @pure.setter
  def pure(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pure"] = value

  @builtins.property
  def packed_element(self):
    return self.operation.attributes["packed_element"]

  @packed_element.setter
  def packed_element(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["packed_element"] = value

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def elementwise_inline_asm(result, asm_string, constraints, pure, packed_element, args, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ElementwiseInlineAsmOp(result=result, asm_string=asm_string, constraints=constraints, pure=pure, packed_element=packed_element, args=args, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ExpandDimsOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.expand_dims"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def expand_dims(src, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExpandDimsOp(src=src, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExperimentalDescriptorLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.experimental_descriptor_load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, desc, indices, *, cache=None, evict=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(desc))
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if cache is not None: attributes["cache"] = (cache if (
        isinstance(cache, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_CacheModifierAttr')) else
          _ods_ir.AttrBuilder.get('TT_CacheModifierAttr')(cache, context=_ods_context))
    if evict is not None: attributes["evict"] = (evict if (
        isinstance(evict, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_EvictionPolicyAttr')) else
          _ods_ir.AttrBuilder.get('TT_EvictionPolicyAttr')(evict, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def desc(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def cache(self):
    return self.operation.attributes["cache"]

  @cache.setter
  def cache(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cache"] = value

  @builtins.property
  def evict(self):
    return self.operation.attributes["evict"]

  @evict.setter
  def evict(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["evict"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def experimental_descriptor_load(result, desc, indices, *, cache=None, evict=None, loc=None, ip=None) -> _ods_ir.Value:
  return ExperimentalDescriptorLoadOp(result=result, desc=desc, indices=indices, cache=cache, evict=evict, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExperimentalDescriptorStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.experimental_descriptor_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, desc, src, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(desc))
    operands.append(_get_op_result_or_value(src))
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def desc(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

def experimental_descriptor_store(desc, src, indices, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ExperimentalDescriptorStoreOp(desc=desc, src=src, indices=indices, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExperimentalTensormapCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.experimental_tensormap_create"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, desc_ptr, global_address, box_dim, global_dim, global_stride, element_stride, elem_type, interleave_layout, swizzle_mode, fill_mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(desc_ptr))
    operands.append(_get_op_result_or_value(global_address))
    operands.append(_get_op_results_or_values(box_dim))
    operands.append(_get_op_results_or_values(global_dim))
    operands.append(_get_op_results_or_values(global_stride))
    operands.append(_get_op_results_or_values(element_stride))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["elem_type"] = (elem_type if (
    isinstance(elem_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(elem_type, context=_ods_context))
    attributes["interleave_layout"] = (interleave_layout if (
    isinstance(interleave_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(interleave_layout, context=_ods_context))
    attributes["swizzle_mode"] = (swizzle_mode if (
    isinstance(swizzle_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(swizzle_mode, context=_ods_context))
    attributes["fill_mode"] = (fill_mode if (
    isinstance(fill_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(fill_mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def desc_ptr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def global_address(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def box_dim(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def global_dim(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def global_stride(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def element_stride(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def elem_type(self):
    return self.operation.attributes["elem_type"]

  @elem_type.setter
  def elem_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["elem_type"] = value

  @builtins.property
  def interleave_layout(self):
    return self.operation.attributes["interleave_layout"]

  @interleave_layout.setter
  def interleave_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interleave_layout"] = value

  @builtins.property
  def swizzle_mode(self):
    return self.operation.attributes["swizzle_mode"]

  @swizzle_mode.setter
  def swizzle_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["swizzle_mode"] = value

  @builtins.property
  def fill_mode(self):
    return self.operation.attributes["fill_mode"]

  @fill_mode.setter
  def fill_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fill_mode"] = value

def experimental_tensormap_create(desc_ptr, global_address, box_dim, global_dim, global_stride, element_stride, elem_type, interleave_layout, swizzle_mode, fill_mode, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ExperimentalTensormapCreateOp(desc_ptr=desc_ptr, global_address=global_address, box_dim=box_dim, global_dim=global_dim, global_stride=global_stride, element_stride=element_stride, elem_type=elem_type, interleave_layout=interleave_layout, swizzle_mode=swizzle_mode, fill_mode=fill_mode, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExperimentalTensormapFenceproxyAcquireOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.experimental_tensormap_fenceproxy_acquire"

  _ODS_REGIONS = (0, True)

  def __init__(self, desc_ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(desc_ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def desc_ptr(self):
    return self.operation.operands[0]

def experimental_tensormap_fenceproxy_acquire(desc_ptr, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ExperimentalTensormapFenceproxyAcquireOp(desc_ptr=desc_ptr, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExternElementwiseOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.extern_elementwise"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, srcs, libname, libpath, symbol, pure, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(srcs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["libname"] = (libname if (
    isinstance(libname, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(libname, context=_ods_context))
    attributes["libpath"] = (libpath if (
    isinstance(libpath, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(libpath, context=_ods_context))
    attributes["symbol"] = (symbol if (
    isinstance(symbol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(symbol, context=_ods_context))
    attributes["pure"] = (pure if (
    isinstance(pure, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(pure, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def srcs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def libname(self):
    return self.operation.attributes["libname"]

  @libname.setter
  def libname(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["libname"] = value

  @builtins.property
  def libpath(self):
    return self.operation.attributes["libpath"]

  @libpath.setter
  def libpath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["libpath"] = value

  @builtins.property
  def symbol(self):
    return self.operation.attributes["symbol"]

  @symbol.setter
  def symbol(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbol"] = value

  @builtins.property
  def pure(self):
    return self.operation.attributes["pure"]

  @pure.setter
  def pure(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pure"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def extern_elementwise(result, srcs, libname, libpath, symbol, pure, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExternElementwiseOp(result=result, srcs=srcs, libname=libname, libpath=libpath, symbol=symbol, pure=pure, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FpToFpOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.fp_to_fp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, rounding=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    if rounding is not None: attributes["rounding"] = (rounding if (
        isinstance(rounding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_RoundingModeAttr')) else
          _ods_ir.AttrBuilder.get('TT_RoundingModeAttr')(rounding, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def rounding(self):
    if "rounding" not in self.operation.attributes:
      return None
    return self.operation.attributes["rounding"]

  @rounding.setter
  def rounding(self, value):
    if value is not None:
      self.operation.attributes["rounding"] = value
    elif "rounding" in self.operation.attributes:
      del self.operation.attributes["rounding"]

  @rounding.deleter
  def rounding(self):
    del self.operation.attributes["rounding"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def fp_to_fp(result, src, *, rounding=None, loc=None, ip=None) -> _ods_ir.Value:
  return FpToFpOp(result=result, src=src, rounding=rounding, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, indices, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gather(src, indices, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return GatherOp(src=src, indices=indices, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetNumProgramsOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.get_num_programs"

  _ODS_REGIONS = (0, True)

  def __init__(self, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_ProgramDim')) else
      _ods_ir.AttrBuilder.get('TT_ProgramDim')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_num_programs(axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetNumProgramsOp(axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetProgramIdOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.get_program_id"

  _ODS_REGIONS = (0, True)

  def __init__(self, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TT_ProgramDim')) else
      _ods_ir.AttrBuilder.get('TT_ProgramDim')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_program_id(axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetProgramIdOp(axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HistogramOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.histogram"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def histogram(result, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return HistogramOp(result=result, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntToPtrOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.int_to_ptr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def int_to_ptr(result, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return IntToPtrOp(result=result, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class JoinOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def join(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return JoinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoadOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.load"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, *, mask=None, other=None, boundaryCheck=None, padding=None, cache=None, evict=None, isVolatile=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    operands.append(_get_op_result_or_value(mask) if mask is not None else None)
    operands.append(_get_op_result_or_value(other) if other is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundaryCheck is not None: attributes["boundaryCheck"] = (boundaryCheck if (
        isinstance(boundaryCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(boundaryCheck, context=_ods_context))
    if padding is not None: attributes["padding"] = (padding if (
        isinstance(padding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_PaddingOptionAttr')) else
          _ods_ir.AttrBuilder.get('TT_PaddingOptionAttr')(padding, context=_ods_context))
    if cache is not None: attributes["cache"] = (cache if (
        isinstance(cache, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_CacheModifierAttr')) else
          _ods_ir.AttrBuilder.get('TT_CacheModifierAttr')(cache, context=_ods_context))
    if evict is not None: attributes["evict"] = (evict if (
        isinstance(evict, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_EvictionPolicyAttr')) else
          _ods_ir.AttrBuilder.get('TT_EvictionPolicyAttr')(evict, context=_ods_context))
    if isVolatile is not None: attributes["isVolatile"] = (isVolatile if (
        isinstance(isVolatile, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isVolatile, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def mask(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def other(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundaryCheck(self):
    return self.operation.attributes["boundaryCheck"]

  @boundaryCheck.setter
  def boundaryCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundaryCheck"] = value

  @builtins.property
  def padding(self):
    if "padding" not in self.operation.attributes:
      return None
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is not None:
      self.operation.attributes["padding"] = value
    elif "padding" in self.operation.attributes:
      del self.operation.attributes["padding"]

  @padding.deleter
  def padding(self):
    del self.operation.attributes["padding"]

  @builtins.property
  def cache(self):
    return self.operation.attributes["cache"]

  @cache.setter
  def cache(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cache"] = value

  @builtins.property
  def evict(self):
    return self.operation.attributes["evict"]

  @evict.setter
  def evict(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["evict"] = value

  @builtins.property
  def isVolatile(self):
    return self.operation.attributes["isVolatile"]

  @isVolatile.setter
  def isVolatile(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isVolatile"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def load(ptr, *, mask=None, other=None, boundary_check=None, padding=None, cache=None, evict=None, is_volatile=None, loc=None, ip=None) -> _ods_ir.Value:
  return LoadOp(ptr=ptr, mask=mask, other=other, boundaryCheck=boundary_check, padding=padding, cache=cache, evict=evict, isVolatile=is_volatile, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeRangeOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.make_range"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, end, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["start"] = (start if (
    isinstance(start, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(start, context=_ods_context))
    attributes["end"] = (end if (
    isinstance(end, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(end, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def start(self):
    return self.operation.attributes["start"]

  @start.setter
  def start(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["start"] = value

  @builtins.property
  def end(self):
    return self.operation.attributes["end"]

  @end.setter
  def end(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_range(result, start, end, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeRangeOp(result=result, start=start, end=end, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTensorDescOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.make_tensor_descriptor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, base, shape, strides, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(base))
    operands.extend(_get_op_results_or_values(shape))
    operands.extend(_get_op_results_or_values(strides))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def base(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def shape(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 1, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def strides(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 1, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tensor_descriptor(result, base, shape, strides, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTensorDescOp(result=result, base=base, shape=shape, strides=strides, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTensorPtrOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.make_tensor_ptr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, base, shape, strides, offsets, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(base))
    operands.extend(_get_op_results_or_values(shape))
    operands.extend(_get_op_results_or_values(strides))
    operands.extend(_get_op_results_or_values(offsets))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    isinstance(order, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(order, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def base(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def shape(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 1, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def strides(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 1, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def offsets(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 1, 2)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def order(self):
    return self.operation.attributes["order"]

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tensor_ptr(result, base, shape, strides, offsets, order, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTensorPtrOp(result=result, base=base, shape=shape, strides=strides, offsets=offsets, order=order, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulhiUIOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.mulhiui"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(x))
    operands.append(_get_op_result_or_value(y))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mulhiui(x, y, *, loc=None, ip=None) -> _ods_ir.Value:
  return MulhiUIOp(x=x, y=y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PreciseDivFOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.precise_divf"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(x))
    operands.append(_get_op_result_or_value(y))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def precise_divf(x, y, *, loc=None, ip=None) -> _ods_ir.Value:
  return PreciseDivFOp(x=x, y=y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PreciseSqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.precise_sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(x))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def precise_sqrt(x, *, loc=None, ip=None) -> _ods_ir.Value:
  return PreciseSqrtOp(x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrintOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, prefix, hex, args, isSigned, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["prefix"] = (prefix if (
    isinstance(prefix, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(prefix, context=_ods_context))
    attributes["hex"] = (hex if (
    isinstance(hex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(hex, context=_ods_context))
    attributes["isSigned"] = (isSigned if (
    isinstance(isSigned, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(isSigned, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def args(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def prefix(self):
    return self.operation.attributes["prefix"]

  @prefix.setter
  def prefix(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["prefix"] = value

  @builtins.property
  def hex(self):
    return self.operation.attributes["hex"]

  @hex.setter
  def hex(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hex"] = value

  @builtins.property
  def isSigned(self):
    return self.operation.attributes["isSigned"]

  @isSigned.setter
  def isSigned(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isSigned"] = value

def print_(prefix, hex, args, is_signed, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrintOp(prefix=prefix, hex=hex, args=args, isSigned=is_signed, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PtrToIntOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.ptr_to_int"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ptr_to_int(result, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return PtrToIntOp(result=result, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.reduce"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, srcs, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(srcs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def srcs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def combineOp(self):
    return self.regions[0]

def reduce(result, srcs, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceOp(result=result, srcs=srcs, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.reduce.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def reduce_return(result, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReduceReturnOp(result=result, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, allow_reorder=None, efficient_layout=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(allow_reorder): attributes["allow_reorder"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(efficient_layout): attributes["efficient_layout"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def allow_reorder(self):
    return "allow_reorder" in self.operation.attributes

  @allow_reorder.setter
  def allow_reorder(self, value):
    if bool(value):
      self.operation.attributes["allow_reorder"] = _ods_ir.UnitAttr.get()
    elif "allow_reorder" in self.operation.attributes:
      del self.operation.attributes["allow_reorder"]

  @allow_reorder.deleter
  def allow_reorder(self):
    del self.operation.attributes["allow_reorder"]

  @builtins.property
  def efficient_layout(self):
    return "efficient_layout" in self.operation.attributes

  @efficient_layout.setter
  def efficient_layout(self, value):
    if bool(value):
      self.operation.attributes["efficient_layout"] = _ods_ir.UnitAttr.get()
    elif "efficient_layout" in self.operation.attributes:
      del self.operation.attributes["efficient_layout"]

  @efficient_layout.deleter
  def efficient_layout(self):
    del self.operation.attributes["efficient_layout"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reshape(result, src, *, allow_reorder=None, efficient_layout=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReshapeOp(result=result, src=src, allow_reorder=allow_reorder, efficient_layout=efficient_layout, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScanOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.scan"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, srcs, axis, reverse, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(srcs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    attributes["reverse"] = (reverse if (
    isinstance(reverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(reverse, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def srcs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def reverse(self):
    return self.operation.attributes["reverse"]

  @reverse.setter
  def reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reverse"] = value

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def combineOp(self):
    return self.regions[0]

def scan(result, srcs, axis, reverse, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ScanOp(result=result, srcs=srcs, axis=axis, reverse=reverse, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ScanReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.scan.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def scan_return(result, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ScanReturnOp(result=result, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SplatOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def splat(result, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return SplatOp(result=result, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def outLHS(self):
    return self.operation.results[0]

  @builtins.property
  def outRHS(self):
    return self.operation.results[1]

def split(src, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return SplitOp(src=src, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class StoreOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, value, *, mask=None, boundaryCheck=None, cache=None, evict=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    operands.append(_get_op_result_or_value(value))
    if mask is not None: operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    if boundaryCheck is not None: attributes["boundaryCheck"] = (boundaryCheck if (
        isinstance(boundaryCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(boundaryCheck, context=_ods_context))
    if cache is not None: attributes["cache"] = (cache if (
        isinstance(cache, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_CacheModifierAttr')) else
          _ods_ir.AttrBuilder.get('TT_CacheModifierAttr')(cache, context=_ods_context))
    if evict is not None: attributes["evict"] = (evict if (
        isinstance(evict, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TT_EvictionPolicyAttr')) else
          _ods_ir.AttrBuilder.get('TT_EvictionPolicyAttr')(evict, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def mask(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def boundaryCheck(self):
    return self.operation.attributes["boundaryCheck"]

  @boundaryCheck.setter
  def boundaryCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundaryCheck"] = value

  @builtins.property
  def cache(self):
    return self.operation.attributes["cache"]

  @cache.setter
  def cache(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cache"] = value

  @builtins.property
  def evict(self):
    return self.operation.attributes["evict"]

  @evict.setter
  def evict(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["evict"] = value

def store(ptr, value, *, mask=None, boundary_check=None, cache=None, evict=None, loc=None, ip=None) -> _ods_ir.Operation:
  return StoreOp(ptr=ptr, value=value, mask=mask, boundaryCheck=boundary_check, cache=cache, evict=evict, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TransOp(_ods_ir.OpView):
  OPERATION_NAME = "tt.trans"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    isinstance(order, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(order, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def order(self):
    return self.operation.attributes["order"]

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def trans(src, order, *, loc=None, ip=None) -> _ods_ir.Value:
  return TransOp(src=src, order=order, loc=loc, ip=ip).result
